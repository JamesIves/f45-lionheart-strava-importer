import { createRequire as __WEBPACK_EXTERNAL_createRequire } from "module";
/******/ var __webpack_modules__ = ({

/***/ 5878:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {


var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var EventAlgorithm_1 = __nccwpck_require__(8012);
/**
 * Adds an algorithm to the given abort signal.
 *
 * @param algorithm - an algorithm
 * @param signal - abort signal
 */
function abort_add(algorithm, signal) {
    /**
     * 1. If signal’s aborted flag is set, then return.
     * 2. Append algorithm to signal’s abort algorithms.
     */
    if (signal._abortedFlag)
        return;
    signal._abortAlgorithms.add(algorithm);
}
exports.abort_add = abort_add;
/**
 * Removes an algorithm from the given abort signal.
 *
 * @param algorithm - an algorithm
 * @param signal - abort signal
 */
function abort_remove(algorithm, signal) {
    /**
     * To remove an algorithm algorithm from an AbortSignal signal, remove
     * algorithm from signal’s abort algorithms.
     */
    signal._abortAlgorithms.delete(algorithm);
}
exports.abort_remove = abort_remove;
/**
 * Signals abort on the given abort signal.
 *
 * @param signal - abort signal
 */
function abort_signalAbort(signal) {
    var e_1, _a;
    /**
     * 1. If signal’s aborted flag is set, then return.
     * 2. Set signal’s aborted flag.
     * 3. For each algorithm in signal’s abort algorithms: run algorithm.
     * 4. Empty signal’s abort algorithms.
     * 5. Fire an event named abort at signal.
     */
    if (signal._abortedFlag)
        return;
    signal._abortedFlag = true;
    try {
        for (var _b = __values(signal._abortAlgorithms), _c = _b.next(); !_c.done; _c = _b.next()) {
            var algorithm = _c.value;
            algorithm.call(signal);
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_1) throw e_1.error; }
    }
    signal._abortAlgorithms.clear();
    EventAlgorithm_1.event_fireAnEvent("abort", signal);
}
exports.abort_signalAbort = abort_signalAbort;
//# sourceMappingURL=AbortAlgorithm.js.map

/***/ }),

/***/ 8365:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
var ElementAlgorithm_1 = __nccwpck_require__(2720);
/**
 * Changes the value of an existing attribute.
 *
 * @param attribute - an attribute node
 * @param value - attribute value
 */
function attr_setAnExistingAttributeValue(attribute, value) {
    /**
     * 1. If attribute’s element is null, then set attribute’s value to value.
     * 2. Otherwise, change attribute from attribute’s element to value.
     */
    if (attribute._element === null) {
        attribute._value = value;
    }
    else {
        ElementAlgorithm_1.element_change(attribute, attribute._element, value);
    }
}
exports.attr_setAnExistingAttributeValue = attr_setAnExistingAttributeValue;
//# sourceMappingURL=AttrAlgorithm.js.map

/***/ }),

/***/ 8652:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
var interfaces_1 = __nccwpck_require__(9454);
var TreeAlgorithm_1 = __nccwpck_require__(3532);
/**
 * Defines the position of a boundary point relative to another.
 *
 * @param bp - a boundary point
 * @param relativeTo - a boundary point to compare to
 */
function boundaryPoint_position(bp, relativeTo) {
    var nodeA = bp[0];
    var offsetA = bp[1];
    var nodeB = relativeTo[0];
    var offsetB = relativeTo[1];
    /**
     * 1. Assert: nodeA and nodeB have the same root.
     */
    console.assert(TreeAlgorithm_1.tree_rootNode(nodeA) === TreeAlgorithm_1.tree_rootNode(nodeB), "Boundary points must share the same root node.");
    /**
     * 2. If nodeA is nodeB, then return equal if offsetA is offsetB, before
     * if offsetA is less than offsetB, and after if offsetA is greater than
     * offsetB.
     */
    if (nodeA === nodeB) {
        if (offsetA === offsetB) {
            return interfaces_1.BoundaryPosition.Equal;
        }
        else if (offsetA < offsetB) {
            return interfaces_1.BoundaryPosition.Before;
        }
        else {
            return interfaces_1.BoundaryPosition.After;
        }
    }
    /**
     * 3. If nodeA is following nodeB, then if the position of (nodeB, offsetB)
     * relative to (nodeA, offsetA) is before, return after, and if it is after,
     * return before.
     */
    if (TreeAlgorithm_1.tree_isFollowing(nodeB, nodeA)) {
        var pos = boundaryPoint_position([nodeB, offsetB], [nodeA, offsetA]);
        if (pos === interfaces_1.BoundaryPosition.Before) {
            return interfaces_1.BoundaryPosition.After;
        }
        else if (pos === interfaces_1.BoundaryPosition.After) {
            return interfaces_1.BoundaryPosition.Before;
        }
    }
    /**
     * 4. If nodeA is an ancestor of nodeB:
     */
    if (TreeAlgorithm_1.tree_isAncestorOf(nodeB, nodeA)) {
        /**
         * 4.1. Let child be nodeB.
         * 4.2. While child is not a child of nodeA, set child to its parent.
         * 4.3. If child’s index is less than offsetA, then return after.
         */
        var child = nodeB;
        while (!TreeAlgorithm_1.tree_isChildOf(nodeA, child)) {
            /* istanbul ignore else */
            if (child._parent !== null) {
                child = child._parent;
            }
        }
        if (TreeAlgorithm_1.tree_index(child) < offsetA) {
            return interfaces_1.BoundaryPosition.After;
        }
    }
    /**
     * 5. Return before.
     */
    return interfaces_1.BoundaryPosition.Before;
}
exports.boundaryPoint_position = boundaryPoint_position;
//# sourceMappingURL=BoundaryPointAlgorithm.js.map

/***/ }),

/***/ 7785:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {


var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var DOMImpl_1 = __nccwpck_require__(698);
var util_1 = __nccwpck_require__(628);
var DOMException_1 = __nccwpck_require__(7175);
var TreeAlgorithm_1 = __nccwpck_require__(3532);
var MutationObserverAlgorithm_1 = __nccwpck_require__(3243);
var DOMAlgorithm_1 = __nccwpck_require__(9484);
/**
 * Replaces character data.
 *
 * @param node - a character data node
 * @param offset - start offset
 * @param count - count of characters to replace
 * @param data - new data
 */
function characterData_replaceData(node, offset, count, data) {
    var e_1, _a;
    /**
     * 1. Let length be node’s length.
     * 2. If offset is greater than length, then throw an "IndexSizeError"
     * DOMException.
     * 3. If offset plus count is greater than length, then set count to length
     * minus offset.
     */
    var length = TreeAlgorithm_1.tree_nodeLength(node);
    if (offset > length) {
        throw new DOMException_1.IndexSizeError("Offset exceeds character data length. Offset: " + offset + ", Length: " + length + ", Node is " + node.nodeName + ".");
    }
    if (offset + count > length) {
        count = length - offset;
    }
    /**
     * 4. Queue a mutation record of "characterData" for node with null, null,
     * node’s data, « », « », null, and null.
     */
    if (DOMImpl_1.dom.features.mutationObservers) {
        MutationObserverAlgorithm_1.observer_queueMutationRecord("characterData", node, null, null, node._data, [], [], null, null);
    }
    /**
     * 5. Insert data into node’s data after offset code units.
     * 6. Let delete offset be offset + data’s length.
     * 7. Starting from delete offset code units, remove count code units from
     * node’s data.
     */
    var newData = node._data.substring(0, offset) + data +
        node._data.substring(offset + count);
    node._data = newData;
    try {
        /**
         * 8. For each live range whose start node is node and start offset is
         * greater than offset but less than or equal to offset plus count, set its
         * start offset to offset.
         * 9. For each live range whose end node is node and end offset is greater
         * than offset but less than or equal to offset plus count, set its end
         * offset to offset.
         * 10. For each live range whose start node is node and start offset is
         * greater than offset plus count, increase its start offset by data’s
         * length and decrease it by count.
         * 11. For each live range whose end node is node and end offset is greater
         * than offset plus count, increase its end offset by data’s length and
         * decrease it by count.
         */
        for (var _b = __values(DOMImpl_1.dom.rangeList), _c = _b.next(); !_c.done; _c = _b.next()) {
            var range = _c.value;
            if (range._start[0] === node && range._start[1] > offset && range._start[1] <= offset + count) {
                range._start[1] = offset;
            }
            if (range._end[0] === node && range._end[1] > offset && range._end[1] <= offset + count) {
                range._end[1] = offset;
            }
            if (range._start[0] === node && range._start[1] > offset + count) {
                range._start[1] += data.length - count;
            }
            if (range._end[0] === node && range._end[1] > offset + count) {
                range._end[1] += data.length - count;
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_1) throw e_1.error; }
    }
    /**
     * 12. If node is a Text node and its parent is not null, run the child
     * text content change steps for node’s parent.
     */
    if (DOMImpl_1.dom.features.steps) {
        if (util_1.Guard.isTextNode(node) && node._parent !== null) {
            DOMAlgorithm_1.dom_runChildTextContentChangeSteps(node._parent);
        }
    }
}
exports.characterData_replaceData = characterData_replaceData;
/**
 * Returns `count` number of characters from `node`'s data starting at
 * the given `offset`.
 *
 * @param node - a character data node
 * @param offset - start offset
 * @param count - count of characters to return
 */
function characterData_substringData(node, offset, count) {
    /**
     * 1. Let length be node’s length.
     * 2. If offset is greater than length, then throw an "IndexSizeError"
     * DOMException.
     * 3. If offset plus count is greater than length, return a string whose
     * value is the code units from the offsetth code unit to the end of node’s
     * data, and then return.
     * 4. Return a string whose value is the code units from the offsetth code
     * unit to the offset+countth code unit in node’s data.
     */
    var length = TreeAlgorithm_1.tree_nodeLength(node);
    if (offset > length) {
        throw new DOMException_1.IndexSizeError("Offset exceeds character data length. Offset: " + offset + ", Length: " + length + ", Node is " + node.nodeName + ".");
    }
    if (offset + count > length) {
        return node._data.substr(offset);
    }
    else {
        return node._data.substr(offset, count);
    }
}
exports.characterData_substringData = characterData_substringData;
//# sourceMappingURL=CharacterDataAlgorithm.js.map

/***/ }),

/***/ 8308:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
var DOMImplementationImpl_1 = __nccwpck_require__(6348);
var WindowImpl_1 = __nccwpck_require__(1448);
var XMLDocumentImpl_1 = __nccwpck_require__(4602);
var DocumentImpl_1 = __nccwpck_require__(2113);
var AbortControllerImpl_1 = __nccwpck_require__(7528);
var AbortSignalImpl_1 = __nccwpck_require__(4560);
var DocumentTypeImpl_1 = __nccwpck_require__(1401);
var ElementImpl_1 = __nccwpck_require__(1342);
var DocumentFragmentImpl_1 = __nccwpck_require__(9793);
var ShadowRootImpl_1 = __nccwpck_require__(6092);
var AttrImpl_1 = __nccwpck_require__(2875);
var TextImpl_1 = __nccwpck_require__(4063);
var CDATASectionImpl_1 = __nccwpck_require__(4104);
var CommentImpl_1 = __nccwpck_require__(8223);
var ProcessingInstructionImpl_1 = __nccwpck_require__(2755);
var HTMLCollectionImpl_1 = __nccwpck_require__(9065);
var NodeListImpl_1 = __nccwpck_require__(5788);
var NodeListStaticImpl_1 = __nccwpck_require__(7654);
var NamedNodeMapImpl_1 = __nccwpck_require__(3145);
var RangeImpl_1 = __nccwpck_require__(3691);
var NodeIteratorImpl_1 = __nccwpck_require__(4142);
var TreeWalkerImpl_1 = __nccwpck_require__(6254);
var NodeFilterImpl_1 = __nccwpck_require__(7030);
var MutationRecordImpl_1 = __nccwpck_require__(2414);
var DOMTokenListImpl_1 = __nccwpck_require__(6629);
/**
 * Creates a `DOMImplementation`.
 *
 * @param document - associated document
 */
function create_domImplementation(document) {
    return DOMImplementationImpl_1.DOMImplementationImpl._create(document);
}
exports.create_domImplementation = create_domImplementation;
/**
 * Creates a `Window` node.
 */
function create_window() {
    return WindowImpl_1.WindowImpl._create();
}
exports.create_window = create_window;
/**
 * Creates an `XMLDocument` node.
 */
function create_xmlDocument() {
    return new XMLDocumentImpl_1.XMLDocumentImpl();
}
exports.create_xmlDocument = create_xmlDocument;
/**
 * Creates a `Document` node.
 */
function create_document() {
    return new DocumentImpl_1.DocumentImpl();
}
exports.create_document = create_document;
/**
 * Creates an `AbortController`.
 */
function create_abortController() {
    return new AbortControllerImpl_1.AbortControllerImpl();
}
exports.create_abortController = create_abortController;
/**
 * Creates an `AbortSignal`.
 */
function create_abortSignal() {
    return AbortSignalImpl_1.AbortSignalImpl._create();
}
exports.create_abortSignal = create_abortSignal;
/**
 * Creates a `DocumentType` node.
 *
 * @param document - owner document
 * @param name - name of the node
 * @param publicId - `PUBLIC` identifier
 * @param systemId - `SYSTEM` identifier
 */
function create_documentType(document, name, publicId, systemId) {
    return DocumentTypeImpl_1.DocumentTypeImpl._create(document, name, publicId, systemId);
}
exports.create_documentType = create_documentType;
/**
 * Creates a new `Element` node.
 *
 * @param document - owner document
 * @param localName - local name
 * @param namespace - namespace
 * @param prefix - namespace prefix
 */
function create_element(document, localName, namespace, prefix) {
    return ElementImpl_1.ElementImpl._create(document, localName, namespace, prefix);
}
exports.create_element = create_element;
/**
 * Creates a new `HTMLElement` node.
 *
 * @param document - owner document
 * @param localName - local name
 * @param namespace - namespace
 * @param prefix - namespace prefix
 */
function create_htmlElement(document, localName, namespace, prefix) {
    // TODO: Implement in HTML DOM
    return ElementImpl_1.ElementImpl._create(document, localName, namespace, prefix);
}
exports.create_htmlElement = create_htmlElement;
/**
 * Creates a new `HTMLUnknownElement` node.
 *
 * @param document - owner document
 * @param localName - local name
 * @param namespace - namespace
 * @param prefix - namespace prefix
 */
function create_htmlUnknownElement(document, localName, namespace, prefix) {
    // TODO: Implement in HTML DOM
    return ElementImpl_1.ElementImpl._create(document, localName, namespace, prefix);
}
exports.create_htmlUnknownElement = create_htmlUnknownElement;
/**
 * Creates a new `DocumentFragment` node.
 *
 * @param document - owner document
 */
function create_documentFragment(document) {
    return DocumentFragmentImpl_1.DocumentFragmentImpl._create(document);
}
exports.create_documentFragment = create_documentFragment;
/**
 * Creates a new `ShadowRoot` node.
 *
 * @param document - owner document
 * @param host - shadow root's host element node
 */
function create_shadowRoot(document, host) {
    return ShadowRootImpl_1.ShadowRootImpl._create(document, host);
}
exports.create_shadowRoot = create_shadowRoot;
/**
 * Creates a new `Attr` node.
 *
 * @param document - owner document
 * @param localName - local name
 */
function create_attr(document, localName) {
    return AttrImpl_1.AttrImpl._create(document, localName);
}
exports.create_attr = create_attr;
/**
 * Creates a new `Text` node.
 *
 * @param document - owner document
 * @param data - node contents
 */
function create_text(document, data) {
    return TextImpl_1.TextImpl._create(document, data);
}
exports.create_text = create_text;
/**
 * Creates a new `CDATASection` node.
 *
 * @param document - owner document
 * @param data - node contents
 */
function create_cdataSection(document, data) {
    return CDATASectionImpl_1.CDATASectionImpl._create(document, data);
}
exports.create_cdataSection = create_cdataSection;
/**
 * Creates a new `Comment` node.
 *
 * @param document - owner document
 * @param data - node contents
 */
function create_comment(document, data) {
    return CommentImpl_1.CommentImpl._create(document, data);
}
exports.create_comment = create_comment;
/**
 * Creates a new `ProcessingInstruction` node.
 *
 * @param document - owner document
 * @param target - instruction target
 * @param data - node contents
 */
function create_processingInstruction(document, target, data) {
    return ProcessingInstructionImpl_1.ProcessingInstructionImpl._create(document, target, data);
}
exports.create_processingInstruction = create_processingInstruction;
/**
 * Creates a new `HTMLCollection`.
 *
 * @param root - root node
 * @param filter - node filter
 */
function create_htmlCollection(root, filter) {
    if (filter === void 0) { filter = (function () { return true; }); }
    return HTMLCollectionImpl_1.HTMLCollectionImpl._create(root, filter);
}
exports.create_htmlCollection = create_htmlCollection;
/**
 * Creates a new live `NodeList`.
 *
 * @param root - root node
 */
function create_nodeList(root) {
    return NodeListImpl_1.NodeListImpl._create(root);
}
exports.create_nodeList = create_nodeList;
/**
 * Creates a new static `NodeList`.
 *
 * @param root - root node
 * @param items - a list of items to initialize the list
 */
function create_nodeListStatic(root, items) {
    return NodeListStaticImpl_1.NodeListStaticImpl._create(root, items);
}
exports.create_nodeListStatic = create_nodeListStatic;
/**
 * Creates a new `NamedNodeMap`.
 *
 * @param element - parent element
 */
function create_namedNodeMap(element) {
    return NamedNodeMapImpl_1.NamedNodeMapImpl._create(element);
}
exports.create_namedNodeMap = create_namedNodeMap;
/**
 * Creates a new `Range`.
 *
 * @param start - start point
 * @param end - end point
 */
function create_range(start, end) {
    return RangeImpl_1.RangeImpl._create(start, end);
}
exports.create_range = create_range;
/**
 * Creates a new `NodeIterator`.
 *
 * @param root - iterator's root node
 * @param reference - reference node
 * @param pointerBeforeReference - whether the iterator is before or after the
 * reference node
 */
function create_nodeIterator(root, reference, pointerBeforeReference) {
    return NodeIteratorImpl_1.NodeIteratorImpl._create(root, reference, pointerBeforeReference);
}
exports.create_nodeIterator = create_nodeIterator;
/**
 * Creates a new `TreeWalker`.
 *
 * @param root - iterator's root node
 * @param current - current node
 */
function create_treeWalker(root, current) {
    return TreeWalkerImpl_1.TreeWalkerImpl._create(root, current);
}
exports.create_treeWalker = create_treeWalker;
/**
 * Creates a new `NodeFilter`.
 */
function create_nodeFilter() {
    return NodeFilterImpl_1.NodeFilterImpl._create();
}
exports.create_nodeFilter = create_nodeFilter;
/**
 * Creates a new `MutationRecord`.
 *
 * @param type - type of mutation: `"attributes"` for an attribute
 * mutation, `"characterData"` for a mutation to a CharacterData node
 * and `"childList"` for a mutation to the tree of nodes.
 * @param target - node affected by the mutation.
 * @param addedNodes - list of added nodes.
 * @param removedNodes - list of removed nodes.
 * @param previousSibling - previous sibling of added or removed nodes.
 * @param nextSibling - next sibling of added or removed nodes.
 * @param attributeName - local name of the changed attribute,
 * and `null` otherwise.
 * @param attributeNamespace - namespace of the changed attribute,
 * and `null` otherwise.
 * @param oldValue - value before mutation: attribute value for an attribute
 * mutation, node `data` for a mutation to a CharacterData node and `null`
 * for a mutation to the tree of nodes.
 */
function create_mutationRecord(type, target, addedNodes, removedNodes, previousSibling, nextSibling, attributeName, attributeNamespace, oldValue) {
    return MutationRecordImpl_1.MutationRecordImpl._create(type, target, addedNodes, removedNodes, previousSibling, nextSibling, attributeName, attributeNamespace, oldValue);
}
exports.create_mutationRecord = create_mutationRecord;
/**
 * Creates a new `DOMTokenList`.
 *
 * @param element - associated element
 * @param attribute - associated attribute
 */
function create_domTokenList(element, attribute) {
    return DOMTokenListImpl_1.DOMTokenListImpl._create(element, attribute);
}
exports.create_domTokenList = create_domTokenList;
//# sourceMappingURL=CreateAlgorithm.js.map

/***/ }),

/***/ 5075:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
var PotentialCustomElementName = /[a-z]([\0-\t\x2D\._a-z\xB7\xC0-\xD6\xD8-\xF6\xF8-\u037D\u037F-\u1FFF\u200C\u200D\u203F\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])*-([\0-\t\x2D\._a-z\xB7\xC0-\xD6\xD8-\xF6\xF8-\u037D\u037F-\u1FFF\u200C\u200D\u203F\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])*/;
var NamesWithHyphen = new Set(['annotation-xml', 'color-profile',
    'font-face', 'font-face-src', 'font-face-uri', 'font-face-format',
    'font-face-name', 'missing-glyph']);
var ElementNames = new Set(['article', 'aside', 'blockquote',
    'body', 'div', 'footer', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6',
    'header', 'main', 'nav', 'p', 'section', 'span']);
var VoidElementNames = new Set(['area', 'base', 'basefont',
    'bgsound', 'br', 'col', 'embed', 'frame', 'hr', 'img', 'input', 'keygen',
    'link', 'menuitem', 'meta', 'param', 'source', 'track', 'wbr']);
var ShadowHostNames = new Set(['article', 'aside', 'blockquote', 'body',
    'div', 'footer', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'header', 'main',
    'nav', 'p', 'section', 'span']);
/**
 * Determines if the given string is a valid custom element name.
 *
 * @param name - a name string
 */
function customElement_isValidCustomElementName(name) {
    if (!PotentialCustomElementName.test(name))
        return false;
    if (NamesWithHyphen.has(name))
        return false;
    return true;
}
exports.customElement_isValidCustomElementName = customElement_isValidCustomElementName;
/**
 * Determines if the given string is a valid element name.
 *
 * @param name - a name string
 */
function customElement_isValidElementName(name) {
    return (ElementNames.has(name));
}
exports.customElement_isValidElementName = customElement_isValidElementName;
/**
 * Determines if the given string is a void element name.
 *
 * @param name - a name string
 */
function customElement_isVoidElementName(name) {
    return (VoidElementNames.has(name));
}
exports.customElement_isVoidElementName = customElement_isVoidElementName;
/**
 * Determines if the given string is a valid shadow host element name.
 *
 * @param name - a name string
 */
function customElement_isValidShadowHostName(name) {
    return (ShadowHostNames.has(name));
}
exports.customElement_isValidShadowHostName = customElement_isValidShadowHostName;
/**
 * Enqueues an upgrade reaction for a custom element.
 *
 * @param element - a custom element
 * @param definition - a custom element definition
 */
function customElement_enqueueACustomElementUpgradeReaction(element, definition) {
    // TODO: Implement in HTML DOM
}
exports.customElement_enqueueACustomElementUpgradeReaction = customElement_enqueueACustomElementUpgradeReaction;
/**
 * Enqueues a callback reaction for a custom element.
 *
 * @param element - a custom element
 * @param callbackName - name of the callback
 * @param args - callback arguments
 */
function customElement_enqueueACustomElementCallbackReaction(element, callbackName, args) {
    // TODO: Implement in HTML DOM
}
exports.customElement_enqueueACustomElementCallbackReaction = customElement_enqueueACustomElementCallbackReaction;
/**
 * Upgrade a custom element.
 *
 * @param element - a custom element
 */
function customElement_upgrade(definition, element) {
    // TODO: Implement in HTML DOM
}
exports.customElement_upgrade = customElement_upgrade;
/**
 * Tries to upgrade a custom element.
 *
 * @param element - a custom element
 */
function customElement_tryToUpgrade(element) {
    // TODO: Implement in HTML DOM
}
exports.customElement_tryToUpgrade = customElement_tryToUpgrade;
/**
 * Looks up a custom element definition.
 *
 * @param document - a document
 * @param namespace - element namespace
 * @param localName - element local name
 * @param is - an `is` value
 */
function customElement_lookUpACustomElementDefinition(document, namespace, localName, is) {
    // TODO: Implement in HTML DOM
    return null;
}
exports.customElement_lookUpACustomElementDefinition = customElement_lookUpACustomElementDefinition;
//# sourceMappingURL=CustomElementAlgorithm.js.map

/***/ }),

/***/ 9484:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {


var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var DOMImpl_1 = __nccwpck_require__(698);
var TreeAlgorithm_1 = __nccwpck_require__(3532);
var util_1 = __nccwpck_require__(628);
var ShadowTreeAlgorithm_1 = __nccwpck_require__(708);
var supportedTokens = new Map();
/**
 * Runs removing steps for node.
 *
 * @param removedNode - removed node
 * @param oldParent - old parent node
 */
function dom_runRemovingSteps(removedNode, oldParent) {
    // No steps defined
}
exports.dom_runRemovingSteps = dom_runRemovingSteps;
/**
 * Runs cloning steps for node.
 *
 * @param copy - node clone
 * @param node - node
 * @param document - document to own the cloned node
 * @param cloneChildrenFlag - whether child nodes are cloned
 */
function dom_runCloningSteps(copy, node, document, cloneChildrenFlag) {
    // No steps defined
}
exports.dom_runCloningSteps = dom_runCloningSteps;
/**
 * Runs adopting steps for node.
 *
 * @param node - node
 * @param oldDocument - old document
 */
function dom_runAdoptingSteps(node, oldDocument) {
    // No steps defined
}
exports.dom_runAdoptingSteps = dom_runAdoptingSteps;
/**
 * Runs attribute change steps for an element node.
 *
 * @param element - element node owning the attribute
 * @param localName - attribute's local name
 * @param oldValue - attribute's old value
 * @param value - attribute's new value
 * @param namespace - attribute's namespace
 */
function dom_runAttributeChangeSteps(element, localName, oldValue, value, namespace) {
    var e_1, _a;
    // run default steps
    if (DOMImpl_1.dom.features.slots) {
        updateASlotablesName.call(element, element, localName, oldValue, value, namespace);
        updateASlotsName.call(element, element, localName, oldValue, value, namespace);
    }
    updateAnElementID.call(element, element, localName, value, namespace);
    try {
        // run custom steps
        for (var _b = __values(element._attributeChangeSteps), _c = _b.next(); !_c.done; _c = _b.next()) {
            var step = _c.value;
            step.call(element, element, localName, oldValue, value, namespace);
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_1) throw e_1.error; }
    }
}
exports.dom_runAttributeChangeSteps = dom_runAttributeChangeSteps;
/**
 * Runs insertion steps for a node.
 *
 * @param insertedNode - inserted node
 */
function dom_runInsertionSteps(insertedNode) {
    // No steps defined
}
exports.dom_runInsertionSteps = dom_runInsertionSteps;
/**
 * Runs pre-removing steps for a node iterator and node.
 *
 * @param nodeIterator - a node iterator
 * @param toBeRemoved - node to be removed
 */
function dom_runNodeIteratorPreRemovingSteps(nodeIterator, toBeRemoved) {
    removeNodeIterator.call(nodeIterator, nodeIterator, toBeRemoved);
}
exports.dom_runNodeIteratorPreRemovingSteps = dom_runNodeIteratorPreRemovingSteps;
/**
 * Determines if there are any supported tokens defined for the given
 * attribute name.
 *
 * @param attributeName - an attribute name
 */
function dom_hasSupportedTokens(attributeName) {
    return supportedTokens.has(attributeName);
}
exports.dom_hasSupportedTokens = dom_hasSupportedTokens;
/**
 * Returns the set of supported tokens defined for the given attribute name.
 *
 * @param attributeName - an attribute name
 */
function dom_getSupportedTokens(attributeName) {
    return supportedTokens.get(attributeName) || new Set();
}
exports.dom_getSupportedTokens = dom_getSupportedTokens;
/**
 * Runs event construction steps.
 *
 * @param event - an event
 */
function dom_runEventConstructingSteps(event) {
    // No steps defined
}
exports.dom_runEventConstructingSteps = dom_runEventConstructingSteps;
/**
 * Runs child text content change steps for a parent node.
 *
 * @param parent - parent node with text node child nodes
 */
function dom_runChildTextContentChangeSteps(parent) {
    // No steps defined
}
exports.dom_runChildTextContentChangeSteps = dom_runChildTextContentChangeSteps;
/**
 * Defines pre-removing steps for a node iterator.
 */
function removeNodeIterator(nodeIterator, toBeRemovedNode) {
    /**
     * 1. If toBeRemovedNode is not an inclusive ancestor of nodeIterator’s
     * reference, or toBeRemovedNode is nodeIterator’s root, then return.
     */
    if (toBeRemovedNode === nodeIterator._root ||
        !TreeAlgorithm_1.tree_isAncestorOf(nodeIterator._reference, toBeRemovedNode, true)) {
        return;
    }
    /**
     * 2. If nodeIterator’s pointer before reference is true, then:
     */
    if (nodeIterator._pointerBeforeReference) {
        /**
         * 2.1. Let next be toBeRemovedNode’s first following node that is an
         * inclusive descendant of nodeIterator’s root and is not an inclusive
         * descendant of toBeRemovedNode, and null if there is no such node.
         */
        while (true) {
            var nextNode = TreeAlgorithm_1.tree_getFollowingNode(nodeIterator._root, toBeRemovedNode);
            if (nextNode !== null &&
                TreeAlgorithm_1.tree_isDescendantOf(nodeIterator._root, nextNode, true) &&
                !TreeAlgorithm_1.tree_isDescendantOf(toBeRemovedNode, nextNode, true)) {
                /**
                 * 2.2. If next is non-null, then set nodeIterator’s reference to next
                 * and return.
                 */
                nodeIterator._reference = nextNode;
                return;
            }
            else if (nextNode === null) {
                /**
                 * 2.3. Otherwise, set nodeIterator’s pointer before reference to false.
                 */
                nodeIterator._pointerBeforeReference = false;
                return;
            }
        }
    }
    /**
     * 3. Set nodeIterator’s reference to toBeRemovedNode’s parent, if
     * toBeRemovedNode’s previous sibling is null, and to the inclusive
     * descendant of toBeRemovedNode’s previous sibling that appears last in
     * tree order otherwise.
     */
    if (toBeRemovedNode._previousSibling === null) {
        if (toBeRemovedNode._parent !== null) {
            nodeIterator._reference = toBeRemovedNode._parent;
        }
    }
    else {
        var referenceNode = toBeRemovedNode._previousSibling;
        var childNode = TreeAlgorithm_1.tree_getFirstDescendantNode(toBeRemovedNode._previousSibling, true, false);
        while (childNode !== null) {
            if (childNode !== null) {
                referenceNode = childNode;
            }
            // loop through to get the last descendant node
            childNode = TreeAlgorithm_1.tree_getNextDescendantNode(toBeRemovedNode._previousSibling, childNode, true, false);
        }
        nodeIterator._reference = referenceNode;
    }
}
/**
 * Defines attribute change steps to update a slot’s name.
 */
function updateASlotsName(element, localName, oldValue, value, namespace) {
    /**
     * 1. If element is a slot, localName is name, and namespace is null, then:
     * 1.1. If value is oldValue, then return.
     * 1.2. If value is null and oldValue is the empty string, then return.
     * 1.3. If value is the empty string and oldValue is null, then return.
     * 1.4. If value is null or the empty string, then set element’s name to the
     * empty string.
     * 1.5. Otherwise, set element’s name to value.
     * 1.6. Run assign slotables for a tree with element’s root.
     */
    if (util_1.Guard.isSlot(element) && localName === "name" && namespace === null) {
        if (value === oldValue)
            return;
        if (value === null && oldValue === '')
            return;
        if (value === '' && oldValue === null)
            return;
        if ((value === null || value === '')) {
            element._name = '';
        }
        else {
            element._name = value;
        }
        ShadowTreeAlgorithm_1.shadowTree_assignSlotablesForATree(TreeAlgorithm_1.tree_rootNode(element));
    }
}
/**
 * Defines attribute change steps to update a slotable’s name.
 */
function updateASlotablesName(element, localName, oldValue, value, namespace) {
    /**
     * 1. If localName is slot and namespace is null, then:
     * 1.1. If value is oldValue, then return.
     * 1.2. If value is null and oldValue is the empty string, then return.
     * 1.3. If value is the empty string and oldValue is null, then return.
     * 1.4. If value is null or the empty string, then set element’s name to
     * the empty string.
     * 1.5. Otherwise, set element’s name to value.
     * 1.6. If element is assigned, then run assign slotables for element’s
     * assigned slot.
     * 1.7. Run assign a slot for element.
     */
    if (util_1.Guard.isSlotable(element) && localName === "slot" && namespace === null) {
        if (value === oldValue)
            return;
        if (value === null && oldValue === '')
            return;
        if (value === '' && oldValue === null)
            return;
        if ((value === null || value === '')) {
            element._name = '';
        }
        else {
            element._name = value;
        }
        if (ShadowTreeAlgorithm_1.shadowTree_isAssigned(element)) {
            ShadowTreeAlgorithm_1.shadowTree_assignSlotables(element._assignedSlot);
        }
        ShadowTreeAlgorithm_1.shadowTree_assignASlot(element);
    }
}
/**
 * Defines attribute change steps to update an element's ID.
 */
function updateAnElementID(element, localName, value, namespace) {
    /**
     * 1. If localName is id, namespace is null, and value is null or the empty
     * string, then unset element’s ID.
     * 2. Otherwise, if localName is id, namespace is null, then set element’s
     * ID to value.
     */
    if (localName === "id" && namespace === null) {
        if (!value)
            element._uniqueIdentifier = undefined;
        else
            element._uniqueIdentifier = value;
    }
}
//# sourceMappingURL=DOMAlgorithm.js.map

/***/ }),

/***/ 6827:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
var OrderedSetAlgorithm_1 = __nccwpck_require__(8421);
var DOMAlgorithm_1 = __nccwpck_require__(9484);
var ElementAlgorithm_1 = __nccwpck_require__(2720);
/**
 * Validates a given token against the supported tokens defined for the given
 * token lists' associated attribute.
 *
 * @param tokenList - a token list
 * @param token - a token
 */
function tokenList_validationSteps(tokenList, token) {
    /**
     * 1. If the associated attribute’s local name does not define supported
     * tokens, throw a TypeError.
     * 2. Let lowercase token be a copy of token, in ASCII lowercase.
     * 3. If lowercase token is present in supported tokens, return true.
     * 4. Return false.
     */
    if (!DOMAlgorithm_1.dom_hasSupportedTokens(tokenList._attribute._localName)) {
        throw new TypeError("There are no supported tokens defined for attribute name: '" + tokenList._attribute._localName + "'.");
    }
    return DOMAlgorithm_1.dom_getSupportedTokens(tokenList._attribute._localName).has(token.toLowerCase());
}
exports.tokenList_validationSteps = tokenList_validationSteps;
/**
 * Updates the value of the token lists' associated attribute.
 *
 * @param tokenList - a token list
 */
function tokenList_updateSteps(tokenList) {
    /**
     * 1. If the associated element does not have an associated attribute and
     * token set is empty, then return.
     * 2. Set an attribute value for the associated element using associated
     * attribute’s local name and the result of running the ordered set
     * serializer for token set.
     */
    if (!tokenList._element.hasAttribute(tokenList._attribute._localName) &&
        tokenList._tokenSet.size === 0) {
        return;
    }
    ElementAlgorithm_1.element_setAnAttributeValue(tokenList._element, tokenList._attribute._localName, OrderedSetAlgorithm_1.orderedSet_serialize(tokenList._tokenSet));
}
exports.tokenList_updateSteps = tokenList_updateSteps;
/**
 * Gets the value of the token lists' associated attribute.
 *
 * @param tokenList - a token list
 */
function tokenList_serializeSteps(tokenList) {
    /**
     * A DOMTokenList object’s serialize steps are to return the result of
     * running get an attribute value given the associated element and the
     * associated attribute’s local name.
     */
    return ElementAlgorithm_1.element_getAnAttributeValue(tokenList._element, tokenList._attribute._localName);
}
exports.tokenList_serializeSteps = tokenList_serializeSteps;
//# sourceMappingURL=DOMTokenListAlgorithm.js.map

/***/ }),

/***/ 1327:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {


var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var DOMImpl_1 = __nccwpck_require__(698);
var util_1 = __nccwpck_require__(628);
var util_2 = __nccwpck_require__(7061);
var ElementImpl_1 = __nccwpck_require__(1342);
var CustomElementAlgorithm_1 = __nccwpck_require__(5075);
var TreeAlgorithm_1 = __nccwpck_require__(3532);
var NamespaceAlgorithm_1 = __nccwpck_require__(9733);
var DOMAlgorithm_1 = __nccwpck_require__(9484);
var ElementAlgorithm_1 = __nccwpck_require__(2720);
var MutationAlgorithm_1 = __nccwpck_require__(45);
/**
 * Returns an element interface for the given name and namespace.
 *
 * @param name - element name
 * @param namespace - namespace
 */
function document_elementInterface(name, namespace) {
    return ElementImpl_1.ElementImpl;
}
exports.document_elementInterface = document_elementInterface;
/**
 * Creates a new element node.
 * See: https://dom.spec.whatwg.org/#internal-createelementns-steps
 *
 * @param document - owner document
 * @param namespace - element namespace
 * @param qualifiedName - qualified name
 * @param options - element options
 */
function document_internalCreateElementNS(document, namespace, qualifiedName, options) {
    /**
     * 1. Let namespace, prefix, and localName be the result of passing
     * namespace and qualifiedName to validate and extract.
     * 2. Let is be null.
     * 3. If options is a dictionary and options’s is is present, then set
     * is to it.
     * 4. Return the result of creating an element given document, localName,
     * namespace, prefix, is, and with the synchronous custom elements flag set.
     */
    var _a = __read(NamespaceAlgorithm_1.namespace_validateAndExtract(namespace, qualifiedName), 3), ns = _a[0], prefix = _a[1], localName = _a[2];
    var is = null;
    if (options !== undefined) {
        if (util_2.isString(options)) {
            is = options;
        }
        else {
            is = options.is;
        }
    }
    return ElementAlgorithm_1.element_createAnElement(document, localName, ns, prefix, is, true);
}
exports.document_internalCreateElementNS = document_internalCreateElementNS;
/**
 * Removes `node` and its subtree from its document and changes
 * its owner document to `document` so that it can be inserted
 * into `document`.
 *
 * @param node - the node to move
 * @param document - document to receive the node and its subtree
 */
function document_adopt(node, document) {
    var e_1, _a;
    // Optimize for common case of inserting a fresh node
    if (node._nodeDocument === document && node._parent === null) {
        return;
    }
    /**
     * 1. Let oldDocument be node’s node document.
     * 2. If node’s parent is not null, remove node from its parent.
     */
    var oldDocument = node._nodeDocument;
    if (node._parent)
        MutationAlgorithm_1.mutation_remove(node, node._parent);
    /**
     * 3. If document is not oldDocument, then:
     */
    if (document !== oldDocument) {
        /**
         * 3.1. For each inclusiveDescendant in node’s shadow-including inclusive
         * descendants:
         */
        var inclusiveDescendant = TreeAlgorithm_1.tree_getFirstDescendantNode(node, true, true);
        while (inclusiveDescendant !== null) {
            /**
             * 3.1.1. Set inclusiveDescendant’s node document to document.
             * 3.1.2. If inclusiveDescendant is an element, then set the node
             * document of each attribute in inclusiveDescendant’s attribute list
             * to document.
             */
            inclusiveDescendant._nodeDocument = document;
            if (util_1.Guard.isElementNode(inclusiveDescendant)) {
                try {
                    for (var _b = (e_1 = void 0, __values(inclusiveDescendant._attributeList._asArray())), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var attr = _c.value;
                        attr._nodeDocument = document;
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
            }
            /**
             * 3.2. For each inclusiveDescendant in node's shadow-including
             * inclusive descendants that is custom, enqueue a custom
             * element callback reaction with inclusiveDescendant,
             * callback name "adoptedCallback", and an argument list
             * containing oldDocument and document.
             */
            if (DOMImpl_1.dom.features.customElements) {
                if (util_1.Guard.isElementNode(inclusiveDescendant) &&
                    inclusiveDescendant._customElementState === "custom") {
                    CustomElementAlgorithm_1.customElement_enqueueACustomElementCallbackReaction(inclusiveDescendant, "adoptedCallback", [oldDocument, document]);
                }
            }
            /**
             * 3.3. For each inclusiveDescendant in node’s shadow-including
             * inclusive descendants, in shadow-including tree order, run the
             * adopting steps with inclusiveDescendant and oldDocument.
             */
            if (DOMImpl_1.dom.features.steps) {
                DOMAlgorithm_1.dom_runAdoptingSteps(inclusiveDescendant, oldDocument);
            }
            inclusiveDescendant = TreeAlgorithm_1.tree_getNextDescendantNode(node, inclusiveDescendant, true, true);
        }
    }
}
exports.document_adopt = document_adopt;
//# sourceMappingURL=DocumentAlgorithm.js.map

/***/ }),

/***/ 2720:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
var DOMImpl_1 = __nccwpck_require__(698);
var infra_1 = __nccwpck_require__(4737);
var util_1 = __nccwpck_require__(628);
var DOMException_1 = __nccwpck_require__(7175);
var CreateAlgorithm_1 = __nccwpck_require__(8308);
var CustomElementAlgorithm_1 = __nccwpck_require__(5075);
var MutationObserverAlgorithm_1 = __nccwpck_require__(3243);
var DOMAlgorithm_1 = __nccwpck_require__(9484);
var MutationAlgorithm_1 = __nccwpck_require__(45);
var DocumentAlgorithm_1 = __nccwpck_require__(1327);
/**
 * Determines whether the element's attribute list contains the given
 * attribute.
 *
 * @param attribute - an attribute node
 * @param element - an element node
 */
function element_has(attribute, element) {
    /**
     * An element has an attribute A if its attribute list contains A.
     */
    return element._attributeList._asArray().indexOf(attribute) !== -1;
}
exports.element_has = element_has;
/**
 * Changes the value of an attribute node.
 *
 * @param attribute - an attribute node
 * @param element - an element node
 * @param value - attribute value
 */
function element_change(attribute, element, value) {
    /**
     * 1. Queue an attribute mutation record for element with attribute’s
     * local name, attribute’s namespace, and attribute’s value.
     */
    if (DOMImpl_1.dom.features.mutationObservers) {
        MutationObserverAlgorithm_1.observer_queueAttributeMutationRecord(element, attribute._localName, attribute._namespace, attribute._value);
    }
    /**
     * 2. If element is custom, then enqueue a custom element callback reaction
     * with element, callback name "attributeChangedCallback", and an argument
     * list containing attribute’s local name, attribute’s value, value, and
     * attribute’s namespace.
     */
    if (DOMImpl_1.dom.features.customElements) {
        if (util_1.Guard.isCustomElementNode(element)) {
            CustomElementAlgorithm_1.customElement_enqueueACustomElementCallbackReaction(element, "attributeChangedCallback", [attribute._localName, attribute._value, value, attribute._namespace]);
        }
    }
    /**
     * 3. Run the attribute change steps with element, attribute’s local name,
     * attribute’s value, value, and attribute’s namespace.
     * 4. Set attribute’s value to value.
     */
    if (DOMImpl_1.dom.features.steps) {
        DOMAlgorithm_1.dom_runAttributeChangeSteps(element, attribute._localName, attribute._value, value, attribute._namespace);
    }
    attribute._value = value;
}
exports.element_change = element_change;
/**
 * Appends an attribute to an element node.
 *
 * @param attribute - an attribute
 * @param element - an element to receive the attribute
 */
function element_append(attribute, element) {
    /**
     * 1. Queue an attribute mutation record for element with attribute’s
     * local name, attribute’s namespace, and null.
     */
    if (DOMImpl_1.dom.features.mutationObservers) {
        MutationObserverAlgorithm_1.observer_queueAttributeMutationRecord(element, attribute._localName, attribute._namespace, null);
    }
    /**
     * 2. If element is custom, then enqueue a custom element callback reaction
     * with element, callback name "attributeChangedCallback", and an argument
     * list containing attribute’s local name, null, attribute’s value, and
     * attribute’s namespace.
     */
    if (DOMImpl_1.dom.features.customElements) {
        if (util_1.Guard.isCustomElementNode(element)) {
            CustomElementAlgorithm_1.customElement_enqueueACustomElementCallbackReaction(element, "attributeChangedCallback", [attribute._localName, null, attribute._value, attribute._namespace]);
        }
    }
    /**
     * 3. Run the attribute change steps with element, attribute’s local name,
     * null, attribute’s value, and attribute’s namespace.
     */
    if (DOMImpl_1.dom.features.steps) {
        DOMAlgorithm_1.dom_runAttributeChangeSteps(element, attribute._localName, null, attribute._value, attribute._namespace);
    }
    /**
     * 4. Append attribute to element’s attribute list.
     * 5. Set attribute’s element to element.
     */
    element._attributeList._asArray().push(attribute);
    attribute._element = element;
    // mark that the document has namespaces
    if (!element._nodeDocument._hasNamespaces && (attribute._namespace !== null ||
        attribute._namespacePrefix !== null || attribute._localName === "xmlns")) {
        element._nodeDocument._hasNamespaces = true;
    }
}
exports.element_append = element_append;
/**
 * Removes an attribute from an element node.
 *
 * @param attribute - an attribute
 * @param element - an element to receive the attribute
 */
function element_remove(attribute, element) {
    /**
     * 1. Queue an attribute mutation record for element with attribute’s
     * local name, attribute’s namespace, and attribute’s value.
     */
    if (DOMImpl_1.dom.features.mutationObservers) {
        MutationObserverAlgorithm_1.observer_queueAttributeMutationRecord(element, attribute._localName, attribute._namespace, attribute._value);
    }
    /**
     * 2. If element is custom, then enqueue a custom element callback reaction
     * with element, callback name "attributeChangedCallback", and an argument
     * list containing attribute’s local name, attribute’s value, null,
     * and attribute’s namespace.
     */
    if (DOMImpl_1.dom.features.customElements) {
        if (util_1.Guard.isCustomElementNode(element)) {
            CustomElementAlgorithm_1.customElement_enqueueACustomElementCallbackReaction(element, "attributeChangedCallback", [attribute._localName, attribute._value, null, attribute._namespace]);
        }
    }
    /**
     * 3. Run the attribute change steps with element, attribute’s local name,
     * attribute’s value, null, and attribute’s namespace.
     */
    if (DOMImpl_1.dom.features.steps) {
        DOMAlgorithm_1.dom_runAttributeChangeSteps(element, attribute._localName, attribute._value, null, attribute._namespace);
    }
    /**
     * 3. Remove attribute from element’s attribute list.
     * 5. Set attribute’s element to null.
     */
    var index = element._attributeList._asArray().indexOf(attribute);
    element._attributeList._asArray().splice(index, 1);
    attribute._element = null;
}
exports.element_remove = element_remove;
/**
 * Replaces an attribute with another of an element node.
 *
 * @param oldAttr - old attribute
 * @param newAttr - new attribute
 * @param element - an element to receive the attribute
 */
function element_replace(oldAttr, newAttr, element) {
    /**
     * 1. Queue an attribute mutation record for element with oldAttr’s
     * local name, oldAttr’s namespace, and oldAttr’s value.
     */
    if (DOMImpl_1.dom.features.mutationObservers) {
        MutationObserverAlgorithm_1.observer_queueAttributeMutationRecord(element, oldAttr._localName, oldAttr._namespace, oldAttr._value);
    }
    /**
     * 2. If element is custom, then enqueue a custom element callback reaction
     * with element, callback name "attributeChangedCallback", and an argument
     * list containing oldAttr’s local name, oldAttr’s value, newAttr’s value,
     * and oldAttr’s namespace.
     */
    if (DOMImpl_1.dom.features.customElements) {
        if (util_1.Guard.isCustomElementNode(element)) {
            CustomElementAlgorithm_1.customElement_enqueueACustomElementCallbackReaction(element, "attributeChangedCallback", [oldAttr._localName, oldAttr._value, newAttr._value, oldAttr._namespace]);
        }
    }
    /**
     * 3. Run the attribute change steps with element, oldAttr’s local name,
     * oldAttr’s value, newAttr’s value, and oldAttr’s namespace.
     */
    if (DOMImpl_1.dom.features.steps) {
        DOMAlgorithm_1.dom_runAttributeChangeSteps(element, oldAttr._localName, oldAttr._value, newAttr._value, oldAttr._namespace);
    }
    /**
     * 4. Replace oldAttr by newAttr in element’s attribute list.
     * 5. Set oldAttr’s element to null.
     * 6. Set newAttr’s element to element.
     */
    var index = element._attributeList._asArray().indexOf(oldAttr);
    if (index !== -1) {
        element._attributeList._asArray()[index] = newAttr;
    }
    oldAttr._element = null;
    newAttr._element = element;
    // mark that the document has namespaces
    if (!element._nodeDocument._hasNamespaces && (newAttr._namespace !== null ||
        newAttr._namespacePrefix !== null || newAttr._localName === "xmlns")) {
        element._nodeDocument._hasNamespaces = true;
    }
}
exports.element_replace = element_replace;
/**
 * Retrieves an attribute with the given name from an element node.
 *
 * @param qualifiedName - an attribute name
 * @param element - an element to receive the attribute
 */
function element_getAnAttributeByName(qualifiedName, element) {
    /**
     * 1. If element is in the HTML namespace and its node document is an HTML
     * document, then set qualifiedName to qualifiedName in ASCII lowercase.
     * 2. Return the first attribute in element’s attribute list whose qualified
     * name is qualifiedName, and null otherwise.
     */
    if (element._namespace === infra_1.namespace.HTML && element._nodeDocument._type === "html") {
        qualifiedName = qualifiedName.toLowerCase();
    }
    return element._attributeList._asArray().find(function (attr) { return attr._qualifiedName === qualifiedName; }) || null;
}
exports.element_getAnAttributeByName = element_getAnAttributeByName;
/**
 * Retrieves an attribute with the given namespace and local name from an
 * element node.
 *
 * @param namespace - an attribute namespace
 * @param localName - an attribute local name
 * @param element - an element to receive the attribute
 */
function element_getAnAttributeByNamespaceAndLocalName(namespace, localName, element) {
    /**
     * 1. If namespace is the empty string, set it to null.
     * 2. Return the attribute in element’s attribute list whose namespace is
     * namespace and local name is localName, if any, and null otherwise.
     */
    var ns = namespace || null;
    return element._attributeList._asArray().find(function (attr) { return attr._namespace === ns && attr._localName === localName; }) || null;
}
exports.element_getAnAttributeByNamespaceAndLocalName = element_getAnAttributeByNamespaceAndLocalName;
/**
 * Retrieves an attribute's value with the given name namespace and local
 * name from an element node.
 *
 * @param element - an element to receive the attribute
 * @param localName - an attribute local name
 * @param namespace - an attribute namespace
 */
function element_getAnAttributeValue(element, localName, namespace) {
    if (namespace === void 0) { namespace = ''; }
    /**
     * 1. Let attr be the result of getting an attribute given namespace,
     * localName, and element.
     * 2. If attr is null, then return the empty string.
     * 3. Return attr’s value.
     */
    var attr = element_getAnAttributeByNamespaceAndLocalName(namespace, localName, element);
    if (attr === null)
        return '';
    else
        return attr._value;
}
exports.element_getAnAttributeValue = element_getAnAttributeValue;
/**
 * Sets an attribute of an element node.
 *
 * @param attr - an attribute
 * @param element - an element to receive the attribute
 */
function element_setAnAttribute(attr, element) {
    /**
     * 1. If attr’s element is neither null nor element, throw an
     * "InUseAttributeError" DOMException.
     * 2. Let oldAttr be the result of getting an attribute given attr’s
     * namespace, attr’s local name, and element.
     * 3. If oldAttr is attr, return attr.
     * 4. If oldAttr is non-null, replace it by attr in element.
     * 5. Otherwise, append attr to element.
     * 6. Return oldAttr.
     */
    if (attr._element !== null && attr._element !== element)
        throw new DOMException_1.InUseAttributeError("This attribute already exists in the document: " + attr._qualifiedName + " as a child of " + attr._element._qualifiedName + ".");
    var oldAttr = element_getAnAttributeByNamespaceAndLocalName(attr._namespace || '', attr._localName, element);
    if (oldAttr === attr)
        return attr;
    if (oldAttr !== null) {
        element_replace(oldAttr, attr, element);
    }
    else {
        element_append(attr, element);
    }
    return oldAttr;
}
exports.element_setAnAttribute = element_setAnAttribute;
/**
 * Sets an attribute's value of an element node.
 *
 * @param element - an element to receive the attribute
 * @param localName - an attribute local name
 * @param value - an attribute value
 * @param prefix - an attribute prefix
 * @param namespace - an attribute namespace
 */
function element_setAnAttributeValue(element, localName, value, prefix, namespace) {
    if (prefix === void 0) { prefix = null; }
    if (namespace === void 0) { namespace = null; }
    /**
     * 1. If prefix is not given, set it to null.
     * 2. If namespace is not given, set it to null.
     * 3. Let attribute be the result of getting an attribute given namespace,
     * localName, and element.
     * 4. If attribute is null, create an attribute whose namespace is
     * namespace, namespace prefix is prefix, local name is localName, value
     * is value, and node document is element’s node document, then append this
     * attribute to element, and then return.
     * 5. Change attribute from element to value.
     */
    var attribute = element_getAnAttributeByNamespaceAndLocalName(namespace || '', localName, element);
    if (attribute === null) {
        var newAttr = CreateAlgorithm_1.create_attr(element._nodeDocument, localName);
        newAttr._namespace = namespace;
        newAttr._namespacePrefix = prefix;
        newAttr._value = value;
        element_append(newAttr, element);
        return;
    }
    element_change(attribute, element, value);
}
exports.element_setAnAttributeValue = element_setAnAttributeValue;
/**
 * Removes an attribute with the given name from an element node.
 *
 * @param qualifiedName - an attribute name
 * @param element - an element to receive the attribute
 */
function element_removeAnAttributeByName(qualifiedName, element) {
    /**
     * 1. Let attr be the result of getting an attribute given qualifiedName
     * and element.
     * 2. If attr is non-null, remove it from element.
     * 3. Return attr.
     */
    var attr = element_getAnAttributeByName(qualifiedName, element);
    if (attr !== null) {
        element_remove(attr, element);
    }
    return attr;
}
exports.element_removeAnAttributeByName = element_removeAnAttributeByName;
/**
 * Removes an attribute with the given namespace and local name from an
 * element node.
 *
 * @param namespace - an attribute namespace
 * @param localName - an attribute local name
 * @param element - an element to receive the attribute
 */
function element_removeAnAttributeByNamespaceAndLocalName(namespace, localName, element) {
    /**
     * 1. Let attr be the result of getting an attribute given namespace, localName, and element.
     * 2. If attr is non-null, remove it from element.
     * 3. Return attr.
     */
    var attr = element_getAnAttributeByNamespaceAndLocalName(namespace, localName, element);
    if (attr !== null) {
        element_remove(attr, element);
    }
    return attr;
}
exports.element_removeAnAttributeByNamespaceAndLocalName = element_removeAnAttributeByNamespaceAndLocalName;
/**
 * Creates an element node.
 * See: https://dom.spec.whatwg.org/#concept-create-element.
 *
 * @param document - the document owning the element
 * @param localName - local name
 * @param namespace - element namespace
 * @param prefix - namespace prefix
 * @param is - the "is" value
 * @param synchronousCustomElementsFlag - synchronous custom elements flag
 */
function element_createAnElement(document, localName, namespace, prefix, is, synchronousCustomElementsFlag) {
    if (prefix === void 0) { prefix = null; }
    if (is === void 0) { is = null; }
    if (synchronousCustomElementsFlag === void 0) { synchronousCustomElementsFlag = false; }
    /**
     * 1. If prefix was not given, let prefix be null.
     * 2. If is was not given, let is be null.
     * 3. Let result be null.
     */
    var result = null;
    if (!DOMImpl_1.dom.features.customElements) {
        result = CreateAlgorithm_1.create_element(document, localName, namespace, prefix);
        result._customElementState = "uncustomized";
        result._customElementDefinition = null;
        result._is = is;
        return result;
    }
    /**
     * 4. Let definition be the result of looking up a custom element definition
     * given document, namespace, localName, and is.
     */
    var definition = CustomElementAlgorithm_1.customElement_lookUpACustomElementDefinition(document, namespace, localName, is);
    if (definition !== null && definition.name !== definition.localName) {
        /**
        * 5. If definition is non-null, and definition’s name is not equal to
        * its local name (i.e., definition represents a customized built-in
        * element), then:
          * 5.1. Let interface be the element interface for localName and the HTML
          * namespace.
          * 5.2. Set result to a new element that implements interface, with no
          * attributes, namespace set to the HTML namespace, namespace prefix
          * set to prefix, local name set to localName, custom element state set
          * to "undefined", custom element definition set to null, is value set
          * to is, and node document set to document.
          * 5.3. If the synchronous custom elements flag is set, upgrade element
          * using definition.
          * 5.4. Otherwise, enqueue a custom element upgrade reaction given result
          * and definition.
          */
        var elemenInterface = DocumentAlgorithm_1.document_elementInterface(localName, infra_1.namespace.HTML);
        result = new elemenInterface();
        result._localName = localName;
        result._namespace = infra_1.namespace.HTML;
        result._namespacePrefix = prefix;
        result._customElementState = "undefined";
        result._customElementDefinition = null;
        result._is = is;
        result._nodeDocument = document;
        if (synchronousCustomElementsFlag) {
            CustomElementAlgorithm_1.customElement_upgrade(definition, result);
        }
        else {
            CustomElementAlgorithm_1.customElement_enqueueACustomElementUpgradeReaction(result, definition);
        }
    }
    else if (definition !== null) {
        /**
         * 6. Otherwise, if definition is non-null, then:
         */
        if (synchronousCustomElementsFlag) {
            /**
             * 6.1. If the synchronous custom elements flag is set, then run these
             * steps while catching any exceptions:
             */
            try {
                /**
                 * 6.1.1. Let C be definition’s constructor.
                 * 6.1.2. Set result to the result of constructing C, with no arguments.
                 * 6.1.3. Assert: result’s custom element state and custom element definition
                 * are initialized.
                 * 6.1.4. Assert: result’s namespace is the HTML namespace.
                 * _Note:_ IDL enforces that result is an HTMLElement object, which all
                 * use the HTML namespace.
                 */
                var C = definition.constructor;
                var result_1 = new C();
                console.assert(result_1._customElementState !== undefined);
                console.assert(result_1._customElementDefinition !== undefined);
                console.assert(result_1._namespace === infra_1.namespace.HTML);
                /**
                 * 6.1.5. If result’s attribute list is not empty, then throw a
                 * "NotSupportedError" DOMException.
                 * 6.1.6. If result has children, then throw a "NotSupportedError"
                 * DOMException.
                 * 6.1.7. If result’s parent is not null, then throw a
                 * "NotSupportedError" DOMException.
                 * 6.1.8. If result’s node document is not document, then throw a
                 * "NotSupportedError" DOMException.
                 * 6.1.9. If result’s local name is not equal to localName, then throw
                 * a "NotSupportedError" DOMException.
                 */
                if (result_1._attributeList.length !== 0)
                    throw new DOMException_1.NotSupportedError("Custom element already has attributes.");
                if (result_1._children.size !== 0)
                    throw new DOMException_1.NotSupportedError("Custom element already has child nodes.");
                if (result_1._parent !== null)
                    throw new DOMException_1.NotSupportedError("Custom element already has a parent node.");
                if (result_1._nodeDocument !== document)
                    throw new DOMException_1.NotSupportedError("Custom element is already in a document.");
                if (result_1._localName !== localName)
                    throw new DOMException_1.NotSupportedError("Custom element has a different local name.");
                /**
                 * 6.1.10. Set result’s namespace prefix to prefix.
                 * 6.1.11. Set result’s is value to null.
                 */
                result_1._namespacePrefix = prefix;
                result_1._is = null;
            }
            catch (e) {
                /**
                 * If any of these steps threw an exception, then:
                 * - Report the exception.
                 * - Set result to a new element that implements the HTMLUnknownElement
                 * interface, with no attributes, namespace set to the HTML namespace,
                 * namespace prefix set to prefix, local name set to localName, custom
                 * element state set to "failed", custom element definition set to null,
                 * is value set to null, and node document set to document.
                 */
                // TODO: Report the exception
                result = CreateAlgorithm_1.create_htmlUnknownElement(document, localName, infra_1.namespace.HTML, prefix);
                result._customElementState = "failed";
                result._customElementDefinition = null;
                result._is = null;
            }
        }
        else {
            /**
             * 6.2. Otherwise:
             * 6.2.1. Set result to a new element that implements the HTMLElement
             * interface, with no attributes, namespace set to the HTML namespace,
             * namespace prefix set to prefix, local name set to localName, custom
             * element state set to "undefined", custom element definition set to
             * null, is value set to null, and node document set to document.
             * 6.2.2. Enqueue a custom element upgrade reaction given result and
             * definition.
             */
            result = CreateAlgorithm_1.create_htmlElement(document, localName, infra_1.namespace.HTML, prefix);
            result._customElementState = "undefined";
            result._customElementDefinition = null;
            result._is = null;
            CustomElementAlgorithm_1.customElement_enqueueACustomElementUpgradeReaction(result, definition);
        }
    }
    else {
        /**
         * 7. Otherwise:
         * 7.1. Let interface be the element interface for localName and
         * namespace.
         * 7.2. Set result to a new element that implements interface, with no
         * attributes, namespace set to namespace, namespace prefix set to prefix,
         * local name set to localName, custom element state set to
         * "uncustomized", custom element definition set to null, is value set to
         * is, and node document set to document.
         */
        var elementInterface = DocumentAlgorithm_1.document_elementInterface(localName, namespace);
        result = new elementInterface();
        result._localName = localName;
        result._namespace = namespace;
        result._namespacePrefix = prefix;
        result._customElementState = "uncustomized";
        result._customElementDefinition = null;
        result._is = is;
        result._nodeDocument = document;
        /**
         * 7.3. If namespace is the HTML namespace, and either localName is a
         * valid custom element name or is is non-null, then set result’s
         * custom element state to "undefined".
         */
        if (namespace === infra_1.namespace.HTML && (is !== null ||
            CustomElementAlgorithm_1.customElement_isValidCustomElementName(localName))) {
            result._customElementState = "undefined";
        }
    }
    /* istanbul ignore next */
    if (result === null) {
        throw new Error("Unable to create element.");
    }
    /**
     * 8. Returns result
     */
    return result;
}
exports.element_createAnElement = element_createAnElement;
/**
 * Inserts a new node adjacent to this element.
 *
 * @param element - a reference element
 * @param where - a string defining where to insert the element node.
 *   - `beforebegin` before this element itself.
 *   - `afterbegin` before the first child.
 *   - `beforeend` after the last child.
 *   - `afterend` after this element itself.
 * @param node - node to insert
 */
function element_insertAdjacent(element, where, node) {
    /**
     * - "beforebegin"
     * If element’s parent is null, return null.
     * Return the result of pre-inserting node into element’s parent before
     * element.
     * - "afterbegin"
     * Return the result of pre-inserting node into element before element’s
     * first child.
     * - "beforeend"
     * Return the result of pre-inserting node into element before null.
     * - "afterend"
     * If element’s parent is null, return null.
     * Return the result of pre-inserting node into element’s parent before element’s next sibling.
     * - Otherwise
     * Throw a "SyntaxError" DOMException.
     */
    switch (where.toLowerCase()) {
        case 'beforebegin':
            if (element._parent === null)
                return null;
            return MutationAlgorithm_1.mutation_preInsert(node, element._parent, element);
        case 'afterbegin':
            return MutationAlgorithm_1.mutation_preInsert(node, element, element._firstChild);
        case 'beforeend':
            return MutationAlgorithm_1.mutation_preInsert(node, element, null);
        case 'afterend':
            if (element._parent === null)
                return null;
            return MutationAlgorithm_1.mutation_preInsert(node, element._parent, element._nextSibling);
        default:
            throw new DOMException_1.SyntaxError("Invalid 'where' argument. \"beforebegin\", \"afterbegin\", \"beforeend\" or \"afterend\" expected");
    }
}
exports.element_insertAdjacent = element_insertAdjacent;
//# sourceMappingURL=ElementAlgorithm.js.map

/***/ }),

/***/ 8012:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {


var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var DOMImpl_1 = __nccwpck_require__(698);
var interfaces_1 = __nccwpck_require__(9454);
var util_1 = __nccwpck_require__(628);
var CustomEventImpl_1 = __nccwpck_require__(3171);
var EventImpl_1 = __nccwpck_require__(2390);
var DOMException_1 = __nccwpck_require__(7175);
var TreeAlgorithm_1 = __nccwpck_require__(3532);
var ShadowTreeAlgorithm_1 = __nccwpck_require__(708);
var DOMAlgorithm_1 = __nccwpck_require__(9484);
/**
 * Sets the canceled flag of an event.
 *
 * @param event - an event
 */
function event_setTheCanceledFlag(event) {
    if (event._cancelable && !event._inPassiveListenerFlag) {
        event._canceledFlag = true;
    }
}
exports.event_setTheCanceledFlag = event_setTheCanceledFlag;
/**
 * Initializes the value of an event.
 *
 * @param event - an event to initialize
 * @param type - the type of event
 * @param bubbles - whether the event propagates in reverse
 * @param cancelable - whether the event can be cancelled
 */
function event_initialize(event, type, bubbles, cancelable) {
    event._initializedFlag = true;
    event._stopPropagationFlag = false;
    event._stopImmediatePropagationFlag = false;
    event._canceledFlag = false;
    event._isTrusted = false;
    event._target = null;
    event._type = type;
    event._bubbles = bubbles;
    event._cancelable = cancelable;
}
exports.event_initialize = event_initialize;
/**
 * Creates a new event.
 *
 * @param eventInterface - event interface
 * @param realm - realm
 */
function event_createAnEvent(eventInterface, realm) {
    if (realm === void 0) { realm = undefined; }
    /**
     * 1. If realm is not given, then set it to null.
     * 2. Let dictionary be the result of converting the JavaScript value
     * undefined to the dictionary type accepted by eventInterface’s
     * constructor. (This dictionary type will either be EventInit or a
     * dictionary that inherits from it.)
     * 3. Let event be the result of running the inner event creation steps with
     * eventInterface, realm, the time of the occurrence that the event is
     * signaling, and dictionary.
     * 4. Initialize event’s isTrusted attribute to true.
     * 5. Return event.
     */
    if (realm === undefined)
        realm = null;
    var dictionary = {};
    var event = event_innerEventCreationSteps(eventInterface, realm, new Date(), dictionary);
    event._isTrusted = true;
    return event;
}
exports.event_createAnEvent = event_createAnEvent;
/**
 * Performs event creation steps.
 *
 * @param eventInterface - event interface
 * @param realm - realm
 * @param time - time of occurrance
 * @param dictionary - event attributes
 *
 */
function event_innerEventCreationSteps(eventInterface, realm, time, dictionary) {
    /**
     * 1. Let event be the result of creating a new object using eventInterface.
     * TODO: Implement realms
     * If realm is non-null, then use that Realm; otherwise, use the default
     * behavior defined in Web IDL.
     */
    var event = new eventInterface("");
    /**
     * 2. Set event’s initialized flag.
     * 3. Initialize event’s timeStamp attribute to a DOMHighResTimeStamp
     * representing the high resolution time from the time origin to time.
     * 4. For each member → value in dictionary, if event has an attribute
     * whose identifier is member, then initialize that attribute to value.
     * 5. Run the event constructing steps with event.
     * 6. Return event.
     */
    event._initializedFlag = true;
    event._timeStamp = time.getTime();
    Object.assign(event, dictionary);
    if (DOMImpl_1.dom.features.steps) {
        DOMAlgorithm_1.dom_runEventConstructingSteps(event);
    }
    return event;
}
exports.event_innerEventCreationSteps = event_innerEventCreationSteps;
/**
 * Dispatches an event to an event target.
 *
 * @param event - the event to dispatch
 * @param target - event target
 * @param legacyTargetOverrideFlag - legacy target override flag
 * @param legacyOutputDidListenersThrowFlag - legacy output flag that returns
 * whether the event listener's callback threw an exception
 */
function event_dispatch(event, target, legacyTargetOverrideFlag, legacyOutputDidListenersThrowFlag) {
    var e_1, _a, e_2, _b;
    if (legacyTargetOverrideFlag === void 0) { legacyTargetOverrideFlag = false; }
    if (legacyOutputDidListenersThrowFlag === void 0) { legacyOutputDidListenersThrowFlag = { value: false }; }
    var clearTargets = false;
    /**
     * 1. Set event's dispatch flag.
     */
    event._dispatchFlag = true;
    /**
     * 2. Let targetOverride be target, if legacy target override flag is not
     * given, and target's associated Document otherwise.
     *
     * _Note:_ legacy target override flag is only used by HTML and only when
     * target is a Window object.
     */
    var targetOverride = target;
    if (legacyTargetOverrideFlag) {
        var doc = target._associatedDocument;
        if (util_1.Guard.isDocumentNode(doc)) {
            targetOverride = doc;
        }
    }
    /**
     * 3. Let activationTarget be null.
     * 4. Let relatedTarget be the result of retargeting event's relatedTarget
     * against target.
     * 5. If target is not relatedTarget or target is event's relatedTarget,
     * then:
    */
    var activationTarget = null;
    var relatedTarget = TreeAlgorithm_1.tree_retarget(event._relatedTarget, target);
    if (target !== relatedTarget || target === event._relatedTarget) {
        /**
         * 5.1. Let touchTargets be a new list.
         * 5.2. For each touchTarget of event's touch target list, append the
         * result of retargeting touchTarget against target to touchTargets.
         * 5.3. Append to an event path with event, target, targetOverride,
         * relatedTarget, touchTargets, and false.
         * 5.4. Let isActivationEvent be true, if event is a MouseEvent object
         * and event's type attribute is "click", and false otherwise.
         * 5.5. If isActivationEvent is true and target has activation behavior,
         * then set activationTarget to target.
         * 5.6. Let slotable be target, if target is a slotable and is assigned,
         * and null otherwise.
         * 5.7. Let slot-in-closed-tree be false.
         * 5.8. Let parent be the result of invoking target's get the parent with
         * event.
         */
        var touchTargets = [];
        try {
            for (var _c = __values(event._touchTargetList), _d = _c.next(); !_d.done; _d = _c.next()) {
                var touchTarget = _d.value;
                touchTargets.push(TreeAlgorithm_1.tree_retarget(touchTarget, target));
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
            }
            finally { if (e_1) throw e_1.error; }
        }
        event_appendToAnEventPath(event, target, targetOverride, relatedTarget, touchTargets, false);
        var isActivationEvent = (util_1.Guard.isMouseEvent(event) && event._type === "click");
        if (isActivationEvent && target._activationBehavior !== undefined) {
            activationTarget = target;
        }
        var slotable = (util_1.Guard.isSlotable(target) && ShadowTreeAlgorithm_1.shadowTree_isAssigned(target)) ?
            target : null;
        var slotInClosedTree = false;
        var parent = target._getTheParent(event);
        /**
         * 5.9. While parent is non-null:
         */
        while (parent !== null && util_1.Guard.isNode(parent)) {
            /**
             * 5.9.1 If slotable is non-null:
             * 5.9.1.1. Assert: parent is a slot.
             * 5.9.1.2. Set slotable to null.
             * 5.9.1.3. If parent's root is a shadow root whose mode is "closed",
             * then set slot-in-closed-tree to true.
             */
            if (slotable !== null) {
                if (!util_1.Guard.isSlot(parent)) {
                    throw new Error("Parent node of a slotable should be a slot.");
                }
                slotable = null;
                var root = TreeAlgorithm_1.tree_rootNode(parent, true);
                if (util_1.Guard.isShadowRoot(root) && root._mode === "closed") {
                    slotInClosedTree = true;
                }
            }
            /**
             * 5.9.2 If parent is a slotable and is assigned, then set slotable to
             * parent.
             * 5.9.3. Let relatedTarget be the result of retargeting event's
             * relatedTarget against parent.
             * 5.9.4. Let touchTargets be a new list.
             * 5.9.4. For each touchTarget of event's touch target list, append the
             * result of retargeting touchTarget against parent to touchTargets.
             */
            if (util_1.Guard.isSlotable(parent) && ShadowTreeAlgorithm_1.shadowTree_isAssigned(parent)) {
                slotable = parent;
            }
            relatedTarget = TreeAlgorithm_1.tree_retarget(event._relatedTarget, parent);
            touchTargets = [];
            try {
                for (var _e = (e_2 = void 0, __values(event._touchTargetList)), _f = _e.next(); !_f.done; _f = _e.next()) {
                    var touchTarget = _f.value;
                    touchTargets.push(TreeAlgorithm_1.tree_retarget(touchTarget, parent));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                }
                finally { if (e_2) throw e_2.error; }
            }
            /**
             * 5.9.6. If parent is a Window object, or parent is a node and target's
             * root is a shadow-including inclusive ancestor of parent, then:
             */
            if (util_1.Guard.isWindow(parent) || (util_1.Guard.isNode(parent) && util_1.Guard.isNode(target) &&
                TreeAlgorithm_1.tree_isAncestorOf(TreeAlgorithm_1.tree_rootNode(target, true), parent, true, true))) {
                /**
                 * 5.9.6.1. If isActivationEvent is true, event's bubbles attribute
                 * is true, activationTarget is null, and parent has activation
                 * behavior, then set activationTarget to parent.
                 * 5.9.6.2. Append to an event path with event, parent, null,
                 * relatedTarget, touchTargets, and slot-in-closed-tree.
                 */
                if (isActivationEvent && event._bubbles && activationTarget === null &&
                    parent._activationBehavior) {
                    activationTarget = parent;
                }
                event_appendToAnEventPath(event, parent, null, relatedTarget, touchTargets, slotInClosedTree);
            }
            else if (parent === relatedTarget) {
                /**
                 * 5.9.7. Otherwise, if parent is relatedTarget,
                 * then set parent to null.
                 */
                parent = null;
            }
            else {
                /**
                 * 5.9.8. Otherwise, set target to parent and then:
                 * 5.9.8.1. If isActivationEvent is true, activationTarget is null,
                 * and target has activation behavior, then set activationTarget
                 * to target.
                 * 5.9.8.2. Append to an event path with event, parent, target,
                 * relatedTarget, touchTargets, and slot-in-closed-tree.
                 */
                target = parent;
                if (isActivationEvent && activationTarget === null &&
                    target._activationBehavior) {
                    activationTarget = target;
                }
                event_appendToAnEventPath(event, parent, target, relatedTarget, touchTargets, slotInClosedTree);
            }
            /**
             * 5.9.9. If parent is non-null, then set parent to the result of
             * invoking parent's get the parent with event.
             * 5.9.10. Set slot-in-closed-tree to false.
             */
            if (parent !== null) {
                parent = parent._getTheParent(event);
            }
            slotInClosedTree = false;
        }
        /**
         * 5.10. Let clearTargetsStruct be the last struct in event's path whose
         * shadow-adjusted target is non-null.
         */
        var clearTargetsStruct = null;
        var path = event._path;
        for (var i = path.length - 1; i >= 0; i--) {
            var struct = path[i];
            if (struct.shadowAdjustedTarget !== null) {
                clearTargetsStruct = struct;
                break;
            }
        }
        /**
         * 5.11. Let clearTargets be true if clearTargetsStruct's shadow-adjusted
         * target, clearTargetsStruct's relatedTarget, or an EventTarget object
         * in clearTargetsStruct's touch target list is a node and its root is
         * a shadow root, and false otherwise.
         */
        if (clearTargetsStruct !== null) {
            if (util_1.Guard.isNode(clearTargetsStruct.shadowAdjustedTarget) &&
                util_1.Guard.isShadowRoot(TreeAlgorithm_1.tree_rootNode(clearTargetsStruct.shadowAdjustedTarget, true))) {
                clearTargets = true;
            }
            else if (util_1.Guard.isNode(clearTargetsStruct.relatedTarget) &&
                util_1.Guard.isShadowRoot(TreeAlgorithm_1.tree_rootNode(clearTargetsStruct.relatedTarget, true))) {
                clearTargets = true;
            }
            else {
                for (var j = 0; j < clearTargetsStruct.touchTargetList.length; j++) {
                    var struct = clearTargetsStruct.touchTargetList[j];
                    if (util_1.Guard.isNode(struct) &&
                        util_1.Guard.isShadowRoot(TreeAlgorithm_1.tree_rootNode(struct, true))) {
                        clearTargets = true;
                        break;
                    }
                }
            }
        }
        /**
         * 5.12. If activationTarget is non-null and activationTarget has
         * legacy-pre-activation behavior, then run activationTarget's
         * legacy-pre-activation behavior.
         */
        if (activationTarget !== null &&
            activationTarget._legacyPreActivationBehavior !== undefined) {
            activationTarget._legacyPreActivationBehavior(event);
        }
        /**
         * 5.13. For each struct in event's path, in reverse order:
         */
        for (var i = path.length - 1; i >= 0; i--) {
            var struct = path[i];
            /**
             * 5.13.1. If struct's shadow-adjusted target is non-null, then set
             * event's eventPhase attribute to AT_TARGET.
             * 5.13.2. Otherwise, set event's eventPhase attribute to
             * CAPTURING_PHASE.
             * 5.13.3. Invoke with struct, event, "capturing", and
             * legacyOutputDidListenersThrowFlag if given.
             */
            if (struct.shadowAdjustedTarget !== null) {
                event._eventPhase = interfaces_1.EventPhase.AtTarget;
            }
            else {
                event._eventPhase = interfaces_1.EventPhase.Capturing;
            }
            event_invoke(struct, event, "capturing", legacyOutputDidListenersThrowFlag);
        }
        /**
         * 5.14. For each struct in event's path
         */
        for (var i = 0; i < path.length; i++) {
            var struct = path[i];
            /**
             * 5.14.1. If struct's shadow-adjusted target is non-null, then set
             * event's eventPhase attribute to AT_TARGET.
             * 5.14.2. Otherwise:
             * 5.14.2.1. If event's bubbles attribute is false, then continue.
             * 5.14.2.2. Set event's eventPhase attribute to BUBBLING_PHASE.
             * 5.14.3. Invoke with struct, event, "bubbling", and
             * legacyOutputDidListenersThrowFlag if given.
             */
            if (struct.shadowAdjustedTarget !== null) {
                event._eventPhase = interfaces_1.EventPhase.AtTarget;
            }
            else {
                if (!event._bubbles)
                    continue;
                event._eventPhase = interfaces_1.EventPhase.Bubbling;
            }
            event_invoke(struct, event, "bubbling", legacyOutputDidListenersThrowFlag);
        }
    }
    /**
     * 6. Set event's eventPhase attribute to NONE.
     * 7. Set event's currentTarget attribute to null.
     * 8. Set event's path to the empty list.
     * 9. Unset event's dispatch flag, stop propagation flag, and stop
     * immediate propagation flag.
     */
    event._eventPhase = interfaces_1.EventPhase.None;
    event._currentTarget = null;
    event._path = [];
    event._dispatchFlag = false;
    event._stopPropagationFlag = false;
    event._stopImmediatePropagationFlag = false;
    /**
     * 10. If clearTargets, then:
     * 10.1. Set event's target to null.
     * 10.2. Set event's relatedTarget to null.
     * 10.3. Set event's touch target list to the empty list.
     */
    if (clearTargets) {
        event._target = null;
        event._relatedTarget = null;
        event._touchTargetList = [];
    }
    /**
     * 11. If activationTarget is non-null, then:
     * 11.1. If event's canceled flag is unset, then run activationTarget's
     * activation behavior with event.
     * 11.2. Otherwise, if activationTarget has legacy-canceled-activation
     * behavior, then run activationTarget's legacy-canceled-activation
     * behavior.
     */
    if (activationTarget !== null) {
        if (!event._canceledFlag && activationTarget._activationBehavior !== undefined) {
            activationTarget._activationBehavior(event);
        }
        else if (activationTarget._legacyCanceledActivationBehavior !== undefined) {
            activationTarget._legacyCanceledActivationBehavior(event);
        }
    }
    /**
     * 12. Return false if event's canceled flag is set, and true otherwise.
     */
    return !event._canceledFlag;
}
exports.event_dispatch = event_dispatch;
/**
 * Appends a new struct to an event's path.
 *
 * @param event - an event
 * @param invocationTarget - the target of the invocation
 * @param shadowAdjustedTarget - shadow-root adjusted event target
 * @param relatedTarget - related event target
 * @param touchTargets - a list of touch targets
 * @param slotInClosedTree - if the target's parent is a closed shadow root
 */
function event_appendToAnEventPath(event, invocationTarget, shadowAdjustedTarget, relatedTarget, touchTargets, slotInClosedTree) {
    /**
     * 1. Let invocationTargetInShadowTree be false.
     * 2. If invocationTarget is a node and its root is a shadow root, then
     * set invocationTargetInShadowTree to true.
     */
    var invocationTargetInShadowTree = false;
    if (util_1.Guard.isNode(invocationTarget) &&
        util_1.Guard.isShadowRoot(TreeAlgorithm_1.tree_rootNode(invocationTarget))) {
        invocationTargetInShadowTree = true;
    }
    /**
     * 3. Let root-of-closed-tree be false.
     * 4. If invocationTarget is a shadow root whose mode is "closed", then
     * set root-of-closed-tree to true.
     */
    var rootOfClosedTree = false;
    if (util_1.Guard.isShadowRoot(invocationTarget) &&
        invocationTarget._mode === "closed") {
        rootOfClosedTree = true;
    }
    /**
     * 5. Append a new struct to event's path whose invocation target is
     * invocationTarget, invocation-target-in-shadow-tree is
     * invocationTargetInShadowTree, shadow-adjusted target is
     * shadowAdjustedTarget, relatedTarget is relatedTarget,
     * touch target list is touchTargets, root-of-closed-tree is
     * root-of-closed-tree, and slot-in-closed-tree is slot-in-closed-tree.
     */
    event._path.push({
        invocationTarget: invocationTarget,
        invocationTargetInShadowTree: invocationTargetInShadowTree,
        shadowAdjustedTarget: shadowAdjustedTarget,
        relatedTarget: relatedTarget,
        touchTargetList: touchTargets,
        rootOfClosedTree: rootOfClosedTree,
        slotInClosedTree: slotInClosedTree
    });
}
exports.event_appendToAnEventPath = event_appendToAnEventPath;
/**
 * Invokes an event.
 *
 * @param struct - a struct defining event's path
 * @param event - the event to invoke
 * @param phase - event phase
 * @param legacyOutputDidListenersThrowFlag - legacy output flag that returns
 * whether the event listener's callback threw an exception
 */
function event_invoke(struct, event, phase, legacyOutputDidListenersThrowFlag) {
    if (legacyOutputDidListenersThrowFlag === void 0) { legacyOutputDidListenersThrowFlag = { value: false }; }
    /**
     * 1. Set event's target to the shadow-adjusted target of the last struct
     * in event's path, that is either struct or preceding struct, whose
     * shadow-adjusted target is non-null.
     */
    var path = event._path;
    var index = -1;
    for (var i = 0; i < path.length; i++) {
        if (path[i] === struct) {
            index = i;
            break;
        }
    }
    if (index !== -1) {
        var item = path[index];
        if (item.shadowAdjustedTarget !== null) {
            event._target = item.shadowAdjustedTarget;
        }
        else if (index > 0) {
            item = path[index - 1];
            if (item.shadowAdjustedTarget !== null) {
                event._target = item.shadowAdjustedTarget;
            }
        }
    }
    /**
     * 2. Set event's relatedTarget to struct's relatedTarget.
     * 3. Set event's touch target list to struct's touch target list.
     * 4. If event's stop propagation flag is set, then return.
     * 5. Initialize event's currentTarget attribute to struct's invocation
     * target.
     * 6. Let listeners be a clone of event's currentTarget attribute value's
     * event listener list.
     *
     * _Note:_ This avoids event listeners added after this point from being
     * run. Note that removal still has an effect due to the removed field.
     */
    event._relatedTarget = struct.relatedTarget;
    event._touchTargetList = struct.touchTargetList;
    if (event._stopPropagationFlag)
        return;
    event._currentTarget = struct.invocationTarget;
    var currentTarget = event._currentTarget;
    var targetListeners = currentTarget._eventListenerList;
    var listeners = new (Array.bind.apply(Array, __spread([void 0], targetListeners)))();
    /**
     * 7. Let found be the result of running inner invoke with event, listeners,
     * phase, and legacyOutputDidListenersThrowFlag if given.
     */
    var found = event_innerInvoke(event, listeners, phase, struct, legacyOutputDidListenersThrowFlag);
    /**
     * 8. If found is false and event's isTrusted attribute is true, then:
     */
    if (!found && event._isTrusted) {
        /**
         * 8.1. Let originalEventType be event's type attribute value.
         * 8.2. If event's type attribute value is a match for any of the strings
         * in the first column in the following table, set event's type attribute
         * value to the string in the second column on the same row as the matching
         * string, and return otherwise.
         *
         * Event type           | Legacy event type
         * -------------------------------------------------
         * "animationend"       | "webkitAnimationEnd"
         * "animationiteration" | "webkitAnimationIteration"
         * "animationstart"     | "webkitAnimationStart"
         * "transitionend"      | "webkitTransitionEnd"
         */
        var originalEventType = event._type;
        if (originalEventType === "animationend") {
            event._type = "webkitAnimationEnd";
        }
        else if (originalEventType === "animationiteration") {
            event._type = "webkitAnimationIteration";
        }
        else if (originalEventType === "animationstart") {
            event._type = "webkitAnimationStart";
        }
        else if (originalEventType === "transitionend") {
            event._type = "webkitTransitionEnd";
        }
        /**
         * 8.3. Inner invoke with event, listeners, phase, and
         * legacyOutputDidListenersThrowFlag if given.
         * 8.4. Set event's type attribute value to originalEventType.
         */
        event_innerInvoke(event, listeners, phase, struct, legacyOutputDidListenersThrowFlag);
        event._type = originalEventType;
    }
}
exports.event_invoke = event_invoke;
/**
 * Invokes an event.
 *
 * @param event - the event to invoke
 * @param listeners - event listeners
 * @param phase - event phase
 * @param struct - a struct defining event's path
 * @param legacyOutputDidListenersThrowFlag - legacy output flag that returns
 * whether the event listener's callback threw an exception
 */
function event_innerInvoke(event, listeners, phase, struct, legacyOutputDidListenersThrowFlag) {
    if (legacyOutputDidListenersThrowFlag === void 0) { legacyOutputDidListenersThrowFlag = { value: false }; }
    /**
     * 1. Let found be false.
     * 2. For each listener in listeners, whose removed is false:
     */
    var found = false;
    for (var i = 0; i < listeners.length; i++) {
        var listener = listeners[i];
        if (!listener.removed) {
            /**
             * 2.1. If event's type attribute value is not listener's type, then
             * continue.
             * 2.2. Set found to true.
             * 2.3. If phase is "capturing" and listener's capture is false, then
             * continue.
             * 2.4. If phase is "bubbling" and listener's capture is true, then
             * continue.
             */
            if (event._type !== listener.type)
                continue;
            found = true;
            if (phase === "capturing" && !listener.capture)
                continue;
            if (phase === "bubbling" && listener.capture)
                continue;
            /**
             * 2.5. If listener's once is true, then remove listener from event's
             * currentTarget attribute value's event listener list.
             */
            if (listener.once && event._currentTarget !== null) {
                var impl = event._currentTarget;
                var index = -1;
                for (var i_1 = 0; i_1 < impl._eventListenerList.length; i_1++) {
                    if (impl._eventListenerList[i_1] === listener) {
                        index = i_1;
                        break;
                    }
                }
                if (index !== -1) {
                    impl._eventListenerList.splice(index, 1);
                }
            }
            /**
             * TODO: Implement realms
             *
             * 2.6. Let global be listener callback's associated Realm's global
             * object.
             */
            var globalObject = undefined;
            /**
             * 2.7. Let currentEvent be undefined.
             * 2.8. If global is a Window object, then:
             * 2.8.1. Set currentEvent to global's current event.
             * 2.8.2. If struct's invocation-target-in-shadow-tree is false, then
             * set global's current event to event.
             */
            var currentEvent = undefined;
            if (util_1.Guard.isWindow(globalObject)) {
                currentEvent = globalObject._currentEvent;
                if (struct.invocationTargetInShadowTree === false) {
                    globalObject._currentEvent = event;
                }
            }
            /**
             * 2.9. If listener's passive is true, then set event's in passive
             * listener flag.
             * 2.10. Call a user object's operation with listener's callback,
             * "handleEvent", « event », and event's currentTarget attribute value.
             */
            if (listener.passive)
                event._inPassiveListenerFlag = true;
            try {
                listener.callback.handleEvent.call(event._currentTarget, event);
            }
            catch (err) {
                /**
                 * If this throws an exception, then:
                 * 2.10.1. Report the exception.
                 * 2.10.2. Set legacyOutputDidListenersThrowFlag if given.
                 *
                 * _Note:_ The legacyOutputDidListenersThrowFlag is only used by
                 * Indexed Database API.
                 * TODO: Report the exception
                 * See: https://html.spec.whatwg.org/multipage/webappapis.html#runtime-script-errors-in-documents
                 */
                legacyOutputDidListenersThrowFlag.value = true;
            }
            /**
             * 2.11. Unset event's in passive listener flag.
             */
            if (listener.passive)
                event._inPassiveListenerFlag = false;
            /**
             * 2.12. If global is a Window object, then set global's current event
             * to currentEvent.
             */
            if (util_1.Guard.isWindow(globalObject)) {
                globalObject._currentEvent = currentEvent;
            }
            /**
             * 2.13. If event's stop immediate propagation flag is set, then return
             * found.
             */
            if (event._stopImmediatePropagationFlag)
                return found;
        }
    }
    /**
     * 3. Return found.
     */
    return found;
}
exports.event_innerInvoke = event_innerInvoke;
/**
 * Fires an event at target.
 * @param e - event name
 * @param target - event target
 * @param eventConstructor - an event constructor, with a description of how
 * IDL attributes are to be initialized
 * @param idlAttributes - a dictionary describing how IDL attributes are
 * to be initialized
 * @param legacyTargetOverrideFlag - legacy target override flag
 */
function event_fireAnEvent(e, target, eventConstructor, idlAttributes, legacyTargetOverrideFlag) {
    /**
     * 1. If eventConstructor is not given, then let eventConstructor be Event.
     */
    if (eventConstructor === undefined) {
        eventConstructor = EventImpl_1.EventImpl;
    }
    /**
     * 2. Let event be the result of creating an event given eventConstructor,
     * in the relevant Realm of target.
     */
    var event = event_createAnEvent(eventConstructor);
    /**
     * 3. Initialize event’s type attribute to e.
     */
    event._type = e;
    /**
     * 4. Initialize any other IDL attributes of event as described in the
     * invocation of this algorithm.
     * _Note:_ This also allows for the isTrusted attribute to be set to false.
     */
    if (idlAttributes) {
        for (var key in idlAttributes) {
            var idlObj = event;
            idlObj[key] = idlAttributes[key];
        }
    }
    /**
     * 5. Return the result of dispatching event at target, with legacy target
     * override flag set if set.
     */
    return event_dispatch(event, target, legacyTargetOverrideFlag);
}
exports.event_fireAnEvent = event_fireAnEvent;
/**
 * Creates an event.
 *
 * @param eventInterface - the name of the event interface
 */
function event_createLegacyEvent(eventInterface) {
    /**
     * 1. Let constructor be null.
     */
    var constructor = null;
    /**
     * TODO: Implement in HTML DOM
     * 2. If interface is an ASCII case-insensitive match for any of the strings
     * in the first column in the following table, then set constructor to the
     * interface in the second column on the same row as the matching string:
     *
     * String | Interface
     * -------|----------
     * "beforeunloadevent" | BeforeUnloadEvent
     * "compositionevent" | CompositionEvent
     * "customevent" | CustomEvent
     * "devicemotionevent" | DeviceMotionEvent
     * "deviceorientationevent" | DeviceOrientationEvent
     * "dragevent" | DragEvent
     * "event" | Event
     * "events" | Event
     * "focusevent" | FocusEvent
     * "hashchangeevent" | HashChangeEvent
     * "htmlevents" | Event
     * "keyboardevent" | KeyboardEvent
     * "messageevent" | MessageEvent
     * "mouseevent" | MouseEvent
     * "mouseevents" |
     * "storageevent" | StorageEvent
     * "svgevents" | Event
     * "textevent" | CompositionEvent
     * "touchevent" | TouchEvent
     * "uievent" | UIEvent
     * "uievents" | UIEvent
     */
    switch (eventInterface.toLowerCase()) {
        case "beforeunloadevent":
            break;
        case "compositionevent":
            break;
        case "customevent":
            constructor = CustomEventImpl_1.CustomEventImpl;
            break;
        case "devicemotionevent":
            break;
        case "deviceorientationevent":
            break;
        case "dragevent":
            break;
        case "event":
        case "events":
            constructor = EventImpl_1.EventImpl;
            break;
        case "focusevent":
            break;
        case "hashchangeevent":
            break;
        case "htmlevents":
            break;
        case "keyboardevent":
            break;
        case "messageevent":
            break;
        case "mouseevent":
            break;
        case "mouseevents":
            break;
        case "storageevent":
            break;
        case "svgevents":
            break;
        case "textevent":
            break;
        case "touchevent":
            break;
        case "uievent":
            break;
        case "uievents":
            break;
    }
    /**
     * 3. If constructor is null, then throw a "NotSupportedError" DOMException.
     */
    if (constructor === null) {
        throw new DOMException_1.NotSupportedError("Event constructor not found for interface " + eventInterface + ".");
    }
    /**
     * 4. If the interface indicated by constructor is not exposed on the
     * relevant global object of the context object, then throw a
     * "NotSupportedError" DOMException.
     * _Note:_ Typically user agents disable support for touch events in some
     * configurations, in which case this clause would be triggered for the
     * interface TouchEvent.
     */
    // TODO: Implement realms
    /**
     * 5. Let event be the result of creating an event given constructor.
     * 6. Initialize event’s type attribute to the empty string.
     * 7. Initialize event’s timeStamp attribute to a DOMHighResTimeStamp
     * representing the high resolution time from the time origin to now.
     * 8. Initialize event’s isTrusted attribute to false.
     * 9. Unset event’s initialized flag.
     */
    var event = new constructor("");
    event._type = "";
    event._timeStamp = new Date().getTime();
    event._isTrusted = false;
    event._initializedFlag = false;
    /**
     * 10. Return event.
     */
    return event;
}
exports.event_createLegacyEvent = event_createLegacyEvent;
/**
 * Getter of an event handler IDL attribute.
 *
 * @param eventTarget - event target
 * @param name - event name
 */
function event_getterEventHandlerIDLAttribute(thisObj, name) {
    /**
     * 1. Let eventTarget be the result of determining the target of an event
     * handler given this object and name.
     * 2. If eventTarget is null, then return null.
     * 3. Return the result of getting the current value of the event handler
     * given eventTarget and name.
     */
    var eventTarget = event_determineTheTargetOfAnEventHandler(thisObj, name);
    if (eventTarget === null)
        return null;
    return event_getTheCurrentValueOfAnEventHandler(eventTarget, name);
}
exports.event_getterEventHandlerIDLAttribute = event_getterEventHandlerIDLAttribute;
/**
 * Setter of an event handler IDL attribute.
 *
 * @param eventTarget - event target
 * @param name - event name
 * @param value - event handler
 */
function event_setterEventHandlerIDLAttribute(thisObj, name, value) {
    /**
     * 1. Let eventTarget be the result of determining the target of an event
     * handler given this object and name.
     * 2. If eventTarget is null, then return.
     * 3. If the given value is null, then deactivate an event handler given
     * eventTarget and name.
     * 4. Otherwise:
     * 4.1. Let handlerMap be eventTarget's event handler map.
     * 4.2. Let eventHandler be handlerMap[name].
     * 4.3. Set eventHandler's value to the given value.
     * 4.4. Activate an event handler given eventTarget and name.
     */
    var eventTarget = event_determineTheTargetOfAnEventHandler(thisObj, name);
    if (eventTarget === null)
        return;
    if (value === null) {
        event_deactivateAnEventHandler(eventTarget, name);
    }
    else {
        var handlerMap = eventTarget._eventHandlerMap;
        var eventHandler = handlerMap["onabort"];
        if (eventHandler !== undefined) {
            eventHandler.value = value;
        }
        event_activateAnEventHandler(eventTarget, name);
    }
}
exports.event_setterEventHandlerIDLAttribute = event_setterEventHandlerIDLAttribute;
/**
 * Determines the target of an event handler.
 *
 * @param eventTarget - event target
 * @param name - event name
 */
function event_determineTheTargetOfAnEventHandler(eventTarget, name) {
    // TODO: Implement in HTML DOM
    return null;
}
exports.event_determineTheTargetOfAnEventHandler = event_determineTheTargetOfAnEventHandler;
/**
 * Gets the current value of an event handler.
 *
 * @param eventTarget - event target
 * @param name - event name
 */
function event_getTheCurrentValueOfAnEventHandler(eventTarget, name) {
    // TODO: Implement in HTML DOM
    return null;
}
exports.event_getTheCurrentValueOfAnEventHandler = event_getTheCurrentValueOfAnEventHandler;
/**
 * Activates an event handler.
 *
 * @param eventTarget - event target
 * @param name - event name
 */
function event_activateAnEventHandler(eventTarget, name) {
    // TODO: Implement in HTML DOM
}
exports.event_activateAnEventHandler = event_activateAnEventHandler;
/**
 * Deactivates an event handler.
 *
 * @param eventTarget - event target
 * @param name - event name
 */
function event_deactivateAnEventHandler(eventTarget, name) {
    // TODO: Implement in HTML DOM
}
exports.event_deactivateAnEventHandler = event_deactivateAnEventHandler;
//# sourceMappingURL=EventAlgorithm.js.map

/***/ }),

/***/ 9807:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {


var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var util_1 = __nccwpck_require__(7061);
/**
 * Flattens the given options argument.
 *
 * @param options - options argument
 */
function eventTarget_flatten(options) {
    /**
     * 1. If options is a boolean, then return options.
     * 2. Return options’s capture.
     */
    if (util_1.isBoolean(options)) {
        return options;
    }
    else {
        return options.capture || false;
    }
}
exports.eventTarget_flatten = eventTarget_flatten;
/**
 * Flattens the given options argument.
 *
 * @param options - options argument
 */
function eventTarget_flattenMore(options) {
    /**
     * 1. Let capture be the result of flattening options.
     * 2. Let once and passive be false.
     * 3. If options is a dictionary, then set passive to options’s passive and
     * once to options’s once.
     * 4. Return capture, passive, and once.
     */
    var capture = eventTarget_flatten(options);
    var once = false;
    var passive = false;
    if (!util_1.isBoolean(options)) {
        once = options.once || false;
        passive = options.passive || false;
    }
    return [capture, passive, once];
}
exports.eventTarget_flattenMore = eventTarget_flattenMore;
/**
 * Adds a new event listener.
 *
 * @param eventTarget - event target
 * @param listener - event listener
 */
function eventTarget_addEventListener(eventTarget, listener) {
    /**
     * 1. If eventTarget is a ServiceWorkerGlobalScope object, its service
     * worker’s script resource’s has ever been evaluated flag is set, and
     * listener’s type matches the type attribute value of any of the service
     * worker events, then report a warning to the console that this might not
     * give the expected results. [SERVICE-WORKERS]
     */
    // TODO: service worker
    /**
     * 2. If listener’s callback is null, then return.
     */
    if (listener.callback === null)
        return;
    /**
     * 3. If eventTarget’s event listener list does not contain an event listener
     * whose type is listener’s type, callback is listener’s callback, and capture
     * is listener’s capture, then append listener to eventTarget’s event listener
     * list.
     */
    for (var i = 0; i < eventTarget._eventListenerList.length; i++) {
        var entry = eventTarget._eventListenerList[i];
        if (entry.type === listener.type && entry.callback.handleEvent === listener.callback.handleEvent
            && entry.capture === listener.capture) {
            return;
        }
    }
    eventTarget._eventListenerList.push(listener);
}
exports.eventTarget_addEventListener = eventTarget_addEventListener;
/**
 * Removes an event listener.
 *
 * @param eventTarget - event target
 * @param listener - event listener
 */
function eventTarget_removeEventListener(eventTarget, listener, index) {
    /**
     * 1. If eventTarget is a ServiceWorkerGlobalScope object and its service
     * worker’s set of event types to handle contains type, then report a
     * warning to the console that this might not give the expected results.
     * [SERVICE-WORKERS]
     */
    // TODO: service worker
    /**
     * 2. Set listener’s removed to true and remove listener from eventTarget’s
     * event listener list.
     */
    listener.removed = true;
    eventTarget._eventListenerList.splice(index, 1);
}
exports.eventTarget_removeEventListener = eventTarget_removeEventListener;
/**
 * Removes all event listeners.
 *
 * @param eventTarget - event target
 */
function eventTarget_removeAllEventListeners(eventTarget) {
    /**
     * To remove all event listeners, given an EventTarget object eventTarget,
     * for each listener of eventTarget’s event listener list, remove an event
     * listener with eventTarget and listener.
     */
    var e_1, _a;
    try {
        for (var _b = __values(eventTarget._eventListenerList), _c = _b.next(); !_c.done; _c = _b.next()) {
            var e = _c.value;
            e.removed = true;
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_1) throw e_1.error; }
    }
    eventTarget._eventListenerList.length = 0;
}
exports.eventTarget_removeAllEventListeners = eventTarget_removeAllEventListeners;
//# sourceMappingURL=EventTargetAlgorithm.js.map

/***/ }),

/***/ 45:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {


var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var DOMImpl_1 = __nccwpck_require__(698);
var DOMException_1 = __nccwpck_require__(7175);
var interfaces_1 = __nccwpck_require__(9454);
var util_1 = __nccwpck_require__(628);
var util_2 = __nccwpck_require__(7061);
var infra_1 = __nccwpck_require__(4737);
var CustomElementAlgorithm_1 = __nccwpck_require__(5075);
var TreeAlgorithm_1 = __nccwpck_require__(3532);
var NodeIteratorAlgorithm_1 = __nccwpck_require__(9670);
var ShadowTreeAlgorithm_1 = __nccwpck_require__(708);
var MutationObserverAlgorithm_1 = __nccwpck_require__(3243);
var DOMAlgorithm_1 = __nccwpck_require__(9484);
var DocumentAlgorithm_1 = __nccwpck_require__(1327);
/**
 * Ensures pre-insertion validity of a node into a parent before a
 * child.
 *
 * @param node - node to insert
 * @param parent - parent node to receive node
 * @param child - child node to insert node before
 */
function mutation_ensurePreInsertionValidity(node, parent, child) {
    var e_1, _a, e_2, _b, e_3, _c, e_4, _d;
    var parentNodeType = parent._nodeType;
    var nodeNodeType = node._nodeType;
    var childNodeType = child ? child._nodeType : null;
    /**
     * 1. If parent is not a Document, DocumentFragment, or Element node,
     * throw a "HierarchyRequestError" DOMException.
     */
    if (parentNodeType !== interfaces_1.NodeType.Document &&
        parentNodeType !== interfaces_1.NodeType.DocumentFragment &&
        parentNodeType !== interfaces_1.NodeType.Element)
        throw new DOMException_1.HierarchyRequestError("Only document, document fragment and element nodes can contain child nodes. Parent node is " + parent.nodeName + ".");
    /**
     * 2. If node is a host-including inclusive ancestor of parent, throw a
     * "HierarchyRequestError" DOMException.
     */
    if (TreeAlgorithm_1.tree_isHostIncludingAncestorOf(parent, node, true))
        throw new DOMException_1.HierarchyRequestError("The node to be inserted cannot be an inclusive ancestor of parent node. Node is " + node.nodeName + ", parent node is " + parent.nodeName + ".");
    /**
     * 3. If child is not null and its parent is not parent, then throw a
     * "NotFoundError" DOMException.
     */
    if (child !== null && child._parent !== parent)
        throw new DOMException_1.NotFoundError("The reference child node cannot be found under parent node. Child node is " + child.nodeName + ", parent node is " + parent.nodeName + ".");
    /**
     * 4. If node is not a DocumentFragment, DocumentType, Element, Text,
     * ProcessingInstruction, or Comment node, throw a "HierarchyRequestError"
     * DOMException.
     */
    if (nodeNodeType !== interfaces_1.NodeType.DocumentFragment &&
        nodeNodeType !== interfaces_1.NodeType.DocumentType &&
        nodeNodeType !== interfaces_1.NodeType.Element &&
        nodeNodeType !== interfaces_1.NodeType.Text &&
        nodeNodeType !== interfaces_1.NodeType.ProcessingInstruction &&
        nodeNodeType !== interfaces_1.NodeType.CData &&
        nodeNodeType !== interfaces_1.NodeType.Comment)
        throw new DOMException_1.HierarchyRequestError("Only document fragment, document type, element, text, processing instruction, cdata section or comment nodes can be inserted. Node is " + node.nodeName + ".");
    /**
     * 5. If either node is a Text node and parent is a document, or node is a
     * doctype and parent is not a document, throw a "HierarchyRequestError"
     * DOMException.
     */
    if (nodeNodeType === interfaces_1.NodeType.Text &&
        parentNodeType === interfaces_1.NodeType.Document)
        throw new DOMException_1.HierarchyRequestError("Cannot insert a text node as a child of a document node. Node is " + node.nodeName + ".");
    if (nodeNodeType === interfaces_1.NodeType.DocumentType &&
        parentNodeType !== interfaces_1.NodeType.Document)
        throw new DOMException_1.HierarchyRequestError("A document type node can only be inserted under a document node. Parent node is " + parent.nodeName + ".");
    /**
     * 6. If parent is a document, and any of the statements below, switched on
     * node, are true, throw a "HierarchyRequestError" DOMException.
     * - DocumentFragment node
     * If node has more than one element child or has a Text node child.
     * Otherwise, if node has one element child and either parent has an element
     * child, child is a doctype, or child is not null and a doctype is
     * following child.
     * - element
     * parent has an element child, child is a doctype, or child is not null and
     * a doctype is following child.
     * - doctype
     * parent has a doctype child, child is non-null and an element is preceding
     * child, or child is null and parent has an element child.
     */
    if (parentNodeType === interfaces_1.NodeType.Document) {
        if (nodeNodeType === interfaces_1.NodeType.DocumentFragment) {
            var eleCount = 0;
            try {
                for (var _e = __values(node._children), _f = _e.next(); !_f.done; _f = _e.next()) {
                    var childNode = _f.value;
                    if (childNode._nodeType === interfaces_1.NodeType.Element)
                        eleCount++;
                    else if (childNode._nodeType === interfaces_1.NodeType.Text)
                        throw new DOMException_1.HierarchyRequestError("Cannot insert text a node as a child of a document node. Node is " + childNode.nodeName + ".");
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_f && !_f.done && (_a = _e.return)) _a.call(_e);
                }
                finally { if (e_1) throw e_1.error; }
            }
            if (eleCount > 1) {
                throw new DOMException_1.HierarchyRequestError("A document node can only have one document element node. Document fragment to be inserted has " + eleCount + " element nodes.");
            }
            else if (eleCount === 1) {
                try {
                    for (var _g = __values(parent._children), _h = _g.next(); !_h.done; _h = _g.next()) {
                        var ele = _h.value;
                        if (ele._nodeType === interfaces_1.NodeType.Element)
                            throw new DOMException_1.HierarchyRequestError("The document node already has a document element node.");
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (_h && !_h.done && (_b = _g.return)) _b.call(_g);
                    }
                    finally { if (e_2) throw e_2.error; }
                }
                if (child) {
                    if (childNodeType === interfaces_1.NodeType.DocumentType)
                        throw new DOMException_1.HierarchyRequestError("Cannot insert an element node before a document type node.");
                    var doctypeChild = child._nextSibling;
                    while (doctypeChild) {
                        if (doctypeChild._nodeType === interfaces_1.NodeType.DocumentType)
                            throw new DOMException_1.HierarchyRequestError("Cannot insert an element node before a document type node.");
                        doctypeChild = doctypeChild._nextSibling;
                    }
                }
            }
        }
        else if (nodeNodeType === interfaces_1.NodeType.Element) {
            try {
                for (var _j = __values(parent._children), _k = _j.next(); !_k.done; _k = _j.next()) {
                    var ele = _k.value;
                    if (ele._nodeType === interfaces_1.NodeType.Element)
                        throw new DOMException_1.HierarchyRequestError("Document already has a document element node. Node is " + node.nodeName + ".");
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_k && !_k.done && (_c = _j.return)) _c.call(_j);
                }
                finally { if (e_3) throw e_3.error; }
            }
            if (child) {
                if (childNodeType === interfaces_1.NodeType.DocumentType)
                    throw new DOMException_1.HierarchyRequestError("Cannot insert an element node before a document type node. Node is " + node.nodeName + ".");
                var doctypeChild = child._nextSibling;
                while (doctypeChild) {
                    if (doctypeChild._nodeType === interfaces_1.NodeType.DocumentType)
                        throw new DOMException_1.HierarchyRequestError("Cannot insert an element node before a document type node. Node is " + node.nodeName + ".");
                    doctypeChild = doctypeChild._nextSibling;
                }
            }
        }
        else if (nodeNodeType === interfaces_1.NodeType.DocumentType) {
            try {
                for (var _l = __values(parent._children), _m = _l.next(); !_m.done; _m = _l.next()) {
                    var ele = _m.value;
                    if (ele._nodeType === interfaces_1.NodeType.DocumentType)
                        throw new DOMException_1.HierarchyRequestError("Document already has a document type node. Node is " + node.nodeName + ".");
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (_m && !_m.done && (_d = _l.return)) _d.call(_l);
                }
                finally { if (e_4) throw e_4.error; }
            }
            if (child) {
                var elementChild = child._previousSibling;
                while (elementChild) {
                    if (elementChild._nodeType === interfaces_1.NodeType.Element)
                        throw new DOMException_1.HierarchyRequestError("Cannot insert a document type node before an element node. Node is " + node.nodeName + ".");
                    elementChild = elementChild._previousSibling;
                }
            }
            else {
                var elementChild = parent._firstChild;
                while (elementChild) {
                    if (elementChild._nodeType === interfaces_1.NodeType.Element)
                        throw new DOMException_1.HierarchyRequestError("Cannot insert a document type node before an element node. Node is " + node.nodeName + ".");
                    elementChild = elementChild._nextSibling;
                }
            }
        }
    }
}
exports.mutation_ensurePreInsertionValidity = mutation_ensurePreInsertionValidity;
/**
 * Ensures pre-insertion validity of a node into a parent before a
 * child, then adopts the node to the tree and inserts it.
 *
 * @param node - node to insert
 * @param parent - parent node to receive node
 * @param child - child node to insert node before
 */
function mutation_preInsert(node, parent, child) {
    /**
     * 1. Ensure pre-insertion validity of node into parent before child.
     * 2. Let reference child be child.
     * 3. If reference child is node, set it to node’s next sibling.
     * 4. Adopt node into parent’s node document.
     * 5. Insert node into parent before reference child.
     * 6. Return node.
     */
    mutation_ensurePreInsertionValidity(node, parent, child);
    var referenceChild = child;
    if (referenceChild === node)
        referenceChild = node._nextSibling;
    DocumentAlgorithm_1.document_adopt(node, parent._nodeDocument);
    mutation_insert(node, parent, referenceChild);
    return node;
}
exports.mutation_preInsert = mutation_preInsert;
/**
 * Inserts a node into a parent node before the given child node.
 *
 * @param node - node to insert
 * @param parent - parent node to receive node
 * @param child - child node to insert node before
 * @param suppressObservers - whether to notify observers
 */
function mutation_insert(node, parent, child, suppressObservers) {
    var e_5, _a;
    // Optimized common case
    if (child === null && node._nodeType !== interfaces_1.NodeType.DocumentFragment) {
        mutation_insert_single(node, parent, suppressObservers);
        return;
    }
    /**
     * 1. Let count be the number of children of node if it is a
     * DocumentFragment node, and one otherwise.
     */
    var count = (node._nodeType === interfaces_1.NodeType.DocumentFragment ?
        node._children.size : 1);
    /**
     * 2. If child is non-null, then:
     */
    if (child !== null) {
        /**
         * 2.1. For each live range whose start node is parent and start
         * offset is greater than child's index, increase its start
         * offset by count.
         * 2.2. For each live range whose end node is parent and end
         * offset is greater than child's index, increase its end
         * offset by count.
         */
        if (DOMImpl_1.dom.rangeList.size !== 0) {
            var index_1 = TreeAlgorithm_1.tree_index(child);
            try {
                for (var _b = __values(DOMImpl_1.dom.rangeList), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var range = _c.value;
                    if (range._start[0] === parent && range._start[1] > index_1) {
                        range._start[1] += count;
                    }
                    if (range._end[0] === parent && range._end[1] > index_1) {
                        range._end[1] += count;
                    }
                }
            }
            catch (e_5_1) { e_5 = { error: e_5_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_5) throw e_5.error; }
            }
        }
    }
    /**
     * 3. Let nodes be node’s children, if node is a DocumentFragment node;
     * otherwise « node ».
     */
    var nodes = node._nodeType === interfaces_1.NodeType.DocumentFragment ? new (Array.bind.apply(Array, __spread([void 0], node._children)))() : [node];
    /**
     * 4. If node is a DocumentFragment node, remove its children with the
     * suppress observers flag set.
     */
    if (node._nodeType === interfaces_1.NodeType.DocumentFragment) {
        while (node._firstChild) {
            mutation_remove(node._firstChild, node, true);
        }
    }
    /**
     * 5. If node is a DocumentFragment node, then queue a tree mutation record
     * for node with « », nodes, null, and null.
     */
    if (DOMImpl_1.dom.features.mutationObservers) {
        if (node._nodeType === interfaces_1.NodeType.DocumentFragment) {
            MutationObserverAlgorithm_1.observer_queueTreeMutationRecord(node, [], nodes, null, null);
        }
    }
    /**
     * 6. Let previousSibling be child’s previous sibling or parent’s last
     * child if child is null.
     */
    var previousSibling = (child ? child._previousSibling : parent._lastChild);
    var index = child === null ? -1 : TreeAlgorithm_1.tree_index(child);
    /**
     * 7. For each node in nodes, in tree order:
     */
    for (var i = 0; i < nodes.length; i++) {
        var node_1 = nodes[i];
        if (util_1.Guard.isElementNode(node_1)) {
            // set document element node
            if (util_1.Guard.isDocumentNode(parent)) {
                parent._documentElement = node_1;
            }
            // mark that the document has namespaces
            if (!node_1._nodeDocument._hasNamespaces && (node_1._namespace !== null ||
                node_1._namespacePrefix !== null)) {
                node_1._nodeDocument._hasNamespaces = true;
            }
        }
        /**
         * 7.1. If child is null, then append node to parent’s children.
         * 7.2. Otherwise, insert node into parent’s children before child’s
         * index.
         */
        node_1._parent = parent;
        if (child === null) {
            infra_1.set.append(parent._children, node_1);
        }
        else {
            infra_1.set.insert(parent._children, node_1, index);
            index++;
        }
        // assign siblings and children for quick lookups
        if (parent._firstChild === null) {
            node_1._previousSibling = null;
            node_1._nextSibling = null;
            parent._firstChild = node_1;
            parent._lastChild = node_1;
        }
        else {
            var prev = (child ? child._previousSibling : parent._lastChild);
            var next = (child ? child : null);
            node_1._previousSibling = prev;
            node_1._nextSibling = next;
            if (prev)
                prev._nextSibling = node_1;
            if (next)
                next._previousSibling = node_1;
            if (!prev)
                parent._firstChild = node_1;
            if (!next)
                parent._lastChild = node_1;
        }
        /**
         * 7.3. If parent is a shadow host and node is a slotable, then
         * assign a slot for node.
         */
        if (DOMImpl_1.dom.features.slots) {
            if (parent._shadowRoot !== null && util_1.Guard.isSlotable(node_1)) {
                ShadowTreeAlgorithm_1.shadowTree_assignASlot(node_1);
            }
        }
        /**
         * 7.4. If node is a Text node, run the child text content change
         * steps for parent.
         */
        if (DOMImpl_1.dom.features.steps) {
            if (util_1.Guard.isTextNode(node_1)) {
                DOMAlgorithm_1.dom_runChildTextContentChangeSteps(parent);
            }
        }
        /**
         * 7.5. If parent's root is a shadow root, and parent is a slot
         * whose assigned nodes is the empty list, then run signal
         * a slot change for parent.
         */
        if (DOMImpl_1.dom.features.slots) {
            if (util_1.Guard.isShadowRoot(TreeAlgorithm_1.tree_rootNode(parent)) &&
                util_1.Guard.isSlot(parent) && util_2.isEmpty(parent._assignedNodes)) {
                ShadowTreeAlgorithm_1.shadowTree_signalASlotChange(parent);
            }
        }
        /**
         * 7.6. Run assign slotables for a tree with node's root.
         */
        if (DOMImpl_1.dom.features.slots) {
            ShadowTreeAlgorithm_1.shadowTree_assignSlotablesForATree(TreeAlgorithm_1.tree_rootNode(node_1));
        }
        /**
         * 7.7. For each shadow-including inclusive descendant
         * inclusiveDescendant of node, in shadow-including tree
         * order:
         */
        var inclusiveDescendant = TreeAlgorithm_1.tree_getFirstDescendantNode(node_1, true, true);
        while (inclusiveDescendant !== null) {
            /**
             * 7.7.1. Run the insertion steps with inclusiveDescendant.
             */
            if (DOMImpl_1.dom.features.steps) {
                DOMAlgorithm_1.dom_runInsertionSteps(inclusiveDescendant);
            }
            if (DOMImpl_1.dom.features.customElements) {
                /**
                 * 7.7.2. If inclusiveDescendant is connected, then:
                 */
                if (util_1.Guard.isElementNode(inclusiveDescendant) &&
                    ShadowTreeAlgorithm_1.shadowTree_isConnected(inclusiveDescendant)) {
                    if (util_1.Guard.isCustomElementNode(inclusiveDescendant)) {
                        /**
                         * 7.7.2.1. If inclusiveDescendant is custom, then enqueue a custom
                         * element callback reaction with inclusiveDescendant, callback name
                         * "connectedCallback", and an empty argument list.
                         */
                        CustomElementAlgorithm_1.customElement_enqueueACustomElementCallbackReaction(inclusiveDescendant, "connectedCallback", []);
                    }
                    else {
                        /**
                         * 7.7.2.2. Otherwise, try to upgrade inclusiveDescendant.
                         */
                        CustomElementAlgorithm_1.customElement_tryToUpgrade(inclusiveDescendant);
                    }
                }
            }
            inclusiveDescendant = TreeAlgorithm_1.tree_getNextDescendantNode(node_1, inclusiveDescendant, true, true);
        }
    }
    /**
     * 8. If suppress observers flag is unset, then queue a tree mutation record
     * for parent with nodes, « », previousSibling, and child.
     */
    if (DOMImpl_1.dom.features.mutationObservers) {
        if (!suppressObservers) {
            MutationObserverAlgorithm_1.observer_queueTreeMutationRecord(parent, nodes, [], previousSibling, child);
        }
    }
}
exports.mutation_insert = mutation_insert;
/**
 * Inserts a node into a parent node. Optimized routine for the common case where
 * node is not a document fragment node and it has no child nodes.
 *
 * @param node - node to insert
 * @param parent - parent node to receive node
 * @param suppressObservers - whether to notify observers
 */
function mutation_insert_single(node, parent, suppressObservers) {
    /**
     * 1. Let count be the number of children of node if it is a
     * DocumentFragment node, and one otherwise.
     * 2. If child is non-null, then:
     * 2.1. For each live range whose start node is parent and start
     * offset is greater than child's index, increase its start
     * offset by count.
     * 2.2. For each live range whose end node is parent and end
     * offset is greater than child's index, increase its end
     * offset by count.
     * 3. Let nodes be node’s children, if node is a DocumentFragment node;
     * otherwise « node ».
     * 4. If node is a DocumentFragment node, remove its children with the
     * suppress observers flag set.
     * 5. If node is a DocumentFragment node, then queue a tree mutation record
     * for node with « », nodes, null, and null.
     */
    /**
     * 6. Let previousSibling be child’s previous sibling or parent’s last
     * child if child is null.
     */
    var previousSibling = parent._lastChild;
    // set document element node
    if (util_1.Guard.isElementNode(node)) {
        // set document element node
        if (util_1.Guard.isDocumentNode(parent)) {
            parent._documentElement = node;
        }
        // mark that the document has namespaces
        if (!node._nodeDocument._hasNamespaces && (node._namespace !== null ||
            node._namespacePrefix !== null)) {
            node._nodeDocument._hasNamespaces = true;
        }
    }
    /**
     * 7. For each node in nodes, in tree order:
     * 7.1. If child is null, then append node to parent’s children.
     * 7.2. Otherwise, insert node into parent’s children before child’s
     * index.
     */
    node._parent = parent;
    parent._children.add(node);
    // assign siblings and children for quick lookups
    if (parent._firstChild === null) {
        node._previousSibling = null;
        node._nextSibling = null;
        parent._firstChild = node;
        parent._lastChild = node;
    }
    else {
        var prev = parent._lastChild;
        node._previousSibling = prev;
        node._nextSibling = null;
        if (prev)
            prev._nextSibling = node;
        if (!prev)
            parent._firstChild = node;
        parent._lastChild = node;
    }
    /**
     * 7.3. If parent is a shadow host and node is a slotable, then
     * assign a slot for node.
     */
    if (DOMImpl_1.dom.features.slots) {
        if (parent._shadowRoot !== null && util_1.Guard.isSlotable(node)) {
            ShadowTreeAlgorithm_1.shadowTree_assignASlot(node);
        }
    }
    /**
     * 7.4. If node is a Text node, run the child text content change
     * steps for parent.
     */
    if (DOMImpl_1.dom.features.steps) {
        if (util_1.Guard.isTextNode(node)) {
            DOMAlgorithm_1.dom_runChildTextContentChangeSteps(parent);
        }
    }
    /**
     * 7.5. If parent's root is a shadow root, and parent is a slot
     * whose assigned nodes is the empty list, then run signal
     * a slot change for parent.
     */
    if (DOMImpl_1.dom.features.slots) {
        if (util_1.Guard.isShadowRoot(TreeAlgorithm_1.tree_rootNode(parent)) &&
            util_1.Guard.isSlot(parent) && util_2.isEmpty(parent._assignedNodes)) {
            ShadowTreeAlgorithm_1.shadowTree_signalASlotChange(parent);
        }
    }
    /**
     * 7.6. Run assign slotables for a tree with node's root.
     */
    if (DOMImpl_1.dom.features.slots) {
        ShadowTreeAlgorithm_1.shadowTree_assignSlotablesForATree(TreeAlgorithm_1.tree_rootNode(node));
    }
    /**
     * 7.7. For each shadow-including inclusive descendant
     * inclusiveDescendant of node, in shadow-including tree
     * order:
     * 7.7.1. Run the insertion steps with inclusiveDescendant.
     */
    if (DOMImpl_1.dom.features.steps) {
        DOMAlgorithm_1.dom_runInsertionSteps(node);
    }
    if (DOMImpl_1.dom.features.customElements) {
        /**
         * 7.7.2. If inclusiveDescendant is connected, then:
         */
        if (util_1.Guard.isElementNode(node) &&
            ShadowTreeAlgorithm_1.shadowTree_isConnected(node)) {
            if (util_1.Guard.isCustomElementNode(node)) {
                /**
                 * 7.7.2.1. If inclusiveDescendant is custom, then enqueue a custom
                 * element callback reaction with inclusiveDescendant, callback name
                 * "connectedCallback", and an empty argument list.
                 */
                CustomElementAlgorithm_1.customElement_enqueueACustomElementCallbackReaction(node, "connectedCallback", []);
            }
            else {
                /**
                 * 7.7.2.2. Otherwise, try to upgrade inclusiveDescendant.
                 */
                CustomElementAlgorithm_1.customElement_tryToUpgrade(node);
            }
        }
    }
    /**
     * 8. If suppress observers flag is unset, then queue a tree mutation record
     * for parent with nodes, « », previousSibling, and child.
     */
    if (DOMImpl_1.dom.features.mutationObservers) {
        if (!suppressObservers) {
            MutationObserverAlgorithm_1.observer_queueTreeMutationRecord(parent, [node], [], previousSibling, null);
        }
    }
}
/**
 * Appends a node to the children of a parent node.
 *
 * @param node - a node
 * @param parent - the parent to receive node
 */
function mutation_append(node, parent) {
    /**
     * To append a node to a parent, pre-insert node into parent before null.
     */
    return mutation_preInsert(node, parent, null);
}
exports.mutation_append = mutation_append;
/**
 * Replaces a node with another node.
 *
 * @param child - child node to remove
 * @param node - node to insert
 * @param parent - parent node to receive node
 */
function mutation_replace(child, node, parent) {
    var e_6, _a, e_7, _b, e_8, _c, e_9, _d;
    /**
     * 1. If parent is not a Document, DocumentFragment, or Element node,
     * throw a "HierarchyRequestError" DOMException.
     */
    if (parent._nodeType !== interfaces_1.NodeType.Document &&
        parent._nodeType !== interfaces_1.NodeType.DocumentFragment &&
        parent._nodeType !== interfaces_1.NodeType.Element)
        throw new DOMException_1.HierarchyRequestError("Only document, document fragment and element nodes can contain child nodes. Parent node is " + parent.nodeName + ".");
    /**
     * 2. If node is a host-including inclusive ancestor of parent, throw a
     * "HierarchyRequestError" DOMException.
     */
    if (TreeAlgorithm_1.tree_isHostIncludingAncestorOf(parent, node, true))
        throw new DOMException_1.HierarchyRequestError("The node to be inserted cannot be an ancestor of parent node. Node is " + node.nodeName + ", parent node is " + parent.nodeName + ".");
    /**
     * 3. If child’s parent is not parent, then throw a "NotFoundError"
     * DOMException.
     */
    if (child._parent !== parent)
        throw new DOMException_1.NotFoundError("The reference child node cannot be found under parent node. Child node is " + child.nodeName + ", parent node is " + parent.nodeName + ".");
    /**
     * 4. If node is not a DocumentFragment, DocumentType, Element, Text,
     * ProcessingInstruction, or Comment node, throw a "HierarchyRequestError"
     * DOMException.
     */
    if (node._nodeType !== interfaces_1.NodeType.DocumentFragment &&
        node._nodeType !== interfaces_1.NodeType.DocumentType &&
        node._nodeType !== interfaces_1.NodeType.Element &&
        node._nodeType !== interfaces_1.NodeType.Text &&
        node._nodeType !== interfaces_1.NodeType.ProcessingInstruction &&
        node._nodeType !== interfaces_1.NodeType.CData &&
        node._nodeType !== interfaces_1.NodeType.Comment)
        throw new DOMException_1.HierarchyRequestError("Only document fragment, document type, element, text, processing instruction, cdata section or comment nodes can be inserted. Node is " + node.nodeName + ".");
    /**
     * 5. If either node is a Text node and parent is a document, or node is a
     * doctype and parent is not a document, throw a "HierarchyRequestError"
     * DOMException.
     */
    if (node._nodeType === interfaces_1.NodeType.Text &&
        parent._nodeType === interfaces_1.NodeType.Document)
        throw new DOMException_1.HierarchyRequestError("Cannot insert a text node as a child of a document node. Node is " + node.nodeName + ".");
    if (node._nodeType === interfaces_1.NodeType.DocumentType &&
        parent._nodeType !== interfaces_1.NodeType.Document)
        throw new DOMException_1.HierarchyRequestError("A document type node can only be inserted under a document node. Parent node is " + parent.nodeName + ".");
    /**
     * 6. If parent is a document, and any of the statements below, switched on
     * node, are true, throw a "HierarchyRequestError" DOMException.
     * - DocumentFragment node
     * If node has more than one element child or has a Text node child.
     * Otherwise, if node has one element child and either parent has an element
     * child that is not child or a doctype is following child.
     * - element
     * parent has an element child that is not child or a doctype is
     * following child.
     * - doctype
     * parent has a doctype child that is not child, or an element is
     * preceding child.
     */
    if (parent._nodeType === interfaces_1.NodeType.Document) {
        if (node._nodeType === interfaces_1.NodeType.DocumentFragment) {
            var eleCount = 0;
            try {
                for (var _e = __values(node._children), _f = _e.next(); !_f.done; _f = _e.next()) {
                    var childNode = _f.value;
                    if (childNode._nodeType === interfaces_1.NodeType.Element)
                        eleCount++;
                    else if (childNode._nodeType === interfaces_1.NodeType.Text)
                        throw new DOMException_1.HierarchyRequestError("Cannot insert text a node as a child of a document node. Node is " + childNode.nodeName + ".");
                }
            }
            catch (e_6_1) { e_6 = { error: e_6_1 }; }
            finally {
                try {
                    if (_f && !_f.done && (_a = _e.return)) _a.call(_e);
                }
                finally { if (e_6) throw e_6.error; }
            }
            if (eleCount > 1) {
                throw new DOMException_1.HierarchyRequestError("A document node can only have one document element node. Document fragment to be inserted has " + eleCount + " element nodes.");
            }
            else if (eleCount === 1) {
                try {
                    for (var _g = __values(parent._children), _h = _g.next(); !_h.done; _h = _g.next()) {
                        var ele = _h.value;
                        if (ele._nodeType === interfaces_1.NodeType.Element && ele !== child)
                            throw new DOMException_1.HierarchyRequestError("The document node already has a document element node.");
                    }
                }
                catch (e_7_1) { e_7 = { error: e_7_1 }; }
                finally {
                    try {
                        if (_h && !_h.done && (_b = _g.return)) _b.call(_g);
                    }
                    finally { if (e_7) throw e_7.error; }
                }
                var doctypeChild = child._nextSibling;
                while (doctypeChild) {
                    if (doctypeChild._nodeType === interfaces_1.NodeType.DocumentType)
                        throw new DOMException_1.HierarchyRequestError("Cannot insert an element node before a document type node.");
                    doctypeChild = doctypeChild._nextSibling;
                }
            }
        }
        else if (node._nodeType === interfaces_1.NodeType.Element) {
            try {
                for (var _j = __values(parent._children), _k = _j.next(); !_k.done; _k = _j.next()) {
                    var ele = _k.value;
                    if (ele._nodeType === interfaces_1.NodeType.Element && ele !== child)
                        throw new DOMException_1.HierarchyRequestError("Document already has a document element node. Node is " + node.nodeName + ".");
                }
            }
            catch (e_8_1) { e_8 = { error: e_8_1 }; }
            finally {
                try {
                    if (_k && !_k.done && (_c = _j.return)) _c.call(_j);
                }
                finally { if (e_8) throw e_8.error; }
            }
            var doctypeChild = child._nextSibling;
            while (doctypeChild) {
                if (doctypeChild._nodeType === interfaces_1.NodeType.DocumentType)
                    throw new DOMException_1.HierarchyRequestError("Cannot insert an element node before a document type node. Node is " + node.nodeName + ".");
                doctypeChild = doctypeChild._nextSibling;
            }
        }
        else if (node._nodeType === interfaces_1.NodeType.DocumentType) {
            try {
                for (var _l = __values(parent._children), _m = _l.next(); !_m.done; _m = _l.next()) {
                    var ele = _m.value;
                    if (ele._nodeType === interfaces_1.NodeType.DocumentType && ele !== child)
                        throw new DOMException_1.HierarchyRequestError("Document already has a document type node. Node is " + node.nodeName + ".");
                }
            }
            catch (e_9_1) { e_9 = { error: e_9_1 }; }
            finally {
                try {
                    if (_m && !_m.done && (_d = _l.return)) _d.call(_l);
                }
                finally { if (e_9) throw e_9.error; }
            }
            var elementChild = child._previousSibling;
            while (elementChild) {
                if (elementChild._nodeType === interfaces_1.NodeType.Element)
                    throw new DOMException_1.HierarchyRequestError("Cannot insert a document type node before an element node. Node is " + node.nodeName + ".");
                elementChild = elementChild._previousSibling;
            }
        }
    }
    /**
     * 7. Let reference child be child’s next sibling.
     * 8. If reference child is node, set it to node’s next sibling.
     * 8. Let previousSibling be child’s previous sibling.
     */
    var referenceChild = child._nextSibling;
    if (referenceChild === node)
        referenceChild = node._nextSibling;
    var previousSibling = child._previousSibling;
    /**
     * 10. Adopt node into parent’s node document.
     * 11. Let removedNodes be the empty list.
     */
    DocumentAlgorithm_1.document_adopt(node, parent._nodeDocument);
    var removedNodes = [];
    /**
     * 12. If child’s parent is not null, then:
     */
    if (child._parent !== null) {
        /**
         * 12.1. Set removedNodes to [child].
         * 12.2. Remove child from its parent with the suppress observers flag
         * set.
         */
        removedNodes.push(child);
        mutation_remove(child, child._parent, true);
    }
    /**
     * 13. Let nodes be node’s children if node is a DocumentFragment node;
     * otherwise [node].
     */
    var nodes = [];
    if (node._nodeType === interfaces_1.NodeType.DocumentFragment) {
        nodes = Array.from(node._children);
    }
    else {
        nodes.push(node);
    }
    /**
     * 14. Insert node into parent before reference child with the suppress
     * observers flag set.
     */
    mutation_insert(node, parent, referenceChild, true);
    /**
     * 15. Queue a tree mutation record for parent with nodes, removedNodes,
     * previousSibling, and reference child.
     */
    if (DOMImpl_1.dom.features.mutationObservers) {
        MutationObserverAlgorithm_1.observer_queueTreeMutationRecord(parent, nodes, removedNodes, previousSibling, referenceChild);
    }
    /**
     * 16. Return child.
     */
    return child;
}
exports.mutation_replace = mutation_replace;
/**
 * Replaces all nodes of a parent with the given node.
 *
 * @param node - node to insert
 * @param parent - parent node to receive node
 */
function mutation_replaceAll(node, parent) {
    var e_10, _a;
    /**
     * 1. If node is not null, adopt node into parent’s node document.
     */
    if (node !== null) {
        DocumentAlgorithm_1.document_adopt(node, parent._nodeDocument);
    }
    /**
     * 2. Let removedNodes be parent’s children.
     */
    var removedNodes = Array.from(parent._children);
    /**
     * 3. Let addedNodes be the empty list.
     * 4. If node is DocumentFragment node, then set addedNodes to node’s
     * children.
     * 5. Otherwise, if node is non-null, set addedNodes to [node].
     */
    var addedNodes = [];
    if (node && node._nodeType === interfaces_1.NodeType.DocumentFragment) {
        addedNodes = Array.from(node._children);
    }
    else if (node !== null) {
        addedNodes.push(node);
    }
    try {
        /**
         * 6. Remove all parent’s children, in tree order, with the suppress
         * observers flag set.
         */
        for (var removedNodes_1 = __values(removedNodes), removedNodes_1_1 = removedNodes_1.next(); !removedNodes_1_1.done; removedNodes_1_1 = removedNodes_1.next()) {
            var childNode = removedNodes_1_1.value;
            mutation_remove(childNode, parent, true);
        }
    }
    catch (e_10_1) { e_10 = { error: e_10_1 }; }
    finally {
        try {
            if (removedNodes_1_1 && !removedNodes_1_1.done && (_a = removedNodes_1.return)) _a.call(removedNodes_1);
        }
        finally { if (e_10) throw e_10.error; }
    }
    /**
     * 7. If node is not null, then insert node into parent before null with the
     * suppress observers flag set.
     */
    if (node !== null) {
        mutation_insert(node, parent, null, true);
    }
    /**
     * 8. Queue a tree mutation record for parent with addedNodes, removedNodes,
     * null, and null.
     */
    if (DOMImpl_1.dom.features.mutationObservers) {
        MutationObserverAlgorithm_1.observer_queueTreeMutationRecord(parent, addedNodes, removedNodes, null, null);
    }
}
exports.mutation_replaceAll = mutation_replaceAll;
/**
 * Ensures pre-removal validity of a child node from a parent, then
 * removes it.
 *
 * @param child - child node to remove
 * @param parent - parent node
 */
function mutation_preRemove(child, parent) {
    /**
     * 1. If child’s parent is not parent, then throw a "NotFoundError"
     * DOMException.
     * 2. Remove child from parent.
     * 3. Return child.
     */
    if (child._parent !== parent)
        throw new DOMException_1.NotFoundError("The child node cannot be found under parent node. Child node is " + child.nodeName + ", parent node is " + parent.nodeName + ".");
    mutation_remove(child, parent);
    return child;
}
exports.mutation_preRemove = mutation_preRemove;
/**
 * Removes a child node from its parent.
 *
 * @param node - node to remove
 * @param parent - parent node
 * @param suppressObservers - whether to notify observers
 */
function mutation_remove(node, parent, suppressObservers) {
    var e_11, _a, e_12, _b, e_13, _c, e_14, _d;
    if (DOMImpl_1.dom.rangeList.size !== 0) {
        /**
         * 1. Let index be node’s index.
         */
        var index = TreeAlgorithm_1.tree_index(node);
        try {
            /**
             * 2. For each live range whose start node is an inclusive descendant of
             * node, set its start to (parent, index).
             * 3. For each live range whose end node is an inclusive descendant of
             * node, set its end to (parent, index).
             */
            for (var _e = __values(DOMImpl_1.dom.rangeList), _f = _e.next(); !_f.done; _f = _e.next()) {
                var range = _f.value;
                if (TreeAlgorithm_1.tree_isDescendantOf(node, range._start[0], true)) {
                    range._start = [parent, index];
                }
                if (TreeAlgorithm_1.tree_isDescendantOf(node, range._end[0], true)) {
                    range._end = [parent, index];
                }
                if (range._start[0] === parent && range._start[1] > index) {
                    range._start[1]--;
                }
                if (range._end[0] === parent && range._end[1] > index) {
                    range._end[1]--;
                }
            }
        }
        catch (e_11_1) { e_11 = { error: e_11_1 }; }
        finally {
            try {
                if (_f && !_f.done && (_a = _e.return)) _a.call(_e);
            }
            finally { if (e_11) throw e_11.error; }
        }
        try {
            /**
             * 4. For each live range whose start node is parent and start offset is
             * greater than index, decrease its start offset by 1.
             * 5. For each live range whose end node is parent and end offset is greater
             * than index, decrease its end offset by 1.
             */
            for (var _g = __values(DOMImpl_1.dom.rangeList), _h = _g.next(); !_h.done; _h = _g.next()) {
                var range = _h.value;
                if (range._start[0] === parent && range._start[1] > index) {
                    range._start[1] -= 1;
                }
                if (range._end[0] === parent && range._end[1] > index) {
                    range._end[1] -= 1;
                }
            }
        }
        catch (e_12_1) { e_12 = { error: e_12_1 }; }
        finally {
            try {
                if (_h && !_h.done && (_b = _g.return)) _b.call(_g);
            }
            finally { if (e_12) throw e_12.error; }
        }
    }
    /**
     * 6. For each NodeIterator object iterator whose root’s node document is
     * node’s node document, run the NodeIterator pre-removing steps given node
     * and iterator.
     */
    if (DOMImpl_1.dom.features.steps) {
        try {
            for (var _j = __values(NodeIteratorAlgorithm_1.nodeIterator_iteratorList()), _k = _j.next(); !_k.done; _k = _j.next()) {
                var iterator = _k.value;
                if (iterator._root._nodeDocument === node._nodeDocument) {
                    DOMAlgorithm_1.dom_runNodeIteratorPreRemovingSteps(iterator, node);
                }
            }
        }
        catch (e_13_1) { e_13 = { error: e_13_1 }; }
        finally {
            try {
                if (_k && !_k.done && (_c = _j.return)) _c.call(_j);
            }
            finally { if (e_13) throw e_13.error; }
        }
    }
    /**
     * 7. Let oldPreviousSibling be node’s previous sibling.
     * 8. Let oldNextSibling be node’s next sibling.
     */
    var oldPreviousSibling = node._previousSibling;
    var oldNextSibling = node._nextSibling;
    // set document element node
    if (util_1.Guard.isDocumentNode(parent) && util_1.Guard.isElementNode(node)) {
        parent._documentElement = null;
    }
    /**
     * 9. Remove node from its parent’s children.
     */
    node._parent = null;
    parent._children.delete(node);
    // assign siblings and children for quick lookups
    var prev = node._previousSibling;
    var next = node._nextSibling;
    node._previousSibling = null;
    node._nextSibling = null;
    if (prev)
        prev._nextSibling = next;
    if (next)
        next._previousSibling = prev;
    if (!prev)
        parent._firstChild = next;
    if (!next)
        parent._lastChild = prev;
    /**
     * 10. If node is assigned, then run assign slotables for node’s assigned
     * slot.
     */
    if (DOMImpl_1.dom.features.slots) {
        if (util_1.Guard.isSlotable(node) && node._assignedSlot !== null && ShadowTreeAlgorithm_1.shadowTree_isAssigned(node)) {
            ShadowTreeAlgorithm_1.shadowTree_assignSlotables(node._assignedSlot);
        }
    }
    /**
     * 11. If parent’s root is a shadow root, and parent is a slot whose
     * assigned nodes is the empty list, then run signal a slot change for
     * parent.
     */
    if (DOMImpl_1.dom.features.slots) {
        if (util_1.Guard.isShadowRoot(TreeAlgorithm_1.tree_rootNode(parent)) &&
            util_1.Guard.isSlot(parent) && util_2.isEmpty(parent._assignedNodes)) {
            ShadowTreeAlgorithm_1.shadowTree_signalASlotChange(parent);
        }
    }
    /**
     * 12. If node has an inclusive descendant that is a slot, then:
     * 12.1. Run assign slotables for a tree with parent's root.
     * 12.2. Run assign slotables for a tree with node.
     */
    if (DOMImpl_1.dom.features.slots) {
        var descendant_1 = TreeAlgorithm_1.tree_getFirstDescendantNode(node, true, false, function (e) { return util_1.Guard.isSlot(e); });
        if (descendant_1 !== null) {
            ShadowTreeAlgorithm_1.shadowTree_assignSlotablesForATree(TreeAlgorithm_1.tree_rootNode(parent));
            ShadowTreeAlgorithm_1.shadowTree_assignSlotablesForATree(node);
        }
    }
    /**
     * 13. Run the removing steps with node and parent.
     */
    if (DOMImpl_1.dom.features.steps) {
        DOMAlgorithm_1.dom_runRemovingSteps(node, parent);
    }
    /**
     * 14. If node is custom, then enqueue a custom element callback
     * reaction with node, callback name "disconnectedCallback",
     * and an empty argument list.
     */
    if (DOMImpl_1.dom.features.customElements) {
        if (util_1.Guard.isCustomElementNode(node)) {
            CustomElementAlgorithm_1.customElement_enqueueACustomElementCallbackReaction(node, "disconnectedCallback", []);
        }
    }
    /**
     * 15. For each shadow-including descendant descendant of node,
     * in shadow-including tree order, then:
     */
    var descendant = TreeAlgorithm_1.tree_getFirstDescendantNode(node, false, true);
    while (descendant !== null) {
        /**
         * 15.1. Run the removing steps with descendant.
         */
        if (DOMImpl_1.dom.features.steps) {
            DOMAlgorithm_1.dom_runRemovingSteps(descendant, node);
        }
        /**
         * 15.2. If descendant is custom, then enqueue a custom element
         * callback reaction with descendant, callback name
         * "disconnectedCallback", and an empty argument list.
         */
        if (DOMImpl_1.dom.features.customElements) {
            if (util_1.Guard.isCustomElementNode(descendant)) {
                CustomElementAlgorithm_1.customElement_enqueueACustomElementCallbackReaction(descendant, "disconnectedCallback", []);
            }
        }
        descendant = TreeAlgorithm_1.tree_getNextDescendantNode(node, descendant, false, true);
    }
    /**
     * 16. For each inclusive ancestor inclusiveAncestor of parent, and
     * then for each registered of inclusiveAncestor's registered
     * observer list, if registered's options's subtree is true,
     * then append a new transient registered observer whose
     * observer is registered's observer, options is registered's
     * options, and source is registered to node's registered
     * observer list.
     */
    if (DOMImpl_1.dom.features.mutationObservers) {
        var inclusiveAncestor = TreeAlgorithm_1.tree_getFirstAncestorNode(parent, true);
        while (inclusiveAncestor !== null) {
            try {
                for (var _l = (e_14 = void 0, __values(inclusiveAncestor._registeredObserverList)), _m = _l.next(); !_m.done; _m = _l.next()) {
                    var registered = _m.value;
                    if (registered.options.subtree) {
                        node._registeredObserverList.push({
                            observer: registered.observer,
                            options: registered.options,
                            source: registered
                        });
                    }
                }
            }
            catch (e_14_1) { e_14 = { error: e_14_1 }; }
            finally {
                try {
                    if (_m && !_m.done && (_d = _l.return)) _d.call(_l);
                }
                finally { if (e_14) throw e_14.error; }
            }
            inclusiveAncestor = TreeAlgorithm_1.tree_getNextAncestorNode(parent, inclusiveAncestor, true);
        }
    }
    /**
     * 17. If suppress observers flag is unset, then queue a tree mutation
     * record for parent with « », « node », oldPreviousSibling, and
     * oldNextSibling.
     */
    if (DOMImpl_1.dom.features.mutationObservers) {
        if (!suppressObservers) {
            MutationObserverAlgorithm_1.observer_queueTreeMutationRecord(parent, [], [node], oldPreviousSibling, oldNextSibling);
        }
    }
    /**
     * 18. If node is a Text node, then run the child text content change steps
     * for parent.
     */
    if (DOMImpl_1.dom.features.steps) {
        if (util_1.Guard.isTextNode(node)) {
            DOMAlgorithm_1.dom_runChildTextContentChangeSteps(parent);
        }
    }
}
exports.mutation_remove = mutation_remove;
//# sourceMappingURL=MutationAlgorithm.js.map

/***/ }),

/***/ 3243:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {


var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var DOMImpl_1 = __nccwpck_require__(698);
var util_1 = __nccwpck_require__(628);
var infra_1 = __nccwpck_require__(4737);
var CreateAlgorithm_1 = __nccwpck_require__(8308);
var TreeAlgorithm_1 = __nccwpck_require__(3532);
var EventAlgorithm_1 = __nccwpck_require__(8012);
/**
 * Queues a mutation observer microtask to the surrounding agent’s mutation
 * observers.
 */
function observer_queueAMutationObserverMicrotask() {
    /**
     * 1. If the surrounding agent’s mutation observer microtask queued is true,
     * then return.
     * 2. Set the surrounding agent’s mutation observer microtask queued to true.
     * 3. Queue a microtask to notify mutation observers.
     */
    var window = DOMImpl_1.dom.window;
    if (window._mutationObserverMicrotaskQueued)
        return;
    window._mutationObserverMicrotaskQueued = true;
    Promise.resolve().then(function () { observer_notifyMutationObservers(); });
}
exports.observer_queueAMutationObserverMicrotask = observer_queueAMutationObserverMicrotask;
/**
 * Notifies the surrounding agent’s mutation observers.
 */
function observer_notifyMutationObservers() {
    var e_1, _a, e_2, _b;
    /**
     * 1. Set the surrounding agent’s mutation observer microtask queued to false.
     * 2. Let notifySet be a clone of the surrounding agent’s mutation observers.
     * 3. Let signalSet be a clone of the surrounding agent’s signal slots.
     * 4. Empty the surrounding agent’s signal slots.
     */
    var window = DOMImpl_1.dom.window;
    window._mutationObserverMicrotaskQueued = false;
    var notifySet = infra_1.set.clone(window._mutationObservers);
    var signalSet = infra_1.set.clone(window._signalSlots);
    infra_1.set.empty(window._signalSlots);
    var _loop_1 = function (mo) {
        /**
         * 5.1. Let records be a clone of mo’s record queue.
         * 5.2. Empty mo’s record queue.
         */
        var records = infra_1.list.clone(mo._recordQueue);
        infra_1.list.empty(mo._recordQueue);
        /**
         * 5.3. For each node of mo’s node list, remove all transient registered
         * observers whose observer is mo from node’s registered observer list.
         */
        for (var i = 0; i < mo._nodeList.length; i++) {
            var node = mo._nodeList[i];
            infra_1.list.remove(node._registeredObserverList, function (observer) {
                return util_1.Guard.isTransientRegisteredObserver(observer) && observer.observer === mo;
            });
        }
        /**
         * 5.4. If records is not empty, then invoke mo’s callback with « records,
         * mo », and mo. If this throws an exception, then report the exception.
         */
        if (!infra_1.list.isEmpty(records)) {
            try {
                mo._callback.call(mo, records, mo);
            }
            catch (err) {
                // TODO: Report the exception
            }
        }
    };
    try {
        /**
         * 5. For each mo of notifySet:
         */
        for (var notifySet_1 = __values(notifySet), notifySet_1_1 = notifySet_1.next(); !notifySet_1_1.done; notifySet_1_1 = notifySet_1.next()) {
            var mo = notifySet_1_1.value;
            _loop_1(mo);
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (notifySet_1_1 && !notifySet_1_1.done && (_a = notifySet_1.return)) _a.call(notifySet_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    /**
     * 6. For each slot of signalSet, fire an event named slotchange, with its
     * bubbles attribute set to true, at slot.
     */
    if (DOMImpl_1.dom.features.slots) {
        try {
            for (var signalSet_1 = __values(signalSet), signalSet_1_1 = signalSet_1.next(); !signalSet_1_1.done; signalSet_1_1 = signalSet_1.next()) {
                var slot = signalSet_1_1.value;
                EventAlgorithm_1.event_fireAnEvent("slotchange", slot, undefined, { bubbles: true });
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (signalSet_1_1 && !signalSet_1_1.done && (_b = signalSet_1.return)) _b.call(signalSet_1);
            }
            finally { if (e_2) throw e_2.error; }
        }
    }
}
exports.observer_notifyMutationObservers = observer_notifyMutationObservers;
/**
 * Queues a mutation record of the given type for target.
 *
 * @param type - mutation record type
 * @param target - target node
 * @param name - name before mutation
 * @param namespace - namespace before mutation
 * @param oldValue - attribute value before mutation
 * @param addedNodes - a list od added nodes
 * @param removedNodes - a list of removed nodes
 * @param previousSibling - previous sibling of target before mutation
 * @param nextSibling - next sibling of target before mutation
 */
function observer_queueMutationRecord(type, target, name, namespace, oldValue, addedNodes, removedNodes, previousSibling, nextSibling) {
    var e_3, _a;
    /**
     * 1. Let interestedObservers be an empty map.
     * 2. Let nodes be the inclusive ancestors of target.
     * 3. For each node in nodes, and then for each registered of node’s
     * registered observer list:
     */
    var interestedObservers = new Map();
    var node = TreeAlgorithm_1.tree_getFirstAncestorNode(target, true);
    while (node !== null) {
        for (var i = 0; i < node._registeredObserverList.length; i++) {
            var registered = node._registeredObserverList[i];
            /**
             * 3.1. Let options be registered’s options.
             * 3.2. If none of the following are true
             * - node is not target and options’s subtree is false
             * - type is "attributes" and options’s attributes is not true
             * - type is "attributes", options’s attributeFilter is present, and
             * options’s attributeFilter does not contain name or namespace is
             * non-null
             * - type is "characterData" and options’s characterData is not true
             * - type is "childList" and options’s childList is false
             */
            var options = registered.options;
            if (node !== target && !options.subtree)
                continue;
            if (type === "attributes" && !options.attributes)
                continue;
            if (type === "attributes" && options.attributeFilter &&
                (!options.attributeFilter.indexOf(name || '') || namespace !== null))
                continue;
            if (type === "characterData" && !options.characterData)
                continue;
            if (type === "childList" && !options.childList)
                continue;
            /**
             * then:
             * 3.2.1. Let mo be registered’s observer.
             * 3.2.2. If interestedObservers[mo] does not exist, then set
             * interestedObservers[mo] to null.
             * 3.2.3. If either type is "attributes" and options’s attributeOldValue
             * is true, or type is "characterData" and options’s
             * characterDataOldValue is true, then set interestedObservers[mo]
             * to oldValue.
             */
            var mo = registered.observer;
            if (!interestedObservers.has(mo)) {
                interestedObservers.set(mo, null);
            }
            if ((type === "attributes" && options.attributeOldValue) ||
                (type === "characterData" && options.characterDataOldValue)) {
                interestedObservers.set(mo, oldValue);
            }
        }
        node = TreeAlgorithm_1.tree_getNextAncestorNode(target, node, true);
    }
    try {
        /**
         * 4. For each observer → mappedOldValue of interestedObservers:
         */
        for (var interestedObservers_1 = __values(interestedObservers), interestedObservers_1_1 = interestedObservers_1.next(); !interestedObservers_1_1.done; interestedObservers_1_1 = interestedObservers_1.next()) {
            var _b = __read(interestedObservers_1_1.value, 2), observer = _b[0], mappedOldValue = _b[1];
            /**
             * 4.1. Let record be a new MutationRecord object with its type set to
             * type, target set to target, attributeName set to name,
             * attributeNamespace set to namespace, oldValue set to mappedOldValue,
             * addedNodes set to addedNodes, removedNodes set to removedNodes,
             * previousSibling set to previousSibling, and nextSibling set to
             * nextSibling.
             * 4.2. Enqueue record to observer’s record queue.
             */
            var record = CreateAlgorithm_1.create_mutationRecord(type, target, CreateAlgorithm_1.create_nodeListStatic(target, addedNodes), CreateAlgorithm_1.create_nodeListStatic(target, removedNodes), previousSibling, nextSibling, name, namespace, mappedOldValue);
            var queue = observer._recordQueue;
            queue.push(record);
        }
    }
    catch (e_3_1) { e_3 = { error: e_3_1 }; }
    finally {
        try {
            if (interestedObservers_1_1 && !interestedObservers_1_1.done && (_a = interestedObservers_1.return)) _a.call(interestedObservers_1);
        }
        finally { if (e_3) throw e_3.error; }
    }
    /**
     * 5. Queue a mutation observer microtask.
     */
    observer_queueAMutationObserverMicrotask();
}
exports.observer_queueMutationRecord = observer_queueMutationRecord;
/**
 * Queues a tree mutation record for target.
 *
 * @param target - target node
 * @param addedNodes - a list od added nodes
 * @param removedNodes - a list of removed nodes
 * @param previousSibling - previous sibling of target before mutation
 * @param nextSibling - next sibling of target before mutation
 */
function observer_queueTreeMutationRecord(target, addedNodes, removedNodes, previousSibling, nextSibling) {
    /**
     * To queue a tree mutation record for target with addedNodes, removedNodes,
     * previousSibling, and nextSibling, queue a mutation record of "childList"
     * for target with null, null, null, addedNodes, removedNodes,
     * previousSibling, and nextSibling.
     */
    observer_queueMutationRecord("childList", target, null, null, null, addedNodes, removedNodes, previousSibling, nextSibling);
}
exports.observer_queueTreeMutationRecord = observer_queueTreeMutationRecord;
/**
 * Queues an attribute mutation record for target.
 *
 * @param target - target node
 * @param name - name before mutation
 * @param namespace - namespace before mutation
 * @param oldValue - attribute value before mutation
 */
function observer_queueAttributeMutationRecord(target, name, namespace, oldValue) {
    /**
     * To queue an attribute mutation record for target with name, namespace,
     * and oldValue, queue a mutation record of "attributes" for target with
     * name, namespace, oldValue, « », « », null, and null.
     */
    observer_queueMutationRecord("attributes", target, name, namespace, oldValue, [], [], null, null);
}
exports.observer_queueAttributeMutationRecord = observer_queueAttributeMutationRecord;
//# sourceMappingURL=MutationObserverAlgorithm.js.map

/***/ }),

/***/ 9733:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
var DOMException_1 = __nccwpck_require__(7175);
var infra_1 = __nccwpck_require__(4737);
var XMLAlgorithm_1 = __nccwpck_require__(6879);
/**
 * Validates the given qualified name.
 *
 * @param qualifiedName - qualified name
 */
function namespace_validate(qualifiedName) {
    /**
     * To validate a qualifiedName, throw an "InvalidCharacterError"
     * DOMException if qualifiedName does not match the Name or QName
     * production.
     */
    if (!XMLAlgorithm_1.xml_isName(qualifiedName))
        throw new DOMException_1.InvalidCharacterError("Invalid XML name: " + qualifiedName);
    if (!XMLAlgorithm_1.xml_isQName(qualifiedName))
        throw new DOMException_1.InvalidCharacterError("Invalid XML qualified name: " + qualifiedName + ".");
}
exports.namespace_validate = namespace_validate;
/**
 * Validates and extracts a namespace, prefix and localName from the
 * given namespace and qualified name.
 * See: https://dom.spec.whatwg.org/#validate-and-extract.
 *
 * @param namespace - namespace
 * @param qualifiedName - qualified name
 *
 * @returns a tuple with `namespace`, `prefix` and `localName`.
 */
function namespace_validateAndExtract(namespace, qualifiedName) {
    /**
     * 1. If namespace is the empty string, set it to null.
     * 2. Validate qualifiedName.
     * 3. Let prefix be null.
     * 4. Let localName be qualifiedName.
     * 5. If qualifiedName contains a ":" (U+003E), then split the string on it
     * and set prefix to the part before and localName to the part after.
     * 6. If prefix is non-null and namespace is null, then throw a
     * "NamespaceError" DOMException.
     * 7. If prefix is "xml" and namespace is not the XML namespace, then throw
     * a "NamespaceError" DOMException.
     * 8. If either qualifiedName or prefix is "xmlns" and namespace is not the
     * XMLNS namespace, then throw a "NamespaceError" DOMException.
     * 9. If namespace is the XMLNS namespace and neither qualifiedName nor
     * prefix is "xmlns", then throw a "NamespaceError" DOMException.
     * 10. Return namespace, prefix, and localName.
     */
    if (!namespace)
        namespace = null;
    namespace_validate(qualifiedName);
    var parts = qualifiedName.split(':');
    var prefix = (parts.length === 2 ? parts[0] : null);
    var localName = (parts.length === 2 ? parts[1] : qualifiedName);
    if (prefix && namespace === null)
        throw new DOMException_1.NamespaceError("Qualified name includes a prefix but the namespace is null.");
    if (prefix === "xml" && namespace !== infra_1.namespace.XML)
        throw new DOMException_1.NamespaceError("Qualified name includes the \"xml\" prefix but the namespace is not the XML namespace.");
    if (namespace !== infra_1.namespace.XMLNS &&
        (prefix === "xmlns" || qualifiedName === "xmlns"))
        throw new DOMException_1.NamespaceError("Qualified name includes the \"xmlns\" prefix but the namespace is not the XMLNS namespace.");
    if (namespace === infra_1.namespace.XMLNS &&
        (prefix !== "xmlns" && qualifiedName !== "xmlns"))
        throw new DOMException_1.NamespaceError("Qualified name does not include the \"xmlns\" prefix but the namespace is the XMLNS namespace.");
    return [namespace, prefix, localName];
}
exports.namespace_validateAndExtract = namespace_validateAndExtract;
/**
 * Extracts a prefix and localName from the given qualified name.
 *
 * @param qualifiedName - qualified name
 *
 * @returns an tuple with `prefix` and `localName`.
 */
function namespace_extractQName(qualifiedName) {
    namespace_validate(qualifiedName);
    var parts = qualifiedName.split(':');
    var prefix = (parts.length === 2 ? parts[0] : null);
    var localName = (parts.length === 2 ? parts[1] : qualifiedName);
    return [prefix, localName];
}
exports.namespace_extractQName = namespace_extractQName;
//# sourceMappingURL=NamespaceAlgorithm.js.map

/***/ }),

/***/ 1228:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {


var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var DOMImpl_1 = __nccwpck_require__(698);
var util_1 = __nccwpck_require__(628);
var infra_1 = __nccwpck_require__(4737);
var CreateAlgorithm_1 = __nccwpck_require__(8308);
var OrderedSetAlgorithm_1 = __nccwpck_require__(8421);
var DOMAlgorithm_1 = __nccwpck_require__(9484);
var MutationAlgorithm_1 = __nccwpck_require__(45);
var ElementAlgorithm_1 = __nccwpck_require__(2720);
/**
 * Replaces the contents of the given node with a single text node.
 *
 * @param string - node contents
 * @param parent - a node
 */
function node_stringReplaceAll(str, parent) {
    /**
     * 1. Let node be null.
     * 2. If string is not the empty string, then set node to a new Text node
     * whose data is string and node document is parent’s node document.
     * 3. Replace all with node within parent.
     */
    var node = null;
    if (str !== '') {
        node = CreateAlgorithm_1.create_text(parent._nodeDocument, str);
    }
    MutationAlgorithm_1.mutation_replaceAll(node, parent);
}
exports.node_stringReplaceAll = node_stringReplaceAll;
/**
 * Clones a node.
 *
 * @param node - a node to clone
 * @param document - the document to own the cloned node
 * @param cloneChildrenFlag - whether to clone node's children
 */
function node_clone(node, document, cloneChildrenFlag) {
    var e_1, _a, e_2, _b;
    if (document === void 0) { document = null; }
    if (cloneChildrenFlag === void 0) { cloneChildrenFlag = false; }
    /**
     * 1. If document is not given, let document be node’s node document.
     */
    if (document === null)
        document = node._nodeDocument;
    var copy;
    if (util_1.Guard.isElementNode(node)) {
        /**
         * 2. If node is an element, then:
         * 2.1. Let copy be the result of creating an element, given document,
         * node’s local name, node’s namespace, node’s namespace prefix,
         * and node’s is value, with the synchronous custom elements flag unset.
         * 2.2. For each attribute in node’s attribute list:
         * 2.2.1. Let copyAttribute be a clone of attribute.
         * 2.2.2. Append copyAttribute to copy.
         */
        copy = ElementAlgorithm_1.element_createAnElement(document, node._localName, node._namespace, node._namespacePrefix, node._is, false);
        try {
            for (var _c = __values(node._attributeList), _d = _c.next(); !_d.done; _d = _c.next()) {
                var attribute = _d.value;
                var copyAttribute = node_clone(attribute, document);
                ElementAlgorithm_1.element_append(copyAttribute, copy);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
            }
            finally { if (e_1) throw e_1.error; }
        }
    }
    else {
        /**
         * 3. Otherwise, let copy be a node that implements the same interfaces as
         * node, and fulfills these additional requirements, switching on node:
         * - Document
         * Set copy’s encoding, content type, URL, origin, type, and mode, to those
         * of node.
         * - DocumentType
         * Set copy’s name, public ID, and system ID, to those of node.
         * - Attr
         * Set copy’s namespace, namespace prefix, local name, and value, to
         * those of node.
         * - Text
         * - Comment
         * Set copy’s data, to that of node.
         * - ProcessingInstruction
         * Set copy’s target and data to those of node.
         * - Any other node
         */
        if (util_1.Guard.isDocumentNode(node)) {
            var doc = CreateAlgorithm_1.create_document();
            doc._encoding = node._encoding;
            doc._contentType = node._contentType;
            doc._URL = node._URL;
            doc._origin = node._origin;
            doc._type = node._type;
            doc._mode = node._mode;
            copy = doc;
        }
        else if (util_1.Guard.isDocumentTypeNode(node)) {
            var doctype = CreateAlgorithm_1.create_documentType(document, node._name, node._publicId, node._systemId);
            copy = doctype;
        }
        else if (util_1.Guard.isAttrNode(node)) {
            var attr = CreateAlgorithm_1.create_attr(document, node.localName);
            attr._namespace = node._namespace;
            attr._namespacePrefix = node._namespacePrefix;
            attr._value = node._value;
            copy = attr;
        }
        else if (util_1.Guard.isExclusiveTextNode(node)) {
            copy = CreateAlgorithm_1.create_text(document, node._data);
        }
        else if (util_1.Guard.isCDATASectionNode(node)) {
            copy = CreateAlgorithm_1.create_cdataSection(document, node._data);
        }
        else if (util_1.Guard.isCommentNode(node)) {
            copy = CreateAlgorithm_1.create_comment(document, node._data);
        }
        else if (util_1.Guard.isProcessingInstructionNode(node)) {
            copy = CreateAlgorithm_1.create_processingInstruction(document, node._target, node._data);
        }
        else if (util_1.Guard.isDocumentFragmentNode(node)) {
            copy = CreateAlgorithm_1.create_documentFragment(document);
        }
        else {
            copy = Object.create(node);
        }
    }
    /**
     * 4. Set copy’s node document and document to copy, if copy is a document,
     * and set copy’s node document to document otherwise.
     */
    if (util_1.Guard.isDocumentNode(copy)) {
        copy._nodeDocument = copy;
        document = copy;
    }
    else {
        copy._nodeDocument = document;
    }
    /**
     * 5. Run any cloning steps defined for node in other applicable
     * specifications and pass copy, node, document and the clone children flag
     * if set, as parameters.
     */
    if (DOMImpl_1.dom.features.steps) {
        DOMAlgorithm_1.dom_runCloningSteps(copy, node, document, cloneChildrenFlag);
    }
    /**
     * 6. If the clone children flag is set, clone all the children of node and
     * append them to copy, with document as specified and the clone children
     * flag being set.
     */
    if (cloneChildrenFlag) {
        try {
            for (var _e = __values(node._children), _f = _e.next(); !_f.done; _f = _e.next()) {
                var child = _f.value;
                var childCopy = node_clone(child, document, true);
                MutationAlgorithm_1.mutation_append(childCopy, copy);
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
            }
            finally { if (e_2) throw e_2.error; }
        }
    }
    /**
     * 7. Return copy.
     */
    return copy;
}
exports.node_clone = node_clone;
/**
 * Determines if two nodes can be considered equal.
 *
 * @param a - node to compare
 * @param b - node to compare
 */
function node_equals(a, b) {
    var e_3, _a, e_4, _b;
    /**
     * 1. A and B’s nodeType attribute value is identical.
     */
    if (a._nodeType !== b._nodeType)
        return false;
    /**
     * 2. The following are also equal, depending on A:
     * - DocumentType
     * Its name, public ID, and system ID.
     * - Element
     * Its namespace, namespace prefix, local name, and its attribute list’s size.
     * - Attr
     * Its namespace, local name, and value.
     * - ProcessingInstruction
     * Its target and data.
     * - Text
     * - Comment
     * Its data.
     */
    if (util_1.Guard.isDocumentTypeNode(a) && util_1.Guard.isDocumentTypeNode(b)) {
        if (a._name !== b._name || a._publicId !== b._publicId ||
            a._systemId !== b._systemId)
            return false;
    }
    else if (util_1.Guard.isElementNode(a) && util_1.Guard.isElementNode(b)) {
        if (a._namespace !== b._namespace || a._namespacePrefix !== b._namespacePrefix ||
            a._localName !== b._localName ||
            a._attributeList.length !== b._attributeList.length)
            return false;
    }
    else if (util_1.Guard.isAttrNode(a) && util_1.Guard.isAttrNode(b)) {
        if (a._namespace !== b._namespace || a._localName !== b._localName ||
            a._value !== b._value)
            return false;
    }
    else if (util_1.Guard.isProcessingInstructionNode(a) && util_1.Guard.isProcessingInstructionNode(b)) {
        if (a._target !== b._target || a._data !== b._data)
            return false;
    }
    else if (util_1.Guard.isCharacterDataNode(a) && util_1.Guard.isCharacterDataNode(b)) {
        if (a._data !== b._data)
            return false;
    }
    /**
     * 3. If A is an element, each attribute in its attribute list has an attribute
     * that equals an attribute in B’s attribute list.
     */
    if (util_1.Guard.isElementNode(a) && util_1.Guard.isElementNode(b)) {
        var attrMap = {};
        try {
            for (var _c = __values(a._attributeList), _d = _c.next(); !_d.done; _d = _c.next()) {
                var attrA = _d.value;
                attrMap[attrA._localName] = attrA;
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
            }
            finally { if (e_3) throw e_3.error; }
        }
        try {
            for (var _e = __values(b._attributeList), _f = _e.next(); !_f.done; _f = _e.next()) {
                var attrB = _f.value;
                var attrA = attrMap[attrB._localName];
                if (!attrA)
                    return false;
                if (!node_equals(attrA, attrB))
                    return false;
            }
        }
        catch (e_4_1) { e_4 = { error: e_4_1 }; }
        finally {
            try {
                if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
            }
            finally { if (e_4) throw e_4.error; }
        }
    }
    /**
     * 4. A and B have the same number of children.
     * 5. Each child of A equals the child of B at the identical index.
     */
    if (a._children.size !== b._children.size)
        return false;
    var itA = a._children[Symbol.iterator]();
    var itB = b._children[Symbol.iterator]();
    var resultA = itA.next();
    var resultB = itB.next();
    while (!resultA.done && !resultB.done) {
        var child1 = resultA.value;
        var child2 = resultB.value;
        if (!node_equals(child1, child2))
            return false;
        resultA = itA.next();
        resultB = itB.next();
    }
    return true;
}
exports.node_equals = node_equals;
/**
 * Returns a collection of elements with the given qualified name which are
 * descendants of the given root node.
 * See: https://dom.spec.whatwg.org/#concept-getelementsbytagname
 *
 * @param qualifiedName - qualified name
 * @param root - root node
 */
function node_listOfElementsWithQualifiedName(qualifiedName, root) {
    /**
     * 1. If qualifiedName is "*" (U+002A), return a HTMLCollection rooted at
     * root, whose filter matches only descendant elements.
     * 2. Otherwise, if root’s node document is an HTML document, return a
     * HTMLCollection rooted at root, whose filter matches the following
     * descendant elements:
     * 2.1. Whose namespace is the HTML namespace and whose qualified name is
     * qualifiedName, in ASCII lowercase.
     * 2.2. Whose namespace is not the HTML namespace and whose qualified name
     * is qualifiedName.
     * 3. Otherwise, return a HTMLCollection rooted at root, whose filter
     * matches descendant elements whose qualified name is qualifiedName.
     */
    if (qualifiedName === "*") {
        return CreateAlgorithm_1.create_htmlCollection(root);
    }
    else if (root._nodeDocument._type === "html") {
        return CreateAlgorithm_1.create_htmlCollection(root, function (ele) {
            if (ele._namespace === infra_1.namespace.HTML &&
                ele._qualifiedName === qualifiedName.toLowerCase()) {
                return true;
            }
            else if (ele._namespace !== infra_1.namespace.HTML &&
                ele._qualifiedName === qualifiedName) {
                return true;
            }
            else {
                return false;
            }
        });
    }
    else {
        return CreateAlgorithm_1.create_htmlCollection(root, function (ele) {
            return (ele._qualifiedName === qualifiedName);
        });
    }
}
exports.node_listOfElementsWithQualifiedName = node_listOfElementsWithQualifiedName;
/**
 * Returns a collection of elements with the given namespace which are
 * descendants of the given root node.
 * See: https://dom.spec.whatwg.org/#concept-getelementsbytagnamens
 *
 * @param namespace - element namespace
 * @param localName - local name
 * @param root - root node
 */
function node_listOfElementsWithNamespace(namespace, localName, root) {
    /**
     * 1. If namespace is the empty string, set it to null.
     * 2. If both namespace and localName are "*" (U+002A), return a
     * HTMLCollection rooted at root, whose filter matches descendant elements.
     * 3. Otherwise, if namespace is "*" (U+002A), return a HTMLCollection
     * rooted at root, whose filter matches descendant elements whose local
     * name is localName.
     * 4. Otherwise, if localName is "*" (U+002A), return a HTMLCollection
     * rooted at root, whose filter matches descendant elements whose
     * namespace is namespace.
     * 5. Otherwise, return a HTMLCollection rooted at root, whose filter
     * matches descendant elements whose namespace is namespace and local
     * name is localName.
     */
    if (namespace === '')
        namespace = null;
    if (namespace === "*" && localName === "*") {
        return CreateAlgorithm_1.create_htmlCollection(root);
    }
    else if (namespace === "*") {
        return CreateAlgorithm_1.create_htmlCollection(root, function (ele) {
            return (ele._localName === localName);
        });
    }
    else if (localName === "*") {
        return CreateAlgorithm_1.create_htmlCollection(root, function (ele) {
            return (ele._namespace === namespace);
        });
    }
    else {
        return CreateAlgorithm_1.create_htmlCollection(root, function (ele) {
            return (ele._localName === localName && ele._namespace === namespace);
        });
    }
}
exports.node_listOfElementsWithNamespace = node_listOfElementsWithNamespace;
/**
 * Returns a collection of elements with the given class names which are
 * descendants of the given root node.
 * See: https://dom.spec.whatwg.org/#concept-getelementsbyclassname
 *
 * @param namespace - element namespace
 * @param localName - local name
 * @param root - root node
 */
function node_listOfElementsWithClassNames(classNames, root) {
    /**
     * 1. Let classes be the result of running the ordered set parser
     * on classNames.
     * 2. If classes is the empty set, return an empty HTMLCollection.
     * 3. Return a HTMLCollection rooted at root, whose filter matches
     * descendant elements that have all their classes in classes.
     * The comparisons for the classes must be done in an ASCII case-insensitive
     * manner if root’s node document’s mode is "quirks", and in a
     * case-sensitive manner otherwise.
     */
    var classes = OrderedSetAlgorithm_1.orderedSet_parse(classNames);
    if (classes.size === 0) {
        return CreateAlgorithm_1.create_htmlCollection(root, function () { return false; });
    }
    var caseSensitive = (root._nodeDocument._mode !== "quirks");
    return CreateAlgorithm_1.create_htmlCollection(root, function (ele) {
        var eleClasses = ele.classList;
        return OrderedSetAlgorithm_1.orderedSet_contains(eleClasses._tokenSet, classes, caseSensitive);
    });
}
exports.node_listOfElementsWithClassNames = node_listOfElementsWithClassNames;
/**
 * Searches for a namespace prefix associated with the given namespace
 * starting from the given element through its ancestors.
 *
 * @param element - an element node to start searching at
 * @param namespace - namespace to search for
 */
function node_locateANamespacePrefix(element, namespace) {
    /**
     * 1. If element’s namespace is namespace and its namespace prefix is not
     * null, then return its namespace prefix.
     */
    if (element._namespace === namespace && element._namespacePrefix !== null) {
        return element._namespacePrefix;
    }
    /**
     * 2. If element has an attribute whose namespace prefix is "xmlns" and
     * value is namespace, then return element’s first such attribute’s
     * local name.
     */
    for (var i = 0; i < element._attributeList.length; i++) {
        var attr = element._attributeList[i];
        if (attr._namespacePrefix === "xmlns" && attr._value === namespace) {
            return attr._localName;
        }
    }
    /**
     * 3. If element’s parent element is not null, then return the result of
     * running locate a namespace prefix on that element using namespace.
     */
    if (element._parent && util_1.Guard.isElementNode(element._parent)) {
        return node_locateANamespacePrefix(element._parent, namespace);
    }
    /**
     * 4. Return null.
     */
    return null;
}
exports.node_locateANamespacePrefix = node_locateANamespacePrefix;
/**
 * Searches for a namespace associated with the given namespace prefix
 * starting from the given node through its ancestors.
 *
 * @param node - a node to start searching at
 * @param prefix - namespace prefix to search for
 */
function node_locateANamespace(node, prefix) {
    if (util_1.Guard.isElementNode(node)) {
        /**
         * 1. If its namespace is not null and its namespace prefix is prefix,
         * then return namespace.
         */
        if (node._namespace !== null && node._namespacePrefix === prefix) {
            return node._namespace;
        }
        /**
         * 2. If it has an attribute whose namespace is the XMLNS namespace,
         * namespace prefix is "xmlns", and local name is prefix, or if prefix
         * is null and it has an attribute whose namespace is the XMLNS namespace,
         * namespace prefix is null, and local name is "xmlns", then return its
         * value if it is not the empty string, and null otherwise.
         */
        for (var i = 0; i < node._attributeList.length; i++) {
            var attr = node._attributeList[i];
            if (attr._namespace === infra_1.namespace.XMLNS &&
                attr._namespacePrefix === "xmlns" &&
                attr._localName === prefix) {
                return attr._value || null;
            }
            if (prefix === null && attr._namespace === infra_1.namespace.XMLNS &&
                attr._namespacePrefix === null && attr._localName === "xmlns") {
                return attr._value || null;
            }
        }
        /**
         * 3. If its parent element is null, then return null.
         */
        if (node.parentElement === null)
            return null;
        /**
         * 4. Return the result of running locate a namespace on its parent
         * element using prefix.
         */
        return node_locateANamespace(node.parentElement, prefix);
    }
    else if (util_1.Guard.isDocumentNode(node)) {
        /**
         * 1. If its document element is null, then return null.
         * 2. Return the result of running locate a namespace on its document
         * element using prefix.
         */
        if (node.documentElement === null)
            return null;
        return node_locateANamespace(node.documentElement, prefix);
    }
    else if (util_1.Guard.isDocumentTypeNode(node) || util_1.Guard.isDocumentFragmentNode(node)) {
        return null;
    }
    else if (util_1.Guard.isAttrNode(node)) {
        /**
         * 1. If its element is null, then return null.
         * 2. Return the result of running locate a namespace on its element
         * using prefix.
         */
        if (node._element === null)
            return null;
        return node_locateANamespace(node._element, prefix);
    }
    else {
        /**
         * 1. If its parent element is null, then return null.
         * 2. Return the result of running locate a namespace on its parent
         * element using prefix.
         */
        if (!node._parent || !util_1.Guard.isElementNode(node._parent))
            return null;
        return node_locateANamespace(node._parent, prefix);
    }
}
exports.node_locateANamespace = node_locateANamespace;
//# sourceMappingURL=NodeAlgorithm.js.map

/***/ }),

/***/ 9670:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
var DOMImpl_1 = __nccwpck_require__(698);
var interfaces_1 = __nccwpck_require__(9454);
var TraversalAlgorithm_1 = __nccwpck_require__(6746);
var TreeAlgorithm_1 = __nccwpck_require__(3532);
/**
 * Returns the next or previous node in the subtree, or `null` if
 * there are none.
 *
 * @param iterator - the `NodeIterator` instance
 * @param forward- `true` to return the next node, or `false` to
 * return the previous node.
 */
function nodeIterator_traverse(iterator, forward) {
    /**
     * 1. Let node be iterator’s reference.
     * 2. Let beforeNode be iterator’s pointer before reference.
     */
    var node = iterator._reference;
    var beforeNode = iterator._pointerBeforeReference;
    /**
     * 3. While true:
     */
    while (true) {
        /**
         * 3.1. Branch on direction:
         */
        if (forward) {
            /**
             * - next
             */
            if (!beforeNode) {
                /**
                 * If beforeNode is false, then set node to the first node following
                 * node in iterator’s iterator collection. If there is no such node,
                 * then return null.
                 */
                var nextNode = TreeAlgorithm_1.tree_getFollowingNode(iterator._root, node);
                if (nextNode) {
                    node = nextNode;
                }
                else {
                    return null;
                }
            }
            else {
                /**
                 * If beforeNode is true, then set it to false.
                 */
                beforeNode = false;
            }
        }
        else {
            /**
             * - previous
             */
            if (beforeNode) {
                /**
                 * If beforeNode is true, then set node to the first node preceding
                 * node in iterator’s iterator collection. If there is no such node,
                 * then return null.
                 */
                var prevNode = TreeAlgorithm_1.tree_getPrecedingNode(iterator.root, node);
                if (prevNode) {
                    node = prevNode;
                }
                else {
                    return null;
                }
            }
            else {
                /**
                 * If beforeNode is false, then set it to true.
                 */
                beforeNode = true;
            }
        }
        /**
         * 3.2. Let result be the result of filtering node within iterator.
         * 3.3. If result is FILTER_ACCEPT, then break.
         */
        var result = TraversalAlgorithm_1.traversal_filter(iterator, node);
        if (result === interfaces_1.FilterResult.Accept) {
            break;
        }
    }
    /**
     * 4. Set iterator’s reference to node.
     * 5. Set iterator’s pointer before reference to beforeNode.
     * 6. Return node.
     */
    iterator._reference = node;
    iterator._pointerBeforeReference = beforeNode;
    return node;
}
exports.nodeIterator_traverse = nodeIterator_traverse;
/**
 * Gets the global iterator list.
 */
function nodeIterator_iteratorList() {
    return DOMImpl_1.dom.window._iteratorList;
}
exports.nodeIterator_iteratorList = nodeIterator_iteratorList;
//# sourceMappingURL=NodeIteratorAlgorithm.js.map

/***/ }),

/***/ 8421:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {


var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var infra_1 = __nccwpck_require__(4737);
/**
 * Converts a whitespace separated string into an array of tokens.
 *
 * @param value - a string of whitespace separated tokens
 */
function orderedSet_parse(value) {
    /**
     * 1. Let inputTokens be the result of splitting input on ASCII whitespace.
     * 2. Let tokens be a new ordered set.
     * 3. For each token in inputTokens, append token to tokens.
     * 4. Return tokens.
     */
    var inputTokens = infra_1.string.splitAStringOnASCIIWhitespace(value);
    return new Set(inputTokens);
}
exports.orderedSet_parse = orderedSet_parse;
/**
 * Converts an array of tokens into a space separated string.
 *
 * @param tokens - an array of token strings
 */
function orderedSet_serialize(tokens) {
    /**
     * The ordered set serializer takes a set and returns the concatenation of
     * set using U+0020 SPACE.
     */
    return __spread(tokens).join(' ');
}
exports.orderedSet_serialize = orderedSet_serialize;
/**
 * Removes duplicate tokens and convert all whitespace characters
 * to space.
 *
 * @param value - a string of whitespace separated tokens
 */
function orderedSet_sanitize(value) {
    return orderedSet_serialize(orderedSet_parse(value));
}
exports.orderedSet_sanitize = orderedSet_sanitize;
/**
 * Determines whether a set contains the other.
 *
 * @param set1 - a set
 * @param set1 - a set that is contained in set1
 * @param caseSensitive - whether matches are case-sensitive
 */
function orderedSet_contains(set1, set2, caseSensitive) {
    var e_1, _a, e_2, _b;
    try {
        for (var set2_1 = __values(set2), set2_1_1 = set2_1.next(); !set2_1_1.done; set2_1_1 = set2_1.next()) {
            var val2 = set2_1_1.value;
            var found = false;
            try {
                for (var set1_1 = (e_2 = void 0, __values(set1)), set1_1_1 = set1_1.next(); !set1_1_1.done; set1_1_1 = set1_1.next()) {
                    var val1 = set1_1_1.value;
                    if (caseSensitive) {
                        if (val1 === val2) {
                            found = true;
                            break;
                        }
                    }
                    else {
                        if (val1.toUpperCase() === val2.toUpperCase()) {
                            found = true;
                            break;
                        }
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (set1_1_1 && !set1_1_1.done && (_b = set1_1.return)) _b.call(set1_1);
                }
                finally { if (e_2) throw e_2.error; }
            }
            if (!found)
                return false;
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (set2_1_1 && !set2_1_1.done && (_a = set2_1.return)) _a.call(set2_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return true;
}
exports.orderedSet_contains = orderedSet_contains;
//# sourceMappingURL=OrderedSetAlgorithm.js.map

/***/ }),

/***/ 9892:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {


var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var util_1 = __nccwpck_require__(7061);
var CreateAlgorithm_1 = __nccwpck_require__(8308);
/**
 * Converts the given nodes or strings into a node (if `nodes` has
 * only one element) or a document fragment.
 *
 * @param nodes - the array of nodes or strings,
 * @param document - owner document
 */
function parentNode_convertNodesIntoANode(nodes, document) {
    var e_1, _a;
    /**
     * 1. Let node be null.
     * 2. Replace each string in nodes with a new Text node whose data is the
     * string and node document is document.
     */
    var node = null;
    for (var i = 0; i < nodes.length; i++) {
        var item = nodes[i];
        if (util_1.isString(item)) {
            var text = CreateAlgorithm_1.create_text(document, item);
            nodes[i] = text;
        }
    }
    /**
     * 3. If nodes contains one node, set node to that node.
     * 4. Otherwise, set node to a new DocumentFragment whose node document is
     * document, and then append each node in nodes, if any, to it.
     */
    if (nodes.length === 1) {
        node = nodes[0];
    }
    else {
        node = CreateAlgorithm_1.create_documentFragment(document);
        var ns = node;
        try {
            for (var nodes_1 = __values(nodes), nodes_1_1 = nodes_1.next(); !nodes_1_1.done; nodes_1_1 = nodes_1.next()) {
                var item = nodes_1_1.value;
                ns.appendChild(item);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (nodes_1_1 && !nodes_1_1.done && (_a = nodes_1.return)) _a.call(nodes_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
    }
    /**
     * 5. Return node.
     */
    return node;
}
exports.parentNode_convertNodesIntoANode = parentNode_convertNodesIntoANode;
//# sourceMappingURL=ParentNodeAlgorithm.js.map

/***/ }),

/***/ 6687:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {


var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var interfaces_1 = __nccwpck_require__(9454);
var DOMException_1 = __nccwpck_require__(7175);
var util_1 = __nccwpck_require__(628);
var CreateAlgorithm_1 = __nccwpck_require__(8308);
var TreeAlgorithm_1 = __nccwpck_require__(3532);
var BoundaryPointAlgorithm_1 = __nccwpck_require__(8652);
var CharacterDataAlgorithm_1 = __nccwpck_require__(7785);
var NodeAlgorithm_1 = __nccwpck_require__(1228);
var MutationAlgorithm_1 = __nccwpck_require__(45);
var TextAlgorithm_1 = __nccwpck_require__(3813);
/**
 * Determines if the node's start boundary point is at its end boundary
 * point.
 *
 * @param range - a range
 */
function range_collapsed(range) {
    /**
     * A range is collapsed if its start node is its end node and its start offset is its end offset.
     */
    return (range._startNode === range._endNode && range._startOffset === range._endOffset);
}
exports.range_collapsed = range_collapsed;
/**
 * Gets the root node of a range.
 *
 * @param range - a range
 */
function range_root(range) {
    /**
     * The root of a live range is the root of its start node.
     */
    return TreeAlgorithm_1.tree_rootNode(range._startNode);
}
exports.range_root = range_root;
/**
 * Determines if a node is fully contained in a range.
 *
 * @param node - a node
 * @param range - a range
 */
function range_isContained(node, range) {
    /**
     * A node node is contained in a live range range if node’s root is range’s
     * root, and (node, 0) is after range’s start, and (node, node’s length) is
     * before range’s end.
     */
    return (TreeAlgorithm_1.tree_rootNode(node) === range_root(range) &&
        BoundaryPointAlgorithm_1.boundaryPoint_position([node, 0], range._start) === interfaces_1.BoundaryPosition.After &&
        BoundaryPointAlgorithm_1.boundaryPoint_position([node, TreeAlgorithm_1.tree_nodeLength(node)], range._end) === interfaces_1.BoundaryPosition.Before);
}
exports.range_isContained = range_isContained;
/**
 * Determines if a node is partially contained in a range.
 *
 * @param node - a node
 * @param range - a range
 */
function range_isPartiallyContained(node, range) {
    /**
     * A node is partially contained in a live range if it’s an inclusive
     * ancestor of the live range’s start node but not its end node,
     * or vice versa.
     */
    var startCheck = TreeAlgorithm_1.tree_isAncestorOf(range._startNode, node, true);
    var endCheck = TreeAlgorithm_1.tree_isAncestorOf(range._endNode, node, true);
    return (startCheck && !endCheck) || (!startCheck && endCheck);
}
exports.range_isPartiallyContained = range_isPartiallyContained;
/**
 * Sets the start boundary point of a range.
 *
 * @param range - a range
 * @param node - a node
 * @param offset - an offset into node
 */
function range_setTheStart(range, node, offset) {
    /**
     * 1. If node is a doctype, then throw an "InvalidNodeTypeError" DOMException.
     * 2. If offset is greater than node’s length, then throw an "IndexSizeError"
     * DOMException.
     * 3. Let bp be the boundary point (node, offset).
     * 4. If these steps were invoked as "set the start"
     * 4.1. If bp is after the range’s end, or if range’s root is not equal to
     * node’s root, set range’s end to bp.
     * 4.2. Set range’s start to bp.
     */
    if (util_1.Guard.isDocumentTypeNode(node)) {
        throw new DOMException_1.InvalidNodeTypeError();
    }
    if (offset > TreeAlgorithm_1.tree_nodeLength(node)) {
        throw new DOMException_1.IndexSizeError();
    }
    var bp = [node, offset];
    if (range_root(range) !== TreeAlgorithm_1.tree_rootNode(node) ||
        BoundaryPointAlgorithm_1.boundaryPoint_position(bp, range._end) === interfaces_1.BoundaryPosition.After) {
        range._end = bp;
    }
    range._start = bp;
}
exports.range_setTheStart = range_setTheStart;
/**
 * Sets the end boundary point of a range.
 *
 * @param range - a range
 * @param node - a node
 * @param offset - an offset into node
 */
function range_setTheEnd(range, node, offset) {
    /**
     * 1. If node is a doctype, then throw an "InvalidNodeTypeError" DOMException.
     * 2. If offset is greater than node’s length, then throw an "IndexSizeError"
     * DOMException.
     * 3. Let bp be the boundary point (node, offset).
     * 4. If these steps were invoked as "set the end"
     * 4.1. If bp is before the range’s start, or if range’s root is not equal
     * to node’s root, set range’s start to bp.
     * 4.2. Set range’s end to bp.
     */
    if (util_1.Guard.isDocumentTypeNode(node)) {
        throw new DOMException_1.InvalidNodeTypeError();
    }
    if (offset > TreeAlgorithm_1.tree_nodeLength(node)) {
        throw new DOMException_1.IndexSizeError();
    }
    var bp = [node, offset];
    if (range_root(range) !== TreeAlgorithm_1.tree_rootNode(node) ||
        BoundaryPointAlgorithm_1.boundaryPoint_position(bp, range._start) === interfaces_1.BoundaryPosition.Before) {
        range._start = bp;
    }
    range._end = bp;
}
exports.range_setTheEnd = range_setTheEnd;
/**
 * Selects a node.
 *
 * @param range - a range
 * @param node - a node
 */
function range_select(node, range) {
    /**
     * 1. Let parent be node’s parent.
     * 2. If parent is null, then throw an "InvalidNodeTypeError" DOMException.
     */
    var parent = node._parent;
    if (parent === null)
        throw new DOMException_1.InvalidNodeTypeError();
    /**
     * 3. Let index be node’s index.
     * 4. Set range’s start to boundary point (parent, index).
     * 5. Set range’s end to boundary point (parent, index plus 1).
     */
    var index = TreeAlgorithm_1.tree_index(node);
    range._start = [parent, index];
    range._end = [parent, index + 1];
}
exports.range_select = range_select;
/**
 * EXtracts the contents of range as a document fragment.
 *
 * @param range - a range
 */
function range_extract(range) {
    var e_1, _a, e_2, _b, e_3, _c;
    /**
     * 1. Let fragment be a new DocumentFragment node whose node document is
     * range’s start node’s node document.
     * 2. If range is collapsed, then return fragment.
     */
    var fragment = CreateAlgorithm_1.create_documentFragment(range._startNode._nodeDocument);
    if (range_collapsed(range))
        return fragment;
    /**
     * 3. Let original start node, original start offset, original end node,
     * and original end offset be range’s start node, start offset, end node,
     * and end offset, respectively.
     */
    var originalStartNode = range._startNode;
    var originalStartOffset = range._startOffset;
    var originalEndNode = range._endNode;
    var originalEndOffset = range._endOffset;
    /**
     * 4. If original start node is original end node, and they are a Text,
     * ProcessingInstruction, or Comment node:
     * 4.1. Let clone be a clone of original start node.
     * 4.2. Set the data of clone to the result of substringing data with node
     * original start node, offset original start offset, and count original end
     * offset minus original start offset.
     * 4.3. Append clone to fragment.
     * 4.4. Replace data with node original start node, offset original start
     * offset, count original end offset minus original start offset, and data
     * the empty string.
     * 4.5. Return fragment.
     */
    if (originalStartNode === originalEndNode &&
        util_1.Guard.isCharacterDataNode(originalStartNode)) {
        var clone = NodeAlgorithm_1.node_clone(originalStartNode);
        clone._data = CharacterDataAlgorithm_1.characterData_substringData(originalStartNode, originalStartOffset, originalEndOffset - originalStartOffset);
        MutationAlgorithm_1.mutation_append(clone, fragment);
        CharacterDataAlgorithm_1.characterData_replaceData(originalStartNode, originalStartOffset, originalEndOffset - originalStartOffset, '');
        return fragment;
    }
    /**
     * 5. Let common ancestor be original start node.
     * 6. While common ancestor is not an inclusive ancestor of original end
     * node, set common ancestor to its own parent.
     */
    var commonAncestor = originalStartNode;
    while (!TreeAlgorithm_1.tree_isAncestorOf(originalEndNode, commonAncestor, true)) {
        if (commonAncestor._parent === null) {
            throw new Error("Parent node  is null.");
        }
        commonAncestor = commonAncestor._parent;
    }
    /**
     * 7. Let first partially contained child be null.
     * 8. If original start node is not an inclusive ancestor of original end
     * node, set first partially contained child to the first child of common
     * ancestor that is partially contained in range.
     */
    var firstPartiallyContainedChild = null;
    if (!TreeAlgorithm_1.tree_isAncestorOf(originalEndNode, originalStartNode, true)) {
        try {
            for (var _d = __values(commonAncestor._children), _e = _d.next(); !_e.done; _e = _d.next()) {
                var node = _e.value;
                if (range_isPartiallyContained(node, range)) {
                    firstPartiallyContainedChild = node;
                    break;
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_e && !_e.done && (_a = _d.return)) _a.call(_d);
            }
            finally { if (e_1) throw e_1.error; }
        }
    }
    /**
     * 9. Let last partially contained child be null.
     * 10. If original end node is not an inclusive ancestor of original start
     * node, set last partially contained child to the last child of common
     * ancestor that is partially contained in range.
     */
    var lastPartiallyContainedChild = null;
    if (!TreeAlgorithm_1.tree_isAncestorOf(originalStartNode, originalEndNode, true)) {
        var children = __spread(commonAncestor._children);
        for (var i = children.length - 1; i > 0; i--) {
            var node = children[i];
            if (range_isPartiallyContained(node, range)) {
                lastPartiallyContainedChild = node;
                break;
            }
        }
    }
    /**
     * 11. Let contained children be a list of all children of common ancestor
     * that are contained in range, in tree order.
     * 12. If any member of contained children is a doctype, then throw a
     * "HierarchyRequestError" DOMException.
     */
    var containedChildren = [];
    try {
        for (var _f = __values(commonAncestor._children), _g = _f.next(); !_g.done; _g = _f.next()) {
            var child = _g.value;
            if (range_isContained(child, range)) {
                if (util_1.Guard.isDocumentTypeNode(child)) {
                    throw new DOMException_1.HierarchyRequestError();
                }
                containedChildren.push(child);
            }
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (_g && !_g.done && (_b = _f.return)) _b.call(_f);
        }
        finally { if (e_2) throw e_2.error; }
    }
    var newNode;
    var newOffset;
    if (TreeAlgorithm_1.tree_isAncestorOf(originalEndNode, originalStartNode, true)) {
        /**
         * 13. If original start node is an inclusive ancestor of original end node,
         * set new node to original start node and new offset to original start
         * offset.
         */
        newNode = originalStartNode;
        newOffset = originalStartOffset;
    }
    else {
        /**
         * 14. Otherwise:
         * 14.1. Let reference node equal original start node.
         * 14.2. While reference node’s parent is not null and is not an inclusive
         * ancestor of original end node, set reference node to its parent.
         * 14.3. Set new node to the parent of reference node, and new offset to
         * one plus reference node’s index.
         */
        var referenceNode = originalStartNode;
        while (referenceNode._parent !== null &&
            !TreeAlgorithm_1.tree_isAncestorOf(originalEndNode, referenceNode._parent)) {
            referenceNode = referenceNode._parent;
        }
        /* istanbul ignore next */
        if (referenceNode._parent === null) {
            /**
             * If reference node’s parent is null, it would be the root of range,
             * so would be an inclusive ancestor of original end node, and we could
             * not reach this point.
             */
            throw new Error("Parent node is null.");
        }
        newNode = referenceNode._parent;
        newOffset = 1 + TreeAlgorithm_1.tree_index(referenceNode);
    }
    if (util_1.Guard.isCharacterDataNode(firstPartiallyContainedChild)) {
        /**
         * 15. If first partially contained child is a Text, ProcessingInstruction,
         * or Comment node:
         * 15.1. Let clone be a clone of original start node.
         * 15.2. Set the data of clone to the result of substringing data with
         * node original start node, offset original start offset, and count
         * original start node’s length minus original start offset.
         * 15.3. Append clone to fragment.
         * 15.4. Replace data with node original start node, offset original
         * start offset, count original start node’s length minus original start
         * offset, and data the empty string.
         */
        var clone = NodeAlgorithm_1.node_clone(originalStartNode);
        clone._data = CharacterDataAlgorithm_1.characterData_substringData(originalStartNode, originalStartOffset, TreeAlgorithm_1.tree_nodeLength(originalStartNode) - originalStartOffset);
        MutationAlgorithm_1.mutation_append(clone, fragment);
        CharacterDataAlgorithm_1.characterData_replaceData(originalStartNode, originalStartOffset, TreeAlgorithm_1.tree_nodeLength(originalStartNode) - originalStartOffset, '');
    }
    else if (firstPartiallyContainedChild !== null) {
        /**
         * 16. Otherwise, if first partially contained child is not null:
         * 16.1. Let clone be a clone of first partially contained child.
         * 16.2. Append clone to fragment.
         * 16.3. Let subrange be a new live range whose start is (original start
         * node, original start offset) and whose end is (first partially
         * contained child, first partially contained child’s length).
         * 16.4. Let subfragment be the result of extracting subrange.
         * 16.5. Append subfragment to clone.
         */
        var clone = NodeAlgorithm_1.node_clone(firstPartiallyContainedChild);
        MutationAlgorithm_1.mutation_append(clone, fragment);
        var subrange = CreateAlgorithm_1.create_range([originalStartNode, originalStartOffset], [firstPartiallyContainedChild, TreeAlgorithm_1.tree_nodeLength(firstPartiallyContainedChild)]);
        var subfragment = range_extract(subrange);
        MutationAlgorithm_1.mutation_append(subfragment, clone);
    }
    try {
        /**
         * 17. For each contained child in contained children, append contained
         * child to fragment.
         */
        for (var containedChildren_1 = __values(containedChildren), containedChildren_1_1 = containedChildren_1.next(); !containedChildren_1_1.done; containedChildren_1_1 = containedChildren_1.next()) {
            var child = containedChildren_1_1.value;
            MutationAlgorithm_1.mutation_append(child, fragment);
        }
    }
    catch (e_3_1) { e_3 = { error: e_3_1 }; }
    finally {
        try {
            if (containedChildren_1_1 && !containedChildren_1_1.done && (_c = containedChildren_1.return)) _c.call(containedChildren_1);
        }
        finally { if (e_3) throw e_3.error; }
    }
    if (util_1.Guard.isCharacterDataNode(lastPartiallyContainedChild)) {
        /**
         * 18. If last partially contained child is a Text, ProcessingInstruction,
         * or Comment node:
         * 18.1. Let clone be a clone of original end node.
         * 18.2. Set the data of clone to the result of substringing data with
         * node original end node, offset 0, and count original end offset.
         * 18.3. Append clone to fragment.
         * 18.4. Replace data with node original end node, offset 0, count
         * original end offset, and data the empty string.
         */
        var clone = NodeAlgorithm_1.node_clone(originalEndNode);
        clone._data = CharacterDataAlgorithm_1.characterData_substringData(originalEndNode, 0, originalEndOffset);
        MutationAlgorithm_1.mutation_append(clone, fragment);
        CharacterDataAlgorithm_1.characterData_replaceData(originalEndNode, 0, originalEndOffset, '');
    }
    else if (lastPartiallyContainedChild !== null) {
        /**
         * 19. Otherwise, if last partially contained child is not null:
         * 19.1. Let clone be a clone of last partially contained child.
         * 19.2. Append clone to fragment.
         * 19.3. Let subrange be a new live range whose start is (last partially
         * contained child, 0) and whose end is (original end node, original
         * end offset).
         * 19.4. Let subfragment be the result of extracting subrange.
         * 19.5. Append subfragment to clone.
         */
        var clone = NodeAlgorithm_1.node_clone(lastPartiallyContainedChild);
        MutationAlgorithm_1.mutation_append(clone, fragment);
        var subrange = CreateAlgorithm_1.create_range([lastPartiallyContainedChild, 0], [originalEndNode, originalEndOffset]);
        var subfragment = range_extract(subrange);
        MutationAlgorithm_1.mutation_append(subfragment, clone);
    }
    /**
     * 20. Set range’s start and end to (new node, new offset).
     */
    range._start = [newNode, newOffset];
    range._end = [newNode, newOffset];
    /**
     * 21. Return fragment.
     */
    return fragment;
}
exports.range_extract = range_extract;
/**
 * Clones the contents of range as a document fragment.
 *
 * @param range - a range
 */
function range_cloneTheContents(range) {
    var e_4, _a, e_5, _b, e_6, _c;
    /**
     * 1. Let fragment be a new DocumentFragment node whose node document
     * is range’s start node’s node document.
     * 2. If range is collapsed, then return fragment.
     */
    var fragment = CreateAlgorithm_1.create_documentFragment(range._startNode._nodeDocument);
    if (range_collapsed(range))
        return fragment;
    /**
     * 3. Let original start node, original start offset, original end node,
     * and original end offset be range’s start node, start offset, end node,
     * and end offset, respectively.
     * 4. If original start node is original end node, and they are a Text,
     * ProcessingInstruction, or Comment node:
     * 4.1. Let clone be a clone of original start node.
     * 4.2. Set the data of clone to the result of substringing data with node
     * original start node, offset original start offset, and count original end
     * offset minus original start offset.
     * 4.3. Append clone to fragment.
     * 4.5. Return fragment.
     */
    var originalStartNode = range._startNode;
    var originalStartOffset = range._startOffset;
    var originalEndNode = range._endNode;
    var originalEndOffset = range._endOffset;
    if (originalStartNode === originalEndNode &&
        util_1.Guard.isCharacterDataNode(originalStartNode)) {
        var clone = NodeAlgorithm_1.node_clone(originalStartNode);
        clone._data = CharacterDataAlgorithm_1.characterData_substringData(originalStartNode, originalStartOffset, originalEndOffset - originalStartOffset);
        MutationAlgorithm_1.mutation_append(clone, fragment);
    }
    /**
     * 5. Let common ancestor be original start node.
     * 6. While common ancestor is not an inclusive ancestor of original end
     * node, set common ancestor to its own parent.
     */
    var commonAncestor = originalStartNode;
    while (!TreeAlgorithm_1.tree_isAncestorOf(originalEndNode, commonAncestor, true)) {
        if (commonAncestor._parent === null) {
            throw new Error("Parent node  is null.");
        }
        commonAncestor = commonAncestor._parent;
    }
    /**
     * 7. Let first partially contained child be null.
     * 8. If original start node is not an inclusive ancestor of original end
     * node, set first partially contained child to the first child of common
     * ancestor that is partially contained in range.
     */
    var firstPartiallyContainedChild = null;
    if (!TreeAlgorithm_1.tree_isAncestorOf(originalEndNode, originalStartNode, true)) {
        try {
            for (var _d = __values(commonAncestor._children), _e = _d.next(); !_e.done; _e = _d.next()) {
                var node = _e.value;
                if (range_isPartiallyContained(node, range)) {
                    firstPartiallyContainedChild = node;
                    break;
                }
            }
        }
        catch (e_4_1) { e_4 = { error: e_4_1 }; }
        finally {
            try {
                if (_e && !_e.done && (_a = _d.return)) _a.call(_d);
            }
            finally { if (e_4) throw e_4.error; }
        }
    }
    /**
     * 9. Let last partially contained child be null.
     * 10. If original end node is not an inclusive ancestor of original start
     * node, set last partially contained child to the last child of common
     * ancestor that is partially contained in range.
     */
    var lastPartiallyContainedChild = null;
    if (!TreeAlgorithm_1.tree_isAncestorOf(originalStartNode, originalEndNode, true)) {
        var children = __spread(commonAncestor._children);
        for (var i = children.length - 1; i > 0; i--) {
            var node = children[i];
            if (range_isPartiallyContained(node, range)) {
                lastPartiallyContainedChild = node;
                break;
            }
        }
    }
    /**
     * 11. Let contained children be a list of all children of common ancestor
     * that are contained in range, in tree order.
     * 12. If any member of contained children is a doctype, then throw a
     * "HierarchyRequestError" DOMException.
     */
    var containedChildren = [];
    try {
        for (var _f = __values(commonAncestor._children), _g = _f.next(); !_g.done; _g = _f.next()) {
            var child = _g.value;
            if (range_isContained(child, range)) {
                if (util_1.Guard.isDocumentTypeNode(child)) {
                    throw new DOMException_1.HierarchyRequestError();
                }
                containedChildren.push(child);
            }
        }
    }
    catch (e_5_1) { e_5 = { error: e_5_1 }; }
    finally {
        try {
            if (_g && !_g.done && (_b = _f.return)) _b.call(_f);
        }
        finally { if (e_5) throw e_5.error; }
    }
    if (util_1.Guard.isCharacterDataNode(firstPartiallyContainedChild)) {
        /**
         * 13. If first partially contained child is a Text, ProcessingInstruction,
         * or Comment node:
         * 13.1. Let clone be a clone of original start node.
         * 13.2. Set the data of clone to the result of substringing data with
         * node original start node, offset original start offset, and count
         * original start node’s length minus original start offset.
         * 13.3. Append clone to fragment.
         */
        var clone = NodeAlgorithm_1.node_clone(originalStartNode);
        clone._data = CharacterDataAlgorithm_1.characterData_substringData(originalStartNode, originalStartOffset, TreeAlgorithm_1.tree_nodeLength(originalStartNode) - originalStartOffset);
        MutationAlgorithm_1.mutation_append(clone, fragment);
    }
    else if (firstPartiallyContainedChild !== null) {
        /**
         * 14. Otherwise, if first partially contained child is not null:
         * 14.1. Let clone be a clone of first partially contained child.
         * 14.2. Append clone to fragment.
         * 14.3. Let subrange be a new live range whose start is (original start
         * node, original start offset) and whose end is (first partially
         * contained child, first partially contained child’s length).
         * 14.4. Let subfragment be the result of cloning the contents of
         * subrange.
         * 14.5. Append subfragment to clone.
         */
        var clone = NodeAlgorithm_1.node_clone(firstPartiallyContainedChild);
        MutationAlgorithm_1.mutation_append(clone, fragment);
        var subrange = CreateAlgorithm_1.create_range([originalStartNode, originalStartOffset], [firstPartiallyContainedChild, TreeAlgorithm_1.tree_nodeLength(firstPartiallyContainedChild)]);
        var subfragment = range_cloneTheContents(subrange);
        MutationAlgorithm_1.mutation_append(subfragment, clone);
    }
    try {
        /**
         * 15. For each contained child in contained children, append contained
         * child to fragment.
         * 15.1. Let clone be a clone of contained child with the clone children
         * flag set.
         * 15.2. Append clone to fragment.
         */
        for (var containedChildren_2 = __values(containedChildren), containedChildren_2_1 = containedChildren_2.next(); !containedChildren_2_1.done; containedChildren_2_1 = containedChildren_2.next()) {
            var child = containedChildren_2_1.value;
            var clone = NodeAlgorithm_1.node_clone(child);
            MutationAlgorithm_1.mutation_append(clone, fragment);
        }
    }
    catch (e_6_1) { e_6 = { error: e_6_1 }; }
    finally {
        try {
            if (containedChildren_2_1 && !containedChildren_2_1.done && (_c = containedChildren_2.return)) _c.call(containedChildren_2);
        }
        finally { if (e_6) throw e_6.error; }
    }
    if (util_1.Guard.isCharacterDataNode(lastPartiallyContainedChild)) {
        /**
         * 16. If last partially contained child is a Text, ProcessingInstruction,
         * or Comment node:
         * 16.1. Let clone be a clone of original end node.
         * 16.2. Set the data of clone to the result of substringing data with
         * node original end node, offset 0, and count original end offset.
         * 16.3. Append clone to fragment.
         */
        var clone = NodeAlgorithm_1.node_clone(originalEndNode);
        clone._data = CharacterDataAlgorithm_1.characterData_substringData(originalEndNode, 0, originalEndOffset);
        MutationAlgorithm_1.mutation_append(clone, fragment);
    }
    else if (lastPartiallyContainedChild !== null) {
        /**
         * 17. Otherwise, if last partially contained child is not null:
         * 17.1. Let clone be a clone of last partially contained child.
         * 17.2. Append clone to fragment.
         * 17.3. Let subrange be a new live range whose start is (last partially
         * contained child, 0) and whose end is (original end node, original
         * end offset).
         * 17.4. Let subfragment be the result of cloning the contents of subrange.
         * 17.5. Append subfragment to clone.
         */
        var clone = NodeAlgorithm_1.node_clone(lastPartiallyContainedChild);
        fragment.append(clone);
        var subrange = CreateAlgorithm_1.create_range([lastPartiallyContainedChild, 0], [originalEndNode, originalEndOffset]);
        var subfragment = range_extract(subrange);
        MutationAlgorithm_1.mutation_append(subfragment, clone);
    }
    /**
     * 18. Return fragment.
     */
    return fragment;
}
exports.range_cloneTheContents = range_cloneTheContents;
/**
 * Inserts a node into a range at the start boundary point.
 *
 * @param node - node to insert
 * @param range - a range
 */
function range_insert(node, range) {
    var e_7, _a;
    /**
     * 1. If range’s start node is a ProcessingInstruction or Comment node, is a
     * Text node whose parent is null, or is node, then throw a
     * "HierarchyRequestError" DOMException.
     */
    if (util_1.Guard.isProcessingInstructionNode(range._startNode) ||
        util_1.Guard.isCommentNode(range._startNode) ||
        (util_1.Guard.isTextNode(range._startNode) && range._startNode._parent === null) ||
        range._startNode === node) {
        throw new DOMException_1.HierarchyRequestError();
    }
    /**
     * 2. Let referenceNode be null.
     * 3. If range’s start node is a Text node, set referenceNode to that Text
     * node.
     * 4. Otherwise, set referenceNode to the child of start node whose index is
     * start offset, and null if there is no such child.
     */
    var referenceNode = null;
    if (util_1.Guard.isTextNode(range._startNode)) {
        referenceNode = range._startNode;
    }
    else {
        var index = 0;
        try {
            for (var _b = __values(range._startNode._children), _c = _b.next(); !_c.done; _c = _b.next()) {
                var child = _c.value;
                if (index === range._startOffset) {
                    referenceNode = child;
                    break;
                }
                index++;
            }
        }
        catch (e_7_1) { e_7 = { error: e_7_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_7) throw e_7.error; }
        }
    }
    /**
     * 5. Let parent be range’s start node if referenceNode is null, and
     * referenceNode’s parent otherwise.
     */
    var parent;
    if (referenceNode === null) {
        parent = range._startNode;
    }
    else {
        if (referenceNode._parent === null) {
            throw new Error("Parent node is null.");
        }
        parent = referenceNode._parent;
    }
    /**
     * 6. Ensure pre-insertion validity of node into parent before referenceNode.
     */
    MutationAlgorithm_1.mutation_ensurePreInsertionValidity(node, parent, referenceNode);
    /**
     * 7. If range’s start node is a Text node, set referenceNode to the result
     * of splitting it with offset range’s start offset.
     */
    if (util_1.Guard.isTextNode(range._startNode)) {
        referenceNode = TextAlgorithm_1.text_split(range._startNode, range._startOffset);
    }
    /**
     * 8. If node is referenceNode, set referenceNode to its next sibling.
     */
    if (node === referenceNode) {
        referenceNode = node._nextSibling;
    }
    /**
     * 9. If node’s parent is not null, remove node from its parent.
     */
    if (node._parent !== null) {
        MutationAlgorithm_1.mutation_remove(node, node._parent);
    }
    /**
     * 10. Let newOffset be parent’s length if referenceNode is null, and
     * referenceNode’s index otherwise.
     */
    var newOffset = (referenceNode === null ?
        TreeAlgorithm_1.tree_nodeLength(parent) : TreeAlgorithm_1.tree_index(referenceNode));
    /**
     * 11. Increase newOffset by node’s length if node is a DocumentFragment
     * node, and one otherwise.
     */
    if (util_1.Guard.isDocumentFragmentNode(node)) {
        newOffset += TreeAlgorithm_1.tree_nodeLength(node);
    }
    else {
        newOffset++;
    }
    /**
     * 12. Pre-insert node into parent before referenceNode.
     */
    MutationAlgorithm_1.mutation_preInsert(node, parent, referenceNode);
    /**
     * 13. If range is collapsed, then set range’s end to (parent, newOffset).
     */
    if (range_collapsed(range)) {
        range._end = [parent, newOffset];
    }
}
exports.range_insert = range_insert;
/**
 * Traverses through all contained nodes of a range.
 *
 * @param range - a range
 */
function range_getContainedNodes(range) {
    var _a;
    return _a = {},
        _a[Symbol.iterator] = function () {
            var container = range.commonAncestorContainer;
            var currentNode = TreeAlgorithm_1.tree_getFirstDescendantNode(container);
            return {
                next: function () {
                    while (currentNode && !range_isContained(currentNode, range)) {
                        currentNode = TreeAlgorithm_1.tree_getNextDescendantNode(container, currentNode);
                    }
                    if (currentNode === null) {
                        return { done: true, value: null };
                    }
                    else {
                        var result = { done: false, value: currentNode };
                        currentNode = TreeAlgorithm_1.tree_getNextDescendantNode(container, currentNode);
                        return result;
                    }
                }
            };
        },
        _a;
}
exports.range_getContainedNodes = range_getContainedNodes;
/**
 * Traverses through all partially contained nodes of a range.
 *
 * @param range - a range
 */
function range_getPartiallyContainedNodes(range) {
    var _a;
    return _a = {},
        _a[Symbol.iterator] = function () {
            var container = range.commonAncestorContainer;
            var currentNode = TreeAlgorithm_1.tree_getFirstDescendantNode(container);
            return {
                next: function () {
                    while (currentNode && !range_isPartiallyContained(currentNode, range)) {
                        currentNode = TreeAlgorithm_1.tree_getNextDescendantNode(container, currentNode);
                    }
                    if (currentNode === null) {
                        return { done: true, value: null };
                    }
                    else {
                        var result = { done: false, value: currentNode };
                        currentNode = TreeAlgorithm_1.tree_getNextDescendantNode(container, currentNode);
                        return result;
                    }
                }
            };
        },
        _a;
}
exports.range_getPartiallyContainedNodes = range_getPartiallyContainedNodes;
//# sourceMappingURL=RangeAlgorithm.js.map

/***/ }),

/***/ 3886:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
var DOMException_1 = __nccwpck_require__(7175);
/**
 * Matches elements with the given selectors.
 *
 * @param selectors - selectors
 * @param node - the node to match against
 */
function selectors_scopeMatchASelectorsString(selectors, node) {
    /**
     * TODO: Selectors
     * 1. Let s be the result of parse a selector selectors. [SELECTORS4]
     * 2. If s is failure, then throw a "SyntaxError" DOMException.
     * 3. Return the result of match a selector against a tree with s and node’s
     * root using scoping root node. [SELECTORS4].
     */
    throw new DOMException_1.NotSupportedError();
}
exports.selectors_scopeMatchASelectorsString = selectors_scopeMatchASelectorsString;
//# sourceMappingURL=SelectorsAlgorithm.js.map

/***/ }),

/***/ 708:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {


var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var DOMImpl_1 = __nccwpck_require__(698);
var util_1 = __nccwpck_require__(628);
var util_2 = __nccwpck_require__(7061);
var TreeAlgorithm_1 = __nccwpck_require__(3532);
var MutationObserverAlgorithm_1 = __nccwpck_require__(3243);
/**
 * Signals a slot change to the given slot.
 *
 * @param slot - a slot
 */
function shadowTree_signalASlotChange(slot) {
    /**
     * 1. Append slot to slot’s relevant agent’s signal slots.
     * 2. Queue a mutation observer microtask.
     */
    var window = DOMImpl_1.dom.window;
    window._signalSlots.add(slot);
    MutationObserverAlgorithm_1.observer_queueAMutationObserverMicrotask();
}
exports.shadowTree_signalASlotChange = shadowTree_signalASlotChange;
/**
 * Determines whether a the shadow tree of the given element node is
 * connected to a document node.
 *
 * @param element - an element node of the shadow tree
 */
function shadowTree_isConnected(element) {
    /**
     * An element is connected if its shadow-including root is a document.
     */
    return util_1.Guard.isDocumentNode(TreeAlgorithm_1.tree_rootNode(element, true));
}
exports.shadowTree_isConnected = shadowTree_isConnected;
/**
 * Determines whether a slotable is assigned.
 *
 * @param slotable - a slotable
 */
function shadowTree_isAssigned(slotable) {
    /**
     * A slotable is assigned if its assigned slot is non-null.
     */
    return (slotable._assignedSlot !== null);
}
exports.shadowTree_isAssigned = shadowTree_isAssigned;
/**
 * Finds a slot for the given slotable.
 *
 * @param slotable - a slotable
 * @param openFlag - `true` to search open shadow tree's only
 */
function shadowTree_findASlot(slotable, openFlag) {
    if (openFlag === void 0) { openFlag = false; }
    /**
     * 1. If slotable’s parent is null, then return null.
     * 2. Let shadow be slotable’s parent’s shadow root.
     * 3. If shadow is null, then return null.
     * 4. If the open flag is set and shadow’s mode is not "open", then
     * return null.
     * 5. Return the first slot in tree order in shadow’s descendants whose name
     * is slotable’s name, if any, and null otherwise.
     */
    var node = util_1.Cast.asNode(slotable);
    var parent = node._parent;
    if (parent === null)
        return null;
    var shadow = parent._shadowRoot || null;
    if (shadow === null)
        return null;
    if (openFlag && shadow._mode !== "open")
        return null;
    var child = TreeAlgorithm_1.tree_getFirstDescendantNode(shadow, false, true, function (e) { return util_1.Guard.isSlot(e); });
    while (child !== null) {
        if (child._name === slotable._name)
            return child;
        child = TreeAlgorithm_1.tree_getNextDescendantNode(shadow, child, false, true, function (e) { return util_1.Guard.isSlot(e); });
    }
    return null;
}
exports.shadowTree_findASlot = shadowTree_findASlot;
/**
 * Finds slotables for the given slot.
 *
 * @param slot - a slot
 */
function shadowTree_findSlotables(slot) {
    var e_1, _a;
    /**
     * 1. Let result be an empty list.
     * 2. If slot’s root is not a shadow root, then return result.
     */
    var result = [];
    var root = TreeAlgorithm_1.tree_rootNode(slot);
    if (!util_1.Guard.isShadowRoot(root))
        return result;
    /**
     * 3. Let host be slot’s root’s host.
     * 4. For each slotable child of host, slotable, in tree order:
     */
    var host = root._host;
    try {
        for (var _b = __values(host._children), _c = _b.next(); !_c.done; _c = _b.next()) {
            var slotable = _c.value;
            if (util_1.Guard.isSlotable(slotable)) {
                /**
                 * 4.1. Let foundSlot be the result of finding a slot given slotable.
                 * 4.2. If foundSlot is slot, then append slotable to result.
                 */
                var foundSlot = shadowTree_findASlot(slotable);
                if (foundSlot === slot) {
                    result.push(slotable);
                }
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_1) throw e_1.error; }
    }
    /**
     * 5. Return result.
     */
    return result;
}
exports.shadowTree_findSlotables = shadowTree_findSlotables;
/**
 * Finds slotables for the given slot.
 *
 * @param slot - a slot
 */
function shadowTree_findFlattenedSlotables(slot) {
    var e_2, _a, e_3, _b;
    /**
     * 1. Let result be an empty list.
     * 2. If slot’s root is not a shadow root, then return result.
     */
    var result = [];
    var root = TreeAlgorithm_1.tree_rootNode(slot);
    if (!util_1.Guard.isShadowRoot(root))
        return result;
    /**
     * 3. Let slotables be the result of finding slotables given slot.
     * 4. If slotables is the empty list, then append each slotable child of
     * slot, in tree order, to slotables.
     */
    var slotables = shadowTree_findSlotables(slot);
    if (util_2.isEmpty(slotables)) {
        try {
            for (var _c = __values(slot._children), _d = _c.next(); !_d.done; _d = _c.next()) {
                var slotable = _d.value;
                if (util_1.Guard.isSlotable(slotable)) {
                    slotables.push(slotable);
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
            }
            finally { if (e_2) throw e_2.error; }
        }
    }
    try {
        /**
         * 5. For each node in slotables:
         */
        for (var slotables_1 = __values(slotables), slotables_1_1 = slotables_1.next(); !slotables_1_1.done; slotables_1_1 = slotables_1.next()) {
            var node = slotables_1_1.value;
            /**
             * 5.1. If node is a slot whose root is a shadow root, then:
             */
            if (util_1.Guard.isSlot(node) && util_1.Guard.isShadowRoot(TreeAlgorithm_1.tree_rootNode(node))) {
                /**
                 * 5.1.1. Let temporaryResult be the result of finding flattened slotables given node.
                 * 5.1.2. Append each slotable in temporaryResult, in order, to result.
                 */
                var temporaryResult = shadowTree_findFlattenedSlotables(node);
                result.push.apply(result, __spread(temporaryResult));
            }
            else {
                /**
                 * 5.2. Otherwise, append node to result.
                 */
                result.push(node);
            }
        }
    }
    catch (e_3_1) { e_3 = { error: e_3_1 }; }
    finally {
        try {
            if (slotables_1_1 && !slotables_1_1.done && (_b = slotables_1.return)) _b.call(slotables_1);
        }
        finally { if (e_3) throw e_3.error; }
    }
    /**
     * 6. Return result.
     */
    return result;
}
exports.shadowTree_findFlattenedSlotables = shadowTree_findFlattenedSlotables;
/**
 * Assigns slotables to the given slot.
 *
 * @param slot - a slot
 */
function shadowTree_assignSlotables(slot) {
    var e_4, _a;
    /**
     * 1. Let slotables be the result of finding slotables for slot.
     * 2. If slotables and slot’s assigned nodes are not identical, then run
     * signal a slot change for slot.
     */
    var slotables = shadowTree_findSlotables(slot);
    if (slotables.length === slot._assignedNodes.length) {
        var nodesIdentical = true;
        for (var i = 0; i < slotables.length; i++) {
            if (slotables[i] !== slot._assignedNodes[i]) {
                nodesIdentical = false;
                break;
            }
        }
        if (!nodesIdentical) {
            shadowTree_signalASlotChange(slot);
        }
    }
    /**
     * 3. Set slot’s assigned nodes to slotables.
     * 4. For each slotable in slotables, set slotable’s assigned slot to slot.
     */
    slot._assignedNodes = slotables;
    try {
        for (var slotables_2 = __values(slotables), slotables_2_1 = slotables_2.next(); !slotables_2_1.done; slotables_2_1 = slotables_2.next()) {
            var slotable = slotables_2_1.value;
            slotable._assignedSlot = slot;
        }
    }
    catch (e_4_1) { e_4 = { error: e_4_1 }; }
    finally {
        try {
            if (slotables_2_1 && !slotables_2_1.done && (_a = slotables_2.return)) _a.call(slotables_2);
        }
        finally { if (e_4) throw e_4.error; }
    }
}
exports.shadowTree_assignSlotables = shadowTree_assignSlotables;
/**
 * Assigns slotables to all nodes of a tree.
 *
 * @param root - root node
 */
function shadowTree_assignSlotablesForATree(root) {
    /**
     * To assign slotables for a tree, given a node root, run assign slotables
     * for each slot slot in root’s inclusive descendants, in tree order.
     */
    var descendant = TreeAlgorithm_1.tree_getFirstDescendantNode(root, true, false, function (e) { return util_1.Guard.isSlot(e); });
    while (descendant !== null) {
        shadowTree_assignSlotables(descendant);
        descendant = TreeAlgorithm_1.tree_getNextDescendantNode(root, descendant, true, false, function (e) { return util_1.Guard.isSlot(e); });
    }
}
exports.shadowTree_assignSlotablesForATree = shadowTree_assignSlotablesForATree;
/**
 * Assigns a slot to a slotables.
 *
 * @param slotable - a slotable
 */
function shadowTree_assignASlot(slotable) {
    /**
     * 1. Let slot be the result of finding a slot with slotable.
     * 2. If slot is non-null, then run assign slotables for slot.
     */
    var slot = shadowTree_findASlot(slotable);
    if (slot !== null) {
        shadowTree_assignSlotables(slot);
    }
}
exports.shadowTree_assignASlot = shadowTree_assignASlot;
//# sourceMappingURL=ShadowTreeAlgorithm.js.map

/***/ }),

/***/ 3813:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {


var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var DOMImpl_1 = __nccwpck_require__(698);
var util_1 = __nccwpck_require__(628);
var DOMException_1 = __nccwpck_require__(7175);
var CreateAlgorithm_1 = __nccwpck_require__(8308);
var TreeAlgorithm_1 = __nccwpck_require__(3532);
var CharacterDataAlgorithm_1 = __nccwpck_require__(7785);
var MutationAlgorithm_1 = __nccwpck_require__(45);
/**
 * Returns node with its adjacent text and cdata node siblings.
 *
 * @param node - a node
 * @param self - whether to include node itself
 */
function text_contiguousTextNodes(node, self) {
    var _a;
    if (self === void 0) { self = false; }
    /**
     * The contiguous Text nodes of a node node are node, node’s previous
     * sibling Text node, if any, and its contiguous Text nodes, and node’s next
     * sibling Text node, if any, and its contiguous Text nodes, avoiding any
     * duplicates.
     */
    return _a = {},
        _a[Symbol.iterator] = function () {
            var currentNode = node;
            while (currentNode && util_1.Guard.isTextNode(currentNode._previousSibling)) {
                currentNode = currentNode._previousSibling;
            }
            return {
                next: function () {
                    if (currentNode && (!self && currentNode === node)) {
                        if (util_1.Guard.isTextNode(currentNode._nextSibling)) {
                            currentNode = currentNode._nextSibling;
                        }
                        else {
                            currentNode = null;
                        }
                    }
                    if (currentNode === null) {
                        return { done: true, value: null };
                    }
                    else {
                        var result = { done: false, value: currentNode };
                        if (util_1.Guard.isTextNode(currentNode._nextSibling)) {
                            currentNode = currentNode._nextSibling;
                        }
                        else {
                            currentNode = null;
                        }
                        return result;
                    }
                }
            };
        },
        _a;
}
exports.text_contiguousTextNodes = text_contiguousTextNodes;
/**
 * Returns node with its adjacent text node siblings.
 *
 * @param node - a node
 * @param self - whether to include node itself
 */
function text_contiguousExclusiveTextNodes(node, self) {
    var _a;
    if (self === void 0) { self = false; }
    /**
     * The contiguous exclusive Text nodes of a node node are node, node’s
     * previous sibling exclusive Text node, if any, and its contiguous
     * exclusive Text nodes, and node’s next sibling exclusive Text node,
     * if any, and its contiguous exclusive Text nodes, avoiding any duplicates.
     */
    return _a = {},
        _a[Symbol.iterator] = function () {
            var currentNode = node;
            while (currentNode && util_1.Guard.isExclusiveTextNode(currentNode._previousSibling)) {
                currentNode = currentNode._previousSibling;
            }
            return {
                next: function () {
                    if (currentNode && (!self && currentNode === node)) {
                        if (util_1.Guard.isExclusiveTextNode(currentNode._nextSibling)) {
                            currentNode = currentNode._nextSibling;
                        }
                        else {
                            currentNode = null;
                        }
                    }
                    if (currentNode === null) {
                        return { done: true, value: null };
                    }
                    else {
                        var result = { done: false, value: currentNode };
                        if (util_1.Guard.isExclusiveTextNode(currentNode._nextSibling)) {
                            currentNode = currentNode._nextSibling;
                        }
                        else {
                            currentNode = null;
                        }
                        return result;
                    }
                }
            };
        },
        _a;
}
exports.text_contiguousExclusiveTextNodes = text_contiguousExclusiveTextNodes;
/**
 * Returns the concatenation of the data of all the Text node descendants of
 * node, in tree order.
 *
 * @param node - a node
 */
function text_descendantTextContent(node) {
    /**
     * The descendant text content of a node node is the concatenation of the
     * data of all the Text node descendants of node, in tree order.
     */
    var contents = '';
    var text = TreeAlgorithm_1.tree_getFirstDescendantNode(node, false, false, function (e) { return util_1.Guard.isTextNode(e); });
    while (text !== null) {
        contents += text._data;
        text = TreeAlgorithm_1.tree_getNextDescendantNode(node, text, false, false, function (e) { return util_1.Guard.isTextNode(e); });
    }
    return contents;
}
exports.text_descendantTextContent = text_descendantTextContent;
/**
 * Splits data at the given offset and returns the remainder as a text
 * node.
 *
 * @param node - a text node
 * @param offset - the offset at which to split the nodes.
 */
function text_split(node, offset) {
    var e_1, _a;
    /**
     * 1. Let length be node’s length.
     * 2. If offset is greater than length, then throw an "IndexSizeError"
     * DOMException.
     */
    var length = node._data.length;
    if (offset > length) {
        throw new DOMException_1.IndexSizeError();
    }
    /**
     * 3. Let count be length minus offset.
     * 4. Let new data be the result of substringing data with node node,
     * offset offset, and count count.
     * 5. Let new node be a new Text node, with the same node document as node.
     * Set new node’s data to new data.
     * 6. Let parent be node’s parent.
     * 7. If parent is not null, then:
     */
    var count = length - offset;
    var newData = CharacterDataAlgorithm_1.characterData_substringData(node, offset, count);
    var newNode = CreateAlgorithm_1.create_text(node._nodeDocument, newData);
    var parent = node._parent;
    if (parent !== null) {
        /**
         * 7.1. Insert new node into parent before node’s next sibling.
         */
        MutationAlgorithm_1.mutation_insert(newNode, parent, node._nextSibling);
        try {
            /**
             * 7.2. For each live range whose start node is node and start offset is
             * greater than offset, set its start node to new node and decrease its
             * start offset by offset.
             * 7.3. For each live range whose end node is node and end offset is greater
             * than offset, set its end node to new node and decrease its end offset
             * by offset.
             * 7.4. For each live range whose start node is parent and start offset is
             * equal to the index of node plus 1, increase its start offset by 1.
             * 7.5. For each live range whose end node is parent and end offset is equal
             * to the index of node plus 1, increase its end offset by 1.
             */
            for (var _b = __values(DOMImpl_1.dom.rangeList), _c = _b.next(); !_c.done; _c = _b.next()) {
                var range = _c.value;
                if (range._start[0] === node && range._start[1] > offset) {
                    range._start[0] = newNode;
                    range._start[1] -= offset;
                }
                if (range._end[0] === node && range._end[1] > offset) {
                    range._end[0] = newNode;
                    range._end[1] -= offset;
                }
                var index = TreeAlgorithm_1.tree_index(node);
                if (range._start[0] === parent && range._start[1] === index + 1) {
                    range._start[1]++;
                }
                if (range._end[0] === parent && range._end[1] === index + 1) {
                    range._end[1]++;
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
    }
    /**
     * 8. Replace data with node node, offset offset, count count, and data
     * the empty string.
     * 9. Return new node.
     */
    CharacterDataAlgorithm_1.characterData_replaceData(node, offset, count, '');
    return newNode;
}
exports.text_split = text_split;
//# sourceMappingURL=TextAlgorithm.js.map

/***/ }),

/***/ 6746:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
var interfaces_1 = __nccwpck_require__(9454);
var DOMException_1 = __nccwpck_require__(7175);
/**
 * Applies the filter to the given node and returns the result.
 *
 * @param traverser - the `NodeIterator` or `TreeWalker` instance
 * @param node - the node to filter
 */
function traversal_filter(traverser, node) {
    /**
     * 1. If traverser’s active flag is set, then throw an "InvalidStateError"
     * DOMException.
     */
    if (traverser._activeFlag) {
        throw new DOMException_1.InvalidStateError();
    }
    /**
     * 2. Let n be node’s nodeType attribute value − 1.
     */
    var n = node._nodeType - 1;
    /**
     * 3. If the nth bit (where 0 is the least significant bit) of traverser’s
     * whatToShow is not set, then return FILTER_SKIP.
     */
    var mask = 1 << n;
    if ((traverser.whatToShow & mask) === 0) {
        return interfaces_1.FilterResult.Skip;
    }
    /**
     * 4. If traverser’s filter is null, then return FILTER_ACCEPT.
     */
    if (!traverser.filter) {
        return interfaces_1.FilterResult.Accept;
    }
    /**
     * 5. Set traverser’s active flag.
     */
    traverser._activeFlag = true;
    /**
     * 6. Let result be the return value of call a user object’s operation with
     * traverser’s filter, "acceptNode", and « node ». If this throws an
     * exception, then unset traverser’s active flag and rethrow the exception.
     */
    var result = interfaces_1.FilterResult.Reject;
    try {
        result = traverser.filter.acceptNode(node);
    }
    catch (err) {
        traverser._activeFlag = false;
        throw err;
    }
    /**
     * 7. Unset traverser’s active flag.
     * 8. Return result.
     */
    traverser._activeFlag = false;
    return result;
}
exports.traversal_filter = traversal_filter;
//# sourceMappingURL=TraversalAlgorithm.js.map

/***/ }),

/***/ 3532:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {


var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var util_1 = __nccwpck_require__(628);
var interfaces_1 = __nccwpck_require__(9454);
/**
 * Gets the next descendant of the given node of the tree rooted at `root`
 * in depth-first pre-order.
 *
 * @param root - root node of the tree
 * @param node - a node
 * @param shadow - whether to visit shadow tree nodes
 */
function _getNextDescendantNode(root, node, shadow) {
    if (shadow === void 0) { shadow = false; }
    // traverse shadow tree
    if (shadow && util_1.Guard.isElementNode(node) && util_1.Guard.isShadowRoot(node.shadowRoot)) {
        if (node.shadowRoot._firstChild)
            return node.shadowRoot._firstChild;
    }
    // traverse child nodes
    if (node._firstChild)
        return node._firstChild;
    if (node === root)
        return null;
    // traverse siblings
    if (node._nextSibling)
        return node._nextSibling;
    // traverse parent's next sibling
    var parent = node._parent;
    while (parent && parent !== root) {
        if (parent._nextSibling)
            return parent._nextSibling;
        parent = parent._parent;
    }
    return null;
}
function _emptyIterator() {
    var _a;
    return _a = {},
        _a[Symbol.iterator] = function () {
            return {
                next: function () {
                    return { done: true, value: null };
                }
            };
        },
        _a;
}
/**
 * Returns the first descendant node of the tree rooted at `node` in
 * depth-first pre-order.
 *
 * @param node - root node of the tree
 * @param self - whether to include `node` in traversal
 * @param shadow - whether to visit shadow tree nodes
 * @param filter - a function to filter nodes
 */
function tree_getFirstDescendantNode(node, self, shadow, filter) {
    if (self === void 0) { self = false; }
    if (shadow === void 0) { shadow = false; }
    var firstNode = (self ? node : _getNextDescendantNode(node, node, shadow));
    while (firstNode && filter && !filter(firstNode)) {
        firstNode = _getNextDescendantNode(node, firstNode, shadow);
    }
    return firstNode;
}
exports.tree_getFirstDescendantNode = tree_getFirstDescendantNode;
/**
 * Returns the next descendant node of the tree rooted at `node` in
 * depth-first pre-order.
 *
 * @param node - root node of the tree
 * @param currentNode - current descendant node
 * @param self - whether to include `node` in traversal
 * @param shadow - whether to visit shadow tree nodes
 * @param filter - a function to filter nodes
 */
function tree_getNextDescendantNode(node, currentNode, self, shadow, filter) {
    if (self === void 0) { self = false; }
    if (shadow === void 0) { shadow = false; }
    var nextNode = _getNextDescendantNode(node, currentNode, shadow);
    while (nextNode && filter && !filter(nextNode)) {
        nextNode = _getNextDescendantNode(node, nextNode, shadow);
    }
    return nextNode;
}
exports.tree_getNextDescendantNode = tree_getNextDescendantNode;
/**
 * Traverses through all descendant nodes of the tree rooted at
 * `node` in depth-first pre-order.
 *
 * @param node - root node of the tree
 * @param self - whether to include `node` in traversal
 * @param shadow - whether to visit shadow tree nodes
 * @param filter - a function to filter nodes
 */
function tree_getDescendantNodes(node, self, shadow, filter) {
    var _a;
    if (self === void 0) { self = false; }
    if (shadow === void 0) { shadow = false; }
    if (!self && node._children.size === 0) {
        return _emptyIterator();
    }
    return _a = {},
        _a[Symbol.iterator] = function () {
            var currentNode = (self ? node : _getNextDescendantNode(node, node, shadow));
            return {
                next: function () {
                    while (currentNode && filter && !filter(currentNode)) {
                        currentNode = _getNextDescendantNode(node, currentNode, shadow);
                    }
                    if (currentNode === null) {
                        return { done: true, value: null };
                    }
                    else {
                        var result = { done: false, value: currentNode };
                        currentNode = _getNextDescendantNode(node, currentNode, shadow);
                        return result;
                    }
                }
            };
        },
        _a;
}
exports.tree_getDescendantNodes = tree_getDescendantNodes;
/**
 * Traverses through all descendant element nodes of the tree rooted at
 * `node` in depth-first preorder.
 *
 * @param node - root node of the tree
 * @param self - whether to include `node` in traversal
 * @param shadow - whether to visit shadow tree nodes
 * @param filter - a function to filter nodes
 */
function tree_getDescendantElements(node, self, shadow, filter) {
    var _a;
    if (self === void 0) { self = false; }
    if (shadow === void 0) { shadow = false; }
    if (!self && node._children.size === 0) {
        return _emptyIterator();
    }
    return _a = {},
        _a[Symbol.iterator] = function () {
            var it = tree_getDescendantNodes(node, self, shadow, function (e) { return util_1.Guard.isElementNode(e); })[Symbol.iterator]();
            var currentNode = it.next().value;
            return {
                next: function () {
                    while (currentNode && filter && !filter(currentNode)) {
                        currentNode = it.next().value;
                    }
                    if (currentNode === null) {
                        return { done: true, value: null };
                    }
                    else {
                        var result = { done: false, value: currentNode };
                        currentNode = it.next().value;
                        return result;
                    }
                }
            };
        },
        _a;
}
exports.tree_getDescendantElements = tree_getDescendantElements;
/**
 * Traverses through all sibling nodes of `node`.
 *
 * @param node - root node of the tree
 * @param self - whether to include `node` in traversal
 * @param filter - a function to filter nodes
 */
function tree_getSiblingNodes(node, self, filter) {
    var _a;
    if (self === void 0) { self = false; }
    if (!node._parent || node._parent._children.size === 0) {
        return _emptyIterator();
    }
    return _a = {},
        _a[Symbol.iterator] = function () {
            var currentNode = node._parent ? node._parent._firstChild : null;
            return {
                next: function () {
                    while (currentNode && (filter && !filter(currentNode) || (!self && currentNode === node))) {
                        currentNode = currentNode._nextSibling;
                    }
                    if (currentNode === null) {
                        return { done: true, value: null };
                    }
                    else {
                        var result = { done: false, value: currentNode };
                        currentNode = currentNode._nextSibling;
                        return result;
                    }
                }
            };
        },
        _a;
}
exports.tree_getSiblingNodes = tree_getSiblingNodes;
/**
 * Gets the first ancestor of `node` in reverse tree order.
 *
 * @param node - root node of the tree
 * @param self - whether to include `node` in traversal
 * @param filter - a function to filter nodes
 */
function tree_getFirstAncestorNode(node, self, filter) {
    if (self === void 0) { self = false; }
    var firstNode = self ? node : node._parent;
    while (firstNode && filter && !filter(firstNode)) {
        firstNode = firstNode._parent;
    }
    return firstNode;
}
exports.tree_getFirstAncestorNode = tree_getFirstAncestorNode;
/**
 * Gets the first ancestor of `node` in reverse tree order.
 *
 * @param node - root node of the tree
 * @param self - whether to include `node` in traversal
 * @param filter - a function to filter nodes
 */
function tree_getNextAncestorNode(node, currentNode, self, filter) {
    if (self === void 0) { self = false; }
    var nextNode = currentNode._parent;
    while (nextNode && filter && !filter(nextNode)) {
        nextNode = nextNode._parent;
    }
    return nextNode;
}
exports.tree_getNextAncestorNode = tree_getNextAncestorNode;
/**
 * Traverses through all ancestor nodes `node` in reverse tree order.
 *
 * @param node - root node of the tree
 * @param self - whether to include `node` in traversal
 * @param filter - a function to filter nodes
 */
function tree_getAncestorNodes(node, self, filter) {
    var _a;
    if (self === void 0) { self = false; }
    if (!self && !node._parent) {
        return _emptyIterator();
    }
    return _a = {},
        _a[Symbol.iterator] = function () {
            var currentNode = tree_getFirstAncestorNode(node, self, filter);
            return {
                next: function () {
                    if (currentNode === null) {
                        return { done: true, value: null };
                    }
                    else {
                        var result = { done: false, value: currentNode };
                        currentNode = tree_getNextAncestorNode(node, currentNode, self, filter);
                        return result;
                    }
                }
            };
        },
        _a;
}
exports.tree_getAncestorNodes = tree_getAncestorNodes;
/**
 * Returns the common ancestor of the given nodes.
 *
 * @param nodeA - a node
 * @param nodeB - a node
 */
function tree_getCommonAncestor(nodeA, nodeB) {
    if (nodeA === nodeB) {
        return nodeA._parent;
    }
    // lists of parent nodes
    var parentsA = [];
    var parentsB = [];
    var pA = tree_getFirstAncestorNode(nodeA, true);
    while (pA !== null) {
        parentsA.push(pA);
        pA = tree_getNextAncestorNode(nodeA, pA, true);
    }
    var pB = tree_getFirstAncestorNode(nodeB, true);
    while (pB !== null) {
        parentsB.push(pB);
        pB = tree_getNextAncestorNode(nodeB, pB, true);
    }
    // walk through parents backwards until they differ
    var pos1 = parentsA.length;
    var pos2 = parentsB.length;
    var parent = null;
    for (var i = Math.min(pos1, pos2); i > 0; i--) {
        var parent1 = parentsA[--pos1];
        var parent2 = parentsB[--pos2];
        if (parent1 !== parent2) {
            break;
        }
        parent = parent1;
    }
    return parent;
}
exports.tree_getCommonAncestor = tree_getCommonAncestor;
/**
 * Returns the node following `node` in depth-first preorder.
 *
 * @param root - root of the subtree
 * @param node - a node
 */
function tree_getFollowingNode(root, node) {
    if (node._firstChild) {
        return node._firstChild;
    }
    else if (node._nextSibling) {
        return node._nextSibling;
    }
    else {
        while (true) {
            var parent = node._parent;
            if (parent === null || parent === root) {
                return null;
            }
            else if (parent._nextSibling) {
                return parent._nextSibling;
            }
            else {
                node = parent;
            }
        }
    }
}
exports.tree_getFollowingNode = tree_getFollowingNode;
/**
 * Returns the node preceding `node` in depth-first preorder.
 *
 * @param root - root of the subtree
 * @param node - a node
 */
function tree_getPrecedingNode(root, node) {
    if (node === root) {
        return null;
    }
    if (node._previousSibling) {
        node = node._previousSibling;
        if (node._lastChild) {
            return node._lastChild;
        }
        else {
            return node;
        }
    }
    else {
        return node._parent;
    }
}
exports.tree_getPrecedingNode = tree_getPrecedingNode;
/**
 * Determines if the node tree is constrained. A node tree is
 * constrained as follows, expressed as a relationship between the
 * type of node and its allowed children:
 *  - Document (In tree order)
 *    * Zero or more nodes each of which is ProcessingInstruction
 *      or Comment.
 *    * Optionally one DocumentType node.
 *    * Zero or more nodes each of which is ProcessingInstruction
 *      or Comment.
 *    * Optionally one Element node.
 *    * Zero or more nodes each of which is ProcessingInstruction
 *      or Comment.
 *  - DocumentFragment, Element
 *    * Zero or more nodes each of which is Element, Text,
 *      ProcessingInstruction, or Comment.
 *  - DocumentType, Text, ProcessingInstruction, Comment
 *    * None.
 *
 * @param node - the root of the tree
 */
function tree_isConstrained(node) {
    var e_1, _a, e_2, _b, e_3, _c;
    switch (node._nodeType) {
        case interfaces_1.NodeType.Document:
            var hasDocType = false;
            var hasElement = false;
            try {
                for (var _d = __values(node._children), _e = _d.next(); !_e.done; _e = _d.next()) {
                    var childNode = _e.value;
                    switch (childNode._nodeType) {
                        case interfaces_1.NodeType.ProcessingInstruction:
                        case interfaces_1.NodeType.Comment:
                            break;
                        case interfaces_1.NodeType.DocumentType:
                            if (hasDocType || hasElement)
                                return false;
                            hasDocType = true;
                            break;
                        case interfaces_1.NodeType.Element:
                            if (hasElement)
                                return false;
                            hasElement = true;
                            break;
                        default:
                            return false;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_e && !_e.done && (_a = _d.return)) _a.call(_d);
                }
                finally { if (e_1) throw e_1.error; }
            }
            break;
        case interfaces_1.NodeType.DocumentFragment:
        case interfaces_1.NodeType.Element:
            try {
                for (var _f = __values(node._children), _g = _f.next(); !_g.done; _g = _f.next()) {
                    var childNode = _g.value;
                    switch (childNode._nodeType) {
                        case interfaces_1.NodeType.Element:
                        case interfaces_1.NodeType.Text:
                        case interfaces_1.NodeType.ProcessingInstruction:
                        case interfaces_1.NodeType.CData:
                        case interfaces_1.NodeType.Comment:
                            break;
                        default:
                            return false;
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_g && !_g.done && (_b = _f.return)) _b.call(_f);
                }
                finally { if (e_2) throw e_2.error; }
            }
            break;
        case interfaces_1.NodeType.DocumentType:
        case interfaces_1.NodeType.Text:
        case interfaces_1.NodeType.ProcessingInstruction:
        case interfaces_1.NodeType.CData:
        case interfaces_1.NodeType.Comment:
            return (!node.hasChildNodes());
    }
    try {
        for (var _h = __values(node._children), _j = _h.next(); !_j.done; _j = _h.next()) {
            var childNode = _j.value;
            // recursively check child nodes
            if (!tree_isConstrained(childNode))
                return false;
        }
    }
    catch (e_3_1) { e_3 = { error: e_3_1 }; }
    finally {
        try {
            if (_j && !_j.done && (_c = _h.return)) _c.call(_h);
        }
        finally { if (e_3) throw e_3.error; }
    }
    return true;
}
exports.tree_isConstrained = tree_isConstrained;
/**
 * Returns the length of a node.
 *
 * @param node - a node to check
 */
function tree_nodeLength(node) {
    /**
        * To determine the length of a node node, switch on node:
        * - DocumentType
        * Zero.
        * - Text
        * - ProcessingInstruction
        * - Comment
        * Its data’s length.
        * - Any other node
        * Its number of children.
        */
    if (util_1.Guard.isDocumentTypeNode(node)) {
        return 0;
    }
    else if (util_1.Guard.isCharacterDataNode(node)) {
        return node._data.length;
    }
    else {
        return node._children.size;
    }
}
exports.tree_nodeLength = tree_nodeLength;
/**
 * Determines if a node is empty.
 *
 * @param node - a node to check
 */
function tree_isEmpty(node) {
    /**
        * A node is considered empty if its length is zero.
        */
    return (tree_nodeLength(node) === 0);
}
exports.tree_isEmpty = tree_isEmpty;
/**
 * Returns the root node of a tree. The root of an object is itself,
 * if its parent is `null`, or else it is the root of its parent.
 * The root of a tree is any object participating in that tree
 * whose parent is `null`.
 *
 * @param node - a node of the tree
 * @param shadow - `true` to return shadow-including root, otherwise
 * `false`
 */
function tree_rootNode(node, shadow) {
    if (shadow === void 0) { shadow = false; }
    /**
        * The root of an object is itself, if its parent is null, or else it is the
        * root of its parent. The root of a tree is any object participating in
        * that tree whose parent is null.
        */
    if (shadow) {
        var root = tree_rootNode(node, false);
        if (util_1.Guard.isShadowRoot(root))
            return tree_rootNode(root._host, true);
        else
            return root;
    }
    else {
        if (!node._parent)
            return node;
        else
            return tree_rootNode(node._parent);
    }
}
exports.tree_rootNode = tree_rootNode;
/**
 * Determines whether `other` is a descendant of `node`. An object
 * A is called a descendant of an object B, if either A is a child
 * of B or A is a child of an object C that is a descendant of B.
 *
 * @param node - a node
 * @param other - the node to check
 * @param self - if `true`, traversal includes `node` itself
 * @param shadow - if `true`, traversal includes the
 * node's and its descendant's shadow trees as well.
 */
function tree_isDescendantOf(node, other, self, shadow) {
    if (self === void 0) { self = false; }
    if (shadow === void 0) { shadow = false; }
    /**
        * An object A is called a descendant of an object B, if either A is a
        * child of B or A is a child of an object C that is a descendant of B.
        *
        * An inclusive descendant is an object or one of its descendants.
    */
    var child = tree_getFirstDescendantNode(node, self, shadow);
    while (child !== null) {
        if (child === other) {
            return true;
        }
        child = tree_getNextDescendantNode(node, child, self, shadow);
    }
    return false;
}
exports.tree_isDescendantOf = tree_isDescendantOf;
/**
 * Determines whether `other` is an ancestor of `node`. An object A
 * is called an ancestor of an object B if and only if B is a
 * descendant of A.
 *
 * @param node - a node
 * @param other - the node to check
 * @param self - if `true`, traversal includes `node` itself
 * @param shadow - if `true`, traversal includes the
 * node's and its descendant's shadow trees as well.
 */
function tree_isAncestorOf(node, other, self, shadow) {
    if (self === void 0) { self = false; }
    if (shadow === void 0) { shadow = false; }
    var ancestor = self ? node : shadow && util_1.Guard.isShadowRoot(node) ?
        node._host : node._parent;
    while (ancestor !== null) {
        if (ancestor === other)
            return true;
        ancestor = shadow && util_1.Guard.isShadowRoot(ancestor) ?
            ancestor._host : ancestor._parent;
    }
    return false;
}
exports.tree_isAncestorOf = tree_isAncestorOf;
/**
 * Determines whether `other` is a host-including ancestor of `node`. An
 * object A is a host-including inclusive ancestor of an object B, if either
 * A is an inclusive ancestor of B, or if B’s root has a non-null host and
 * A is a host-including inclusive ancestor of B’s root’s host.
 *
 * @param node - a node
 * @param other - the node to check
 * @param self - if `true`, traversal includes `node` itself
 */
function tree_isHostIncludingAncestorOf(node, other, self) {
    if (self === void 0) { self = false; }
    if (tree_isAncestorOf(node, other, self))
        return true;
    var root = tree_rootNode(node);
    if (util_1.Guard.isDocumentFragmentNode(root) && root._host !== null &&
        tree_isHostIncludingAncestorOf(root._host, other, self))
        return true;
    return false;
}
exports.tree_isHostIncludingAncestorOf = tree_isHostIncludingAncestorOf;
/**
 * Determines whether `other` is a sibling of `node`. An object A is
 * called a sibling of an object B, if and only if B and A share
 * the same non-null parent.
 *
 * @param node - a node
 * @param other - the node to check
 * @param self - if `true`, traversal includes `node` itself
 */
function tree_isSiblingOf(node, other, self) {
    if (self === void 0) { self = false; }
    /**
        * An object A is called a sibling of an object B, if and only if B and A
        * share the same non-null parent.
        *
        * An inclusive sibling is an object or one of its siblings.
        */
    if (node === other) {
        if (self)
            return true;
    }
    else {
        return (node._parent !== null && node._parent === other._parent);
    }
    return false;
}
exports.tree_isSiblingOf = tree_isSiblingOf;
/**
 * Determines whether `other` is preceding `node`. An object A is
 * preceding an object B if A and B are in the same tree and A comes
 * before B in tree order.
 *
 * @param node - a node
 * @param other - the node to check
 */
function tree_isPreceding(node, other) {
    /**
        * An object A is preceding an object B if A and B are in the same tree and
        * A comes before B in tree order.
        */
    var nodePos = tree_treePosition(node);
    var otherPos = tree_treePosition(other);
    if (nodePos === -1 || otherPos === -1)
        return false;
    else if (tree_rootNode(node) !== tree_rootNode(other))
        return false;
    else
        return otherPos < nodePos;
}
exports.tree_isPreceding = tree_isPreceding;
/**
 * Determines whether `other` is following `node`. An object A is
 * following an object B if A and B are in the same tree and A comes
 * after B in tree order.
 *
 * @param node - a node
 * @param other - the node to check
 */
function tree_isFollowing(node, other) {
    /**
        * An object A is following an object B if A and B are in the same tree and
        * A comes after B in tree order.
        */
    var nodePos = tree_treePosition(node);
    var otherPos = tree_treePosition(other);
    if (nodePos === -1 || otherPos === -1)
        return false;
    else if (tree_rootNode(node) !== tree_rootNode(other))
        return false;
    else
        return otherPos > nodePos;
}
exports.tree_isFollowing = tree_isFollowing;
/**
 * Determines whether `other` is the parent node of `node`.
 *
 * @param node - a node
 * @param other - the node to check
 */
function tree_isParentOf(node, other) {
    /**
        * An object that participates in a tree has a parent, which is either
        * null or an object, and has children, which is an ordered set of objects.
        * An object A whose parent is object B is a child of B.
        */
    return (node._parent === other);
}
exports.tree_isParentOf = tree_isParentOf;
/**
 * Determines whether `other` is a child node of `node`.
 *
 * @param node - a node
 * @param other - the node to check
 */
function tree_isChildOf(node, other) {
    /**
        * An object that participates in a tree has a parent, which is either
        * null or an object, and has children, which is an ordered set of objects.
        * An object A whose parent is object B is a child of B.
        */
    return (other._parent === node);
}
exports.tree_isChildOf = tree_isChildOf;
/**
 * Returns the previous sibling node of `node` or null if it has no
 * preceding sibling.
 *
 * @param node
 */
function tree_previousSibling(node) {
    /**
        * The previous sibling of an object is its first preceding sibling or null
        * if it has no preceding sibling.
        */
    return node._previousSibling;
}
exports.tree_previousSibling = tree_previousSibling;
/**
 * Returns the next sibling node of `node` or null if it has no
 * following sibling.
 *
 * @param node
 */
function tree_nextSibling(node) {
    /**
        * The next sibling of an object is its first following sibling or null
        * if it has no following sibling.
        */
    return node._nextSibling;
}
exports.tree_nextSibling = tree_nextSibling;
/**
 * Returns the first child node of `node` or null if it has no
 * children.
 *
 * @param node
 */
function tree_firstChild(node) {
    /**
        * The first child of an object is its first child or null if it has no
        * children.
        */
    return node._firstChild;
}
exports.tree_firstChild = tree_firstChild;
/**
 * Returns the last child node of `node` or null if it has no
 * children.
 *
 * @param node
 */
function tree_lastChild(node) {
    /**
        * The last child of an object is its last child or null if it has no
        * children.
        */
    return node._lastChild;
}
exports.tree_lastChild = tree_lastChild;
/**
 * Returns the zero-based index of `node` when counted preorder in
 * the tree rooted at `root`. Returns `-1` if `node` is not in
 * the tree.
 *
 * @param node - the node to get the index of
 */
function tree_treePosition(node) {
    var root = tree_rootNode(node);
    var pos = 0;
    var childNode = tree_getFirstDescendantNode(root);
    while (childNode !== null) {
        pos++;
        if (childNode === node)
            return pos;
        childNode = tree_getNextDescendantNode(root, childNode);
    }
    return -1;
}
exports.tree_treePosition = tree_treePosition;
/**
 * Determines the index of `node`. The index of an object is its number of
 * preceding siblings, or 0 if it has none.
 *
 * @param node - a node
 * @param other - the node to check
 */
function tree_index(node) {
    /**
        * The index of an object is its number of preceding siblings, or 0 if it
        * has none.
        */
    var n = 0;
    while (node._previousSibling !== null) {
        n++;
        node = node._previousSibling;
    }
    return n;
}
exports.tree_index = tree_index;
/**
 * Retargets an object against another object.
 *
 * @param a - an object to retarget
 * @param b - an object to retarget against
 */
function tree_retarget(a, b) {
    /**
        * To retarget an object A against an object B, repeat these steps until
        * they return an object:
        * 1. If one of the following is true
        * - A is not a node
        * - A's root is not a shadow root
        * - B is a node and A's root is a shadow-including inclusive ancestor
        * of B
        * then return A.
        * 2. Set A to A's root's host.
        */
    while (true) {
        if (!a || !util_1.Guard.isNode(a)) {
            return a;
        }
        var rootOfA = tree_rootNode(a);
        if (!util_1.Guard.isShadowRoot(rootOfA)) {
            return a;
        }
        if (b && util_1.Guard.isNode(b) && tree_isAncestorOf(rootOfA, b, true, true)) {
            return a;
        }
        a = rootOfA.host;
    }
}
exports.tree_retarget = tree_retarget;
//# sourceMappingURL=TreeAlgorithm.js.map

/***/ }),

/***/ 6094:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
var interfaces_1 = __nccwpck_require__(9454);
var TraversalAlgorithm_1 = __nccwpck_require__(6746);
/**
 * Returns the first or last child node, or `null` if there are none.
 *
 * @param walker - the `TreeWalker` instance
 * @param first - `true` to return the first child node, or `false` to
 * return the last child node.
 */
function treeWalker_traverseChildren(walker, first) {
    /**
     * 1. Let node be walker’s current.
     * 2. Set node to node’s first child if type is first, and node’s last child
     * if type is last.
     * 3. While node is non-null:
     */
    var node = (first ? walker._current._firstChild : walker._current._lastChild);
    while (node !== null) {
        /**
         * 3.1. Let result be the result of filtering node within walker.
         */
        var result = TraversalAlgorithm_1.traversal_filter(walker, node);
        if (result === interfaces_1.FilterResult.Accept) {
            /**
             * 3.2. If result is FILTER_ACCEPT, then set walker’s current to node and
             * return node.
             */
            walker._current = node;
            return node;
        }
        else if (result === interfaces_1.FilterResult.Skip) {
            /**
             * 3.3. If result is FILTER_SKIP, then:
             * 3.3.1. Let child be node’s first child if type is first, and node’s
             * last child if type is last.
             * 3.3.2. If child is non-null, then set node to child and continue.
             */
            var child = (first ? node._firstChild : node._lastChild);
            if (child !== null) {
                node = child;
                continue;
            }
        }
        /**
         * 3.4. While node is non-null:
         */
        while (node !== null) {
            /**
             * 3.4.1. Let sibling be node’s next sibling if type is first, and
             * node’s previous sibling if type is last.
             * 3.4.2. If sibling is non-null, then set node to sibling and break.
             */
            var sibling = (first ? node._nextSibling : node._previousSibling);
            if (sibling !== null) {
                node = sibling;
                break;
            }
            /**
             * 3.4.3. Let parent be node’s parent.
             * 3.4.4. If parent is null, walker’s root, or walker’s current, then
             * return null.
             */
            var parent = node._parent;
            if (parent === null || parent === walker._root || parent === walker._current) {
                return null;
            }
            /**
             * 3.4.5. Set node to parent.
             */
            node = parent;
        }
    }
    /**
     * 5. Return null
     */
    return null;
}
exports.treeWalker_traverseChildren = treeWalker_traverseChildren;
/**
 * Returns the next or previous sibling node, or `null` if there are none.
 *
 * @param walker - the `TreeWalker` instance
 * @param next - `true` to return the next sibling node, or `false` to
 * return the previous sibling node.
 */
function treeWalker_traverseSiblings(walker, next) {
    /**
     * 1. Let node be walker’s current.
     * 2. If node is root, then return null.
     * 3. While node is non-null:
     */
    var node = walker._current;
    if (node === walker._root)
        return null;
    while (true) {
        /**
         * 3.1. Let sibling be node’s next sibling if type is next, and node’s
         * previous sibling if type is previous.
         * 3.2. While sibling is non-null:
         */
        var sibling = (next ? node._nextSibling : node._previousSibling);
        while (sibling !== null) {
            /**
             * 3.2.1. Set node to sibling.
             * 3.2.2. Let result be the result of filtering node within walker.
             * 3.2.3. If result is FILTER_ACCEPT, then set walker’s current to node
             * and return node.
             */
            node = sibling;
            var result = TraversalAlgorithm_1.traversal_filter(walker, node);
            if (result === interfaces_1.FilterResult.Accept) {
                walker._current = node;
                return node;
            }
            /**
             * 3.2.4. Set sibling to node’s first child if type is next, and node’s
             * last child if type is previous.
             * 3.2.5. If result is FILTER_REJECT or sibling is null, then set
             * sibling to node’s next sibling if type is next, and node’s previous
             * sibling if type is previous.
             */
            sibling = (next ? node._firstChild : node._lastChild);
            if (result === interfaces_1.FilterResult.Reject || sibling === null) {
                sibling = (next ? node._nextSibling : node._previousSibling);
            }
        }
        /**
         * 3.3. Set node to node’s parent.
         * 3.4. If node is null or walker’s root, then return null.
         */
        node = node._parent;
        if (node === null || node === walker._root) {
            return null;
        }
        /**
         * 3.5. If the return value of filtering node within walker is FILTER_ACCEPT,
         * then return null.
         */
        if (TraversalAlgorithm_1.traversal_filter(walker, node) === interfaces_1.FilterResult.Accept) {
            return null;
        }
    }
}
exports.treeWalker_traverseSiblings = treeWalker_traverseSiblings;
//# sourceMappingURL=TreeWalkerAlgorithm.js.map

/***/ }),

/***/ 4239:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * Defines a WebIDL `Const` property on the given object.
 *
 * @param o - object on which to add the property
 * @param name - property name
 * @param value - property value
 */
function idl_defineConst(o, name, value) {
    Object.defineProperty(o, name, { writable: false, enumerable: true, configurable: false, value: value });
}
exports.idl_defineConst = idl_defineConst;
//# sourceMappingURL=WebIDLAlgorithm.js.map

/***/ }),

/***/ 6879:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * Determines if the given string is valid for a `"Name"` construct.
 *
 * @param name - name string to test
 */
function xml_isName(name) {
    for (var i = 0; i < name.length; i++) {
        var n = name.charCodeAt(i);
        // NameStartChar
        if ((n >= 97 && n <= 122) || // [a-z]
            (n >= 65 && n <= 90) || // [A-Z]
            n === 58 || n === 95 || // ':' or '_'
            (n >= 0xC0 && n <= 0xD6) ||
            (n >= 0xD8 && n <= 0xF6) ||
            (n >= 0xF8 && n <= 0x2FF) ||
            (n >= 0x370 && n <= 0x37D) ||
            (n >= 0x37F && n <= 0x1FFF) ||
            (n >= 0x200C && n <= 0x200D) ||
            (n >= 0x2070 && n <= 0x218F) ||
            (n >= 0x2C00 && n <= 0x2FEF) ||
            (n >= 0x3001 && n <= 0xD7FF) ||
            (n >= 0xF900 && n <= 0xFDCF) ||
            (n >= 0xFDF0 && n <= 0xFFFD)) {
            continue;
        }
        else if (i !== 0 &&
            (n === 45 || n === 46 || // '-' or '.'
                (n >= 48 && n <= 57) || // [0-9]
                (n === 0xB7) ||
                (n >= 0x0300 && n <= 0x036F) ||
                (n >= 0x203F && n <= 0x2040))) {
            continue;
        }
        if (n >= 0xD800 && n <= 0xDBFF && i < name.length - 1) {
            var n2 = name.charCodeAt(i + 1);
            if (n2 >= 0xDC00 && n2 <= 0xDFFF) {
                n = (n - 0xD800) * 0x400 + n2 - 0xDC00 + 0x10000;
                i++;
                if (n >= 0x10000 && n <= 0xEFFFF) {
                    continue;
                }
            }
        }
        return false;
    }
    return true;
}
exports.xml_isName = xml_isName;
/**
 * Determines if the given string is valid for a `"QName"` construct.
 *
 * @param name - name string to test
 */
function xml_isQName(name) {
    var colonFound = false;
    for (var i = 0; i < name.length; i++) {
        var n = name.charCodeAt(i);
        // NameStartChar
        if ((n >= 97 && n <= 122) || // [a-z]
            (n >= 65 && n <= 90) || // [A-Z]
            n === 95 || // '_'
            (n >= 0xC0 && n <= 0xD6) ||
            (n >= 0xD8 && n <= 0xF6) ||
            (n >= 0xF8 && n <= 0x2FF) ||
            (n >= 0x370 && n <= 0x37D) ||
            (n >= 0x37F && n <= 0x1FFF) ||
            (n >= 0x200C && n <= 0x200D) ||
            (n >= 0x2070 && n <= 0x218F) ||
            (n >= 0x2C00 && n <= 0x2FEF) ||
            (n >= 0x3001 && n <= 0xD7FF) ||
            (n >= 0xF900 && n <= 0xFDCF) ||
            (n >= 0xFDF0 && n <= 0xFFFD)) {
            continue;
        }
        else if (i !== 0 &&
            (n === 45 || n === 46 || // '-' or '.'
                (n >= 48 && n <= 57) || // [0-9]
                (n === 0xB7) ||
                (n >= 0x0300 && n <= 0x036F) ||
                (n >= 0x203F && n <= 0x2040))) {
            continue;
        }
        else if (i !== 0 && n === 58) { // :
            if (colonFound)
                return false; // multiple colons in qname
            if (i === name.length - 1)
                return false; // colon at the end of qname
            colonFound = true;
            continue;
        }
        if (n >= 0xD800 && n <= 0xDBFF && i < name.length - 1) {
            var n2 = name.charCodeAt(i + 1);
            if (n2 >= 0xDC00 && n2 <= 0xDFFF) {
                n = (n - 0xD800) * 0x400 + n2 - 0xDC00 + 0x10000;
                i++;
                if (n >= 0x10000 && n <= 0xEFFFF) {
                    continue;
                }
            }
        }
        return false;
    }
    return true;
}
exports.xml_isQName = xml_isQName;
/**
 * Determines if the given string contains legal characters.
 *
 * @param chars - sequence of characters to test
 */
function xml_isLegalChar(chars) {
    for (var i = 0; i < chars.length; i++) {
        var n = chars.charCodeAt(i);
        // #x9 | #xA | #xD | [#x20-#xD7FF] | [#xE000-#xFFFD] | [#x10000-#x10FFFF]
        if (n === 0x9 || n === 0xA || n === 0xD ||
            (n >= 0x20 && n <= 0xD7FF) ||
            (n >= 0xE000 && n <= 0xFFFD)) {
            continue;
        }
        if (n >= 0xD800 && n <= 0xDBFF && i < chars.length - 1) {
            var n2 = chars.charCodeAt(i + 1);
            if (n2 >= 0xDC00 && n2 <= 0xDFFF) {
                n = (n - 0xD800) * 0x400 + n2 - 0xDC00 + 0x10000;
                i++;
                if (n >= 0x10000 && n <= 0x10FFFF) {
                    continue;
                }
            }
        }
        return false;
    }
    return true;
}
exports.xml_isLegalChar = xml_isLegalChar;
/**
 * Determines if the given string contains legal characters for a public
 * identifier.
 *
 * @param chars - sequence of characters to test
 */
function xml_isPubidChar(chars) {
    for (var i = 0; i < chars.length; i++) {
        // PubId chars are all in the ASCII range, no need to check surrogates
        var n = chars.charCodeAt(i);
        // #x20 | #xD | #xA | [a-zA-Z0-9] | [-'()+,./:=?;!*#@$_%]
        if ((n >= 97 && n <= 122) || // [a-z]
            (n >= 65 && n <= 90) || // [A-Z]
            (n >= 39 && n <= 59) || // ['()*+,-./] | [0-9] | [:;]
            n === 0x20 || n === 0xD || n === 0xA || // #x20 | #xD | #xA
            (n >= 35 && n <= 37) || // [#$%]
            n === 33 || // !
            n === 61 || n === 63 || n === 64 || n === 95) { // [=?@_]
            continue;
        }
        else {
            return false;
        }
    }
    return true;
}
exports.xml_isPubidChar = xml_isPubidChar;
//# sourceMappingURL=XMLAlgorithm.js.map

/***/ }),

/***/ 6573:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", ({ value: true }));
__export(__nccwpck_require__(5878));
__export(__nccwpck_require__(8365));
__export(__nccwpck_require__(8652));
__export(__nccwpck_require__(7785));
__export(__nccwpck_require__(8308));
__export(__nccwpck_require__(5075));
__export(__nccwpck_require__(1327));
__export(__nccwpck_require__(9484));
__export(__nccwpck_require__(6827));
__export(__nccwpck_require__(2720));
__export(__nccwpck_require__(8012));
__export(__nccwpck_require__(9807));
__export(__nccwpck_require__(45));
__export(__nccwpck_require__(3243));
__export(__nccwpck_require__(9733));
__export(__nccwpck_require__(1228));
__export(__nccwpck_require__(9670));
__export(__nccwpck_require__(8421));
__export(__nccwpck_require__(9892));
__export(__nccwpck_require__(6687));
__export(__nccwpck_require__(3886));
__export(__nccwpck_require__(708));
__export(__nccwpck_require__(3813));
__export(__nccwpck_require__(6746));
__export(__nccwpck_require__(3532));
__export(__nccwpck_require__(6094));
__export(__nccwpck_require__(4239));
__export(__nccwpck_require__(6879));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 7528:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
var algorithm_1 = __nccwpck_require__(6573);
/**
 * Represents a controller that allows to abort DOM requests.
 */
var AbortControllerImpl = /** @class */ (function () {
    /**
     * Initializes a new instance of `AbortController`.
     */
    function AbortControllerImpl() {
        /**
         * 1. Let signal be a new AbortSignal object.
         * 2. Let controller be a new AbortController object whose signal is signal.
         * 3. Return controller.
         */
        this._signal = algorithm_1.create_abortSignal();
    }
    Object.defineProperty(AbortControllerImpl.prototype, "signal", {
        /** @inheritdoc */
        get: function () { return this._signal; },
        enumerable: true,
        configurable: true
    });
    /** @inheritdoc */
    AbortControllerImpl.prototype.abort = function () {
        algorithm_1.abort_signalAbort(this._signal);
    };
    return AbortControllerImpl;
}());
exports.AbortControllerImpl = AbortControllerImpl;
//# sourceMappingURL=AbortControllerImpl.js.map

/***/ }),

/***/ 4560:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
var EventTargetImpl_1 = __nccwpck_require__(3611);
var algorithm_1 = __nccwpck_require__(6573);
/**
 * Represents a signal object that communicates with a DOM request and abort
 * it through an AbortController.
 */
var AbortSignalImpl = /** @class */ (function (_super) {
    __extends(AbortSignalImpl, _super);
    /**
     * Initializes a new instance of `AbortSignal`.
     */
    function AbortSignalImpl() {
        var _this = _super.call(this) || this;
        _this._abortedFlag = false;
        _this._abortAlgorithms = new Set();
        return _this;
    }
    Object.defineProperty(AbortSignalImpl.prototype, "aborted", {
        /** @inheritdoc */
        get: function () { return this._abortedFlag; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbortSignalImpl.prototype, "onabort", {
        /** @inheritdoc */
        get: function () {
            return algorithm_1.event_getterEventHandlerIDLAttribute(this, "onabort");
        },
        set: function (val) {
            algorithm_1.event_setterEventHandlerIDLAttribute(this, "onabort", val);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Creates a new `AbortSignal`.
     */
    AbortSignalImpl._create = function () {
        return new AbortSignalImpl();
    };
    return AbortSignalImpl;
}(EventTargetImpl_1.EventTargetImpl));
exports.AbortSignalImpl = AbortSignalImpl;
//# sourceMappingURL=AbortSignalImpl.js.map

/***/ }),

/***/ 3773:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * Represents an abstract range with a start and end boundary point.
 */
var AbstractRangeImpl = /** @class */ (function () {
    function AbstractRangeImpl() {
    }
    Object.defineProperty(AbstractRangeImpl.prototype, "_startNode", {
        get: function () { return this._start[0]; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractRangeImpl.prototype, "_startOffset", {
        get: function () { return this._start[1]; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractRangeImpl.prototype, "_endNode", {
        get: function () { return this._end[0]; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractRangeImpl.prototype, "_endOffset", {
        get: function () { return this._end[1]; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractRangeImpl.prototype, "_collapsed", {
        get: function () {
            return (this._start[0] === this._end[0] &&
                this._start[1] === this._end[1]);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractRangeImpl.prototype, "startContainer", {
        /** @inheritdoc */
        get: function () { return this._startNode; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractRangeImpl.prototype, "startOffset", {
        /** @inheritdoc */
        get: function () { return this._startOffset; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractRangeImpl.prototype, "endContainer", {
        /** @inheritdoc */
        get: function () { return this._endNode; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractRangeImpl.prototype, "endOffset", {
        /** @inheritdoc */
        get: function () { return this._endOffset; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractRangeImpl.prototype, "collapsed", {
        /** @inheritdoc */
        get: function () { return this._collapsed; },
        enumerable: true,
        configurable: true
    });
    return AbstractRangeImpl;
}());
exports.AbstractRangeImpl = AbstractRangeImpl;
//# sourceMappingURL=AbstractRangeImpl.js.map

/***/ }),

/***/ 2875:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
var interfaces_1 = __nccwpck_require__(9454);
var NodeImpl_1 = __nccwpck_require__(2280);
var algorithm_1 = __nccwpck_require__(6573);
var WebIDLAlgorithm_1 = __nccwpck_require__(4239);
/**
 * Represents an attribute of an element node.
 */
var AttrImpl = /** @class */ (function (_super) {
    __extends(AttrImpl, _super);
    /**
     * Initializes a new instance of `Attr`.
     *
     * @param localName - local name
     */
    function AttrImpl(localName) {
        var _this = _super.call(this) || this;
        _this._namespace = null;
        _this._namespacePrefix = null;
        _this._element = null;
        _this._value = '';
        _this._localName = localName;
        return _this;
    }
    Object.defineProperty(AttrImpl.prototype, "ownerElement", {
        /** @inheritdoc */
        get: function () { return this._element; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AttrImpl.prototype, "namespaceURI", {
        /** @inheritdoc */
        get: function () { return this._namespace; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AttrImpl.prototype, "prefix", {
        /** @inheritdoc */
        get: function () { return this._namespacePrefix; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AttrImpl.prototype, "localName", {
        /** @inheritdoc */
        get: function () { return this._localName; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AttrImpl.prototype, "name", {
        /** @inheritdoc */
        get: function () { return this._qualifiedName; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AttrImpl.prototype, "value", {
        /** @inheritdoc */
        get: function () { return this._value; },
        set: function (value) {
            /**
             * The value attribute’s setter must set an existing attribute value with
             * context object and the given value.
             */
            algorithm_1.attr_setAnExistingAttributeValue(this, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AttrImpl.prototype, "_qualifiedName", {
        /**
         * Returns the qualified name.
         */
        get: function () {
            /**
             * An attribute’s qualified name is its local name if its namespace prefix
             * is null, and its namespace prefix, followed by ":", followed by its
             * local name, otherwise.
             */
            return (this._namespacePrefix !== null ?
                this._namespacePrefix + ':' + this._localName :
                this._localName);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Creates an `Attr`.
     *
     * @param document - owner document
     * @param localName - local name
     */
    AttrImpl._create = function (document, localName) {
        var node = new AttrImpl(localName);
        node._nodeDocument = document;
        return node;
    };
    return AttrImpl;
}(NodeImpl_1.NodeImpl));
exports.AttrImpl = AttrImpl;
/**
 * Initialize prototype properties
 */
WebIDLAlgorithm_1.idl_defineConst(AttrImpl.prototype, "_nodeType", interfaces_1.NodeType.Attribute);
WebIDLAlgorithm_1.idl_defineConst(AttrImpl.prototype, "specified", true);
//# sourceMappingURL=AttrImpl.js.map

/***/ }),

/***/ 4104:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
var TextImpl_1 = __nccwpck_require__(4063);
var interfaces_1 = __nccwpck_require__(9454);
var WebIDLAlgorithm_1 = __nccwpck_require__(4239);
/**
 * Represents a CDATA node.
 */
var CDATASectionImpl = /** @class */ (function (_super) {
    __extends(CDATASectionImpl, _super);
    /**
     * Initializes a new instance of `CDATASection`.
     *
     * @param data - node contents
     */
    function CDATASectionImpl(data) {
        return _super.call(this, data) || this;
    }
    /**
     * Creates a new `CDATASection`.
     *
     * @param document - owner document
     * @param data - node contents
     */
    CDATASectionImpl._create = function (document, data) {
        if (data === void 0) { data = ''; }
        var node = new CDATASectionImpl(data);
        node._nodeDocument = document;
        return node;
    };
    return CDATASectionImpl;
}(TextImpl_1.TextImpl));
exports.CDATASectionImpl = CDATASectionImpl;
/**
 * Initialize prototype properties
 */
WebIDLAlgorithm_1.idl_defineConst(CDATASectionImpl.prototype, "_nodeType", interfaces_1.NodeType.CData);
//# sourceMappingURL=CDATASectionImpl.js.map

/***/ }),

/***/ 765:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
var NodeImpl_1 = __nccwpck_require__(2280);
var algorithm_1 = __nccwpck_require__(6573);
/**
 * Represents a generic text node.
 */
var CharacterDataImpl = /** @class */ (function (_super) {
    __extends(CharacterDataImpl, _super);
    /**
     * Initializes a new instance of `CharacterData`.
     *
     * @param data - the text content
     */
    function CharacterDataImpl(data) {
        var _this = _super.call(this) || this;
        _this._data = data;
        return _this;
    }
    Object.defineProperty(CharacterDataImpl.prototype, "data", {
        /** @inheritdoc */
        get: function () { return this._data; },
        set: function (value) {
            algorithm_1.characterData_replaceData(this, 0, this._data.length, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CharacterDataImpl.prototype, "length", {
        /** @inheritdoc */
        get: function () { return this._data.length; },
        enumerable: true,
        configurable: true
    });
    /** @inheritdoc */
    CharacterDataImpl.prototype.substringData = function (offset, count) {
        /**
         * The substringData(offset, count) method, when invoked, must return the
         * result of running substring data with node context object, offset offset, and count count.
         */
        return algorithm_1.characterData_substringData(this, offset, count);
    };
    /** @inheritdoc */
    CharacterDataImpl.prototype.appendData = function (data) {
        /**
         * The appendData(data) method, when invoked, must replace data with node
         * context object, offset context object’s length, count 0, and data data.
         */
        return algorithm_1.characterData_replaceData(this, this._data.length, 0, data);
    };
    /** @inheritdoc */
    CharacterDataImpl.prototype.insertData = function (offset, data) {
        /**
         * The insertData(offset, data) method, when invoked, must replace data with
         * node context object, offset offset, count 0, and data data.
         */
        algorithm_1.characterData_replaceData(this, offset, 0, data);
    };
    /** @inheritdoc */
    CharacterDataImpl.prototype.deleteData = function (offset, count) {
        /**
         * The deleteData(offset, count) method, when invoked, must replace data
         * with node context object, offset offset, count count, and data the
         * empty string.
         */
        algorithm_1.characterData_replaceData(this, offset, count, '');
    };
    /** @inheritdoc */
    CharacterDataImpl.prototype.replaceData = function (offset, count, data) {
        /**
         * The replaceData(offset, count, data) method, when invoked, must replace
         * data with node context object, offset offset, count count, and data data.
         */
        algorithm_1.characterData_replaceData(this, offset, count, data);
    };
    Object.defineProperty(CharacterDataImpl.prototype, "previousElementSibling", {
        // MIXIN: NonDocumentTypeChildNode
        /* istanbul ignore next */
        get: function () { throw new Error("Mixin: NonDocumentTypeChildNode not implemented."); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CharacterDataImpl.prototype, "nextElementSibling", {
        /* istanbul ignore next */
        get: function () { throw new Error("Mixin: NonDocumentTypeChildNode not implemented."); },
        enumerable: true,
        configurable: true
    });
    // MIXIN: ChildNode
    /* istanbul ignore next */
    CharacterDataImpl.prototype.before = function () {
        var nodes = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            nodes[_i] = arguments[_i];
        }
        throw new Error("Mixin: ChildNode not implemented.");
    };
    /* istanbul ignore next */
    CharacterDataImpl.prototype.after = function () {
        var nodes = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            nodes[_i] = arguments[_i];
        }
        throw new Error("Mixin: ChildNode not implemented.");
    };
    /* istanbul ignore next */
    CharacterDataImpl.prototype.replaceWith = function () {
        var nodes = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            nodes[_i] = arguments[_i];
        }
        throw new Error("Mixin: ChildNode not implemented.");
    };
    /* istanbul ignore next */
    CharacterDataImpl.prototype.remove = function () { throw new Error("Mixin: ChildNode not implemented."); };
    return CharacterDataImpl;
}(NodeImpl_1.NodeImpl));
exports.CharacterDataImpl = CharacterDataImpl;
//# sourceMappingURL=CharacterDataImpl.js.map

/***/ }),

/***/ 3728:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
var util_1 = __nccwpck_require__(628);
var algorithm_1 = __nccwpck_require__(6573);
/**
 * Represents a mixin that extends child nodes that can have siblings
 * including doctypes. This mixin is implemented by {@link Element},
 * {@link CharacterData} and {@link DocumentType}.
 */
var ChildNodeImpl = /** @class */ (function () {
    function ChildNodeImpl() {
    }
    /** @inheritdoc */
    ChildNodeImpl.prototype.before = function () {
        var nodes = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            nodes[_i] = arguments[_i];
        }
        /**
         * 1. Let parent be context object’s parent.
         * 2. If parent is null, then return.
         */
        var context = util_1.Cast.asNode(this);
        var parent = context._parent;
        if (parent === null)
            return;
        /**
         * 3. Let viablePreviousSibling be context object’s first preceding
         * sibling not in nodes, and null otherwise.
         */
        var viablePreviousSibling = context._previousSibling;
        var flag = true;
        while (flag && viablePreviousSibling) {
            flag = false;
            for (var i = 0; i < nodes.length; i++) {
                var child = nodes[i];
                if (child === viablePreviousSibling) {
                    viablePreviousSibling = viablePreviousSibling._previousSibling;
                    flag = true;
                    break;
                }
            }
        }
        /**
         * 4. Let node be the result of converting nodes into a node, given nodes
         * and context object’s node document.
         */
        var node = algorithm_1.parentNode_convertNodesIntoANode(nodes, context._nodeDocument);
        /**
         * 5. If viablePreviousSibling is null, set it to parent’s first child,
         * and to viablePreviousSibling’s next sibling otherwise.
         */
        if (viablePreviousSibling === null)
            viablePreviousSibling = parent._firstChild;
        else
            viablePreviousSibling = viablePreviousSibling._nextSibling;
        /**
         * 6. Pre-insert node into parent before viablePreviousSibling.
         */
        algorithm_1.mutation_preInsert(node, parent, viablePreviousSibling);
    };
    /** @inheritdoc */
    ChildNodeImpl.prototype.after = function () {
        var nodes = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            nodes[_i] = arguments[_i];
        }
        /**
         * 1. Let parent be context object’s parent.
         * 2. If parent is null, then return.
         */
        var context = util_1.Cast.asNode(this);
        var parent = context._parent;
        if (!parent)
            return;
        /**
         * 3. Let viableNextSibling be context object’s first following sibling not
         * in nodes, and null otherwise.
         */
        var viableNextSibling = context._nextSibling;
        var flag = true;
        while (flag && viableNextSibling) {
            flag = false;
            for (var i = 0; i < nodes.length; i++) {
                var child = nodes[i];
                if (child === viableNextSibling) {
                    viableNextSibling = viableNextSibling._nextSibling;
                    flag = true;
                    break;
                }
            }
        }
        /**
         * 4. Let node be the result of converting nodes into a node, given nodes
         * and context object’s node document.
         */
        var node = algorithm_1.parentNode_convertNodesIntoANode(nodes, context._nodeDocument);
        /**
         * 5. Pre-insert node into parent before viableNextSibling.
         */
        algorithm_1.mutation_preInsert(node, parent, viableNextSibling);
    };
    /** @inheritdoc */
    ChildNodeImpl.prototype.replaceWith = function () {
        var nodes = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            nodes[_i] = arguments[_i];
        }
        /**
         * 1. Let parent be context object’s parent.
         * 2. If parent is null, then return.
         */
        var context = util_1.Cast.asNode(this);
        var parent = context._parent;
        if (!parent)
            return;
        /**
         * 3. Let viableNextSibling be context object’s first following sibling not
         * in nodes, and null otherwise.
         */
        var viableNextSibling = context._nextSibling;
        var flag = true;
        while (flag && viableNextSibling) {
            flag = false;
            for (var i = 0; i < nodes.length; i++) {
                var child = nodes[i];
                if (child === viableNextSibling) {
                    viableNextSibling = viableNextSibling._nextSibling;
                    flag = true;
                    break;
                }
            }
        }
        /**
         * 4. Let node be the result of converting nodes into a node, given nodes
         * and context object’s node document.
         */
        var node = algorithm_1.parentNode_convertNodesIntoANode(nodes, context._nodeDocument);
        /**
         * 5. If context object’s parent is parent, replace the context object with
         * node within parent.
         * _Note:_ Context object could have been inserted into node.
         * 6. Otherwise, pre-insert node into parent before viableNextSibling.
         */
        if (context._parent === parent)
            algorithm_1.mutation_replace(context, node, parent);
        else
            algorithm_1.mutation_preInsert(node, parent, viableNextSibling);
    };
    /** @inheritdoc */
    ChildNodeImpl.prototype.remove = function () {
        /**
         * 1. If context object’s parent is null, then return.
         * 2. Remove the context object from context object’s parent.
         */
        var context = util_1.Cast.asNode(this);
        var parent = context._parent;
        if (!parent)
            return;
        algorithm_1.mutation_remove(context, parent);
    };
    return ChildNodeImpl;
}());
exports.ChildNodeImpl = ChildNodeImpl;
//# sourceMappingURL=ChildNodeImpl.js.map

/***/ }),

/***/ 8223:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
var interfaces_1 = __nccwpck_require__(9454);
var CharacterDataImpl_1 = __nccwpck_require__(765);
var WebIDLAlgorithm_1 = __nccwpck_require__(4239);
/**
 * Represents a comment node.
 */
var CommentImpl = /** @class */ (function (_super) {
    __extends(CommentImpl, _super);
    /**
     * Initializes a new instance of `Comment`.
     *
     * @param data - the text content
     */
    function CommentImpl(data) {
        if (data === void 0) { data = ''; }
        return _super.call(this, data) || this;
    }
    /**
     * Creates a new `Comment`.
     *
     * @param document - owner document
     * @param data - node contents
     */
    CommentImpl._create = function (document, data) {
        if (data === void 0) { data = ''; }
        var node = new CommentImpl(data);
        node._nodeDocument = document;
        return node;
    };
    return CommentImpl;
}(CharacterDataImpl_1.CharacterDataImpl));
exports.CommentImpl = CommentImpl;
/**
 * Initialize prototype properties
 */
WebIDLAlgorithm_1.idl_defineConst(CommentImpl.prototype, "_nodeType", interfaces_1.NodeType.Comment);
//# sourceMappingURL=CommentImpl.js.map

/***/ }),

/***/ 3171:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
var EventImpl_1 = __nccwpck_require__(2390);
var algorithm_1 = __nccwpck_require__(6573);
/**
 * Represents and event that carries custom data.
 */
var CustomEventImpl = /** @class */ (function (_super) {
    __extends(CustomEventImpl, _super);
    /**
     * Initializes a new instance of `CustomEvent`.
     */
    function CustomEventImpl(type, eventInit) {
        var _this = _super.call(this, type, eventInit) || this;
        _this._detail = null;
        _this._detail = (eventInit && eventInit.detail) || null;
        return _this;
    }
    Object.defineProperty(CustomEventImpl.prototype, "detail", {
        /** @inheritdoc */
        get: function () { return this._detail; },
        enumerable: true,
        configurable: true
    });
    /** @inheritdoc */
    CustomEventImpl.prototype.initCustomEvent = function (type, bubbles, cancelable, detail) {
        if (bubbles === void 0) { bubbles = false; }
        if (cancelable === void 0) { cancelable = false; }
        if (detail === void 0) { detail = null; }
        /**
         * 1. If the context object’s dispatch flag is set, then return.
         */
        if (this._dispatchFlag)
            return;
        /**
         * 2. Initialize the context object with type, bubbles, and cancelable.
         */
        algorithm_1.event_initialize(this, type, bubbles, cancelable);
        /**
         * 3. Set the context object’s detail attribute to detail.
         */
        this._detail = detail;
    };
    return CustomEventImpl;
}(EventImpl_1.EventImpl));
exports.CustomEventImpl = CustomEventImpl;
//# sourceMappingURL=CustomEventImpl.js.map

/***/ }),

/***/ 7175:
/***/ (function(__unused_webpack_module, exports) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * Represents the base class of `Error` objects used by this module.
 */
var DOMException = /** @class */ (function (_super) {
    __extends(DOMException, _super);
    /**
     *
     * @param name - message name
     * @param message - error message
     */
    function DOMException(name, message) {
        if (message === void 0) { message = ""; }
        var _this = _super.call(this, message) || this;
        _this.name = name;
        return _this;
    }
    return DOMException;
}(Error));
exports.DOMException = DOMException;
var DOMStringSizeError = /** @class */ (function (_super) {
    __extends(DOMStringSizeError, _super);
    /**
    * @param message - error message
    */
    function DOMStringSizeError(message) {
        if (message === void 0) { message = ""; }
        return _super.call(this, "DOMStringSizeError", message) || this;
    }
    return DOMStringSizeError;
}(DOMException));
exports.DOMStringSizeError = DOMStringSizeError;
var WrongDocumentError = /** @class */ (function (_super) {
    __extends(WrongDocumentError, _super);
    /**
    * @param message - error message
    */
    function WrongDocumentError(message) {
        if (message === void 0) { message = ""; }
        return _super.call(this, "WrongDocumentError", "The object is in the wrong document. " + message) || this;
    }
    return WrongDocumentError;
}(DOMException));
exports.WrongDocumentError = WrongDocumentError;
var NoDataAllowedError = /** @class */ (function (_super) {
    __extends(NoDataAllowedError, _super);
    /**
    * @param message - error message
    */
    function NoDataAllowedError(message) {
        if (message === void 0) { message = ""; }
        return _super.call(this, "NoDataAllowedError", message) || this;
    }
    return NoDataAllowedError;
}(DOMException));
exports.NoDataAllowedError = NoDataAllowedError;
var NoModificationAllowedError = /** @class */ (function (_super) {
    __extends(NoModificationAllowedError, _super);
    /**
    * @param message - error message
    */
    function NoModificationAllowedError(message) {
        if (message === void 0) { message = ""; }
        return _super.call(this, "NoModificationAllowedError", "The object can not be modified. " + message) || this;
    }
    return NoModificationAllowedError;
}(DOMException));
exports.NoModificationAllowedError = NoModificationAllowedError;
var NotSupportedError = /** @class */ (function (_super) {
    __extends(NotSupportedError, _super);
    /**
    * @param message - error message
    */
    function NotSupportedError(message) {
        if (message === void 0) { message = ""; }
        return _super.call(this, "NotSupportedError", "The operation is not supported. " + message) || this;
    }
    return NotSupportedError;
}(DOMException));
exports.NotSupportedError = NotSupportedError;
var InUseAttributeError = /** @class */ (function (_super) {
    __extends(InUseAttributeError, _super);
    /**
    * @param message - error message
    */
    function InUseAttributeError(message) {
        if (message === void 0) { message = ""; }
        return _super.call(this, "InUseAttributeError", message) || this;
    }
    return InUseAttributeError;
}(DOMException));
exports.InUseAttributeError = InUseAttributeError;
var InvalidStateError = /** @class */ (function (_super) {
    __extends(InvalidStateError, _super);
    /**
    * @param message - error message
    */
    function InvalidStateError(message) {
        if (message === void 0) { message = ""; }
        return _super.call(this, "InvalidStateError", "The object is in an invalid state. " + message) || this;
    }
    return InvalidStateError;
}(DOMException));
exports.InvalidStateError = InvalidStateError;
var InvalidModificationError = /** @class */ (function (_super) {
    __extends(InvalidModificationError, _super);
    /**
    * @param message - error message
    */
    function InvalidModificationError(message) {
        if (message === void 0) { message = ""; }
        return _super.call(this, "InvalidModificationError", "The object can not be modified in this way. " + message) || this;
    }
    return InvalidModificationError;
}(DOMException));
exports.InvalidModificationError = InvalidModificationError;
var NamespaceError = /** @class */ (function (_super) {
    __extends(NamespaceError, _super);
    /**
    * @param message - error message
    */
    function NamespaceError(message) {
        if (message === void 0) { message = ""; }
        return _super.call(this, "NamespaceError", "The operation is not allowed by Namespaces in XML. [XMLNS] " + message) || this;
    }
    return NamespaceError;
}(DOMException));
exports.NamespaceError = NamespaceError;
var InvalidAccessError = /** @class */ (function (_super) {
    __extends(InvalidAccessError, _super);
    /**
    * @param message - error message
    */
    function InvalidAccessError(message) {
        if (message === void 0) { message = ""; }
        return _super.call(this, "InvalidAccessError", "The object does not support the operation or argument. " + message) || this;
    }
    return InvalidAccessError;
}(DOMException));
exports.InvalidAccessError = InvalidAccessError;
var ValidationError = /** @class */ (function (_super) {
    __extends(ValidationError, _super);
    /**
    * @param message - error message
    */
    function ValidationError(message) {
        if (message === void 0) { message = ""; }
        return _super.call(this, "ValidationError", message) || this;
    }
    return ValidationError;
}(DOMException));
exports.ValidationError = ValidationError;
var TypeMismatchError = /** @class */ (function (_super) {
    __extends(TypeMismatchError, _super);
    /**
    * @param message - error message
    */
    function TypeMismatchError(message) {
        if (message === void 0) { message = ""; }
        return _super.call(this, "TypeMismatchError", message) || this;
    }
    return TypeMismatchError;
}(DOMException));
exports.TypeMismatchError = TypeMismatchError;
var SecurityError = /** @class */ (function (_super) {
    __extends(SecurityError, _super);
    /**
    * @param message - error message
    */
    function SecurityError(message) {
        if (message === void 0) { message = ""; }
        return _super.call(this, "SecurityError", "The operation is insecure. " + message) || this;
    }
    return SecurityError;
}(DOMException));
exports.SecurityError = SecurityError;
var NetworkError = /** @class */ (function (_super) {
    __extends(NetworkError, _super);
    /**
    * @param message - error message
    */
    function NetworkError(message) {
        if (message === void 0) { message = ""; }
        return _super.call(this, "NetworkError", "A network error occurred. " + message) || this;
    }
    return NetworkError;
}(DOMException));
exports.NetworkError = NetworkError;
var AbortError = /** @class */ (function (_super) {
    __extends(AbortError, _super);
    /**
    * @param message - error message
    */
    function AbortError(message) {
        if (message === void 0) { message = ""; }
        return _super.call(this, "AbortError", "The operation was aborted. " + message) || this;
    }
    return AbortError;
}(DOMException));
exports.AbortError = AbortError;
var URLMismatchError = /** @class */ (function (_super) {
    __extends(URLMismatchError, _super);
    /**
    * @param message - error message
    */
    function URLMismatchError(message) {
        if (message === void 0) { message = ""; }
        return _super.call(this, "URLMismatchError", "The given URL does not match another URL. " + message) || this;
    }
    return URLMismatchError;
}(DOMException));
exports.URLMismatchError = URLMismatchError;
var QuotaExceededError = /** @class */ (function (_super) {
    __extends(QuotaExceededError, _super);
    /**
    * @param message - error message
    */
    function QuotaExceededError(message) {
        if (message === void 0) { message = ""; }
        return _super.call(this, "QuotaExceededError", "The quota has been exceeded. " + message) || this;
    }
    return QuotaExceededError;
}(DOMException));
exports.QuotaExceededError = QuotaExceededError;
var TimeoutError = /** @class */ (function (_super) {
    __extends(TimeoutError, _super);
    /**
    * @param message - error message
    */
    function TimeoutError(message) {
        if (message === void 0) { message = ""; }
        return _super.call(this, "TimeoutError", "The operation timed out. " + message) || this;
    }
    return TimeoutError;
}(DOMException));
exports.TimeoutError = TimeoutError;
var InvalidNodeTypeError = /** @class */ (function (_super) {
    __extends(InvalidNodeTypeError, _super);
    /**
    * @param message - error message
    */
    function InvalidNodeTypeError(message) {
        if (message === void 0) { message = ""; }
        return _super.call(this, "InvalidNodeTypeError", "The supplied node is incorrect or has an incorrect ancestor for this operation. " + message) || this;
    }
    return InvalidNodeTypeError;
}(DOMException));
exports.InvalidNodeTypeError = InvalidNodeTypeError;
var DataCloneError = /** @class */ (function (_super) {
    __extends(DataCloneError, _super);
    /**
    * @param message - error message
    */
    function DataCloneError(message) {
        if (message === void 0) { message = ""; }
        return _super.call(this, "DataCloneError", "The object can not be cloned. " + message) || this;
    }
    return DataCloneError;
}(DOMException));
exports.DataCloneError = DataCloneError;
var NotImplementedError = /** @class */ (function (_super) {
    __extends(NotImplementedError, _super);
    /**
    * @param message - error message
    */
    function NotImplementedError(message) {
        if (message === void 0) { message = ""; }
        return _super.call(this, "NotImplementedError", "The DOM method is not implemented by this module. " + message) || this;
    }
    return NotImplementedError;
}(DOMException));
exports.NotImplementedError = NotImplementedError;
var HierarchyRequestError = /** @class */ (function (_super) {
    __extends(HierarchyRequestError, _super);
    /**
     * @param message - error message
     */
    function HierarchyRequestError(message) {
        if (message === void 0) { message = ""; }
        return _super.call(this, "HierarchyRequestError", "The operation would yield an incorrect node tree. " + message) || this;
    }
    return HierarchyRequestError;
}(DOMException));
exports.HierarchyRequestError = HierarchyRequestError;
var NotFoundError = /** @class */ (function (_super) {
    __extends(NotFoundError, _super);
    /**
     * @param message - error message
     */
    function NotFoundError(message) {
        if (message === void 0) { message = ""; }
        return _super.call(this, "NotFoundError", "The object can not be found here. " + message) || this;
    }
    return NotFoundError;
}(DOMException));
exports.NotFoundError = NotFoundError;
var IndexSizeError = /** @class */ (function (_super) {
    __extends(IndexSizeError, _super);
    /**
     * @param message - error message
     */
    function IndexSizeError(message) {
        if (message === void 0) { message = ""; }
        return _super.call(this, "IndexSizeError", "The index is not in the allowed range. " + message) || this;
    }
    return IndexSizeError;
}(DOMException));
exports.IndexSizeError = IndexSizeError;
var SyntaxError = /** @class */ (function (_super) {
    __extends(SyntaxError, _super);
    /**
     * @param message - error message
     */
    function SyntaxError(message) {
        if (message === void 0) { message = ""; }
        return _super.call(this, "SyntaxError", "The string did not match the expected pattern. " + message) || this;
    }
    return SyntaxError;
}(DOMException));
exports.SyntaxError = SyntaxError;
var InvalidCharacterError = /** @class */ (function (_super) {
    __extends(InvalidCharacterError, _super);
    /**
     * @param message - error message
     */
    function InvalidCharacterError(message) {
        if (message === void 0) { message = ""; }
        return _super.call(this, "InvalidCharacterError", "The string contains invalid characters. " + message) || this;
    }
    return InvalidCharacterError;
}(DOMException));
exports.InvalidCharacterError = InvalidCharacterError;
//# sourceMappingURL=DOMException.js.map

/***/ }),

/***/ 698:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
var util_1 = __nccwpck_require__(7061);
var CreateAlgorithm_1 = __nccwpck_require__(8308);
/**
 * Represents an object implementing DOM algorithms.
 */
var DOMImpl = /** @class */ (function () {
    /**
     * Initializes a new instance of `DOM`.
     */
    function DOMImpl() {
        this._features = {
            mutationObservers: true,
            customElements: true,
            slots: true,
            steps: true
        };
        this._window = null;
        this._compareCache = new util_1.CompareCache();
        this._rangeList = new util_1.FixedSizeSet();
    }
    /**
     * Sets DOM algorithm features.
     *
     * @param features - DOM features supported by algorithms. All features are
     * enabled by default unless explicity disabled.
     */
    DOMImpl.prototype.setFeatures = function (features) {
        if (features === undefined)
            features = true;
        if (util_1.isObject(features)) {
            for (var key in features) {
                this._features[key] = features[key] || false;
            }
        }
        else {
            // enable/disable all features
            for (var key in this._features) {
                this._features[key] = features;
            }
        }
    };
    Object.defineProperty(DOMImpl.prototype, "features", {
        /**
         * Gets DOM algorithm features.
         */
        get: function () { return this._features; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DOMImpl.prototype, "window", {
        /**
         * Gets the DOM window.
         */
        get: function () {
            if (this._window === null) {
                this._window = CreateAlgorithm_1.create_window();
            }
            return this._window;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DOMImpl.prototype, "compareCache", {
        /**
         * Gets the global node compare cache.
         */
        get: function () { return this._compareCache; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DOMImpl.prototype, "rangeList", {
        /**
         * Gets the global range list.
         */
        get: function () { return this._rangeList; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DOMImpl, "instance", {
        /**
         * Returns the instance of `DOM`.
         */
        get: function () {
            if (!DOMImpl._instance) {
                DOMImpl._instance = new DOMImpl();
            }
            return DOMImpl._instance;
        },
        enumerable: true,
        configurable: true
    });
    return DOMImpl;
}());
/**
 * Represents an object implementing DOM algorithms.
 */
exports.dom = DOMImpl.instance;
//# sourceMappingURL=DOMImpl.js.map

/***/ }),

/***/ 6348:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
var DOMImpl_1 = __nccwpck_require__(698);
var infra_1 = __nccwpck_require__(4737);
var algorithm_1 = __nccwpck_require__(6573);
var WebIDLAlgorithm_1 = __nccwpck_require__(4239);
/**
 * Represents an object providing methods which are not dependent on
 * any particular document.
 */
var DOMImplementationImpl = /** @class */ (function () {
    /**
     * Initializes a new instance of `DOMImplementation`.
     *
     * @param document - the associated document
     */
    function DOMImplementationImpl(document) {
        this._associatedDocument = document || DOMImpl_1.dom.window.document;
    }
    /** @inheritdoc */
    DOMImplementationImpl.prototype.createDocumentType = function (qualifiedName, publicId, systemId) {
        /**
         * 1. Validate qualifiedName.
         * 2. Return a new doctype, with qualifiedName as its name, publicId as its
         * public ID, and systemId as its system ID, and with its node document set
         * to the associated document of the context object.
         */
        algorithm_1.namespace_validate(qualifiedName);
        return algorithm_1.create_documentType(this._associatedDocument, qualifiedName, publicId, systemId);
    };
    /** @inheritdoc */
    DOMImplementationImpl.prototype.createDocument = function (namespace, qualifiedName, doctype) {
        if (doctype === void 0) { doctype = null; }
        /**
         * 1. Let document be a new XMLDocument.
         */
        var document = algorithm_1.create_xmlDocument();
        /**
         * 2. Let element be null.
         * 3. If qualifiedName is not the empty string, then set element to
         * the result of running the internal createElementNS steps, given document,
         * namespace, qualifiedName, and an empty dictionary.
         */
        var element = null;
        if (qualifiedName) {
            element = algorithm_1.document_internalCreateElementNS(document, namespace, qualifiedName);
        }
        /**
         * 4. If doctype is non-null, append doctype to document.
         * 5. If element is non-null, append element to document.
         */
        if (doctype)
            document.appendChild(doctype);
        if (element)
            document.appendChild(element);
        /**
         * 6. document’s origin is context object’s associated document’s origin.
         */
        document._origin = this._associatedDocument._origin;
        /**
         * 7. document’s content type is determined by namespace:
         * - HTML namespace
         * application/xhtml+xml
         * - SVG namespace
         * image/svg+xml
         * - Any other namespace
         * application/xml
         */
        if (namespace === infra_1.namespace.HTML)
            document._contentType = "application/xhtml+xml";
        else if (namespace === infra_1.namespace.SVG)
            document._contentType = "image/svg+xml";
        else
            document._contentType = "application/xml";
        /**
         * 8. Return document.
         */
        return document;
    };
    /** @inheritdoc */
    DOMImplementationImpl.prototype.createHTMLDocument = function (title) {
        /**
         * 1. Let doc be a new document that is an HTML document.
         * 2. Set doc’s content type to "text/html".
         */
        var doc = algorithm_1.create_document();
        doc._type = "html";
        doc._contentType = "text/html";
        /**
         * 3. Append a new doctype, with "html" as its name and with its node
         * document set to doc, to doc.
         */
        doc.appendChild(algorithm_1.create_documentType(doc, "html", "", ""));
        /**
         * 4. Append the result of creating an element given doc, html, and the
         * HTML namespace, to doc.
         */
        var htmlElement = algorithm_1.element_createAnElement(doc, "html", infra_1.namespace.HTML);
        doc.appendChild(htmlElement);
        /**
         * 5. Append the result of creating an element given doc, head, and the
         * HTML namespace, to the html element created earlier.
         */
        var headElement = algorithm_1.element_createAnElement(doc, "head", infra_1.namespace.HTML);
        htmlElement.appendChild(headElement);
        /**
         * 6. If title is given:
         * 6.1. Append the result of creating an element given doc, title, and
         * the HTML namespace, to the head element created earlier.
         * 6.2. Append a new Text node, with its data set to title (which could
         * be the empty string) and its node document set to doc, to the title
         * element created earlier.
         */
        if (title !== undefined) {
            var titleElement = algorithm_1.element_createAnElement(doc, "title", infra_1.namespace.HTML);
            headElement.appendChild(titleElement);
            var textElement = algorithm_1.create_text(doc, title);
            titleElement.appendChild(textElement);
        }
        /**
         * 7. Append the result of creating an element given doc, body, and the
         * HTML namespace, to the html element created earlier.
         */
        var bodyElement = algorithm_1.element_createAnElement(doc, "body", infra_1.namespace.HTML);
        htmlElement.appendChild(bodyElement);
        /**
         * 8. doc’s origin is context object’s associated document’s origin.
         */
        doc._origin = this._associatedDocument._origin;
        /**
         * 9. Return doc.
         */
        return doc;
    };
    /** @inheritdoc */
    DOMImplementationImpl.prototype.hasFeature = function () { return true; };
    /**
     * Creates a new `DOMImplementation`.
     *
     * @param document - owner document
     */
    DOMImplementationImpl._create = function (document) {
        return new DOMImplementationImpl(document);
    };
    return DOMImplementationImpl;
}());
exports.DOMImplementationImpl = DOMImplementationImpl;
WebIDLAlgorithm_1.idl_defineConst(DOMImplementationImpl.prototype, "_ID", "@oozcitak/dom");
//# sourceMappingURL=DOMImplementationImpl.js.map

/***/ }),

/***/ 6629:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {


var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var DOMImpl_1 = __nccwpck_require__(698);
var DOMException_1 = __nccwpck_require__(7175);
var infra_1 = __nccwpck_require__(4737);
var algorithm_1 = __nccwpck_require__(6573);
/**
 * Represents a token set.
 */
var DOMTokenListImpl = /** @class */ (function () {
    /**
     * Initializes a new instance of `DOMTokenList`.
     *
     * @param element - associated element
     * @param attribute - associated attribute
     */
    function DOMTokenListImpl(element, attribute) {
        /**
         * 1. Let element be associated element.
         * 2. Let localName be associated attribute’s local name.
         * 3. Let value be the result of getting an attribute value given element
         * and localName.
         * 4. Run the attribute change steps for element, localName, value, value,
         * and null.
         */
        this._element = element;
        this._attribute = attribute;
        this._tokenSet = new Set();
        var localName = attribute._localName;
        var value = algorithm_1.element_getAnAttributeValue(element, localName);
        // define a closure to be called when the associated attribute's value changes
        var thisObj = this;
        function updateTokenSet(element, localName, oldValue, value, namespace) {
            /**
             * 1. If localName is associated attribute’s local name, namespace is null,
             * and value is null, then empty token set.
             * 2. Otherwise, if localName is associated attribute’s local name,
             * namespace is null, then set token set to value, parsed.
             */
            if (localName === thisObj._attribute._localName && namespace === null) {
                if (!value)
                    thisObj._tokenSet.clear();
                else
                    thisObj._tokenSet = algorithm_1.orderedSet_parse(value);
            }
        }
        // add the closure to the associated element's attribute change steps
        this._element._attributeChangeSteps.push(updateTokenSet);
        if (DOMImpl_1.dom.features.steps) {
            algorithm_1.dom_runAttributeChangeSteps(element, localName, value, value, null);
        }
    }
    Object.defineProperty(DOMTokenListImpl.prototype, "length", {
        /** @inheritdoc */
        get: function () {
            /**
             * The length attribute' getter must return context object’s token set’s
             * size.
             */
            return this._tokenSet.size;
        },
        enumerable: true,
        configurable: true
    });
    /** @inheritdoc */
    DOMTokenListImpl.prototype.item = function (index) {
        var e_1, _a;
        /**
         * 1. If index is equal to or greater than context object’s token set’s
         * size, then return null.
         * 2. Return context object’s token set[index].
         */
        var i = 0;
        try {
            for (var _b = __values(this._tokenSet), _c = _b.next(); !_c.done; _c = _b.next()) {
                var token = _c.value;
                if (i === index)
                    return token;
                i++;
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return null;
    };
    /** @inheritdoc */
    DOMTokenListImpl.prototype.contains = function (token) {
        /**
         * The contains(token) method, when invoked, must return true if context
         * object’s token set[token] exists, and false otherwise.
         */
        return this._tokenSet.has(token);
    };
    /** @inheritdoc */
    DOMTokenListImpl.prototype.add = function () {
        var e_2, _a;
        var tokens = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            tokens[_i] = arguments[_i];
        }
        try {
            /**
             * 1. For each token in tokens:
             * 1.1. If token is the empty string, then throw a "SyntaxError"
             * DOMException.
             * 1.2. If token contains any ASCII whitespace, then throw an
             * "InvalidCharacterError" DOMException.
             * 2. For each token in tokens, append token to context object’s token set.
             * 3. Run the update steps.
             */
            for (var tokens_1 = __values(tokens), tokens_1_1 = tokens_1.next(); !tokens_1_1.done; tokens_1_1 = tokens_1.next()) {
                var token = tokens_1_1.value;
                if (token === '') {
                    throw new DOMException_1.SyntaxError("Cannot add an empty token.");
                }
                else if (infra_1.codePoint.ASCIIWhiteSpace.test(token)) {
                    throw new DOMException_1.InvalidCharacterError("Token cannot contain whitespace.");
                }
                else {
                    this._tokenSet.add(token);
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (tokens_1_1 && !tokens_1_1.done && (_a = tokens_1.return)) _a.call(tokens_1);
            }
            finally { if (e_2) throw e_2.error; }
        }
        algorithm_1.tokenList_updateSteps(this);
    };
    /** @inheritdoc */
    DOMTokenListImpl.prototype.remove = function () {
        var e_3, _a;
        var tokens = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            tokens[_i] = arguments[_i];
        }
        try {
            /**
             * 1. For each token in tokens:
             * 1.1. If token is the empty string, then throw a "SyntaxError"
             * DOMException.
             * 1.2. If token contains any ASCII whitespace, then throw an
             * "InvalidCharacterError" DOMException.
             * 2. For each token in tokens, remove token from context object’s token set.
             * 3. Run the update steps.
             */
            for (var tokens_2 = __values(tokens), tokens_2_1 = tokens_2.next(); !tokens_2_1.done; tokens_2_1 = tokens_2.next()) {
                var token = tokens_2_1.value;
                if (token === '') {
                    throw new DOMException_1.SyntaxError("Cannot remove an empty token.");
                }
                else if (infra_1.codePoint.ASCIIWhiteSpace.test(token)) {
                    throw new DOMException_1.InvalidCharacterError("Token cannot contain whitespace.");
                }
                else {
                    this._tokenSet.delete(token);
                }
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (tokens_2_1 && !tokens_2_1.done && (_a = tokens_2.return)) _a.call(tokens_2);
            }
            finally { if (e_3) throw e_3.error; }
        }
        algorithm_1.tokenList_updateSteps(this);
    };
    /** @inheritdoc */
    DOMTokenListImpl.prototype.toggle = function (token, force) {
        if (force === void 0) { force = undefined; }
        /**
         * 1. If token is the empty string, then throw a "SyntaxError" DOMException.
         * 2. If token contains any ASCII whitespace, then throw an
         * "InvalidCharacterError" DOMException.
         */
        if (token === '') {
            throw new DOMException_1.SyntaxError("Cannot toggle an empty token.");
        }
        else if (infra_1.codePoint.ASCIIWhiteSpace.test(token)) {
            throw new DOMException_1.InvalidCharacterError("Token cannot contain whitespace.");
        }
        /**
         * 3. If context object’s token set[token] exists, then:
         */
        if (this._tokenSet.has(token)) {
            /**
             * 3.1. If force is either not given or is false, then remove token from
             * context object’s token set, run the update steps and return false.
             * 3.2. Return true.
             */
            if (force === undefined || force === false) {
                this._tokenSet.delete(token);
                algorithm_1.tokenList_updateSteps(this);
                return false;
            }
            return true;
        }
        /**
         * 4. Otherwise, if force not given or is true, append token to context
         * object’s token set, run the update steps, and return true.
         */
        if (force === undefined || force === true) {
            this._tokenSet.add(token);
            algorithm_1.tokenList_updateSteps(this);
            return true;
        }
        /**
         * 5. Return false.
         */
        return false;
    };
    /** @inheritdoc */
    DOMTokenListImpl.prototype.replace = function (token, newToken) {
        /**
         * 1. If either token or newToken is the empty string, then throw a
         * "SyntaxError" DOMException.
         * 2. If either token or newToken contains any ASCII whitespace, then throw
         * an "InvalidCharacterError" DOMException.
         */
        if (token === '' || newToken === '') {
            throw new DOMException_1.SyntaxError("Cannot replace an empty token.");
        }
        else if (infra_1.codePoint.ASCIIWhiteSpace.test(token) || infra_1.codePoint.ASCIIWhiteSpace.test(newToken)) {
            throw new DOMException_1.InvalidCharacterError("Token cannot contain whitespace.");
        }
        /**
         * 3. If context object’s token set does not contain token, then return
         * false.
         */
        if (!this._tokenSet.has(token))
            return false;
        /**
         * 4. Replace token in context object’s token set with newToken.
         * 5. Run the update steps.
         * 6. Return true.
         */
        infra_1.set.replace(this._tokenSet, token, newToken);
        algorithm_1.tokenList_updateSteps(this);
        return true;
    };
    /** @inheritdoc */
    DOMTokenListImpl.prototype.supports = function (token) {
        /**
         * 1. Let result be the return value of validation steps called with token.
         * 2. Return result.
         */
        return algorithm_1.tokenList_validationSteps(this, token);
    };
    Object.defineProperty(DOMTokenListImpl.prototype, "value", {
        /** @inheritdoc */
        get: function () {
            /**
             * The value attribute must return the result of running context object’s
             * serialize steps.
             */
            return algorithm_1.tokenList_serializeSteps(this);
        },
        set: function (value) {
            /**
             * Setting the value attribute must set an attribute value for the
             * associated element using associated attribute’s local name and the given
             * value.
             */
            algorithm_1.element_setAnAttributeValue(this._element, this._attribute._localName, value);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns an iterator for the token set.
     */
    DOMTokenListImpl.prototype[Symbol.iterator] = function () {
        var it = this._tokenSet[Symbol.iterator]();
        return {
            next: function () {
                return it.next();
            }
        };
    };
    /**
     * Creates a new `DOMTokenList`.
     *
     * @param element - associated element
     * @param attribute - associated attribute
     */
    DOMTokenListImpl._create = function (element, attribute) {
        return new DOMTokenListImpl(element, attribute);
    };
    return DOMTokenListImpl;
}());
exports.DOMTokenListImpl = DOMTokenListImpl;
//# sourceMappingURL=DOMTokenListImpl.js.map

/***/ }),

/***/ 9793:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
var interfaces_1 = __nccwpck_require__(9454);
var NodeImpl_1 = __nccwpck_require__(2280);
var WebIDLAlgorithm_1 = __nccwpck_require__(4239);
/**
 * Represents a document fragment in the XML tree.
 */
var DocumentFragmentImpl = /** @class */ (function (_super) {
    __extends(DocumentFragmentImpl, _super);
    /**
     * Initializes a new instance of `DocumentFragment`.
     *
     * @param host - shadow root's host element
     */
    function DocumentFragmentImpl(host) {
        if (host === void 0) { host = null; }
        var _this = _super.call(this) || this;
        _this._children = new Set();
        _this._host = host;
        return _this;
    }
    // MIXIN: NonElementParentNode
    /* istanbul ignore next */
    DocumentFragmentImpl.prototype.getElementById = function (elementId) { throw new Error("Mixin: NonElementParentNode not implemented."); };
    Object.defineProperty(DocumentFragmentImpl.prototype, "children", {
        // MIXIN: ParentNode
        /* istanbul ignore next */
        get: function () { throw new Error("Mixin: ParentNode not implemented."); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DocumentFragmentImpl.prototype, "firstElementChild", {
        /* istanbul ignore next */
        get: function () { throw new Error("Mixin: ParentNode not implemented."); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DocumentFragmentImpl.prototype, "lastElementChild", {
        /* istanbul ignore next */
        get: function () { throw new Error("Mixin: ParentNode not implemented."); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DocumentFragmentImpl.prototype, "childElementCount", {
        /* istanbul ignore next */
        get: function () { throw new Error("Mixin: ParentNode not implemented."); },
        enumerable: true,
        configurable: true
    });
    /* istanbul ignore next */
    DocumentFragmentImpl.prototype.prepend = function () {
        var nodes = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            nodes[_i] = arguments[_i];
        }
        throw new Error("Mixin: ParentNode not implemented.");
    };
    /* istanbul ignore next */
    DocumentFragmentImpl.prototype.append = function () {
        var nodes = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            nodes[_i] = arguments[_i];
        }
        throw new Error("Mixin: ParentNode not implemented.");
    };
    /* istanbul ignore next */
    DocumentFragmentImpl.prototype.querySelector = function (selectors) { throw new Error("Mixin: ParentNode not implemented."); };
    /* istanbul ignore next */
    DocumentFragmentImpl.prototype.querySelectorAll = function (selectors) { throw new Error("Mixin: ParentNode not implemented."); };
    /**
     * Creates a new `DocumentFragment`.
     *
     * @param document - owner document
     * @param host - shadow root's host element
     */
    DocumentFragmentImpl._create = function (document, host) {
        if (host === void 0) { host = null; }
        var node = new DocumentFragmentImpl(host);
        node._nodeDocument = document;
        return node;
    };
    return DocumentFragmentImpl;
}(NodeImpl_1.NodeImpl));
exports.DocumentFragmentImpl = DocumentFragmentImpl;
/**
 * Initialize prototype properties
 */
WebIDLAlgorithm_1.idl_defineConst(DocumentFragmentImpl.prototype, "_nodeType", interfaces_1.NodeType.DocumentFragment);
//# sourceMappingURL=DocumentFragmentImpl.js.map

/***/ }),

/***/ 2113:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var DOMImpl_1 = __nccwpck_require__(698);
var interfaces_1 = __nccwpck_require__(9454);
var DOMException_1 = __nccwpck_require__(7175);
var NodeImpl_1 = __nccwpck_require__(2280);
var util_1 = __nccwpck_require__(628);
var util_2 = __nccwpck_require__(7061);
var infra_1 = __nccwpck_require__(4737);
var URLAlgorithm_1 = __nccwpck_require__(3650);
var algorithm_1 = __nccwpck_require__(6573);
var WebIDLAlgorithm_1 = __nccwpck_require__(4239);
/**
 * Represents a document node.
 */
var DocumentImpl = /** @class */ (function (_super) {
    __extends(DocumentImpl, _super);
    /**
     * Initializes a new instance of `Document`.
     */
    function DocumentImpl() {
        var _this = _super.call(this) || this;
        _this._children = new Set();
        _this._encoding = {
            name: "UTF-8",
            labels: ["unicode-1-1-utf-8", "utf-8", "utf8"]
        };
        _this._contentType = 'application/xml';
        _this._URL = {
            scheme: "about",
            username: "",
            password: "",
            host: null,
            port: null,
            path: ["blank"],
            query: null,
            fragment: null,
            _cannotBeABaseURLFlag: true,
            _blobURLEntry: null
        };
        _this._origin = null;
        _this._type = "xml";
        _this._mode = "no-quirks";
        _this._documentElement = null;
        _this._hasNamespaces = false;
        _this._nodeDocumentOverwrite = null;
        return _this;
    }
    Object.defineProperty(DocumentImpl.prototype, "_nodeDocument", {
        get: function () { return this._nodeDocumentOverwrite || this; },
        set: function (val) { this._nodeDocumentOverwrite = val; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DocumentImpl.prototype, "implementation", {
        /** @inheritdoc */
        get: function () {
            /**
             * The implementation attribute’s getter must return the DOMImplementation
             * object that is associated with the document.
             */
            return this._implementation || (this._implementation = algorithm_1.create_domImplementation(this));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DocumentImpl.prototype, "URL", {
        /** @inheritdoc */
        get: function () {
            /**
             * The URL attribute’s getter and documentURI attribute’s getter must return
             * the URL, serialized.
             * See: https://url.spec.whatwg.org/#concept-url-serializer
             */
            return URLAlgorithm_1.urlSerializer(this._URL);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DocumentImpl.prototype, "documentURI", {
        /** @inheritdoc */
        get: function () { return this.URL; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DocumentImpl.prototype, "origin", {
        /** @inheritdoc */
        get: function () {
            return "null";
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DocumentImpl.prototype, "compatMode", {
        /** @inheritdoc */
        get: function () {
            /**
             * The compatMode attribute’s getter must return "BackCompat" if context
             * object’s mode is "quirks", and "CSS1Compat" otherwise.
             */
            return this._mode === "quirks" ? "BackCompat" : "CSS1Compat";
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DocumentImpl.prototype, "characterSet", {
        /** @inheritdoc */
        get: function () {
            /**
             * The characterSet attribute’s getter, charset attribute’s getter, and
             * inputEncoding attribute’s getter, must return context object’s
             * encoding’s name.
             */
            return this._encoding.name;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DocumentImpl.prototype, "charset", {
        /** @inheritdoc */
        get: function () { return this._encoding.name; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DocumentImpl.prototype, "inputEncoding", {
        /** @inheritdoc */
        get: function () { return this._encoding.name; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DocumentImpl.prototype, "contentType", {
        /** @inheritdoc */
        get: function () {
            /**
             * The contentType attribute’s getter must return the content type.
             */
            return this._contentType;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DocumentImpl.prototype, "doctype", {
        /** @inheritdoc */
        get: function () {
            var e_1, _a;
            try {
                /**
                 * The doctype attribute’s getter must return the child of the document
                 * that is a doctype, and null otherwise.
                 */
                for (var _b = __values(this._children), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var child = _c.value;
                    if (util_1.Guard.isDocumentTypeNode(child))
                        return child;
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return null;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DocumentImpl.prototype, "documentElement", {
        /** @inheritdoc */
        get: function () {
            /**
             * The documentElement attribute’s getter must return the document element.
             */
            return this._documentElement;
        },
        enumerable: true,
        configurable: true
    });
    /** @inheritdoc */
    DocumentImpl.prototype.getElementsByTagName = function (qualifiedName) {
        /**
         * The getElementsByTagName(qualifiedName) method, when invoked, must return
         * the list of elements with qualified name qualifiedName for the context object.
         */
        return algorithm_1.node_listOfElementsWithQualifiedName(qualifiedName, this);
    };
    /** @inheritdoc */
    DocumentImpl.prototype.getElementsByTagNameNS = function (namespace, localName) {
        /**
         * The getElementsByTagNameNS(namespace, localName) method, when invoked,
         * must return the list of elements with namespace namespace and local name
         * localName for the context object.
         */
        return algorithm_1.node_listOfElementsWithNamespace(namespace, localName, this);
    };
    /** @inheritdoc */
    DocumentImpl.prototype.getElementsByClassName = function (classNames) {
        /**
         * The getElementsByClassName(classNames) method, when invoked, must return
         * the list of elements with class names classNames for the context object.
         */
        return algorithm_1.node_listOfElementsWithClassNames(classNames, this);
    };
    /** @inheritdoc */
    DocumentImpl.prototype.createElement = function (localName, options) {
        /**
         * 1. If localName does not match the Name production, then throw an
         * "InvalidCharacterError" DOMException.
         * 2. If the context object is an HTML document, then set localName to
         * localName in ASCII lowercase.
         * 3. Let is be null.
         * 4. If options is a dictionary and options’s is is present, then set is
         * to it.
         * 5. Let namespace be the HTML namespace, if the context object is an
         * HTML document or context object’s content type is
         * "application/xhtml+xml", and null otherwise.
         * 6. Return the result of creating an element given the context object,
         * localName, namespace, null, is, and with the synchronous custom elements
         * flag set.
         */
        if (!algorithm_1.xml_isName(localName))
            throw new DOMException_1.InvalidCharacterError();
        if (this._type === "html")
            localName = localName.toLowerCase();
        var is = null;
        if (options !== undefined) {
            if (util_2.isString(options)) {
                is = options;
            }
            else {
                is = options.is;
            }
        }
        var namespace = (this._type === "html" || this._contentType === "application/xhtml+xml") ?
            infra_1.namespace.HTML : null;
        return algorithm_1.element_createAnElement(this, localName, namespace, null, is, true);
    };
    /** @inheritdoc */
    DocumentImpl.prototype.createElementNS = function (namespace, qualifiedName, options) {
        /**
         * The createElementNS(namespace, qualifiedName, options) method, when
         * invoked, must return the result of running the internal createElementNS
         * steps, given context object, namespace, qualifiedName, and options.
         */
        return algorithm_1.document_internalCreateElementNS(this, namespace, qualifiedName, options);
    };
    /** @inheritdoc */
    DocumentImpl.prototype.createDocumentFragment = function () {
        /**
         * The createDocumentFragment() method, when invoked, must return a new
         * DocumentFragment node with its node document set to the context object.
         */
        return algorithm_1.create_documentFragment(this);
    };
    /** @inheritdoc */
    DocumentImpl.prototype.createTextNode = function (data) {
        /**
         * The createTextNode(data) method, when invoked, must return a new Text
         * node with its data set to data and node document set to the context object.
         */
        return algorithm_1.create_text(this, data);
    };
    /** @inheritdoc */
    DocumentImpl.prototype.createCDATASection = function (data) {
        /**
         * 1. If context object is an HTML document, then throw a
         * "NotSupportedError" DOMException.
         * 2. If data contains the string "]]>", then throw an
         * "InvalidCharacterError" DOMException.
         * 3. Return a new CDATASection node with its data set to data and node
         * document set to the context object.
         */
        if (this._type === "html")
            throw new DOMException_1.NotSupportedError();
        if (data.indexOf(']]>') !== -1)
            throw new DOMException_1.InvalidCharacterError();
        return algorithm_1.create_cdataSection(this, data);
    };
    /** @inheritdoc */
    DocumentImpl.prototype.createComment = function (data) {
        /**
         * The createComment(data) method, when invoked, must return a new Comment
         * node with its data set to data and node document set to the context object.
         */
        return algorithm_1.create_comment(this, data);
    };
    /** @inheritdoc */
    DocumentImpl.prototype.createProcessingInstruction = function (target, data) {
        /**
         * 1. If target does not match the Name production, then throw an
         * "InvalidCharacterError" DOMException.
         * 2. If data contains the string "?>", then throw an
         * "InvalidCharacterError" DOMException.
         * 3. Return a new ProcessingInstruction node, with target set to target,
         * data set to data, and node document set to the context object.
         */
        if (!algorithm_1.xml_isName(target))
            throw new DOMException_1.InvalidCharacterError();
        if (data.indexOf("?>") !== -1)
            throw new DOMException_1.InvalidCharacterError();
        return algorithm_1.create_processingInstruction(this, target, data);
    };
    /** @inheritdoc */
    DocumentImpl.prototype.importNode = function (node, deep) {
        if (deep === void 0) { deep = false; }
        /**
         * 1. If node is a document or shadow root, then throw a "NotSupportedError" DOMException.
         */
        if (util_1.Guard.isDocumentNode(node) || util_1.Guard.isShadowRoot(node))
            throw new DOMException_1.NotSupportedError();
        /**
         * 2. Return a clone of node, with context object and the clone children flag set if deep is true.
         */
        return algorithm_1.node_clone(node, this, deep);
    };
    /** @inheritdoc */
    DocumentImpl.prototype.adoptNode = function (node) {
        /**
         * 1. If node is a document, then throw a "NotSupportedError" DOMException.
         */
        if (util_1.Guard.isDocumentNode(node))
            throw new DOMException_1.NotSupportedError();
        /**
         * 2. If node is a shadow root, then throw a "HierarchyRequestError" DOMException.
         */
        if (util_1.Guard.isShadowRoot(node))
            throw new DOMException_1.HierarchyRequestError();
        /**
         * 3. Adopt node into the context object.
         * 4. Return node.
         */
        algorithm_1.document_adopt(node, this);
        return node;
    };
    /** @inheritdoc */
    DocumentImpl.prototype.createAttribute = function (localName) {
        /**
         * 1. If localName does not match the Name production in XML, then throw
         * an "InvalidCharacterError" DOMException.
         * 2. If the context object is an HTML document, then set localName to
         * localName in ASCII lowercase.
         * 3. Return a new attribute whose local name is localName and node document
         * is context object.
         */
        if (!algorithm_1.xml_isName(localName))
            throw new DOMException_1.InvalidCharacterError();
        if (this._type === "html") {
            localName = localName.toLowerCase();
        }
        var attr = algorithm_1.create_attr(this, localName);
        return attr;
    };
    /** @inheritdoc */
    DocumentImpl.prototype.createAttributeNS = function (namespace, qualifiedName) {
        /**
         * 1. Let namespace, prefix, and localName be the result of passing
         * namespace and qualifiedName to validate and extract.
         * 2. Return a new attribute whose namespace is namespace, namespace prefix
         * is prefix, local name is localName, and node document is context object.
         */
        var _a = __read(algorithm_1.namespace_validateAndExtract(namespace, qualifiedName), 3), ns = _a[0], prefix = _a[1], localName = _a[2];
        var attr = algorithm_1.create_attr(this, localName);
        attr._namespace = ns;
        attr._namespacePrefix = prefix;
        return attr;
    };
    /** @inheritdoc */
    DocumentImpl.prototype.createEvent = function (eventInterface) {
        return algorithm_1.event_createLegacyEvent(eventInterface);
    };
    /** @inheritdoc */
    DocumentImpl.prototype.createRange = function () {
        /**
         * The createRange() method, when invoked, must return a new live range
         * with (context object, 0) as its start and end.
         */
        var range = algorithm_1.create_range();
        range._start = [this, 0];
        range._end = [this, 0];
        return range;
    };
    /** @inheritdoc */
    DocumentImpl.prototype.createNodeIterator = function (root, whatToShow, filter) {
        if (whatToShow === void 0) { whatToShow = interfaces_1.WhatToShow.All; }
        if (filter === void 0) { filter = null; }
        /**
         * 1. Let iterator be a new NodeIterator object.
         * 2. Set iterator’s root and iterator’s reference to root.
         * 3. Set iterator’s pointer before reference to true.
         * 4. Set iterator’s whatToShow to whatToShow.
         * 5. Set iterator’s filter to filter.
         * 6. Return iterator.
         */
        var iterator = algorithm_1.create_nodeIterator(root, root, true);
        iterator._whatToShow = whatToShow;
        iterator._iteratorCollection = algorithm_1.create_nodeList(root);
        if (util_2.isFunction(filter)) {
            iterator._filter = algorithm_1.create_nodeFilter();
            iterator._filter.acceptNode = filter;
        }
        else {
            iterator._filter = filter;
        }
        return iterator;
    };
    /** @inheritdoc */
    DocumentImpl.prototype.createTreeWalker = function (root, whatToShow, filter) {
        if (whatToShow === void 0) { whatToShow = interfaces_1.WhatToShow.All; }
        if (filter === void 0) { filter = null; }
        /**
         * 1. Let walker be a new TreeWalker object.
         * 2. Set walker’s root and walker’s current to root.
         * 3. Set walker’s whatToShow to whatToShow.
         * 4. Set walker’s filter to filter.
         * 5. Return walker.
         */
        var walker = algorithm_1.create_treeWalker(root, root);
        walker._whatToShow = whatToShow;
        if (util_2.isFunction(filter)) {
            walker._filter = algorithm_1.create_nodeFilter();
            walker._filter.acceptNode = filter;
        }
        else {
            walker._filter = filter;
        }
        return walker;
    };
    /**
     * Gets the parent event target for the given event.
     *
     * @param event - an event
     */
    DocumentImpl.prototype._getTheParent = function (event) {
        /**
         * TODO: Implement realms
         * A document’s get the parent algorithm, given an event, returns null if
         * event’s type attribute value is "load" or document does not have a
         * browsing context, and the document’s relevant global object otherwise.
         */
        if (event._type === "load") {
            return null;
        }
        else {
            return DOMImpl_1.dom.window;
        }
    };
    // MIXIN: NonElementParentNode
    /* istanbul ignore next */
    DocumentImpl.prototype.getElementById = function (elementId) { throw new Error("Mixin: NonElementParentNode not implemented."); };
    Object.defineProperty(DocumentImpl.prototype, "children", {
        // MIXIN: DocumentOrShadowRoot
        // No elements
        // MIXIN: ParentNode
        /* istanbul ignore next */
        get: function () { throw new Error("Mixin: ParentNode not implemented."); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DocumentImpl.prototype, "firstElementChild", {
        /* istanbul ignore next */
        get: function () { throw new Error("Mixin: ParentNode not implemented."); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DocumentImpl.prototype, "lastElementChild", {
        /* istanbul ignore next */
        get: function () { throw new Error("Mixin: ParentNode not implemented."); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DocumentImpl.prototype, "childElementCount", {
        /* istanbul ignore next */
        get: function () { throw new Error("Mixin: ParentNode not implemented."); },
        enumerable: true,
        configurable: true
    });
    /* istanbul ignore next */
    DocumentImpl.prototype.prepend = function () {
        var nodes = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            nodes[_i] = arguments[_i];
        }
        throw new Error("Mixin: ParentNode not implemented.");
    };
    /* istanbul ignore next */
    DocumentImpl.prototype.append = function () {
        var nodes = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            nodes[_i] = arguments[_i];
        }
        throw new Error("Mixin: ParentNode not implemented.");
    };
    /* istanbul ignore next */
    DocumentImpl.prototype.querySelector = function (selectors) { throw new Error("Mixin: ParentNode not implemented."); };
    /* istanbul ignore next */
    DocumentImpl.prototype.querySelectorAll = function (selectors) { throw new Error("Mixin: ParentNode not implemented."); };
    return DocumentImpl;
}(NodeImpl_1.NodeImpl));
exports.DocumentImpl = DocumentImpl;
/**
 * Initialize prototype properties
 */
WebIDLAlgorithm_1.idl_defineConst(DocumentImpl.prototype, "_nodeType", interfaces_1.NodeType.Document);
//# sourceMappingURL=DocumentImpl.js.map

/***/ }),

/***/ 8024:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * Represents a mixin for an interface to be used to share APIs between
 * documents and shadow roots. This mixin is implemented by
 * {@link Document} and {@link ShadowRoot}.
 *
 * _Note:_ The DocumentOrShadowRoot mixin is expected to be used by other
 * standards that want to define APIs shared between documents and shadow roots.
 */
var DocumentOrShadowRootImpl = /** @class */ (function () {
    function DocumentOrShadowRootImpl() {
    }
    return DocumentOrShadowRootImpl;
}());
exports.DocumentOrShadowRootImpl = DocumentOrShadowRootImpl;
//# sourceMappingURL=DocumentOrShadowRootImpl.js.map

/***/ }),

/***/ 1401:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
var interfaces_1 = __nccwpck_require__(9454);
var NodeImpl_1 = __nccwpck_require__(2280);
var WebIDLAlgorithm_1 = __nccwpck_require__(4239);
/**
 * Represents an object providing methods which are not dependent on
 * any particular document
 */
var DocumentTypeImpl = /** @class */ (function (_super) {
    __extends(DocumentTypeImpl, _super);
    /**
     * Initializes a new instance of `DocumentType`.
     *
     * @param name - name of the node
     * @param publicId - `PUBLIC` identifier
     * @param systemId - `SYSTEM` identifier
     */
    function DocumentTypeImpl(name, publicId, systemId) {
        var _this = _super.call(this) || this;
        _this._name = '';
        _this._publicId = '';
        _this._systemId = '';
        _this._name = name;
        _this._publicId = publicId;
        _this._systemId = systemId;
        return _this;
    }
    Object.defineProperty(DocumentTypeImpl.prototype, "name", {
        /** @inheritdoc */
        get: function () { return this._name; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DocumentTypeImpl.prototype, "publicId", {
        /** @inheritdoc */
        get: function () { return this._publicId; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DocumentTypeImpl.prototype, "systemId", {
        /** @inheritdoc */
        get: function () { return this._systemId; },
        enumerable: true,
        configurable: true
    });
    // MIXIN: ChildNode
    /* istanbul ignore next */
    DocumentTypeImpl.prototype.before = function () {
        var nodes = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            nodes[_i] = arguments[_i];
        }
        throw new Error("Mixin: ChildNode not implemented.");
    };
    /* istanbul ignore next */
    DocumentTypeImpl.prototype.after = function () {
        var nodes = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            nodes[_i] = arguments[_i];
        }
        throw new Error("Mixin: ChildNode not implemented.");
    };
    /* istanbul ignore next */
    DocumentTypeImpl.prototype.replaceWith = function () {
        var nodes = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            nodes[_i] = arguments[_i];
        }
        throw new Error("Mixin: ChildNode not implemented.");
    };
    /* istanbul ignore next */
    DocumentTypeImpl.prototype.remove = function () { throw new Error("Mixin: ChildNode not implemented."); };
    /**
     * Creates a new `DocumentType`.
     *
     * @param document - owner document
     * @param name - name of the node
     * @param publicId - `PUBLIC` identifier
     * @param systemId - `SYSTEM` identifier
     */
    DocumentTypeImpl._create = function (document, name, publicId, systemId) {
        if (publicId === void 0) { publicId = ''; }
        if (systemId === void 0) { systemId = ''; }
        var node = new DocumentTypeImpl(name, publicId, systemId);
        node._nodeDocument = document;
        return node;
    };
    return DocumentTypeImpl;
}(NodeImpl_1.NodeImpl));
exports.DocumentTypeImpl = DocumentTypeImpl;
/**
 * Initialize prototype properties
 */
WebIDLAlgorithm_1.idl_defineConst(DocumentTypeImpl.prototype, "_nodeType", interfaces_1.NodeType.DocumentType);
//# sourceMappingURL=DocumentTypeImpl.js.map

/***/ }),

/***/ 1342:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var interfaces_1 = __nccwpck_require__(9454);
var NodeImpl_1 = __nccwpck_require__(2280);
var DOMException_1 = __nccwpck_require__(7175);
var infra_1 = __nccwpck_require__(4737);
var algorithm_1 = __nccwpck_require__(6573);
var WebIDLAlgorithm_1 = __nccwpck_require__(4239);
/**
 * Represents an element node.
 */
var ElementImpl = /** @class */ (function (_super) {
    __extends(ElementImpl, _super);
    /**
     * Initializes a new instance of `Element`.
     */
    function ElementImpl() {
        var _this = _super.call(this) || this;
        _this._children = new Set();
        _this._namespace = null;
        _this._namespacePrefix = null;
        _this._localName = "";
        _this._customElementState = "undefined";
        _this._customElementDefinition = null;
        _this._is = null;
        _this._shadowRoot = null;
        _this._attributeList = algorithm_1.create_namedNodeMap(_this);
        _this._attributeChangeSteps = [];
        _this._name = '';
        _this._assignedSlot = null;
        return _this;
    }
    Object.defineProperty(ElementImpl.prototype, "namespaceURI", {
        /** @inheritdoc */
        get: function () { return this._namespace; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ElementImpl.prototype, "prefix", {
        /** @inheritdoc */
        get: function () { return this._namespacePrefix; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ElementImpl.prototype, "localName", {
        /** @inheritdoc */
        get: function () { return this._localName; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ElementImpl.prototype, "tagName", {
        /** @inheritdoc */
        get: function () { return this._htmlUppercasedQualifiedName; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ElementImpl.prototype, "id", {
        /** @inheritdoc */
        get: function () {
            return algorithm_1.element_getAnAttributeValue(this, "id");
        },
        set: function (value) {
            algorithm_1.element_setAnAttributeValue(this, "id", value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ElementImpl.prototype, "className", {
        /** @inheritdoc */
        get: function () {
            return algorithm_1.element_getAnAttributeValue(this, "class");
        },
        set: function (value) {
            algorithm_1.element_setAnAttributeValue(this, "class", value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ElementImpl.prototype, "classList", {
        /** @inheritdoc */
        get: function () {
            var attr = algorithm_1.element_getAnAttributeByName("class", this);
            if (attr === null) {
                attr = algorithm_1.create_attr(this._nodeDocument, "class");
            }
            return algorithm_1.create_domTokenList(this, attr);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ElementImpl.prototype, "slot", {
        /** @inheritdoc */
        get: function () {
            return algorithm_1.element_getAnAttributeValue(this, "slot");
        },
        set: function (value) {
            algorithm_1.element_setAnAttributeValue(this, "slot", value);
        },
        enumerable: true,
        configurable: true
    });
    /** @inheritdoc */
    ElementImpl.prototype.hasAttributes = function () {
        return this._attributeList.length !== 0;
    };
    Object.defineProperty(ElementImpl.prototype, "attributes", {
        /** @inheritdoc */
        get: function () { return this._attributeList; },
        enumerable: true,
        configurable: true
    });
    /** @inheritdoc */
    ElementImpl.prototype.getAttributeNames = function () {
        var e_1, _a;
        /**
         * The getAttributeNames() method, when invoked, must return the qualified
         * names of the attributes in context object’s attribute list, in order,
         * and a new list otherwise.
         */
        var names = [];
        try {
            for (var _b = __values(this._attributeList), _c = _b.next(); !_c.done; _c = _b.next()) {
                var attr = _c.value;
                names.push(attr._qualifiedName);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return names;
    };
    /** @inheritdoc */
    ElementImpl.prototype.getAttribute = function (qualifiedName) {
        /**
         * 1. Let attr be the result of getting an attribute given qualifiedName
         * and the context object.
         * 2. If attr is null, return null.
         * 3. Return attr’s value.
         */
        var attr = algorithm_1.element_getAnAttributeByName(qualifiedName, this);
        return (attr ? attr._value : null);
    };
    /** @inheritdoc */
    ElementImpl.prototype.getAttributeNS = function (namespace, localName) {
        /**
         * 1. Let attr be the result of getting an attribute given namespace,
         * localName, and the context object.
         * 2. If attr is null, return null.
         * 3. Return attr’s value.
         */
        var attr = algorithm_1.element_getAnAttributeByNamespaceAndLocalName(namespace, localName, this);
        return (attr ? attr._value : null);
    };
    /** @inheritdoc */
    ElementImpl.prototype.setAttribute = function (qualifiedName, value) {
        /**
         * 1. If qualifiedName does not match the Name production in XML, then
         * throw an "InvalidCharacterError" DOMException.
         */
        if (!algorithm_1.xml_isName(qualifiedName))
            throw new DOMException_1.InvalidCharacterError();
        /**
         * 2. If the context object is in the HTML namespace and its node document
         * is an HTML document, then set qualifiedName to qualifiedName in ASCII
         * lowercase.
         */
        if (this._namespace === infra_1.namespace.HTML && this._nodeDocument._type === "html") {
            qualifiedName = qualifiedName.toLowerCase();
        }
        /**
         * 3. Let attribute be the first attribute in context object’s attribute
         * list whose qualified name is qualifiedName, and null otherwise.
         */
        var attribute = null;
        for (var i = 0; i < this._attributeList.length; i++) {
            var attr = this._attributeList[i];
            if (attr._qualifiedName === qualifiedName) {
                attribute = attr;
                break;
            }
        }
        /**
         * 4. If attribute is null, create an attribute whose local name is
         * qualifiedName, value is value, and node document is context object’s
         * node document, then append this attribute to context object, and
         * then return.
         */
        if (attribute === null) {
            attribute = algorithm_1.create_attr(this._nodeDocument, qualifiedName);
            attribute._value = value;
            algorithm_1.element_append(attribute, this);
            return;
        }
        /**
         * 5. Change attribute from context object to value.
         */
        algorithm_1.element_change(attribute, this, value);
    };
    /** @inheritdoc */
    ElementImpl.prototype.setAttributeNS = function (namespace, qualifiedName, value) {
        /**
         * 1. Let namespace, prefix, and localName be the result of passing
         * namespace and qualifiedName to validate and extract.
         * 2. Set an attribute value for the context object using localName, value,
         * and also prefix and namespace.
         */
        var _a = __read(algorithm_1.namespace_validateAndExtract(namespace, qualifiedName), 3), ns = _a[0], prefix = _a[1], localName = _a[2];
        algorithm_1.element_setAnAttributeValue(this, localName, value, prefix, ns);
    };
    /** @inheritdoc */
    ElementImpl.prototype.removeAttribute = function (qualifiedName) {
        /**
         * The removeAttribute(qualifiedName) method, when invoked, must remove an
         * attribute given qualifiedName and the context object, and then return
         * undefined.
         */
        algorithm_1.element_removeAnAttributeByName(qualifiedName, this);
    };
    /** @inheritdoc */
    ElementImpl.prototype.removeAttributeNS = function (namespace, localName) {
        /**
         * The removeAttributeNS(namespace, localName) method, when invoked, must
         * remove an attribute given namespace, localName, and context object, and
         * then return undefined.
         */
        algorithm_1.element_removeAnAttributeByNamespaceAndLocalName(namespace, localName, this);
    };
    /** @inheritdoc */
    ElementImpl.prototype.hasAttribute = function (qualifiedName) {
        /**
         * 1. If the context object is in the HTML namespace and its node document
         * is an HTML document, then set qualifiedName to qualifiedName in ASCII
         * lowercase.
         * 2. Return true if the context object has an attribute whose qualified
         * name is qualifiedName, and false otherwise.
         */
        if (this._namespace === infra_1.namespace.HTML && this._nodeDocument._type === "html") {
            qualifiedName = qualifiedName.toLowerCase();
        }
        for (var i = 0; i < this._attributeList.length; i++) {
            var attr = this._attributeList[i];
            if (attr._qualifiedName === qualifiedName) {
                return true;
            }
        }
        return false;
    };
    /** @inheritdoc */
    ElementImpl.prototype.toggleAttribute = function (qualifiedName, force) {
        /**
         * 1. If qualifiedName does not match the Name production in XML, then
         * throw an "InvalidCharacterError" DOMException.
         */
        if (!algorithm_1.xml_isName(qualifiedName))
            throw new DOMException_1.InvalidCharacterError();
        /**
         * 2. If the context object is in the HTML namespace and its node document
         * is an HTML document, then set qualifiedName to qualifiedName in ASCII
         * lowercase.
         */
        if (this._namespace === infra_1.namespace.HTML && this._nodeDocument._type === "html") {
            qualifiedName = qualifiedName.toLowerCase();
        }
        /**
         * 3. Let attribute be the first attribute in the context object’s attribute
         * list whose qualified name is qualifiedName, and null otherwise.
         */
        var attribute = null;
        for (var i = 0; i < this._attributeList.length; i++) {
            var attr = this._attributeList[i];
            if (attr._qualifiedName === qualifiedName) {
                attribute = attr;
                break;
            }
        }
        if (attribute === null) {
            /**
             * 4. If attribute is null, then:
             * 4.1. If force is not given or is true, create an attribute whose local
             * name is qualifiedName, value is the empty string, and node document is
             * the context object’s node document, then append this attribute to the
             * context object, and then return true.
             * 4.2. Return false.
             */
            if (force === undefined || force === true) {
                attribute = algorithm_1.create_attr(this._nodeDocument, qualifiedName);
                attribute._value = '';
                algorithm_1.element_append(attribute, this);
                return true;
            }
            return false;
        }
        else if (force === undefined || force === false) {
            /**
             * 5. Otherwise, if force is not given or is false, remove an attribute
             * given qualifiedName and the context object, and then return false.
             */
            algorithm_1.element_removeAnAttributeByName(qualifiedName, this);
            return false;
        }
        /**
         * 6. Return true.
         */
        return true;
    };
    /** @inheritdoc */
    ElementImpl.prototype.hasAttributeNS = function (namespace, localName) {
        /**
         * 1. If namespace is the empty string, set it to null.
         * 2. Return true if the context object has an attribute whose namespace is
         * namespace and local name is localName, and false otherwise.
         */
        var ns = namespace || null;
        for (var i = 0; i < this._attributeList.length; i++) {
            var attr = this._attributeList[i];
            if (attr._namespace === ns && attr._localName === localName) {
                return true;
            }
        }
        return false;
    };
    /** @inheritdoc */
    ElementImpl.prototype.getAttributeNode = function (qualifiedName) {
        /**
         * The getAttributeNode(qualifiedName) method, when invoked, must return the
         * result of getting an attribute given qualifiedName and context object.
         */
        return algorithm_1.element_getAnAttributeByName(qualifiedName, this);
    };
    /** @inheritdoc */
    ElementImpl.prototype.getAttributeNodeNS = function (namespace, localName) {
        /**
         * The getAttributeNodeNS(namespace, localName) method, when invoked, must
         * return the result of getting an attribute given namespace, localName, and
         * the context object.
         */
        return algorithm_1.element_getAnAttributeByNamespaceAndLocalName(namespace, localName, this);
    };
    /** @inheritdoc */
    ElementImpl.prototype.setAttributeNode = function (attr) {
        /**
         * The setAttributeNode(attr) and setAttributeNodeNS(attr) methods, when
         * invoked, must return the result of setting an attribute given attr and
         * the context object.
         */
        return algorithm_1.element_setAnAttribute(attr, this);
    };
    /** @inheritdoc */
    ElementImpl.prototype.setAttributeNodeNS = function (attr) {
        return algorithm_1.element_setAnAttribute(attr, this);
    };
    /** @inheritdoc */
    ElementImpl.prototype.removeAttributeNode = function (attr) {
        /**
         * 1. If context object’s attribute list does not contain attr, then throw
         * a "NotFoundError" DOMException.
         * 2. Remove attr from context object.
         * 3. Return attr.
         */
        var found = false;
        for (var i = 0; i < this._attributeList.length; i++) {
            var attribute = this._attributeList[i];
            if (attribute === attr) {
                found = true;
                break;
            }
        }
        if (!found)
            throw new DOMException_1.NotFoundError();
        algorithm_1.element_remove(attr, this);
        return attr;
    };
    /** @inheritdoc */
    ElementImpl.prototype.attachShadow = function (init) {
        /**
         * 1. If context object’s namespace is not the HTML namespace, then throw a
         * "NotSupportedError" DOMException.
         */
        if (this._namespace !== infra_1.namespace.HTML)
            throw new DOMException_1.NotSupportedError();
        /**
         * 2. If context object’s local name is not a valid custom element name,
         * "article", "aside", "blockquote", "body", "div", "footer", "h1", "h2",
         * "h3", "h4", "h5", "h6", "header", "main" "nav", "p", "section",
         * or "span", then throw a "NotSupportedError" DOMException.
         */
        if (!algorithm_1.customElement_isValidCustomElementName(this._localName) &&
            !algorithm_1.customElement_isValidShadowHostName(this._localName))
            throw new DOMException_1.NotSupportedError();
        /**
         * 3. If context object’s local name is a valid custom element name,
         * or context object’s is value is not null, then:
         * 3.1. Let definition be the result of looking up a custom element
         * definition given context object’s node document, its namespace, its
         * local name, and its is value.
         * 3.2. If definition is not null and definition’s disable shadow is true,
         *  then throw a "NotSupportedError" DOMException.
         */
        if (algorithm_1.customElement_isValidCustomElementName(this._localName) || this._is !== null) {
            var definition = algorithm_1.customElement_lookUpACustomElementDefinition(this._nodeDocument, this._namespace, this._localName, this._is);
            if (definition !== null && definition.disableShadow === true) {
                throw new DOMException_1.NotSupportedError();
            }
        }
        /**
         * 4. If context object is a shadow host, then throw an "NotSupportedError"
         * DOMException.
         */
        if (this._shadowRoot !== null)
            throw new DOMException_1.NotSupportedError();
        /**
         * 5. Let shadow be a new shadow root whose node document is context
         * object’s node document, host is context object, and mode is init’s mode.
         * 6. Set context object’s shadow root to shadow.
         * 7. Return shadow.
         */
        var shadow = algorithm_1.create_shadowRoot(this._nodeDocument, this);
        shadow._mode = init.mode;
        this._shadowRoot = shadow;
        return shadow;
    };
    Object.defineProperty(ElementImpl.prototype, "shadowRoot", {
        /** @inheritdoc */
        get: function () {
            /**
             * 1. Let shadow be context object’s shadow root.
             * 2. If shadow is null or its mode is "closed", then return null.
             * 3. Return shadow.
             */
            var shadow = this._shadowRoot;
            if (shadow === null || shadow.mode === "closed")
                return null;
            else
                return shadow;
        },
        enumerable: true,
        configurable: true
    });
    /** @inheritdoc */
    ElementImpl.prototype.closest = function (selectors) {
        /**
         * TODO: Selectors
         * 1. Let s be the result of parse a selector from selectors. [SELECTORS4]
         * 2. If s is failure, throw a "SyntaxError" DOMException.
         * 3. Let elements be context object’s inclusive ancestors that are
         * elements, in reverse tree order.
         * 4. For each element in elements, if match a selector against an element,
         * using s, element, and :scope element context object, returns success,
         * return element. [SELECTORS4]
         * 5. Return null.
         */
        throw new DOMException_1.NotImplementedError();
    };
    /** @inheritdoc */
    ElementImpl.prototype.matches = function (selectors) {
        /**
         * TODO: Selectors
         * 1. Let s be the result of parse a selector from selectors. [SELECTORS4]
         * 2. If s is failure, throw a "SyntaxError" DOMException.
         * 3. Return true if the result of match a selector against an element,
         * using s, element, and :scope element context object, returns success,
         * and false otherwise. [SELECTORS4]
         */
        throw new DOMException_1.NotImplementedError();
    };
    /** @inheritdoc */
    ElementImpl.prototype.webkitMatchesSelector = function (selectors) {
        return this.matches(selectors);
    };
    /** @inheritdoc */
    ElementImpl.prototype.getElementsByTagName = function (qualifiedName) {
        /**
         * The getElementsByTagName(qualifiedName) method, when invoked, must return
         * the list of elements with qualified name qualifiedName for context
         * object.
         */
        return algorithm_1.node_listOfElementsWithQualifiedName(qualifiedName, this);
    };
    /** @inheritdoc */
    ElementImpl.prototype.getElementsByTagNameNS = function (namespace, localName) {
        /**
         * The getElementsByTagNameNS(namespace, localName) method, when invoked,
         * must return the list of elements with namespace namespace and local name
         * localName for context object.
         */
        return algorithm_1.node_listOfElementsWithNamespace(namespace, localName, this);
    };
    /** @inheritdoc */
    ElementImpl.prototype.getElementsByClassName = function (classNames) {
        /**
         * The getElementsByClassName(classNames) method, when invoked, must return
         * the list of elements with class names classNames for context object.
         */
        return algorithm_1.node_listOfElementsWithClassNames(classNames, this);
    };
    /** @inheritdoc */
    ElementImpl.prototype.insertAdjacentElement = function (where, element) {
        /**
         * The insertAdjacentElement(where, element) method, when invoked, must
         * return the result of running insert adjacent, given context object,
         *  where, and element.
         */
        return algorithm_1.element_insertAdjacent(this, where, element);
    };
    /** @inheritdoc */
    ElementImpl.prototype.insertAdjacentText = function (where, data) {
        /**
         * 1. Let text be a new Text node whose data is data and node document is
         * context object’s node document.
         * 2. Run insert adjacent, given context object, where, and text.
         */
        var text = algorithm_1.create_text(this._nodeDocument, data);
        algorithm_1.element_insertAdjacent(this, where, text);
    };
    Object.defineProperty(ElementImpl.prototype, "_qualifiedName", {
        /**
         * Returns the qualified name.
         */
        get: function () {
            /**
             * An element’s qualified name is its local name if its namespace prefix is
             * null, and its namespace prefix, followed by ":", followed by its
             * local name, otherwise.
             */
            return (this._namespacePrefix ?
                this._namespacePrefix + ':' + this._localName :
                this._localName);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ElementImpl.prototype, "_htmlUppercasedQualifiedName", {
        /**
         * Returns the upper-cased qualified name for a html element.
         */
        get: function () {
            /**
             * 1. Let qualifiedName be context object’s qualified name.
             * 2. If the context object is in the HTML namespace and its node document
             * is an HTML document, then set qualifiedName to qualifiedName in ASCII
             * uppercase.
             * 3. Return qualifiedName.
             */
            var qualifiedName = this._qualifiedName;
            if (this._namespace === infra_1.namespace.HTML && this._nodeDocument._type === "html") {
                qualifiedName = qualifiedName.toUpperCase();
            }
            return qualifiedName;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ElementImpl.prototype, "children", {
        // MIXIN: ParentNode
        /* istanbul ignore next */
        get: function () { throw new Error("Mixin: ParentNode not implemented."); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ElementImpl.prototype, "firstElementChild", {
        /* istanbul ignore next */
        get: function () { throw new Error("Mixin: ParentNode not implemented."); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ElementImpl.prototype, "lastElementChild", {
        /* istanbul ignore next */
        get: function () { throw new Error("Mixin: ParentNode not implemented."); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ElementImpl.prototype, "childElementCount", {
        /* istanbul ignore next */
        get: function () { throw new Error("Mixin: ParentNode not implemented."); },
        enumerable: true,
        configurable: true
    });
    /* istanbul ignore next */
    ElementImpl.prototype.prepend = function () {
        var nodes = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            nodes[_i] = arguments[_i];
        }
        throw new Error("Mixin: ParentNode not implemented.");
    };
    /* istanbul ignore next */
    ElementImpl.prototype.append = function () {
        var nodes = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            nodes[_i] = arguments[_i];
        }
        throw new Error("Mixin: ParentNode not implemented.");
    };
    /* istanbul ignore next */
    ElementImpl.prototype.querySelector = function (selectors) { throw new Error("Mixin: ParentNode not implemented."); };
    /* istanbul ignore next */
    ElementImpl.prototype.querySelectorAll = function (selectors) { throw new Error("Mixin: ParentNode not implemented."); };
    Object.defineProperty(ElementImpl.prototype, "previousElementSibling", {
        // MIXIN: NonDocumentTypeChildNode
        /* istanbul ignore next */
        get: function () { throw new Error("Mixin: NonDocumentTypeChildNode not implemented."); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ElementImpl.prototype, "nextElementSibling", {
        /* istanbul ignore next */
        get: function () { throw new Error("Mixin: NonDocumentTypeChildNode not implemented."); },
        enumerable: true,
        configurable: true
    });
    // MIXIN: ChildNode
    /* istanbul ignore next */
    ElementImpl.prototype.before = function () {
        var nodes = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            nodes[_i] = arguments[_i];
        }
        throw new Error("Mixin: ChildNode not implemented.");
    };
    /* istanbul ignore next */
    ElementImpl.prototype.after = function () {
        var nodes = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            nodes[_i] = arguments[_i];
        }
        throw new Error("Mixin: ChildNode not implemented.");
    };
    /* istanbul ignore next */
    ElementImpl.prototype.replaceWith = function () {
        var nodes = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            nodes[_i] = arguments[_i];
        }
        throw new Error("Mixin: ChildNode not implemented.");
    };
    /* istanbul ignore next */
    ElementImpl.prototype.remove = function () { throw new Error("Mixin: ChildNode not implemented."); };
    Object.defineProperty(ElementImpl.prototype, "assignedSlot", {
        // MIXIN: Slotable
        /* istanbul ignore next */
        get: function () { throw new Error("Mixin: Slotable not implemented."); },
        enumerable: true,
        configurable: true
    });
    /**
     * Creates a new `Element`.
     *
     * @param document - owner document
     * @param localName - local name
     * @param namespace - namespace
     * @param prefix - namespace prefix
     */
    ElementImpl._create = function (document, localName, namespace, namespacePrefix) {
        if (namespace === void 0) { namespace = null; }
        if (namespacePrefix === void 0) { namespacePrefix = null; }
        var node = new ElementImpl();
        node._localName = localName;
        node._namespace = namespace;
        node._namespacePrefix = namespacePrefix;
        node._nodeDocument = document;
        return node;
    };
    return ElementImpl;
}(NodeImpl_1.NodeImpl));
exports.ElementImpl = ElementImpl;
/**
 * Initialize prototype properties
 */
WebIDLAlgorithm_1.idl_defineConst(ElementImpl.prototype, "_nodeType", interfaces_1.NodeType.Element);
//# sourceMappingURL=ElementImpl.js.map

/***/ }),

/***/ 2390:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
var interfaces_1 = __nccwpck_require__(9454);
var algorithm_1 = __nccwpck_require__(6573);
var WebIDLAlgorithm_1 = __nccwpck_require__(4239);
/**
 * Represents a DOM event.
 */
var EventImpl = /** @class */ (function () {
    /**
     * Initializes a new instance of `Event`.
     */
    function EventImpl(type, eventInit) {
        this._target = null;
        this._relatedTarget = null;
        this._touchTargetList = [];
        this._path = [];
        this._currentTarget = null;
        this._eventPhase = interfaces_1.EventPhase.None;
        this._stopPropagationFlag = false;
        this._stopImmediatePropagationFlag = false;
        this._canceledFlag = false;
        this._inPassiveListenerFlag = false;
        this._composedFlag = false;
        this._initializedFlag = false;
        this._dispatchFlag = false;
        this._isTrusted = false;
        this._bubbles = false;
        this._cancelable = false;
        /**
         * When a constructor of the Event interface, or of an interface that
         * inherits from the Event interface, is invoked, these steps must be run,
         * given the arguments type and eventInitDict:
         * 1. Let event be the result of running the inner event creation steps with
         * this interface, null, now, and eventInitDict.
         * 2. Initialize event’s type attribute to type.
         * 3. Return event.
         */
        this._type = type;
        if (eventInit) {
            this._bubbles = eventInit.bubbles || false;
            this._cancelable = eventInit.cancelable || false;
            this._composedFlag = eventInit.composed || false;
        }
        this._initializedFlag = true;
        this._timeStamp = new Date().getTime();
    }
    Object.defineProperty(EventImpl.prototype, "type", {
        /** @inheritdoc */
        get: function () { return this._type; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EventImpl.prototype, "target", {
        /** @inheritdoc */
        get: function () { return this._target; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EventImpl.prototype, "srcElement", {
        /** @inheritdoc */
        get: function () { return this._target; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EventImpl.prototype, "currentTarget", {
        /** @inheritdoc */
        get: function () { return this._currentTarget; },
        enumerable: true,
        configurable: true
    });
    /** @inheritdoc */
    EventImpl.prototype.composedPath = function () {
        /**
         * 1. Let composedPath be an empty list.
         * 2. Let path be the context object’s path.
         * 3. If path is empty, then return composedPath.
         * 4. Let currentTarget be the context object’s currentTarget attribute
         * value.
         * 5. Append currentTarget to composedPath.
         * 6. Let currentTargetIndex be 0.
         * 7. Let currentTargetHiddenSubtreeLevel be 0.
         */
        var composedPath = [];
        var path = this._path;
        if (path.length === 0)
            return composedPath;
        var currentTarget = this._currentTarget;
        if (currentTarget === null) {
            throw new Error("Event currentTarget is null.");
        }
        composedPath.push(currentTarget);
        var currentTargetIndex = 0;
        var currentTargetHiddenSubtreeLevel = 0;
        /**
         * 8. Let index be path’s size − 1.
         * 9. While index is greater than or equal to 0:
         */
        var index = path.length - 1;
        while (index >= 0) {
            /**
             * 9.1. If path[index]'s root-of-closed-tree is true, then increase
             * currentTargetHiddenSubtreeLevel by 1.
             * 9.2. If path[index]'s invocation target is currentTarget, then set
             * currentTargetIndex to index and break.
             * 9.3. If path[index]'s slot-in-closed-tree is true, then decrease
             * currentTargetHiddenSubtreeLevel by 1.
             * 9.4. Decrease index by 1.
             */
            if (path[index].rootOfClosedTree) {
                currentTargetHiddenSubtreeLevel++;
            }
            if (path[index].invocationTarget === currentTarget) {
                currentTargetIndex = index;
                break;
            }
            if (path[index].slotInClosedTree) {
                currentTargetHiddenSubtreeLevel--;
            }
            index--;
        }
        /**
         * 10. Let currentHiddenLevel and maxHiddenLevel be
         * currentTargetHiddenSubtreeLevel.
         */
        var currentHiddenLevel = currentTargetHiddenSubtreeLevel;
        var maxHiddenLevel = currentTargetHiddenSubtreeLevel;
        /**
         * 11. Set index to currentTargetIndex − 1.
         * 12. While index is greater than or equal to 0:
         */
        index = currentTargetIndex - 1;
        while (index >= 0) {
            /**
             * 12.1. If path[index]'s root-of-closed-tree is true, then increase
             * currentHiddenLevel by 1.
             * 12.2. If currentHiddenLevel is less than or equal to maxHiddenLevel,
             * then prepend path[index]'s invocation target to composedPath.
             */
            if (path[index].rootOfClosedTree) {
                currentHiddenLevel++;
            }
            if (currentHiddenLevel <= maxHiddenLevel) {
                composedPath.unshift(path[index].invocationTarget);
            }
            /**
             * 12.3. If path[index]'s slot-in-closed-tree is true, then:
             */
            if (path[index].slotInClosedTree) {
                /**
                 * 12.3.1. Decrease currentHiddenLevel by 1.
                 * 12.3.2. If currentHiddenLevel is less than maxHiddenLevel, then set
                 * maxHiddenLevel to currentHiddenLevel.
                 */
                currentHiddenLevel--;
                if (currentHiddenLevel < maxHiddenLevel) {
                    maxHiddenLevel = currentHiddenLevel;
                }
            }
            /**
             * 12.4. Decrease index by 1.
             */
            index--;
        }
        /**
         * 13. Set currentHiddenLevel and maxHiddenLevel to
         * currentTargetHiddenSubtreeLevel.
         */
        currentHiddenLevel = currentTargetHiddenSubtreeLevel;
        maxHiddenLevel = currentTargetHiddenSubtreeLevel;
        /**
         * 14. Set index to currentTargetIndex + 1.
         * 15. While index is less than path’s size:
         */
        index = currentTargetIndex + 1;
        while (index < path.length) {
            /**
             * 15.1. If path[index]'s slot-in-closed-tree is true, then increase
             * currentHiddenLevel by 1.
             * 15.2. If currentHiddenLevel is less than or equal to maxHiddenLevel,
             * then append path[index]'s invocation target to composedPath.
             */
            if (path[index].slotInClosedTree) {
                currentHiddenLevel++;
            }
            if (currentHiddenLevel <= maxHiddenLevel) {
                composedPath.push(path[index].invocationTarget);
            }
            /**
             * 15.3. If path[index]'s root-of-closed-tree is true, then:
             */
            if (path[index].rootOfClosedTree) {
                /**
                 * 15.3.1. Decrease currentHiddenLevel by 1.
                 * 15.3.2. If currentHiddenLevel is less than maxHiddenLevel, then set
                 * maxHiddenLevel to currentHiddenLevel.
                 */
                currentHiddenLevel--;
                if (currentHiddenLevel < maxHiddenLevel) {
                    maxHiddenLevel = currentHiddenLevel;
                }
            }
            /**
             * 15.4. Increase index by 1.
             */
            index++;
        }
        /**
         * 16. Return composedPath.
         */
        return composedPath;
    };
    Object.defineProperty(EventImpl.prototype, "eventPhase", {
        /** @inheritdoc */
        get: function () { return this._eventPhase; },
        enumerable: true,
        configurable: true
    });
    /** @inheritdoc */
    EventImpl.prototype.stopPropagation = function () { this._stopPropagationFlag = true; };
    Object.defineProperty(EventImpl.prototype, "cancelBubble", {
        /** @inheritdoc */
        get: function () { return this._stopPropagationFlag; },
        set: function (value) { if (value)
            this.stopPropagation(); },
        enumerable: true,
        configurable: true
    });
    /** @inheritdoc */
    EventImpl.prototype.stopImmediatePropagation = function () {
        this._stopPropagationFlag = true;
        this._stopImmediatePropagationFlag = true;
    };
    Object.defineProperty(EventImpl.prototype, "bubbles", {
        /** @inheritdoc */
        get: function () { return this._bubbles; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EventImpl.prototype, "cancelable", {
        /** @inheritdoc */
        get: function () { return this._cancelable; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EventImpl.prototype, "returnValue", {
        /** @inheritdoc */
        get: function () { return !this._canceledFlag; },
        set: function (value) {
            if (!value) {
                algorithm_1.event_setTheCanceledFlag(this);
            }
        },
        enumerable: true,
        configurable: true
    });
    /** @inheritdoc */
    EventImpl.prototype.preventDefault = function () {
        algorithm_1.event_setTheCanceledFlag(this);
    };
    Object.defineProperty(EventImpl.prototype, "defaultPrevented", {
        /** @inheritdoc */
        get: function () { return this._canceledFlag; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EventImpl.prototype, "composed", {
        /** @inheritdoc */
        get: function () { return this._composedFlag; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EventImpl.prototype, "isTrusted", {
        /** @inheritdoc */
        get: function () { return this._isTrusted; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EventImpl.prototype, "timeStamp", {
        /** @inheritdoc */
        get: function () { return this._timeStamp; },
        enumerable: true,
        configurable: true
    });
    /** @inheritdoc */
    EventImpl.prototype.initEvent = function (type, bubbles, cancelable) {
        if (bubbles === void 0) { bubbles = false; }
        if (cancelable === void 0) { cancelable = false; }
        /**
         * 1. If the context object’s dispatch flag is set, then return.
         */
        if (this._dispatchFlag)
            return;
        /**
         * 2. Initialize the context object with type, bubbles, and cancelable.
         */
        algorithm_1.event_initialize(this, type, bubbles, cancelable);
    };
    EventImpl.NONE = 0;
    EventImpl.CAPTURING_PHASE = 1;
    EventImpl.AT_TARGET = 2;
    EventImpl.BUBBLING_PHASE = 3;
    return EventImpl;
}());
exports.EventImpl = EventImpl;
/**
 * Define constants on prototype.
 */
WebIDLAlgorithm_1.idl_defineConst(EventImpl.prototype, "NONE", 0);
WebIDLAlgorithm_1.idl_defineConst(EventImpl.prototype, "CAPTURING_PHASE", 1);
WebIDLAlgorithm_1.idl_defineConst(EventImpl.prototype, "AT_TARGET", 2);
WebIDLAlgorithm_1.idl_defineConst(EventImpl.prototype, "BUBBLING_PHASE", 3);
//# sourceMappingURL=EventImpl.js.map

/***/ }),

/***/ 3611:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {


var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var DOMException_1 = __nccwpck_require__(7175);
var util_1 = __nccwpck_require__(628);
var algorithm_1 = __nccwpck_require__(6573);
/**
 * Represents a target to which an event can be dispatched.
 */
var EventTargetImpl = /** @class */ (function () {
    /**
     * Initializes a new instance of `EventTarget`.
     */
    function EventTargetImpl() {
    }
    Object.defineProperty(EventTargetImpl.prototype, "_eventListenerList", {
        get: function () {
            return this.__eventListenerList || (this.__eventListenerList = []);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EventTargetImpl.prototype, "_eventHandlerMap", {
        get: function () {
            return this.__eventHandlerMap || (this.__eventHandlerMap = {});
        },
        enumerable: true,
        configurable: true
    });
    /** @inheritdoc */
    EventTargetImpl.prototype.addEventListener = function (type, callback, options) {
        if (options === void 0) { options = { passive: false, once: false, capture: false }; }
        /**
         * 1. Let capture, passive, and once be the result of flattening more options.
         */
        var _a = __read(algorithm_1.eventTarget_flattenMore(options), 3), capture = _a[0], passive = _a[1], once = _a[2];
        // convert callback function to EventListener, return if null
        var listenerCallback;
        if (!callback) {
            return;
        }
        else if (util_1.Guard.isEventListener(callback)) {
            listenerCallback = callback;
        }
        else {
            listenerCallback = { handleEvent: callback };
        }
        /**
         * 2. Add an event listener with the context object and an event listener
         * whose type is type, callback is callback, capture is capture, passive is
         * passive, and once is once.
         */
        algorithm_1.eventTarget_addEventListener(this, {
            type: type,
            callback: listenerCallback,
            capture: capture,
            passive: passive,
            once: once,
            removed: false
        });
    };
    /** @inheritdoc */
    EventTargetImpl.prototype.removeEventListener = function (type, callback, options) {
        /**
         * TODO: Implement realms
         * 1. If the context object’s relevant global object is a
         * ServiceWorkerGlobalScope object and its associated service worker’s
         * script resource’s has ever been evaluated flag is set, then throw
         * a TypeError. [SERVICE-WORKERS]
         */
        if (options === void 0) { options = { capture: false }; }
        /**
         * 2. Let capture be the result of flattening options.
         */
        var capture = algorithm_1.eventTarget_flatten(options);
        if (!callback)
            return;
        /**
         * 3. If the context object’s event listener list contains an event listener
         * whose type is type, callback is callback, and capture is capture, then
         * remove an event listener with the context object and that event listener.
         */
        for (var i = 0; i < this._eventListenerList.length; i++) {
            var entry = this._eventListenerList[i];
            if (entry.type !== type || entry.capture !== capture)
                continue;
            if (util_1.Guard.isEventListener(callback) && entry.callback === callback) {
                algorithm_1.eventTarget_removeEventListener(this, entry, i);
                break;
            }
            else if (callback && entry.callback.handleEvent === callback) {
                algorithm_1.eventTarget_removeEventListener(this, entry, i);
                break;
            }
        }
    };
    /** @inheritdoc */
    EventTargetImpl.prototype.dispatchEvent = function (event) {
        /**
         * 1. If event’s dispatch flag is set, or if its initialized flag is not
         * set, then throw an "InvalidStateError" DOMException.
         * 2. Initialize event’s isTrusted attribute to false.
         * 3. Return the result of dispatching event to the context object.
         */
        if (event._dispatchFlag || !event._initializedFlag) {
            throw new DOMException_1.InvalidStateError();
        }
        event._isTrusted = false;
        return algorithm_1.event_dispatch(event, this);
    };
    /** @inheritdoc */
    EventTargetImpl.prototype._getTheParent = function (event) {
        return null;
    };
    return EventTargetImpl;
}());
exports.EventTargetImpl = EventTargetImpl;
//# sourceMappingURL=EventTargetImpl.js.map

/***/ }),

/***/ 9065:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
var infra_1 = __nccwpck_require__(4737);
var algorithm_1 = __nccwpck_require__(6573);
var util_1 = __nccwpck_require__(628);
var util_2 = __nccwpck_require__(7061);
/**
 * Represents a collection of elements.
 */
var HTMLCollectionImpl = /** @class */ (function () {
    /**
     * Initializes a new instance of `HTMLCollection`.
     *
     * @param root - root node
     * @param filter - node filter
     */
    function HTMLCollectionImpl(root, filter) {
        this._live = true;
        this._root = root;
        this._filter = filter;
        return new Proxy(this, this);
    }
    Object.defineProperty(HTMLCollectionImpl.prototype, "length", {
        /** @inheritdoc */
        get: function () {
            var _this = this;
            /**
             * The length attribute’s getter must return the number of nodes
             * represented by the collection.
             */
            var count = 0;
            var node = algorithm_1.tree_getFirstDescendantNode(this._root, false, false, function (e) { return util_1.Guard.isElementNode(e) && _this._filter(e); });
            while (node !== null) {
                count++;
                node = algorithm_1.tree_getNextDescendantNode(this._root, node, false, false, function (e) { return util_1.Guard.isElementNode(e) && _this._filter(e); });
            }
            return count;
        },
        enumerable: true,
        configurable: true
    });
    /** @inheritdoc */
    HTMLCollectionImpl.prototype.item = function (index) {
        var _this = this;
        /**
         * The item(index) method, when invoked, must return the indexth element
         * in the collection. If there is no indexth element in the collection,
         * then the method must return null.
         */
        var i = 0;
        var node = algorithm_1.tree_getFirstDescendantNode(this._root, false, false, function (e) { return util_1.Guard.isElementNode(e) && _this._filter(e); });
        while (node !== null) {
            if (i === index)
                return node;
            else
                i++;
            node = algorithm_1.tree_getNextDescendantNode(this._root, node, false, false, function (e) { return util_1.Guard.isElementNode(e) && _this._filter(e); });
        }
        return null;
    };
    /** @inheritdoc */
    HTMLCollectionImpl.prototype.namedItem = function (key) {
        var _this = this;
        /**
         * 1. If key is the empty string, return null.
         * 2. Return the first element in the collection for which at least one of
         * the following is true:
         * - it has an ID which is key;
         * - it is in the HTML namespace and has a name attribute whose value is key;
         * or null if there is no such element.
         */
        if (key === '')
            return null;
        var ele = algorithm_1.tree_getFirstDescendantNode(this._root, false, false, function (e) { return util_1.Guard.isElementNode(e) && _this._filter(e); });
        while (ele != null) {
            if (ele._uniqueIdentifier === key) {
                return ele;
            }
            else if (ele._namespace === infra_1.namespace.HTML) {
                for (var i = 0; i < ele._attributeList.length; i++) {
                    var attr = ele._attributeList[i];
                    if (attr._localName === "name" && attr._namespace === null &&
                        attr._namespacePrefix === null && attr._value === key)
                        return ele;
                }
            }
            ele = algorithm_1.tree_getNextDescendantNode(this._root, ele, false, false, function (e) { return util_1.Guard.isElementNode(e) && _this._filter(e); });
        }
        return null;
    };
    /** @inheritdoc */
    HTMLCollectionImpl.prototype[Symbol.iterator] = function () {
        var root = this._root;
        var filter = this._filter;
        var currentNode = algorithm_1.tree_getFirstDescendantNode(root, false, false, function (e) { return util_1.Guard.isElementNode(e) && filter(e); });
        return {
            next: function () {
                if (currentNode === null) {
                    return { done: true, value: null };
                }
                else {
                    var result = { done: false, value: currentNode };
                    currentNode = algorithm_1.tree_getNextDescendantNode(root, currentNode, false, false, function (e) { return util_1.Guard.isElementNode(e) && filter(e); });
                    return result;
                }
            }
        };
    };
    /**
     * Implements a proxy get trap to provide array-like access.
     */
    HTMLCollectionImpl.prototype.get = function (target, key, receiver) {
        if (!util_2.isString(key) || HTMLCollectionImpl.reservedNames.indexOf(key) !== -1) {
            return Reflect.get(target, key, receiver);
        }
        var index = Number(key);
        if (isNaN(index)) {
            return target.namedItem(key) || undefined;
        }
        else {
            return target.item(index) || undefined;
        }
    };
    /**
     * Implements a proxy set trap to provide array-like access.
     */
    HTMLCollectionImpl.prototype.set = function (target, key, value, receiver) {
        if (!util_2.isString(key) || HTMLCollectionImpl.reservedNames.indexOf(key) !== -1) {
            return Reflect.set(target, key, value, receiver);
        }
        var index = Number(key);
        var node = isNaN(index) ?
            target.namedItem(key) || undefined : target.item(index) || undefined;
        if (node && node._parent) {
            algorithm_1.mutation_replace(node, value, node._parent);
            return true;
        }
        else {
            return false;
        }
    };
    /**
     * Creates a new `HTMLCollection`.
     *
     * @param root - root node
     * @param filter - node filter
     */
    HTMLCollectionImpl._create = function (root, filter) {
        if (filter === void 0) { filter = (function () { return true; }); }
        return new HTMLCollectionImpl(root, filter);
    };
    HTMLCollectionImpl.reservedNames = ['_root', '_live', '_filter', 'length',
        'item', 'namedItem', 'get', 'set'];
    return HTMLCollectionImpl;
}());
exports.HTMLCollectionImpl = HTMLCollectionImpl;
//# sourceMappingURL=HTMLCollectionImpl.js.map

/***/ }),

/***/ 9137:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {


var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var DOMImpl_1 = __nccwpck_require__(698);
var util_1 = __nccwpck_require__(628);
var infra_1 = __nccwpck_require__(4737);
/**
 * Represents an object that can be used to observe mutations to the tree of
 * nodes.
 */
var MutationObserverImpl = /** @class */ (function () {
    /**
     * Initializes a new instance of `MutationObserver`.
     *
     * @param callback - the callback function
     */
    function MutationObserverImpl(callback) {
        this._nodeList = [];
        this._recordQueue = [];
        /**
         * 1. Let mo be a new MutationObserver object whose callback is callback.
         * 2. Append mo to mo’s relevant agent’s mutation observers.
         * 3. Return mo.
         */
        this._callback = callback;
        var window = DOMImpl_1.dom.window;
        infra_1.set.append(window._mutationObservers, this);
    }
    /** @inheritdoc */
    MutationObserverImpl.prototype.observe = function (target, options) {
        var e_1, _a;
        options = options || {
            childList: false,
            subtree: false
        };
        /**
         * 1. If either options’s attributeOldValue or attributeFilter is present
         * and options’s attributes is omitted, then set options’s attributes
         * to true.
         * 2. If options’s characterDataOldValue is present and options’s
         * characterData is omitted, then set options’s characterData to true.
         * 3. If none of options’s childList, attributes, and characterData is
         * true, then throw a TypeError.
         * 4. If options’s attributeOldValue is true and options’s attributes is
         * false, then throw a TypeError.
         * 5. If options’s attributeFilter is present and options’s attributes is
         *  false, then throw a TypeError.
         * 6. If options’s characterDataOldValue is true and options’s characterData
         * is false, then throw a TypeError.
         */
        if ((options.attributeOldValue !== undefined || options.attributeFilter !== undefined) &&
            options.attributes === undefined) {
            options.attributes = true;
        }
        if (options.characterDataOldValue !== undefined && options.characterData === undefined) {
            options.characterData = true;
        }
        if (!options.childList && !options.attributes && !options.characterData) {
            throw new TypeError();
        }
        if (options.attributeOldValue && !options.attributes) {
            throw new TypeError();
        }
        if (options.attributeFilter !== undefined && !options.attributes) {
            throw new TypeError();
        }
        if (options.characterDataOldValue && !options.characterData) {
            throw new TypeError();
        }
        /**
         * 7. For each registered of target’s registered observer list, if
         * registered’s observer is the context object:
         */
        var isRegistered = false;
        var coptions = options;
        var _loop_1 = function (registered) {
            var e_2, _a;
            if (registered.observer === this_1) {
                isRegistered = true;
                try {
                    /**
                     * 7.1. For each node of the context object’s node list, remove all
                     * transient registered observers whose source is registered from node’s
                     * registered observer list.
                     */
                    for (var _b = (e_2 = void 0, __values(this_1._nodeList)), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var node = _c.value;
                        infra_1.list.remove(node._registeredObserverList, function (ob) {
                            return util_1.Guard.isTransientRegisteredObserver(ob) && ob.source === registered;
                        });
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                    }
                    finally { if (e_2) throw e_2.error; }
                }
                /**
                 * 7.2. Set registered’s options to options.
                 */
                registered.options = coptions;
            }
        };
        var this_1 = this;
        try {
            for (var _b = __values(target._registeredObserverList), _c = _b.next(); !_c.done; _c = _b.next()) {
                var registered = _c.value;
                _loop_1(registered);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        /**
         * 8. Otherwise:
         * 8.1. Append a new registered observer whose observer is the context
         * object and options is options to target’s registered observer list.
         * 8.2. Append target to the context object’s node list.
         */
        if (!isRegistered) {
            target._registeredObserverList.push({ observer: this, options: options });
            this._nodeList.push(target);
        }
    };
    /** @inheritdoc */
    MutationObserverImpl.prototype.disconnect = function () {
        var e_3, _a;
        var _this = this;
        try {
            /**
             * 1. For each node of the context object’s node list, remove any
             * registered observer from node’s registered observer list for which the
             * context object is the observer.
             */
            for (var _b = __values(this._nodeList), _c = _b.next(); !_c.done; _c = _b.next()) {
                var node = _c.value;
                infra_1.list.remove((node)._registeredObserverList, function (ob) {
                    return ob.observer === _this;
                });
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_3) throw e_3.error; }
        }
        /**
         * 2. Empty the context object’s record queue.
         */
        this._recordQueue = [];
    };
    /** @inheritdoc */
    MutationObserverImpl.prototype.takeRecords = function () {
        /**
         * 1. Let records be a clone of the context object’s record queue.
         * 2. Empty the context object’s record queue.
         * 3. Return records.
         */
        var records = this._recordQueue;
        this._recordQueue = [];
        return records;
    };
    return MutationObserverImpl;
}());
exports.MutationObserverImpl = MutationObserverImpl;
//# sourceMappingURL=MutationObserverImpl.js.map

/***/ }),

/***/ 2414:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * Represents a mutation record.
 */
var MutationRecordImpl = /** @class */ (function () {
    /**
     * Initializes a new instance of `MutationRecord`.
     *
     * @param type - type of mutation: `"attributes"` for an attribute
     * mutation, `"characterData"` for a mutation to a CharacterData node
     * and `"childList"` for a mutation to the tree of nodes.
     * @param target - node affected by the mutation.
     * @param addedNodes - list of added nodes.
     * @param removedNodes - list of removed nodes.
     * @param previousSibling - previous sibling of added or removed nodes.
     * @param nextSibling - next sibling of added or removed nodes.
     * @param attributeName - local name of the changed attribute,
     * and `null` otherwise.
     * @param attributeNamespace - namespace of the changed attribute,
     * and `null` otherwise.
     * @param oldValue - value before mutation: attribute value for an attribute
     * mutation, node `data` for a mutation to a CharacterData node and `null`
     * for a mutation to the tree of nodes.
     */
    function MutationRecordImpl(type, target, addedNodes, removedNodes, previousSibling, nextSibling, attributeName, attributeNamespace, oldValue) {
        this._type = type;
        this._target = target;
        this._addedNodes = addedNodes;
        this._removedNodes = removedNodes;
        this._previousSibling = previousSibling;
        this._nextSibling = nextSibling;
        this._attributeName = attributeName;
        this._attributeNamespace = attributeNamespace;
        this._oldValue = oldValue;
    }
    Object.defineProperty(MutationRecordImpl.prototype, "type", {
        /** @inheritdoc */
        get: function () { return this._type; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MutationRecordImpl.prototype, "target", {
        /** @inheritdoc */
        get: function () { return this._target; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MutationRecordImpl.prototype, "addedNodes", {
        /** @inheritdoc */
        get: function () { return this._addedNodes; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MutationRecordImpl.prototype, "removedNodes", {
        /** @inheritdoc */
        get: function () { return this._removedNodes; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MutationRecordImpl.prototype, "previousSibling", {
        /** @inheritdoc */
        get: function () { return this._previousSibling; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MutationRecordImpl.prototype, "nextSibling", {
        /** @inheritdoc */
        get: function () { return this._nextSibling; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MutationRecordImpl.prototype, "attributeName", {
        /** @inheritdoc */
        get: function () { return this._attributeName; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MutationRecordImpl.prototype, "attributeNamespace", {
        /** @inheritdoc */
        get: function () { return this._attributeNamespace; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MutationRecordImpl.prototype, "oldValue", {
        /** @inheritdoc */
        get: function () { return this._oldValue; },
        enumerable: true,
        configurable: true
    });
    /**
     * Creates a new `MutationRecord`.
     *
     * @param type - type of mutation: `"attributes"` for an attribute
     * mutation, `"characterData"` for a mutation to a CharacterData node
     * and `"childList"` for a mutation to the tree of nodes.
     * @param target - node affected by the mutation.
     * @param addedNodes - list of added nodes.
     * @param removedNodes - list of removed nodes.
     * @param previousSibling - previous sibling of added or removed nodes.
     * @param nextSibling - next sibling of added or removed nodes.
     * @param attributeName - local name of the changed attribute,
     * and `null` otherwise.
     * @param attributeNamespace - namespace of the changed attribute,
     * and `null` otherwise.
     * @param oldValue - value before mutation: attribute value for an attribute
     * mutation, node `data` for a mutation to a CharacterData node and `null`
     * for a mutation to the tree of nodes.
     */
    MutationRecordImpl._create = function (type, target, addedNodes, removedNodes, previousSibling, nextSibling, attributeName, attributeNamespace, oldValue) {
        return new MutationRecordImpl(type, target, addedNodes, removedNodes, previousSibling, nextSibling, attributeName, attributeNamespace, oldValue);
    };
    return MutationRecordImpl;
}());
exports.MutationRecordImpl = MutationRecordImpl;
//# sourceMappingURL=MutationRecordImpl.js.map

/***/ }),

/***/ 3145:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
var DOMException_1 = __nccwpck_require__(7175);
var algorithm_1 = __nccwpck_require__(6573);
/**
 * Represents a collection of attributes.
 */
var NamedNodeMapImpl = /** @class */ (function (_super) {
    __extends(NamedNodeMapImpl, _super);
    /**
     * Initializes a new instance of `NamedNodeMap`.
     *
     * @param element - parent element
     */
    function NamedNodeMapImpl(element) {
        var _this = _super.call(this) || this;
        _this._element = element;
        // TODO: This workaround is needed to extend Array in ES5
        Object.setPrototypeOf(_this, NamedNodeMapImpl.prototype);
        return _this;
    }
    NamedNodeMapImpl.prototype._asArray = function () { return this; };
    /** @inheritdoc */
    NamedNodeMapImpl.prototype.item = function (index) {
        /**
         * 1. If index is equal to or greater than context object’s attribute list’s
         * size, then return null.
         * 2. Otherwise, return context object’s attribute list[index].
         *
         */
        return this[index] || null;
    };
    /** @inheritdoc */
    NamedNodeMapImpl.prototype.getNamedItem = function (qualifiedName) {
        /**
         * The getNamedItem(qualifiedName) method, when invoked, must return the
         * result of getting an attribute given qualifiedName and element.
         */
        return algorithm_1.element_getAnAttributeByName(qualifiedName, this._element);
    };
    /** @inheritdoc */
    NamedNodeMapImpl.prototype.getNamedItemNS = function (namespace, localName) {
        /**
         * The getNamedItemNS(namespace, localName) method, when invoked, must
         * return the result of getting an attribute given namespace, localName,
         * and element.
         */
        return algorithm_1.element_getAnAttributeByNamespaceAndLocalName(namespace || '', localName, this._element);
    };
    /** @inheritdoc */
    NamedNodeMapImpl.prototype.setNamedItem = function (attr) {
        /**
         * The setNamedItem(attr) and setNamedItemNS(attr) methods, when invoked,
         * must return the result of setting an attribute given attr and element.
         */
        return algorithm_1.element_setAnAttribute(attr, this._element);
    };
    /** @inheritdoc */
    NamedNodeMapImpl.prototype.setNamedItemNS = function (attr) {
        return algorithm_1.element_setAnAttribute(attr, this._element);
    };
    /** @inheritdoc */
    NamedNodeMapImpl.prototype.removeNamedItem = function (qualifiedName) {
        /**
         * 1. Let attr be the result of removing an attribute given qualifiedName
         * and element.
         * 2. If attr is null, then throw a "NotFoundError" DOMException.
         * 3. Return attr.
         */
        var attr = algorithm_1.element_removeAnAttributeByName(qualifiedName, this._element);
        if (attr === null)
            throw new DOMException_1.NotFoundError();
        return attr;
    };
    /** @inheritdoc */
    NamedNodeMapImpl.prototype.removeNamedItemNS = function (namespace, localName) {
        /**
         * 1. Let attr be the result of removing an attribute given namespace,
         * localName, and element.
         * 2. If attr is null, then throw a "NotFoundError" DOMException.
         * 3. Return attr.
         */
        var attr = algorithm_1.element_removeAnAttributeByNamespaceAndLocalName(namespace || '', localName, this._element);
        if (attr === null)
            throw new DOMException_1.NotFoundError();
        return attr;
    };
    /**
     * Creates a new `NamedNodeMap`.
     *
     * @param element - parent element
     */
    NamedNodeMapImpl._create = function (element) {
        return new NamedNodeMapImpl(element);
    };
    return NamedNodeMapImpl;
}(Array));
exports.NamedNodeMapImpl = NamedNodeMapImpl;
//# sourceMappingURL=NamedNodeMapImpl.js.map

/***/ }),

/***/ 7030:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
var interfaces_1 = __nccwpck_require__(9454);
var WebIDLAlgorithm_1 = __nccwpck_require__(4239);
/**
 * Represents a node filter.
 */
var NodeFilterImpl = /** @class */ (function () {
    /**
     * Initializes a new instance of `NodeFilter`.
     */
    function NodeFilterImpl() {
    }
    /**
     * Callback function.
     */
    NodeFilterImpl.prototype.acceptNode = function (node) {
        return interfaces_1.FilterResult.Accept;
    };
    /**
     * Creates a new `NodeFilter`.
     */
    NodeFilterImpl._create = function () {
        return new NodeFilterImpl();
    };
    NodeFilterImpl.FILTER_ACCEPT = 1;
    NodeFilterImpl.FILTER_REJECT = 2;
    NodeFilterImpl.FILTER_SKIP = 3;
    NodeFilterImpl.SHOW_ALL = 0xffffffff;
    NodeFilterImpl.SHOW_ELEMENT = 0x1;
    NodeFilterImpl.SHOW_ATTRIBUTE = 0x2;
    NodeFilterImpl.SHOW_TEXT = 0x4;
    NodeFilterImpl.SHOW_CDATA_SECTION = 0x8;
    NodeFilterImpl.SHOW_ENTITY_REFERENCE = 0x10;
    NodeFilterImpl.SHOW_ENTITY = 0x20;
    NodeFilterImpl.SHOW_PROCESSING_INSTRUCTION = 0x40;
    NodeFilterImpl.SHOW_COMMENT = 0x80;
    NodeFilterImpl.SHOW_DOCUMENT = 0x100;
    NodeFilterImpl.SHOW_DOCUMENT_TYPE = 0x200;
    NodeFilterImpl.SHOW_DOCUMENT_FRAGMENT = 0x400;
    NodeFilterImpl.SHOW_NOTATION = 0x800;
    return NodeFilterImpl;
}());
exports.NodeFilterImpl = NodeFilterImpl;
/**
 * Define constants on prototype.
 */
WebIDLAlgorithm_1.idl_defineConst(NodeFilterImpl.prototype, "FILTER_ACCEPT", 1);
WebIDLAlgorithm_1.idl_defineConst(NodeFilterImpl.prototype, "FILTER_REJECT", 2);
WebIDLAlgorithm_1.idl_defineConst(NodeFilterImpl.prototype, "FILTER_SKIP", 3);
WebIDLAlgorithm_1.idl_defineConst(NodeFilterImpl.prototype, "SHOW_ALL", 0xffffffff);
WebIDLAlgorithm_1.idl_defineConst(NodeFilterImpl.prototype, "SHOW_ELEMENT", 0x1);
WebIDLAlgorithm_1.idl_defineConst(NodeFilterImpl.prototype, "SHOW_ATTRIBUTE", 0x2);
WebIDLAlgorithm_1.idl_defineConst(NodeFilterImpl.prototype, "SHOW_TEXT", 0x4);
WebIDLAlgorithm_1.idl_defineConst(NodeFilterImpl.prototype, "SHOW_CDATA_SECTION", 0x8);
WebIDLAlgorithm_1.idl_defineConst(NodeFilterImpl.prototype, "SHOW_ENTITY_REFERENCE", 0x10);
WebIDLAlgorithm_1.idl_defineConst(NodeFilterImpl.prototype, "SHOW_ENTITY", 0x20);
WebIDLAlgorithm_1.idl_defineConst(NodeFilterImpl.prototype, "SHOW_PROCESSING_INSTRUCTION", 0x40);
WebIDLAlgorithm_1.idl_defineConst(NodeFilterImpl.prototype, "SHOW_COMMENT", 0x80);
WebIDLAlgorithm_1.idl_defineConst(NodeFilterImpl.prototype, "SHOW_DOCUMENT", 0x100);
WebIDLAlgorithm_1.idl_defineConst(NodeFilterImpl.prototype, "SHOW_DOCUMENT_TYPE", 0x200);
WebIDLAlgorithm_1.idl_defineConst(NodeFilterImpl.prototype, "SHOW_DOCUMENT_FRAGMENT", 0x400);
WebIDLAlgorithm_1.idl_defineConst(NodeFilterImpl.prototype, "SHOW_NOTATION", 0x800);
//# sourceMappingURL=NodeFilterImpl.js.map

/***/ }),

/***/ 2280:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var DOMImpl_1 = __nccwpck_require__(698);
var interfaces_1 = __nccwpck_require__(9454);
var EventTargetImpl_1 = __nccwpck_require__(3611);
var util_1 = __nccwpck_require__(628);
var DOMException_1 = __nccwpck_require__(7175);
var algorithm_1 = __nccwpck_require__(6573);
var URLAlgorithm_1 = __nccwpck_require__(3650);
var WebIDLAlgorithm_1 = __nccwpck_require__(4239);
/**
 * Represents a generic XML node.
 */
var NodeImpl = /** @class */ (function (_super) {
    __extends(NodeImpl, _super);
    /**
     * Initializes a new instance of `Node`.
     */
    function NodeImpl() {
        var _this = _super.call(this) || this;
        _this._parent = null;
        _this._firstChild = null;
        _this._lastChild = null;
        _this._previousSibling = null;
        _this._nextSibling = null;
        return _this;
    }
    Object.defineProperty(NodeImpl.prototype, "_childNodes", {
        get: function () {
            return this.__childNodes || (this.__childNodes = algorithm_1.create_nodeList(this));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NodeImpl.prototype, "_nodeDocument", {
        get: function () { return this._nodeDocumentOverride || DOMImpl_1.dom.window._associatedDocument; },
        set: function (val) { this._nodeDocumentOverride = val; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NodeImpl.prototype, "_registeredObserverList", {
        get: function () {
            return this.__registeredObserverList || (this.__registeredObserverList = []);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NodeImpl.prototype, "nodeType", {
        /** @inheritdoc */
        get: function () { return this._nodeType; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NodeImpl.prototype, "nodeName", {
        /**
         * Returns a string appropriate for the type of node.
         */
        get: function () {
            if (util_1.Guard.isElementNode(this)) {
                return this._htmlUppercasedQualifiedName;
            }
            else if (util_1.Guard.isAttrNode(this)) {
                return this._qualifiedName;
            }
            else if (util_1.Guard.isExclusiveTextNode(this)) {
                return "#text";
            }
            else if (util_1.Guard.isCDATASectionNode(this)) {
                return "#cdata-section";
            }
            else if (util_1.Guard.isProcessingInstructionNode(this)) {
                return this._target;
            }
            else if (util_1.Guard.isCommentNode(this)) {
                return "#comment";
            }
            else if (util_1.Guard.isDocumentNode(this)) {
                return "#document";
            }
            else if (util_1.Guard.isDocumentTypeNode(this)) {
                return this._name;
            }
            else if (util_1.Guard.isDocumentFragmentNode(this)) {
                return "#document-fragment";
            }
            else {
                return "";
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NodeImpl.prototype, "baseURI", {
        /**
         * Gets the absolute base URL of the node.
         */
        get: function () {
            /**
             * The baseURI attribute’s getter must return node document’s document
             * base URL, serialized.
             * TODO: Implement in HTML DOM
             * https://html.spec.whatwg.org/multipage/urls-and-fetching.html#document-base-url
             */
            return URLAlgorithm_1.urlSerializer(this._nodeDocument._URL);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NodeImpl.prototype, "isConnected", {
        /**
         * Returns whether the node is rooted to a document node.
         */
        get: function () {
            /**
             * The isConnected attribute’s getter must return true, if context object
             * is connected, and false otherwise.
             */
            return util_1.Guard.isElementNode(this) && algorithm_1.shadowTree_isConnected(this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NodeImpl.prototype, "ownerDocument", {
        /**
         * Returns the parent document.
         */
        get: function () {
            /**
             * The ownerDocument attribute’s getter must return null, if the context
             * object is a document, and the context object’s node document otherwise.
             * _Note:_ The node document of a document is that document itself. All
             * nodes have a node document at all times.
             */
            if (this._nodeType === interfaces_1.NodeType.Document)
                return null;
            else
                return this._nodeDocument;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns the root node.
     *
     * @param options - if options has `composed = true` this function
     * returns the node's shadow-including root, otherwise it returns
     * the node's root node.
     */
    NodeImpl.prototype.getRootNode = function (options) {
        /**
         * The getRootNode(options) method, when invoked, must return context
         * object’s shadow-including root if options’s composed is true,
         * and context object’s root otherwise.
         */
        return algorithm_1.tree_rootNode(this, !!options && options.composed);
    };
    Object.defineProperty(NodeImpl.prototype, "parentNode", {
        /**
         * Returns the parent node.
         */
        get: function () {
            /**
             * The parentNode attribute’s getter must return the context object’s parent.
             * _Note:_ An Attr node has no parent.
             */
            if (this._nodeType === interfaces_1.NodeType.Attribute) {
                return null;
            }
            else {
                return this._parent;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NodeImpl.prototype, "parentElement", {
        /**
         * Returns the parent element.
         */
        get: function () {
            /**
             * The parentElement attribute’s getter must return the context object’s
             * parent element.
             */
            if (this._parent && util_1.Guard.isElementNode(this._parent)) {
                return this._parent;
            }
            else {
                return null;
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Determines whether a node has any children.
     */
    NodeImpl.prototype.hasChildNodes = function () {
        /**
         * The hasChildNodes() method, when invoked, must return true if the context
         * object has children, and false otherwise.
         */
        return (this._firstChild !== null);
    };
    Object.defineProperty(NodeImpl.prototype, "childNodes", {
        /**
         * Returns a {@link NodeList} of child nodes.
         */
        get: function () {
            /**
             * The childNodes attribute’s getter must return a NodeList rooted at the
             * context object matching only children.
             */
            return this._childNodes;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NodeImpl.prototype, "firstChild", {
        /**
         * Returns the first child node.
         */
        get: function () {
            /**
             * The firstChild attribute’s getter must return the context object’s first
             * child.
             */
            return this._firstChild;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NodeImpl.prototype, "lastChild", {
        /**
         * Returns the last child node.
         */
        get: function () {
            /**
             * The lastChild attribute’s getter must return the context object’s last
             * child.
             */
            return this._lastChild;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NodeImpl.prototype, "previousSibling", {
        /**
         * Returns the previous sibling node.
         */
        get: function () {
            /**
             * The previousSibling attribute’s getter must return the context object’s
             * previous sibling.
             * _Note:_ An Attr node has no siblings.
             */
            return this._previousSibling;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NodeImpl.prototype, "nextSibling", {
        /**
         * Returns the next sibling node.
         */
        get: function () {
            /**
             * The nextSibling attribute’s getter must return the context object’s
             * next sibling.
             */
            return this._nextSibling;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NodeImpl.prototype, "nodeValue", {
        /**
         * Gets or sets the data associated with a {@link CharacterData} node or the
         * value of an {@link @Attr} node. For other node types returns `null`.
         */
        get: function () {
            if (util_1.Guard.isAttrNode(this)) {
                return this._value;
            }
            else if (util_1.Guard.isCharacterDataNode(this)) {
                return this._data;
            }
            else {
                return null;
            }
        },
        set: function (value) {
            if (value === null) {
                value = '';
            }
            if (util_1.Guard.isAttrNode(this)) {
                algorithm_1.attr_setAnExistingAttributeValue(this, value);
            }
            else if (util_1.Guard.isCharacterDataNode(this)) {
                algorithm_1.characterData_replaceData(this, 0, this._data.length, value);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NodeImpl.prototype, "textContent", {
        /**
         * Returns the concatenation of data of all the {@link Text}
         * node descendants in tree order. When set, replaces the text
         * contents of the node with the given value.
         */
        get: function () {
            if (util_1.Guard.isDocumentFragmentNode(this) || util_1.Guard.isElementNode(this)) {
                return algorithm_1.text_descendantTextContent(this);
            }
            else if (util_1.Guard.isAttrNode(this)) {
                return this._value;
            }
            else if (util_1.Guard.isCharacterDataNode(this)) {
                return this._data;
            }
            else {
                return null;
            }
        },
        set: function (value) {
            if (value === null) {
                value = '';
            }
            if (util_1.Guard.isDocumentFragmentNode(this) || util_1.Guard.isElementNode(this)) {
                algorithm_1.node_stringReplaceAll(value, this);
            }
            else if (util_1.Guard.isAttrNode(this)) {
                algorithm_1.attr_setAnExistingAttributeValue(this, value);
            }
            else if (util_1.Guard.isCharacterDataNode(this)) {
                algorithm_1.characterData_replaceData(this, 0, algorithm_1.tree_nodeLength(this), value);
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Puts all {@link Text} nodes in the full depth of the sub-tree
     * underneath this node into a "normal" form where only markup
     * (e.g., tags, comments, processing instructions, CDATA sections,
     * and entity references) separates {@link Text} nodes, i.e., there
     * are no adjacent Text nodes.
     */
    NodeImpl.prototype.normalize = function () {
        var e_1, _a, e_2, _b;
        /**
         * The normalize() method, when invoked, must run these steps for each
         * descendant exclusive Text node node of context object:
         */
        var descendantNodes = [];
        var node = algorithm_1.tree_getFirstDescendantNode(this, false, false, function (e) { return util_1.Guard.isExclusiveTextNode(e); });
        while (node !== null) {
            descendantNodes.push(node);
            node = algorithm_1.tree_getNextDescendantNode(this, node, false, false, function (e) { return util_1.Guard.isExclusiveTextNode(e); });
        }
        for (var i = 0; i < descendantNodes.length; i++) {
            var node_1 = descendantNodes[i];
            if (node_1._parent === null)
                continue;
            /**
             * 1. Let length be node’s length.
             * 2. If length is zero, then remove node and continue with the next
             * exclusive Text node, if any.
             */
            var length = algorithm_1.tree_nodeLength(node_1);
            if (length === 0) {
                algorithm_1.mutation_remove(node_1, node_1._parent);
                continue;
            }
            /**
             * 3. Let data be the concatenation of the data of node’s contiguous
             * exclusive Text nodes (excluding itself), in tree order.
             */
            var textSiblings = [];
            var data = '';
            try {
                for (var _c = (e_1 = void 0, __values(algorithm_1.text_contiguousExclusiveTextNodes(node_1))), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var sibling = _d.value;
                    textSiblings.push(sibling);
                    data += sibling._data;
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                }
                finally { if (e_1) throw e_1.error; }
            }
            /**
             * 4. Replace data with node node, offset length, count 0, and data data.
             */
            algorithm_1.characterData_replaceData(node_1, length, 0, data);
            /**
             * 5. Let currentNode be node’s next sibling.
             * 6. While currentNode is an exclusive Text node:
             */
            if (DOMImpl_1.dom.rangeList.size !== 0) {
                var currentNode = node_1._nextSibling;
                while (currentNode !== null && util_1.Guard.isExclusiveTextNode(currentNode)) {
                    /**
                     * 6.1. For each live range whose start node is currentNode, add length
                     * to its start offset and set its start node to node.
                     * 6.2. For each live range whose end node is currentNode, add length to
                     * its end offset and set its end node to node.
                     * 6.3. For each live range whose start node is currentNode’s parent and
                     * start offset is currentNode’s index, set its start node to node and
                     * its start offset to length.
                     * 6.4. For each live range whose end node is currentNode’s parent and
                     * end offset is currentNode’s index, set its end node to node and its
                     * end offset to length.
                     */
                    var cn = currentNode;
                    var index = algorithm_1.tree_index(cn);
                    try {
                        for (var _e = (e_2 = void 0, __values(DOMImpl_1.dom.rangeList)), _f = _e.next(); !_f.done; _f = _e.next()) {
                            var range = _f.value;
                            if (range._start[0] === cn) {
                                range._start[0] = node_1;
                                range._start[1] += length;
                            }
                            if (range._end[0] === cn) {
                                range._end[0] = node_1;
                                range._end[1] += length;
                            }
                            if (range._start[0] === cn._parent && range._start[1] === index) {
                                range._start[0] = node_1;
                                range._start[1] = length;
                            }
                            if (range._end[0] === cn._parent && range._end[1] === index) {
                                range._end[0] = node_1;
                                range._end[1] = length;
                            }
                        }
                    }
                    catch (e_2_1) { e_2 = { error: e_2_1 }; }
                    finally {
                        try {
                            if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                        }
                        finally { if (e_2) throw e_2.error; }
                    }
                    /**
                     * 6.5. Add currentNode’s length to length.
                     * 6.6. Set currentNode to its next sibling.
                     */
                    length += algorithm_1.tree_nodeLength(currentNode);
                    currentNode = currentNode._nextSibling;
                }
            }
            /**
             * 7. Remove node’s contiguous exclusive Text nodes (excluding itself),
             * in tree order.
             */
            for (var i_1 = 0; i_1 < textSiblings.length; i_1++) {
                var sibling = textSiblings[i_1];
                if (sibling._parent === null)
                    continue;
                algorithm_1.mutation_remove(sibling, sibling._parent);
            }
        }
    };
    /**
     * Returns a duplicate of this node, i.e., serves as a generic copy
     * constructor for nodes. The duplicate node has no parent
     * ({@link parentNode} returns `null`).
     *
     * @param deep - if `true`, recursively clone the subtree under the
     * specified node. If `false`, clone only the node itself (and its
     * attributes, if it is an {@link Element}).
     */
    NodeImpl.prototype.cloneNode = function (deep) {
        if (deep === void 0) { deep = false; }
        /**
         * 1. If context object is a shadow root, then throw a "NotSupportedError"
         * DOMException.
         * 2. Return a clone of the context object, with the clone children flag set
         * if deep is true.
         */
        if (util_1.Guard.isShadowRoot(this))
            throw new DOMException_1.NotSupportedError();
        return algorithm_1.node_clone(this, null, deep);
    };
    /**
     * Determines if the given node is equal to this one.
     *
     * @param node - the node to compare with
     */
    NodeImpl.prototype.isEqualNode = function (node) {
        if (node === void 0) { node = null; }
        /**
         * The isEqualNode(otherNode) method, when invoked, must return true if
         * otherNode is non-null and context object equals otherNode, and false
         * otherwise.
         */
        return (node !== null && algorithm_1.node_equals(this, node));
    };
    /**
     * Determines if the given node is reference equal to this one.
     *
     * @param node - the node to compare with
     */
    NodeImpl.prototype.isSameNode = function (node) {
        if (node === void 0) { node = null; }
        /**
         * The isSameNode(otherNode) method, when invoked, must return true if
         * otherNode is context object, and false otherwise.
         */
        return (this === node);
    };
    /**
     * Returns a bitmask indicating the position of the given `node`
     * relative to this node.
     */
    NodeImpl.prototype.compareDocumentPosition = function (other) {
        /**
         * 1. If context object is other, then return zero.
         * 2. Let node1 be other and node2 be context object.
         * 3. Let attr1 and attr2 be null.
         * attr1’s element.
         */
        if (other === this)
            return 0;
        var node1 = other;
        var node2 = this;
        var attr1 = null;
        var attr2 = null;
        /**
         * 4. If node1 is an attribute, then set attr1 to node1 and node1 to
         * attr1’s element.
         */
        if (util_1.Guard.isAttrNode(node1)) {
            attr1 = node1;
            node1 = attr1._element;
        }
        /**
         * 5. If node2 is an attribute, then:
         */
        if (util_1.Guard.isAttrNode(node2)) {
            /**
             * 5.1. Set attr2 to node2 and node2 to attr2’s element.
             */
            attr2 = node2;
            node2 = attr2._element;
            /**
             * 5.2. If attr1 and node1 are non-null, and node2 is node1, then:
             */
            if (attr1 && node1 && (node1 === node2)) {
                /**
                 * 5.2. For each attr in node2’s attribute list:
                 */
                for (var i = 0; i < node2._attributeList.length; i++) {
                    var attr = node2._attributeList[i];
                    /**
                     * 5.2.1. If attr equals attr1, then return the result of adding
                     * DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC and
                     * DOCUMENT_POSITION_PRECEDING.
                     * 5.2.2. If attr equals attr2, then return the result of adding
                     * DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC and
                     * DOCUMENT_POSITION_FOLLOWING.
                     */
                    if (algorithm_1.node_equals(attr, attr1)) {
                        return interfaces_1.Position.ImplementationSpecific | interfaces_1.Position.Preceding;
                    }
                    else if (algorithm_1.node_equals(attr, attr2)) {
                        return interfaces_1.Position.ImplementationSpecific | interfaces_1.Position.Following;
                    }
                }
            }
        }
        /**
         * 6. If node1 or node2 is null, or node1’s root is not node2’s root, then
         * return the result of adding DOCUMENT_POSITION_DISCONNECTED,
         * DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC, and either
         * DOCUMENT_POSITION_PRECEDING or DOCUMENT_POSITION_FOLLOWING,
         * with the constraint that this is to be consistent, together.
         */
        if (node1 === null || node2 === null ||
            algorithm_1.tree_rootNode(node1) !== algorithm_1.tree_rootNode(node2)) {
            // nodes are disconnected
            // return a random result but cache the value for consistency
            return interfaces_1.Position.Disconnected | interfaces_1.Position.ImplementationSpecific |
                (DOMImpl_1.dom.compareCache.check(this, other) ? interfaces_1.Position.Preceding : interfaces_1.Position.Following);
        }
        /**
         * 7. If node1 is an ancestor of node2 and attr1 is null, or node1 is node2
         * and attr2 is non-null, then return the result of adding
         * DOCUMENT_POSITION_CONTAINS to DOCUMENT_POSITION_PRECEDING.
         */
        if ((!attr1 && algorithm_1.tree_isAncestorOf(node2, node1)) ||
            (attr2 && (node1 === node2))) {
            return interfaces_1.Position.Contains | interfaces_1.Position.Preceding;
        }
        /**
         * 8. If node1 is a descendant of node2 and attr2 is null, or node1 is node2
         * and attr1 is non-null, then return the result of adding
         * DOCUMENT_POSITION_CONTAINED_BY to DOCUMENT_POSITION_FOLLOWING.
         */
        if ((!attr2 && algorithm_1.tree_isDescendantOf(node2, node1)) ||
            (attr1 && (node1 === node2))) {
            return interfaces_1.Position.ContainedBy | interfaces_1.Position.Following;
        }
        /**
         * 9. If node1 is preceding node2, then return DOCUMENT_POSITION_PRECEDING.
         */
        if (algorithm_1.tree_isPreceding(node2, node1))
            return interfaces_1.Position.Preceding;
        /**
         * 10. Return DOCUMENT_POSITION_FOLLOWING.
         */
        return interfaces_1.Position.Following;
    };
    /**
     * Returns `true` if given node is an inclusive descendant of this
     * node, and `false` otherwise (including when other node is `null`).
     *
     * @param other - the node to check
     */
    NodeImpl.prototype.contains = function (other) {
        /**
         * The contains(other) method, when invoked, must return true if other is an
         * inclusive descendant of context object, and false otherwise (including
         * when other is null).
         */
        if (other === null)
            return false;
        return algorithm_1.tree_isDescendantOf(this, other, true);
    };
    /**
     * Returns the prefix for a given namespace URI, if present, and
     * `null` if not.
     *
     * @param namespace - the namespace to search
     */
    NodeImpl.prototype.lookupPrefix = function (namespace) {
        /**
         * 1. If namespace is null or the empty string, then return null.
         * 2. Switch on the context object:
         */
        if (!namespace)
            return null;
        if (util_1.Guard.isElementNode(this)) {
            /**
             * Return the result of locating a namespace prefix for it using
             * namespace.
             */
            return algorithm_1.node_locateANamespacePrefix(this, namespace);
        }
        else if (util_1.Guard.isDocumentNode(this)) {
            /**
             * Return the result of locating a namespace prefix for its document
             * element, if its document element is non-null, and null otherwise.
             */
            if (this.documentElement === null) {
                return null;
            }
            else {
                return algorithm_1.node_locateANamespacePrefix(this.documentElement, namespace);
            }
        }
        else if (util_1.Guard.isDocumentTypeNode(this) || util_1.Guard.isDocumentFragmentNode(this)) {
            return null;
        }
        else if (util_1.Guard.isAttrNode(this)) {
            /**
             * Return the result of locating a namespace prefix for its element,
             * if its element is non-null, and null otherwise.
             */
            if (this._element === null) {
                return null;
            }
            else {
                return algorithm_1.node_locateANamespacePrefix(this._element, namespace);
            }
        }
        else {
            /**
             * Return the result of locating a namespace prefix for its parent
             * element, if its parent element is non-null, and null otherwise.
             */
            if (this._parent !== null && util_1.Guard.isElementNode(this._parent)) {
                return algorithm_1.node_locateANamespacePrefix(this._parent, namespace);
            }
            else {
                return null;
            }
        }
    };
    /**
     * Returns the namespace URI for a given prefix if present, and `null`
     * if not.
     *
     * @param prefix - the prefix to search
     */
    NodeImpl.prototype.lookupNamespaceURI = function (prefix) {
        /**
         * 1. If prefix is the empty string, then set it to null.
         * 2. Return the result of running locate a namespace for the context object
         * using prefix.
         */
        return algorithm_1.node_locateANamespace(this, prefix || null);
    };
    /**
     * Returns `true` if the namespace is the default namespace on this
     * node or `false` if not.
     *
     * @param namespace - the namespace to check
     */
    NodeImpl.prototype.isDefaultNamespace = function (namespace) {
        /**
         * 1. If namespace is the empty string, then set it to null.
         * 2. Let defaultNamespace be the result of running locate a namespace for
         * context object using null.
         * 3. Return true if defaultNamespace is the same as namespace, and false otherwise.
         */
        if (!namespace)
            namespace = null;
        var defaultNamespace = algorithm_1.node_locateANamespace(this, null);
        return (defaultNamespace === namespace);
    };
    /**
     * Inserts the node `newChild` before the existing child node
     * `refChild`. If `refChild` is `null`, inserts `newChild` at the end
     * of the list of children.
     *
     * If `newChild` is a {@link DocumentFragment} object, all of its
     * children are inserted, in the same order, before `refChild`.
     *
     * If `newChild` is already in the tree, it is first removed.
     *
     * @param newChild - the node to insert
     * @param refChild - the node before which the new node must be
     *   inserted
     *
     * @returns the newly inserted child node
     */
    NodeImpl.prototype.insertBefore = function (newChild, refChild) {
        /**
         * The insertBefore(node, child) method, when invoked, must return the
         * result of pre-inserting node into context object before child.
         */
        return algorithm_1.mutation_preInsert(newChild, this, refChild);
    };
    /**
     * Adds the node `newChild` to the end of the list of children of this
     * node, and returns it. If `newChild` is already in the tree, it is
     * first removed.
     *
     * If `newChild` is a {@link DocumentFragment} object, the entire
     * contents of the document fragment are moved into the child list of
     * this node.
     *
     * @param newChild - the node to add
     *
     * @returns the newly inserted child node
     */
    NodeImpl.prototype.appendChild = function (newChild) {
        /**
         * The appendChild(node) method, when invoked, must return the result of
         * appending node to context object.
         */
        return algorithm_1.mutation_append(newChild, this);
    };
    /**
     * Replaces the child node `oldChild` with `newChild` in the list of
     * children, and returns the `oldChild` node. If `newChild` is already
     * in the tree, it is first removed.
     *
     * @param newChild - the new node to put in the child list
     * @param oldChild - the node being replaced in the list
     *
     * @returns the removed child node
     */
    NodeImpl.prototype.replaceChild = function (newChild, oldChild) {
        /**
         * The replaceChild(node, child) method, when invoked, must return the
         * result of replacing child with node within context object.
         */
        return algorithm_1.mutation_replace(oldChild, newChild, this);
    };
    /**
    * Removes the child node indicated by `oldChild` from the list of
    * children, and returns it.
    *
    * @param oldChild - the node being removed from the list
    *
    * @returns the removed child node
    */
    NodeImpl.prototype.removeChild = function (oldChild) {
        /**
         * The removeChild(child) method, when invoked, must return the result of
         * pre-removing child from context object.
         */
        return algorithm_1.mutation_preRemove(oldChild, this);
    };
    /**
     * Gets the parent event target for the given event.
     *
     * @param event - an event
     */
    NodeImpl.prototype._getTheParent = function (event) {
        /**
         * A node’s get the parent algorithm, given an event, returns the node’s
         * assigned slot, if node is assigned, and node’s parent otherwise.
         */
        if (util_1.Guard.isSlotable(this) && algorithm_1.shadowTree_isAssigned(this)) {
            return this._assignedSlot;
        }
        else {
            return this._parent;
        }
    };
    NodeImpl.ELEMENT_NODE = 1;
    NodeImpl.ATTRIBUTE_NODE = 2;
    NodeImpl.TEXT_NODE = 3;
    NodeImpl.CDATA_SECTION_NODE = 4;
    NodeImpl.ENTITY_REFERENCE_NODE = 5;
    NodeImpl.ENTITY_NODE = 6;
    NodeImpl.PROCESSING_INSTRUCTION_NODE = 7;
    NodeImpl.COMMENT_NODE = 8;
    NodeImpl.DOCUMENT_NODE = 9;
    NodeImpl.DOCUMENT_TYPE_NODE = 10;
    NodeImpl.DOCUMENT_FRAGMENT_NODE = 11;
    NodeImpl.NOTATION_NODE = 12;
    NodeImpl.DOCUMENT_POSITION_DISCONNECTED = 0x01;
    NodeImpl.DOCUMENT_POSITION_PRECEDING = 0x02;
    NodeImpl.DOCUMENT_POSITION_FOLLOWING = 0x04;
    NodeImpl.DOCUMENT_POSITION_CONTAINS = 0x08;
    NodeImpl.DOCUMENT_POSITION_CONTAINED_BY = 0x10;
    NodeImpl.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = 0x20;
    return NodeImpl;
}(EventTargetImpl_1.EventTargetImpl));
exports.NodeImpl = NodeImpl;
/**
 * A performance tweak to share an empty set between all node classes. This will
 * be overwritten by element, document and document fragment nodes to supply an
 * actual set of nodes.
 */
NodeImpl.prototype._children = new util_1.EmptySet();
/**
 * Define constants on prototype.
 */
WebIDLAlgorithm_1.idl_defineConst(NodeImpl.prototype, "ELEMENT_NODE", 1);
WebIDLAlgorithm_1.idl_defineConst(NodeImpl.prototype, "ATTRIBUTE_NODE", 2);
WebIDLAlgorithm_1.idl_defineConst(NodeImpl.prototype, "TEXT_NODE", 3);
WebIDLAlgorithm_1.idl_defineConst(NodeImpl.prototype, "CDATA_SECTION_NODE", 4);
WebIDLAlgorithm_1.idl_defineConst(NodeImpl.prototype, "ENTITY_REFERENCE_NODE", 5);
WebIDLAlgorithm_1.idl_defineConst(NodeImpl.prototype, "ENTITY_NODE", 6);
WebIDLAlgorithm_1.idl_defineConst(NodeImpl.prototype, "PROCESSING_INSTRUCTION_NODE", 7);
WebIDLAlgorithm_1.idl_defineConst(NodeImpl.prototype, "COMMENT_NODE", 8);
WebIDLAlgorithm_1.idl_defineConst(NodeImpl.prototype, "DOCUMENT_NODE", 9);
WebIDLAlgorithm_1.idl_defineConst(NodeImpl.prototype, "DOCUMENT_TYPE_NODE", 10);
WebIDLAlgorithm_1.idl_defineConst(NodeImpl.prototype, "DOCUMENT_FRAGMENT_NODE", 11);
WebIDLAlgorithm_1.idl_defineConst(NodeImpl.prototype, "NOTATION_NODE", 12);
WebIDLAlgorithm_1.idl_defineConst(NodeImpl.prototype, "DOCUMENT_POSITION_DISCONNECTED", 0x01);
WebIDLAlgorithm_1.idl_defineConst(NodeImpl.prototype, "DOCUMENT_POSITION_PRECEDING", 0x02);
WebIDLAlgorithm_1.idl_defineConst(NodeImpl.prototype, "DOCUMENT_POSITION_FOLLOWING", 0x04);
WebIDLAlgorithm_1.idl_defineConst(NodeImpl.prototype, "DOCUMENT_POSITION_CONTAINS", 0x08);
WebIDLAlgorithm_1.idl_defineConst(NodeImpl.prototype, "DOCUMENT_POSITION_CONTAINED_BY", 0x10);
WebIDLAlgorithm_1.idl_defineConst(NodeImpl.prototype, "DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC", 0x20);
//# sourceMappingURL=NodeImpl.js.map

/***/ }),

/***/ 4142:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
var TraverserImpl_1 = __nccwpck_require__(8506);
var algorithm_1 = __nccwpck_require__(6573);
/**
 * Represents an object which can be used to iterate through the nodes
 * of a subtree.
 */
var NodeIteratorImpl = /** @class */ (function (_super) {
    __extends(NodeIteratorImpl, _super);
    /**
     * Initializes a new instance of `NodeIterator`.
     */
    function NodeIteratorImpl(root, reference, pointerBeforeReference) {
        var _this = _super.call(this, root) || this;
        _this._iteratorCollection = undefined;
        _this._reference = reference;
        _this._pointerBeforeReference = pointerBeforeReference;
        algorithm_1.nodeIterator_iteratorList().add(_this);
        return _this;
    }
    Object.defineProperty(NodeIteratorImpl.prototype, "referenceNode", {
        /** @inheritdoc */
        get: function () { return this._reference; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NodeIteratorImpl.prototype, "pointerBeforeReferenceNode", {
        /** @inheritdoc */
        get: function () { return this._pointerBeforeReference; },
        enumerable: true,
        configurable: true
    });
    /** @inheritdoc */
    NodeIteratorImpl.prototype.nextNode = function () {
        /**
         * The nextNode() method, when invoked, must return the result of
         * traversing with the context object and next.
         */
        return algorithm_1.nodeIterator_traverse(this, true);
    };
    /** @inheritdoc */
    NodeIteratorImpl.prototype.previousNode = function () {
        /**
         * The previousNode() method, when invoked, must return the result of
         * traversing with the context object and previous.
         */
        return algorithm_1.nodeIterator_traverse(this, false);
    };
    /** @inheritdoc */
    NodeIteratorImpl.prototype.detach = function () {
        /**
         * The detach() method, when invoked, must do nothing.
         *
         * since JS lacks weak references, we still use detach
         */
        algorithm_1.nodeIterator_iteratorList().delete(this);
    };
    /**
     * Creates a new `NodeIterator`.
     *
     * @param root - iterator's root node
     * @param reference - reference node
     * @param pointerBeforeReference - whether the iterator is before or after the
     * reference node
     */
    NodeIteratorImpl._create = function (root, reference, pointerBeforeReference) {
        return new NodeIteratorImpl(root, reference, pointerBeforeReference);
    };
    return NodeIteratorImpl;
}(TraverserImpl_1.TraverserImpl));
exports.NodeIteratorImpl = NodeIteratorImpl;
//# sourceMappingURL=NodeIteratorImpl.js.map

/***/ }),

/***/ 5788:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {


var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var DOMImpl_1 = __nccwpck_require__(698);
var util_1 = __nccwpck_require__(7061);
var algorithm_1 = __nccwpck_require__(6573);
/**
 * Represents an ordered set of nodes.
 */
var NodeListImpl = /** @class */ (function () {
    /**
     * Initializes a new instance of `NodeList`.
     *
     * @param root - root node
     */
    function NodeListImpl(root) {
        this._live = true;
        this._filter = null;
        this._length = 0;
        this._root = root;
        return new Proxy(this, this);
    }
    Object.defineProperty(NodeListImpl.prototype, "length", {
        /** @inheritdoc */
        get: function () {
            /**
             * The length attribute must return the number of nodes represented
             * by the collection.
             */
            return this._root._children.size;
        },
        enumerable: true,
        configurable: true
    });
    /** @inheritdoc */
    NodeListImpl.prototype.item = function (index) {
        /**
         * The item(index) method must return the indexth node in the collection.
         * If there is no indexth node in the collection, then the method must
         * return null.
         */
        if (index < 0 || index > this.length - 1)
            return null;
        if (index < this.length / 2) {
            var i = 0;
            var node = this._root._firstChild;
            while (node !== null && i !== index) {
                node = node._nextSibling;
                i++;
            }
            return node;
        }
        else {
            var i = this.length - 1;
            var node = this._root._lastChild;
            while (node !== null && i !== index) {
                node = node._previousSibling;
                i--;
            }
            return node;
        }
    };
    /** @inheritdoc */
    NodeListImpl.prototype.keys = function () {
        var _a;
        return _a = {},
            _a[Symbol.iterator] = function () {
                var index = 0;
                return {
                    next: function () {
                        if (index === this.length) {
                            return { done: true, value: null };
                        }
                        else {
                            return { done: false, value: index++ };
                        }
                    }.bind(this)
                };
            }.bind(this),
            _a;
    };
    /** @inheritdoc */
    NodeListImpl.prototype.values = function () {
        var _a;
        return _a = {},
            _a[Symbol.iterator] = function () {
                var it = this[Symbol.iterator]();
                return {
                    next: function () {
                        return it.next();
                    }
                };
            }.bind(this),
            _a;
    };
    /** @inheritdoc */
    NodeListImpl.prototype.entries = function () {
        var _a;
        return _a = {},
            _a[Symbol.iterator] = function () {
                var it = this[Symbol.iterator]();
                var index = 0;
                return {
                    next: function () {
                        var itResult = it.next();
                        if (itResult.done) {
                            return { done: true, value: null };
                        }
                        else {
                            return { done: false, value: [index++, itResult.value] };
                        }
                    }
                };
            }.bind(this),
            _a;
    };
    /** @inheritdoc */
    NodeListImpl.prototype[Symbol.iterator] = function () {
        return this._root._children[Symbol.iterator]();
    };
    /** @inheritdoc */
    NodeListImpl.prototype.forEach = function (callback, thisArg) {
        var e_1, _a;
        if (thisArg === undefined) {
            thisArg = DOMImpl_1.dom.window;
        }
        var index = 0;
        try {
            for (var _b = __values(this._root._children), _c = _b.next(); !_c.done; _c = _b.next()) {
                var node = _c.value;
                callback.call(thisArg, node, index++, this);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
    };
    /**
     * Implements a proxy get trap to provide array-like access.
     */
    NodeListImpl.prototype.get = function (target, key, receiver) {
        if (!util_1.isString(key)) {
            return Reflect.get(target, key, receiver);
        }
        var index = Number(key);
        if (isNaN(index)) {
            return Reflect.get(target, key, receiver);
        }
        return target.item(index) || undefined;
    };
    /**
     * Implements a proxy set trap to provide array-like access.
     */
    NodeListImpl.prototype.set = function (target, key, value, receiver) {
        if (!util_1.isString(key)) {
            return Reflect.set(target, key, value, receiver);
        }
        var index = Number(key);
        if (isNaN(index)) {
            return Reflect.set(target, key, value, receiver);
        }
        var node = target.item(index) || undefined;
        if (!node)
            return false;
        if (node._parent) {
            algorithm_1.mutation_replace(node, value, node._parent);
            return true;
        }
        else {
            return false;
        }
    };
    /**
     * Creates a new `NodeList`.
     *
     * @param root - root node
     */
    NodeListImpl._create = function (root) {
        return new NodeListImpl(root);
    };
    return NodeListImpl;
}());
exports.NodeListImpl = NodeListImpl;
//# sourceMappingURL=NodeListImpl.js.map

/***/ }),

/***/ 7654:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {


var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var DOMImpl_1 = __nccwpck_require__(698);
var util_1 = __nccwpck_require__(7061);
/**
 * Represents an ordered list of nodes.
 * This is a static implementation of `NodeList`.
 */
var NodeListStaticImpl = /** @class */ (function () {
    /**
     * Initializes a new instance of `NodeList`.
     *
     * @param root - root node
     */
    function NodeListStaticImpl(root) {
        this._live = false;
        this._items = [];
        this._length = 0;
        this._root = root;
        this._items = [];
        this._filter = function (node) { return true; };
        return new Proxy(this, this);
    }
    Object.defineProperty(NodeListStaticImpl.prototype, "length", {
        /** @inheritdoc */
        get: function () {
            /**
             * The length attribute must return the number of nodes represented by
             * the collection.
             */
            return this._items.length;
        },
        enumerable: true,
        configurable: true
    });
    /** @inheritdoc */
    NodeListStaticImpl.prototype.item = function (index) {
        /**
         * The item(index) method must return the indexth node in the collection.
         * If there is no indexth node in the collection, then the method must
         * return null.
         */
        if (index < 0 || index > this.length - 1)
            return null;
        return this._items[index];
    };
    /** @inheritdoc */
    NodeListStaticImpl.prototype.keys = function () {
        var _a;
        return _a = {},
            _a[Symbol.iterator] = function () {
                var index = 0;
                return {
                    next: function () {
                        if (index === this.length) {
                            return { done: true, value: null };
                        }
                        else {
                            return { done: false, value: index++ };
                        }
                    }.bind(this)
                };
            }.bind(this),
            _a;
    };
    /** @inheritdoc */
    NodeListStaticImpl.prototype.values = function () {
        var _a;
        return _a = {},
            _a[Symbol.iterator] = function () {
                var it = this[Symbol.iterator]();
                return {
                    next: function () {
                        return it.next();
                    }
                };
            }.bind(this),
            _a;
    };
    /** @inheritdoc */
    NodeListStaticImpl.prototype.entries = function () {
        var _a;
        return _a = {},
            _a[Symbol.iterator] = function () {
                var it = this[Symbol.iterator]();
                var index = 0;
                return {
                    next: function () {
                        var itResult = it.next();
                        if (itResult.done) {
                            return { done: true, value: null };
                        }
                        else {
                            return { done: false, value: [index++, itResult.value] };
                        }
                    }
                };
            }.bind(this),
            _a;
    };
    /** @inheritdoc */
    NodeListStaticImpl.prototype[Symbol.iterator] = function () {
        var it = this._items[Symbol.iterator]();
        return {
            next: function () {
                return it.next();
            }
        };
    };
    /** @inheritdoc */
    NodeListStaticImpl.prototype.forEach = function (callback, thisArg) {
        var e_1, _a;
        if (thisArg === undefined) {
            thisArg = DOMImpl_1.dom.window;
        }
        var index = 0;
        try {
            for (var _b = __values(this._items), _c = _b.next(); !_c.done; _c = _b.next()) {
                var node = _c.value;
                callback.call(thisArg, node, index++, this);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
    };
    /**
     * Implements a proxy get trap to provide array-like access.
     */
    NodeListStaticImpl.prototype.get = function (target, key, receiver) {
        if (!util_1.isString(key)) {
            return Reflect.get(target, key, receiver);
        }
        var index = Number(key);
        if (isNaN(index)) {
            return Reflect.get(target, key, receiver);
        }
        return target._items[index] || undefined;
    };
    /**
     * Implements a proxy set trap to provide array-like access.
     */
    NodeListStaticImpl.prototype.set = function (target, key, value, receiver) {
        if (!util_1.isString(key)) {
            return Reflect.set(target, key, value, receiver);
        }
        var index = Number(key);
        if (isNaN(index)) {
            return Reflect.set(target, key, value, receiver);
        }
        if (index >= 0 && index < target._items.length) {
            target._items[index] = value;
            return true;
        }
        else {
            return false;
        }
    };
    /**
     * Creates a new `NodeList`.
     *
     * @param root - root node
     * @param items - a list of items to initialize the list
     */
    NodeListStaticImpl._create = function (root, items) {
        var list = new NodeListStaticImpl(root);
        list._items = items;
        return list;
    };
    return NodeListStaticImpl;
}());
exports.NodeListStaticImpl = NodeListStaticImpl;
//# sourceMappingURL=NodeListStaticImpl.js.map

/***/ }),

/***/ 2256:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
var util_1 = __nccwpck_require__(628);
/**
 * Represents a mixin that extends child nodes that can have siblings
 * other than doctypes. This mixin is implemented by {@link Element} and
 * {@link CharacterData}.
 */
var NonDocumentTypeChildNodeImpl = /** @class */ (function () {
    function NonDocumentTypeChildNodeImpl() {
    }
    Object.defineProperty(NonDocumentTypeChildNodeImpl.prototype, "previousElementSibling", {
        /** @inheritdoc */
        get: function () {
            /**
             * The previousElementSibling attribute’s getter must return the first
             * preceding sibling that is an element, and null otherwise.
             */
            var node = util_1.Cast.asNode(this)._previousSibling;
            while (node) {
                if (util_1.Guard.isElementNode(node))
                    return node;
                else
                    node = node._previousSibling;
            }
            return null;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NonDocumentTypeChildNodeImpl.prototype, "nextElementSibling", {
        /** @inheritdoc */
        get: function () {
            /**
             * The nextElementSibling attribute’s getter must return the first
             * following sibling that is an element, and null otherwise.
             */
            var node = util_1.Cast.asNode(this)._nextSibling;
            while (node) {
                if (util_1.Guard.isElementNode(node))
                    return node;
                else
                    node = node._nextSibling;
            }
            return null;
        },
        enumerable: true,
        configurable: true
    });
    return NonDocumentTypeChildNodeImpl;
}());
exports.NonDocumentTypeChildNodeImpl = NonDocumentTypeChildNodeImpl;
//# sourceMappingURL=NonDocumentTypeChildNodeImpl.js.map

/***/ }),

/***/ 5325:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
var util_1 = __nccwpck_require__(628);
var algorithm_1 = __nccwpck_require__(6573);
/**
 * Represents a mixin that extends non-element parent nodes. This mixin
 * is implemented by {@link Document} and {@link DocumentFragment}.
 */
var NonElementParentNodeImpl = /** @class */ (function () {
    function NonElementParentNodeImpl() {
    }
    /** @inheritdoc */
    NonElementParentNodeImpl.prototype.getElementById = function (id) {
        /**
         * The getElementById(elementId) method, when invoked, must return the first
         * element, in tree order, within the context object’s descendants,
         * whose ID is elementId, and null if there is no such element otherwise.
         */
        var ele = algorithm_1.tree_getFirstDescendantNode(util_1.Cast.asNode(this), false, false, function (e) { return util_1.Guard.isElementNode(e); });
        while (ele !== null) {
            if (ele._uniqueIdentifier === id) {
                return ele;
            }
            ele = algorithm_1.tree_getNextDescendantNode(util_1.Cast.asNode(this), ele, false, false, function (e) { return util_1.Guard.isElementNode(e); });
        }
        return null;
    };
    return NonElementParentNodeImpl;
}());
exports.NonElementParentNodeImpl = NonElementParentNodeImpl;
//# sourceMappingURL=NonElementParentNodeImpl.js.map

/***/ }),

/***/ 1824:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {


var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var util_1 = __nccwpck_require__(628);
var algorithm_1 = __nccwpck_require__(6573);
/**
 * Represents a mixin that extends parent nodes that can have children.
 * This mixin is implemented by {@link Element}, {@link Document} and
 * {@link DocumentFragment}.
 */
var ParentNodeImpl = /** @class */ (function () {
    function ParentNodeImpl() {
    }
    Object.defineProperty(ParentNodeImpl.prototype, "children", {
        /** @inheritdoc */
        get: function () {
            /**
             * The children attribute’s getter must return an HTMLCollection collection
             * rooted at context object matching only element children.
             */
            return algorithm_1.create_htmlCollection(util_1.Cast.asNode(this));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ParentNodeImpl.prototype, "firstElementChild", {
        /** @inheritdoc */
        get: function () {
            /**
             * The firstElementChild attribute’s getter must return the first child
             * that is an element, and null otherwise.
             */
            var node = util_1.Cast.asNode(this)._firstChild;
            while (node) {
                if (util_1.Guard.isElementNode(node))
                    return node;
                else
                    node = node._nextSibling;
            }
            return null;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ParentNodeImpl.prototype, "lastElementChild", {
        /** @inheritdoc */
        get: function () {
            /**
             * The lastElementChild attribute’s getter must return the last child that
             * is an element, and null otherwise.
             */
            var node = util_1.Cast.asNode(this)._lastChild;
            while (node) {
                if (util_1.Guard.isElementNode(node))
                    return node;
                else
                    node = node._previousSibling;
            }
            return null;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ParentNodeImpl.prototype, "childElementCount", {
        /** @inheritdoc */
        get: function () {
            var e_1, _a;
            /**
             * The childElementCount attribute’s getter must return the number of
             * children of context object that are elements.
             */
            var count = 0;
            try {
                for (var _b = __values(util_1.Cast.asNode(this)._children), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var childNode = _c.value;
                    if (util_1.Guard.isElementNode(childNode))
                        count++;
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return count;
        },
        enumerable: true,
        configurable: true
    });
    /** @inheritdoc */
    ParentNodeImpl.prototype.prepend = function () {
        var nodes = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            nodes[_i] = arguments[_i];
        }
        /**
         * 1. Let node be the result of converting nodes into a node given nodes
         * and context object’s node document.
         * 2. Pre-insert node into context object before the context object’s first
         * child.
         */
        var node = util_1.Cast.asNode(this);
        var childNode = algorithm_1.parentNode_convertNodesIntoANode(nodes, node._nodeDocument);
        algorithm_1.mutation_preInsert(childNode, node, node._firstChild);
    };
    /** @inheritdoc */
    ParentNodeImpl.prototype.append = function () {
        var nodes = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            nodes[_i] = arguments[_i];
        }
        /**
         * 1. Let node be the result of converting nodes into a node given nodes
         * and context object’s node document.
         * 2. Append node to context object.
         */
        var node = util_1.Cast.asNode(this);
        var childNode = algorithm_1.parentNode_convertNodesIntoANode(nodes, node._nodeDocument);
        algorithm_1.mutation_append(childNode, node);
    };
    /** @inheritdoc */
    ParentNodeImpl.prototype.querySelector = function (selectors) {
        /**
         * The querySelector(selectors) method, when invoked, must return the first
         * result of running scope-match a selectors string selectors against
         * context object, if the result is not an empty list, and null otherwise.
         */
        var node = util_1.Cast.asNode(this);
        var result = algorithm_1.selectors_scopeMatchASelectorsString(selectors, node);
        return (result.length === 0 ? null : result[0]);
    };
    /** @inheritdoc */
    ParentNodeImpl.prototype.querySelectorAll = function (selectors) {
        /**
         * The querySelectorAll(selectors) method, when invoked, must return the
         * static result of running scope-match a selectors string selectors against
         * context object.
         */
        var node = util_1.Cast.asNode(this);
        var result = algorithm_1.selectors_scopeMatchASelectorsString(selectors, node);
        return algorithm_1.create_nodeListStatic(node, result);
    };
    return ParentNodeImpl;
}());
exports.ParentNodeImpl = ParentNodeImpl;
//# sourceMappingURL=ParentNodeImpl.js.map

/***/ }),

/***/ 2755:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
var interfaces_1 = __nccwpck_require__(9454);
var CharacterDataImpl_1 = __nccwpck_require__(765);
var WebIDLAlgorithm_1 = __nccwpck_require__(4239);
/**
 * Represents a processing instruction node.
 */
var ProcessingInstructionImpl = /** @class */ (function (_super) {
    __extends(ProcessingInstructionImpl, _super);
    /**
     * Initializes a new instance of `ProcessingInstruction`.
     */
    function ProcessingInstructionImpl(target, data) {
        var _this = _super.call(this, data) || this;
        _this._target = target;
        return _this;
    }
    Object.defineProperty(ProcessingInstructionImpl.prototype, "target", {
        /**
         * Gets the target of the {@link ProcessingInstruction} node.
         */
        get: function () { return this._target; },
        enumerable: true,
        configurable: true
    });
    /**
     * Creates a new `ProcessingInstruction`.
     *
     * @param document - owner document
     * @param target - instruction target
     * @param data - node contents
     */
    ProcessingInstructionImpl._create = function (document, target, data) {
        var node = new ProcessingInstructionImpl(target, data);
        node._nodeDocument = document;
        return node;
    };
    return ProcessingInstructionImpl;
}(CharacterDataImpl_1.CharacterDataImpl));
exports.ProcessingInstructionImpl = ProcessingInstructionImpl;
/**
 * Initialize prototype properties
 */
WebIDLAlgorithm_1.idl_defineConst(ProcessingInstructionImpl.prototype, "_nodeType", interfaces_1.NodeType.ProcessingInstruction);
//# sourceMappingURL=ProcessingInstructionImpl.js.map

/***/ }),

/***/ 3691:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var DOMImpl_1 = __nccwpck_require__(698);
var interfaces_1 = __nccwpck_require__(9454);
var AbstractRangeImpl_1 = __nccwpck_require__(3773);
var DOMException_1 = __nccwpck_require__(7175);
var algorithm_1 = __nccwpck_require__(6573);
var WebIDLAlgorithm_1 = __nccwpck_require__(4239);
var util_1 = __nccwpck_require__(628);
/**
 * Represents a live range.
 */
var RangeImpl = /** @class */ (function (_super) {
    __extends(RangeImpl, _super);
    /**
     * Initializes a new instance of `Range`.
     */
    function RangeImpl() {
        var _this = _super.call(this) || this;
        /**
         * The Range() constructor, when invoked, must return a new live range with
         * (current global object’s associated Document, 0) as its start and end.
         */
        var doc = DOMImpl_1.dom.window._associatedDocument;
        _this._start = [doc, 0];
        _this._end = [doc, 0];
        DOMImpl_1.dom.rangeList.add(_this);
        return _this;
    }
    Object.defineProperty(RangeImpl.prototype, "commonAncestorContainer", {
        /** @inheritdoc */
        get: function () {
            /**
             * 1. Let container be start node.
             * 2. While container is not an inclusive ancestor of end node, let
             * container be container’s parent.
             * 3. Return container.
             */
            var container = this._start[0];
            while (!algorithm_1.tree_isAncestorOf(this._end[0], container, true)) {
                if (container._parent === null) {
                    throw new Error("Parent node  is null.");
                }
                container = container._parent;
            }
            return container;
        },
        enumerable: true,
        configurable: true
    });
    /** @inheritdoc */
    RangeImpl.prototype.setStart = function (node, offset) {
        /**
         * The setStart(node, offset) method, when invoked, must set the start of
         * context object to boundary point (node, offset).
         */
        algorithm_1.range_setTheStart(this, node, offset);
    };
    /** @inheritdoc */
    RangeImpl.prototype.setEnd = function (node, offset) {
        /**
         * The setEnd(node, offset) method, when invoked, must set the end of
         * context object to boundary point (node, offset).
         */
        algorithm_1.range_setTheEnd(this, node, offset);
    };
    /** @inheritdoc */
    RangeImpl.prototype.setStartBefore = function (node) {
        /**
         * 1. Let parent be node’s parent.
         * 2. If parent is null, then throw an "InvalidNodeTypeError" DOMException.
         * 3. Set the start of the context object to boundary point
         * (parent, node’s index).
         */
        var parent = node._parent;
        if (parent === null)
            throw new DOMException_1.InvalidNodeTypeError();
        algorithm_1.range_setTheStart(this, parent, algorithm_1.tree_index(node));
    };
    /** @inheritdoc */
    RangeImpl.prototype.setStartAfter = function (node) {
        /**
         * 1. Let parent be node’s parent.
         * 2. If parent is null, then throw an "InvalidNodeTypeError" DOMException.
         * 3. Set the start of the context object to boundary point
         * (parent, node’s index plus 1).
         */
        var parent = node._parent;
        if (parent === null)
            throw new DOMException_1.InvalidNodeTypeError();
        algorithm_1.range_setTheStart(this, parent, algorithm_1.tree_index(node) + 1);
    };
    /** @inheritdoc */
    RangeImpl.prototype.setEndBefore = function (node) {
        /**
         * 1. Let parent be node’s parent.
         * 2. If parent is null, then throw an "InvalidNodeTypeError" DOMException.
         * 3. Set the end of the context object to boundary point
         * (parent, node’s index).
         */
        var parent = node._parent;
        if (parent === null)
            throw new DOMException_1.InvalidNodeTypeError();
        algorithm_1.range_setTheEnd(this, parent, algorithm_1.tree_index(node));
    };
    /** @inheritdoc */
    RangeImpl.prototype.setEndAfter = function (node) {
        /**
         * 1. Let parent be node’s parent.
         * 2. If parent is null, then throw an "InvalidNodeTypeError" DOMException.
         * 3. Set the end of the context object to boundary point
         * (parent, node’s index plus 1).
         */
        var parent = node._parent;
        if (parent === null)
            throw new DOMException_1.InvalidNodeTypeError();
        algorithm_1.range_setTheEnd(this, parent, algorithm_1.tree_index(node) + 1);
    };
    /** @inheritdoc */
    RangeImpl.prototype.collapse = function (toStart) {
        /**
         * The collapse(toStart) method, when invoked, must if toStart is true,
         * set end to start, and set start to end otherwise.
         */
        if (toStart) {
            this._end = this._start;
        }
        else {
            this._start = this._end;
        }
    };
    /** @inheritdoc */
    RangeImpl.prototype.selectNode = function (node) {
        /**
         * The selectNode(node) method, when invoked, must select node within
         * context object.
         */
        algorithm_1.range_select(node, this);
    };
    /** @inheritdoc */
    RangeImpl.prototype.selectNodeContents = function (node) {
        /**
         * 1. If node is a doctype, throw an "InvalidNodeTypeError" DOMException.
         * 2. Let length be the length of node.
         * 3. Set start to the boundary point (node, 0).
         * 4. Set end to the boundary point (node, length).
         */
        if (util_1.Guard.isDocumentTypeNode(node))
            throw new DOMException_1.InvalidNodeTypeError();
        var length = algorithm_1.tree_nodeLength(node);
        this._start = [node, 0];
        this._end = [node, length];
    };
    /** @inheritdoc */
    RangeImpl.prototype.compareBoundaryPoints = function (how, sourceRange) {
        /**
         * 1. If how is not one of
         * - START_TO_START,
         * - START_TO_END,
         * - END_TO_END, and
         * - END_TO_START,
         * then throw a "NotSupportedError" DOMException.
         */
        if (how !== interfaces_1.HowToCompare.StartToStart && how !== interfaces_1.HowToCompare.StartToEnd &&
            how !== interfaces_1.HowToCompare.EndToEnd && how !== interfaces_1.HowToCompare.EndToStart)
            throw new DOMException_1.NotSupportedError();
        /**
         * 2. If context object’s root is not the same as sourceRange’s root,
         * then throw a "WrongDocumentError" DOMException.
         */
        if (algorithm_1.range_root(this) !== algorithm_1.range_root(sourceRange))
            throw new DOMException_1.WrongDocumentError();
        /**
         * 3. If how is:
         * - START_TO_START:
         * Let this point be the context object’s start. Let other point be
         * sourceRange’s start.
         * - START_TO_END:
         * Let this point be the context object’s end. Let other point be
         * sourceRange’s start.
         * - END_TO_END:
         * Let this point be the context object’s end. Let other point be
         * sourceRange’s end.
         * - END_TO_START:
         * Let this point be the context object’s start. Let other point be
         * sourceRange’s end.
         */
        var thisPoint;
        var otherPoint;
        switch (how) {
            case interfaces_1.HowToCompare.StartToStart:
                thisPoint = this._start;
                otherPoint = sourceRange._start;
                break;
            case interfaces_1.HowToCompare.StartToEnd:
                thisPoint = this._end;
                otherPoint = sourceRange._start;
                break;
            case interfaces_1.HowToCompare.EndToEnd:
                thisPoint = this._end;
                otherPoint = sourceRange._end;
                break;
            case interfaces_1.HowToCompare.EndToStart:
                thisPoint = this._start;
                otherPoint = sourceRange._end;
                break;
            /* istanbul ignore next */
            default:
                throw new DOMException_1.NotSupportedError();
        }
        /**
         * 4. If the position of this point relative to other point is
         * - before
         * Return −1.
         * - equal
         * Return 0.
         * - after
         * Return 1.
         */
        var position = algorithm_1.boundaryPoint_position(thisPoint, otherPoint);
        if (position === interfaces_1.BoundaryPosition.Before) {
            return -1;
        }
        else if (position === interfaces_1.BoundaryPosition.After) {
            return 1;
        }
        else {
            return 0;
        }
    };
    /** @inheritdoc */
    RangeImpl.prototype.deleteContents = function () {
        var e_1, _a, e_2, _b;
        /**
         * 1. If the context object is collapsed, then return.
         * 2. Let original start node, original start offset, original end node,
         * and original end offset be the context object’s start node,
         * start offset, end node, and end offset, respectively.
         */
        if (algorithm_1.range_collapsed(this))
            return;
        var originalStartNode = this._startNode;
        var originalStartOffset = this._startOffset;
        var originalEndNode = this._endNode;
        var originalEndOffset = this._endOffset;
        /**
         * 3. If original start node and original end node are the same, and they
         * are a Text, ProcessingInstruction, or Comment node, replace data with
         * node original start node, offset original start offset, count original
         * end offset minus original start offset, and data the empty string,
         * and then return.
         */
        if (originalStartNode === originalEndNode &&
            util_1.Guard.isCharacterDataNode(originalStartNode)) {
            algorithm_1.characterData_replaceData(originalStartNode, originalStartOffset, originalEndOffset - originalStartOffset, '');
            return;
        }
        /**
         * 4. Let nodes to remove be a list of all the nodes that are contained in
         * the context object, in tree order, omitting any node whose parent is also
         * contained in the context object.
         */
        var nodesToRemove = [];
        try {
            for (var _c = __values(algorithm_1.range_getContainedNodes(this)), _d = _c.next(); !_d.done; _d = _c.next()) {
                var node = _d.value;
                var parent = node._parent;
                if (parent !== null && algorithm_1.range_isContained(parent, this)) {
                    continue;
                }
                nodesToRemove.push(node);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
            }
            finally { if (e_1) throw e_1.error; }
        }
        var newNode;
        var newOffset;
        if (algorithm_1.tree_isAncestorOf(originalEndNode, originalStartNode, true)) {
            /**
             * 5. If original start node is an inclusive ancestor of original end
             * node, set new node to original start node and new offset to original
             * start offset.
             */
            newNode = originalStartNode;
            newOffset = originalStartOffset;
        }
        else {
            /**
             * 6. Otherwise:
             * 6.1. Let reference node equal original start node.
             * 6.2. While reference node’s parent is not null and is not an inclusive
             * ancestor of original end node, set reference node to its parent.
             * 6.3. Set new node to the parent of reference node, and new offset to
             * one plus the index of reference node.
             */
            var referenceNode = originalStartNode;
            while (referenceNode._parent !== null &&
                !algorithm_1.tree_isAncestorOf(originalEndNode, referenceNode._parent, true)) {
                referenceNode = referenceNode._parent;
            }
            /* istanbul ignore next */
            if (referenceNode._parent === null) {
                throw new Error("Parent node is null.");
            }
            newNode = referenceNode._parent;
            newOffset = algorithm_1.tree_index(referenceNode) + 1;
        }
        /**
         * 7. If original start node is a Text, ProcessingInstruction, or Comment
         * node, replace data with node original start node, offset original start
         * offset, count original start node’s length minus original start offset,
         * data the empty string.
         */
        if (util_1.Guard.isCharacterDataNode(originalStartNode)) {
            algorithm_1.characterData_replaceData(originalStartNode, originalStartOffset, algorithm_1.tree_nodeLength(originalStartNode) - originalStartOffset, '');
        }
        try {
            /**
             * 8. For each node in nodes to remove, in tree order, remove node from its
             * parent.
             */
            for (var nodesToRemove_1 = __values(nodesToRemove), nodesToRemove_1_1 = nodesToRemove_1.next(); !nodesToRemove_1_1.done; nodesToRemove_1_1 = nodesToRemove_1.next()) {
                var node = nodesToRemove_1_1.value;
                /* istanbul ignore else */
                if (node._parent) {
                    algorithm_1.mutation_remove(node, node._parent);
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (nodesToRemove_1_1 && !nodesToRemove_1_1.done && (_b = nodesToRemove_1.return)) _b.call(nodesToRemove_1);
            }
            finally { if (e_2) throw e_2.error; }
        }
        /**
         * 9. If original end node is a Text, ProcessingInstruction, or Comment
         * node, replace data with node original end node, offset 0, count original
         * end offset and data the empty string.
         */
        if (util_1.Guard.isCharacterDataNode(originalEndNode)) {
            algorithm_1.characterData_replaceData(originalEndNode, 0, originalEndOffset, '');
        }
        /**
         * 10. Set start and end to (new node, new offset).
         */
        this._start = [newNode, newOffset];
        this._end = [newNode, newOffset];
    };
    /** @inheritdoc */
    RangeImpl.prototype.extractContents = function () {
        /**
         * The extractContents() method, when invoked, must return the result of
         * extracting the context object.
         */
        return algorithm_1.range_extract(this);
    };
    /** @inheritdoc */
    RangeImpl.prototype.cloneContents = function () {
        /**
         * The cloneContents() method, when invoked, must return the result of
         * cloning the contents of the context object.
         */
        return algorithm_1.range_cloneTheContents(this);
    };
    /** @inheritdoc */
    RangeImpl.prototype.insertNode = function (node) {
        /**
         * The insertNode(node) method, when invoked, must insert node into the
         * context object.
         */
        return algorithm_1.range_insert(node, this);
    };
    /** @inheritdoc */
    RangeImpl.prototype.surroundContents = function (newParent) {
        var e_3, _a;
        try {
            /**
             * 1. If a non-Text node is partially contained in the context object, then
             * throw an "InvalidStateError" DOMException.
             */
            for (var _b = __values(algorithm_1.range_getPartiallyContainedNodes(this)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var node = _c.value;
                if (!util_1.Guard.isTextNode(node)) {
                    throw new DOMException_1.InvalidStateError();
                }
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_3) throw e_3.error; }
        }
        /**
         * 2. If newParent is a Document, DocumentType, or DocumentFragment node,
         * then throw an "InvalidNodeTypeError" DOMException.
         */
        if (util_1.Guard.isDocumentNode(newParent) ||
            util_1.Guard.isDocumentTypeNode(newParent) ||
            util_1.Guard.isDocumentFragmentNode(newParent)) {
            throw new DOMException_1.InvalidNodeTypeError();
        }
        /**
         * 3. Let fragment be the result of extracting the context object.
         */
        var fragment = algorithm_1.range_extract(this);
        /**
         * 4. If newParent has children, then replace all with null within newParent.
         */
        if ((newParent)._children.size !== 0) {
            algorithm_1.mutation_replaceAll(null, newParent);
        }
        /**
         * 5. Insert newParent into the context object.
         * 6. Append fragment to newParent.
         */
        algorithm_1.range_insert(newParent, this);
        algorithm_1.mutation_append(fragment, newParent);
        /**
         * 7. Select newParent within the context object.
         */
        algorithm_1.range_select(newParent, this);
    };
    /** @inheritdoc */
    RangeImpl.prototype.cloneRange = function () {
        /**
         * The cloneRange() method, when invoked, must return a new live range with
         * the same start and end as the context object.
         */
        return algorithm_1.create_range(this._start, this._end);
    };
    /** @inheritdoc */
    RangeImpl.prototype.detach = function () {
        /**
         * The detach() method, when invoked, must do nothing.
         *
         * since JS lacks weak references, we still use detach
         */
        DOMImpl_1.dom.rangeList.delete(this);
    };
    /** @inheritdoc */
    RangeImpl.prototype.isPointInRange = function (node, offset) {
        /**
         * 1. If node’s root is different from the context object’s root, return false.
         */
        if (algorithm_1.tree_rootNode(node) !== algorithm_1.range_root(this)) {
            return false;
        }
        /**
         * 2. If node is a doctype, then throw an "InvalidNodeTypeError" DOMException.
         * 3. If offset is greater than node’s length, then throw an
         * "IndexSizeError" DOMException.
         */
        if (util_1.Guard.isDocumentTypeNode(node))
            throw new DOMException_1.InvalidNodeTypeError();
        if (offset > algorithm_1.tree_nodeLength(node))
            throw new DOMException_1.IndexSizeError();
        /**
         * 4. If (node, offset) is before start or after end, return false.
         */
        var bp = [node, offset];
        if (algorithm_1.boundaryPoint_position(bp, this._start) === interfaces_1.BoundaryPosition.Before ||
            algorithm_1.boundaryPoint_position(bp, this._end) === interfaces_1.BoundaryPosition.After) {
            return false;
        }
        /**
         * 5. Return true.
         */
        return true;
    };
    /** @inheritdoc */
    RangeImpl.prototype.comparePoint = function (node, offset) {
        /**
         * 1. If node’s root is different from the context object’s root, then throw
         * a "WrongDocumentError" DOMException.
         * 2. If node is a doctype, then throw an "InvalidNodeTypeError" DOMException.
         * 3. If offset is greater than node’s length, then throw an
         * "IndexSizeError" DOMException.
         */
        if (algorithm_1.tree_rootNode(node) !== algorithm_1.range_root(this))
            throw new DOMException_1.WrongDocumentError();
        if (util_1.Guard.isDocumentTypeNode(node))
            throw new DOMException_1.InvalidNodeTypeError();
        if (offset > algorithm_1.tree_nodeLength(node))
            throw new DOMException_1.IndexSizeError();
        /**
         * 4. If (node, offset) is before start, return −1.
         * 5. If (node, offset) is after end, return 1.
         * 6. Return 0.
         */
        var bp = [node, offset];
        if (algorithm_1.boundaryPoint_position(bp, this._start) === interfaces_1.BoundaryPosition.Before) {
            return -1;
        }
        else if (algorithm_1.boundaryPoint_position(bp, this._end) === interfaces_1.BoundaryPosition.After) {
            return 1;
        }
        else {
            return 0;
        }
    };
    /** @inheritdoc */
    RangeImpl.prototype.intersectsNode = function (node) {
        /**
         * 1. If node’s root is different from the context object’s root, return false.
         */
        if (algorithm_1.tree_rootNode(node) !== algorithm_1.range_root(this)) {
            return false;
        }
        /**
         * 2. Let parent be node’s parent.
         * 3. If parent is null, return true.
         */
        var parent = node._parent;
        if (parent === null)
            return true;
        /**
         * 4. Let offset be node’s index.
         */
        var offset = algorithm_1.tree_index(node);
        /**
         * 5. If (parent, offset) is before end and (parent, offset plus 1) is
         * after start, return true.
         */
        if (algorithm_1.boundaryPoint_position([parent, offset], this._end) === interfaces_1.BoundaryPosition.Before &&
            algorithm_1.boundaryPoint_position([parent, offset + 1], this._start) === interfaces_1.BoundaryPosition.After) {
            return true;
        }
        /**
         * 6. Return false.
         */
        return false;
    };
    RangeImpl.prototype.toString = function () {
        var e_4, _a;
        /**
         * 1. Let s be the empty string.
         */
        var s = '';
        /**
         * 2. If the context object’s start node is the context object’s end node
         * and it is a Text node, then return the substring of that Text node’s data
         * beginning at the context object’s start offset and ending at the context
         * object’s end offset.
         */
        if (this._startNode === this._endNode && util_1.Guard.isTextNode(this._startNode)) {
            return this._startNode._data.substring(this._startOffset, this._endOffset);
        }
        /**
         * 3. If the context object’s start node is a Text node, then append the
         * substring of that node’s data from the context object’s start offset
         * until the end to s.
         */
        if (util_1.Guard.isTextNode(this._startNode)) {
            s += this._startNode._data.substring(this._startOffset);
        }
        try {
            /**
             * 4. Append the concatenation of the data of all Text nodes that are
             * contained in the context object, in tree order, to s.
             */
            for (var _b = __values(algorithm_1.range_getContainedNodes(this)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var child = _c.value;
                if (util_1.Guard.isTextNode(child)) {
                    s += child._data;
                }
            }
        }
        catch (e_4_1) { e_4 = { error: e_4_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_4) throw e_4.error; }
        }
        /**
         * 5. If the context object’s end node is a Text node, then append the
         * substring of that node’s data from its start until the context object’s
         * end offset to s.
         */
        if (util_1.Guard.isTextNode(this._endNode)) {
            s += this._endNode._data.substring(0, this._endOffset);
        }
        /**
         * 6. Return s.
         */
        return s;
    };
    /**
     * Creates a new `Range`.
     *
     * @param start - start point
     * @param end - end point
     */
    RangeImpl._create = function (start, end) {
        var range = new RangeImpl();
        if (start)
            range._start = start;
        if (end)
            range._end = end;
        return range;
    };
    RangeImpl.START_TO_START = 0;
    RangeImpl.START_TO_END = 1;
    RangeImpl.END_TO_END = 2;
    RangeImpl.END_TO_START = 3;
    return RangeImpl;
}(AbstractRangeImpl_1.AbstractRangeImpl));
exports.RangeImpl = RangeImpl;
/**
 * Define constants on prototype.
 */
WebIDLAlgorithm_1.idl_defineConst(RangeImpl.prototype, "START_TO_START", 0);
WebIDLAlgorithm_1.idl_defineConst(RangeImpl.prototype, "START_TO_END", 1);
WebIDLAlgorithm_1.idl_defineConst(RangeImpl.prototype, "END_TO_END", 2);
WebIDLAlgorithm_1.idl_defineConst(RangeImpl.prototype, "END_TO_START", 3);
//# sourceMappingURL=RangeImpl.js.map

/***/ }),

/***/ 6092:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
var DocumentFragmentImpl_1 = __nccwpck_require__(9793);
var util_1 = __nccwpck_require__(7061);
var algorithm_1 = __nccwpck_require__(6573);
/**
 * Represents a shadow root.
 */
var ShadowRootImpl = /** @class */ (function (_super) {
    __extends(ShadowRootImpl, _super);
    /**
     * Initializes a new instance of `ShadowRoot`.
     *
     * @param host - shadow root's host element
     * @param mode - shadow root's mode
     */
    function ShadowRootImpl(host, mode) {
        var _this = _super.call(this) || this;
        _this._host = host;
        _this._mode = mode;
        return _this;
    }
    Object.defineProperty(ShadowRootImpl.prototype, "mode", {
        /** @inheritdoc */
        get: function () { return this._mode; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ShadowRootImpl.prototype, "host", {
        /** @inheritdoc */
        get: function () { return this._host; },
        enumerable: true,
        configurable: true
    });
    /**
     * Gets the parent event target for the given event.
     *
     * @param event - an event
     */
    ShadowRootImpl.prototype._getTheParent = function (event) {
        /**
         * A shadow root’s get the parent algorithm, given an event, returns null
         * if event’s composed flag is unset and shadow root is the root of
         * event’s path’s first struct’s invocation target, and shadow root’s host
         * otherwise.
         */
        if (!event._composedFlag && !util_1.isEmpty(event._path) &&
            algorithm_1.tree_rootNode(event._path[0].invocationTarget) === this) {
            return null;
        }
        else {
            return this._host;
        }
    };
    // MIXIN: DocumentOrShadowRoot
    // No elements
    /**
     * Creates a new `ShadowRoot`.
     *
     * @param document - owner document
     * @param host - shadow root's host element
     */
    ShadowRootImpl._create = function (document, host) {
        return new ShadowRootImpl(host, "closed");
    };
    return ShadowRootImpl;
}(DocumentFragmentImpl_1.DocumentFragmentImpl));
exports.ShadowRootImpl = ShadowRootImpl;
//# sourceMappingURL=ShadowRootImpl.js.map

/***/ }),

/***/ 3940:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
var algorithm_1 = __nccwpck_require__(6573);
/**
 * Represents a mixin that allows nodes to become the contents of
 * a <slot> element. This mixin is implemented by {@link Element} and
 * {@link Text}.
 */
var SlotableImpl = /** @class */ (function () {
    function SlotableImpl() {
    }
    Object.defineProperty(SlotableImpl.prototype, "_name", {
        get: function () { return this.__name || ''; },
        set: function (val) { this.__name = val; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SlotableImpl.prototype, "_assignedSlot", {
        get: function () { return this.__assignedSlot || null; },
        set: function (val) { this.__assignedSlot = val; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SlotableImpl.prototype, "assignedSlot", {
        /** @inheritdoc */
        get: function () {
            return algorithm_1.shadowTree_findASlot(this, true);
        },
        enumerable: true,
        configurable: true
    });
    return SlotableImpl;
}());
exports.SlotableImpl = SlotableImpl;
//# sourceMappingURL=SlotableImpl.js.map

/***/ }),

/***/ 7685:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
var AbstractRangeImpl_1 = __nccwpck_require__(3773);
var DOMException_1 = __nccwpck_require__(7175);
var util_1 = __nccwpck_require__(628);
/**
 * Represents a static range.
 */
var StaticRangeImpl = /** @class */ (function (_super) {
    __extends(StaticRangeImpl, _super);
    /**
     * Initializes a new instance of `StaticRange`.
     */
    function StaticRangeImpl(init) {
        var _this = _super.call(this) || this;
        /**
         * 1. If init’s startContainer or endContainer is a DocumentType or Attr
         * node, then throw an "InvalidNodeTypeError" DOMException.
         * 2. Let staticRange be a new StaticRange object.
         * 3. Set staticRange’s start to (init’s startContainer, init’s startOffset)
         * and end to (init’s endContainer, init’s endOffset).
         * 4. Return staticRange.
         */
        if (util_1.Guard.isDocumentTypeNode(init.startContainer) || util_1.Guard.isAttrNode(init.startContainer) ||
            util_1.Guard.isDocumentTypeNode(init.endContainer) || util_1.Guard.isAttrNode(init.endContainer)) {
            throw new DOMException_1.InvalidNodeTypeError();
        }
        _this._start = [init.startContainer, init.startOffset];
        _this._end = [init.endContainer, init.endOffset];
        return _this;
    }
    return StaticRangeImpl;
}(AbstractRangeImpl_1.AbstractRangeImpl));
exports.StaticRangeImpl = StaticRangeImpl;
//# sourceMappingURL=StaticRangeImpl.js.map

/***/ }),

/***/ 4063:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var interfaces_1 = __nccwpck_require__(9454);
var CharacterDataImpl_1 = __nccwpck_require__(765);
var algorithm_1 = __nccwpck_require__(6573);
var WebIDLAlgorithm_1 = __nccwpck_require__(4239);
/**
 * Represents a text node.
 */
var TextImpl = /** @class */ (function (_super) {
    __extends(TextImpl, _super);
    /**
     * Initializes a new instance of `Text`.
     *
     * @param data - the text content
     */
    function TextImpl(data) {
        if (data === void 0) { data = ''; }
        var _this = _super.call(this, data) || this;
        _this._name = '';
        _this._assignedSlot = null;
        return _this;
    }
    Object.defineProperty(TextImpl.prototype, "wholeText", {
        /** @inheritdoc */
        get: function () {
            var e_1, _a;
            /**
             * The wholeText attribute’s getter must return the concatenation of the
             * data of the contiguous Text nodes of the context object, in tree order.
             */
            var text = '';
            try {
                for (var _b = __values(algorithm_1.text_contiguousTextNodes(this, true)), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var node = _c.value;
                    text = text + node._data;
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return text;
        },
        enumerable: true,
        configurable: true
    });
    /** @inheritdoc */
    TextImpl.prototype.splitText = function (offset) {
        /**
         * The splitText(offset) method, when invoked, must split context object
         * with offset offset.
         */
        return algorithm_1.text_split(this, offset);
    };
    Object.defineProperty(TextImpl.prototype, "assignedSlot", {
        // MIXIN: Slotable
        /* istanbul ignore next */
        get: function () { throw new Error("Mixin: Slotable not implemented."); },
        enumerable: true,
        configurable: true
    });
    /**
     * Creates a `Text`.
     *
     * @param document - owner document
     * @param data - the text content
     */
    TextImpl._create = function (document, data) {
        if (data === void 0) { data = ''; }
        var node = new TextImpl(data);
        node._nodeDocument = document;
        return node;
    };
    return TextImpl;
}(CharacterDataImpl_1.CharacterDataImpl));
exports.TextImpl = TextImpl;
/**
 * Initialize prototype properties
 */
WebIDLAlgorithm_1.idl_defineConst(TextImpl.prototype, "_nodeType", interfaces_1.NodeType.Text);
//# sourceMappingURL=TextImpl.js.map

/***/ }),

/***/ 8506:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
var interfaces_1 = __nccwpck_require__(9454);
/**
 * Represents an object which can be used to iterate through the nodes
 * of a subtree.
 */
var TraverserImpl = /** @class */ (function () {
    /**
     * Initializes a new instance of `Traverser`.
     *
     * @param root - root node
     */
    function TraverserImpl(root) {
        this._activeFlag = false;
        this._root = root;
        this._whatToShow = interfaces_1.WhatToShow.All;
        this._filter = null;
    }
    Object.defineProperty(TraverserImpl.prototype, "root", {
        /** @inheritdoc */
        get: function () { return this._root; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TraverserImpl.prototype, "whatToShow", {
        /** @inheritdoc */
        get: function () { return this._whatToShow; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TraverserImpl.prototype, "filter", {
        /** @inheritdoc */
        get: function () { return this._filter; },
        enumerable: true,
        configurable: true
    });
    return TraverserImpl;
}());
exports.TraverserImpl = TraverserImpl;
//# sourceMappingURL=TraverserImpl.js.map

/***/ }),

/***/ 6254:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
var interfaces_1 = __nccwpck_require__(9454);
var TraverserImpl_1 = __nccwpck_require__(8506);
var algorithm_1 = __nccwpck_require__(6573);
/**
 * Represents the nodes of a subtree and a position within them.
 */
var TreeWalkerImpl = /** @class */ (function (_super) {
    __extends(TreeWalkerImpl, _super);
    /**
     * Initializes a new instance of `TreeWalker`.
     */
    function TreeWalkerImpl(root, current) {
        var _this = _super.call(this, root) || this;
        _this._current = current;
        return _this;
    }
    Object.defineProperty(TreeWalkerImpl.prototype, "currentNode", {
        /** @inheritdoc */
        get: function () { return this._current; },
        set: function (value) { this._current = value; },
        enumerable: true,
        configurable: true
    });
    /** @inheritdoc */
    TreeWalkerImpl.prototype.parentNode = function () {
        /**
         * 1. Let node be the context object’s current.
         * 2. While node is non-null and is not the context object’s root:
         */
        var node = this._current;
        while (node !== null && node !== this._root) {
            /**
             * 2.1. Set node to node’s parent.
             * 2.2. If node is non-null and filtering node within the context object
             * returns FILTER_ACCEPT, then set the context object’s current to node
             * and return node.
             */
            node = node._parent;
            if (node !== null &&
                algorithm_1.traversal_filter(this, node) === interfaces_1.FilterResult.Accept) {
                this._current = node;
                return node;
            }
        }
        /**
         * 3. Return null.
         */
        return null;
    };
    /** @inheritdoc */
    TreeWalkerImpl.prototype.firstChild = function () {
        /**
         * The firstChild() method, when invoked, must traverse children with the
         * context object and first.
         */
        return algorithm_1.treeWalker_traverseChildren(this, true);
    };
    /** @inheritdoc */
    TreeWalkerImpl.prototype.lastChild = function () {
        /**
         * The lastChild() method, when invoked, must traverse children with the
         * context object and last.
         */
        return algorithm_1.treeWalker_traverseChildren(this, false);
    };
    /** @inheritdoc */
    TreeWalkerImpl.prototype.nextSibling = function () {
        /**
         * The nextSibling() method, when invoked, must traverse siblings with the
         * context object and next.
         */
        return algorithm_1.treeWalker_traverseSiblings(this, true);
    };
    /** @inheritdoc */
    TreeWalkerImpl.prototype.previousNode = function () {
        /**
         * 1. Let node be the context object’s current.
         * 2. While node is not the context object’s root:
         */
        var node = this._current;
        while (node !== this._root) {
            /**
             * 2.1. Let sibling be node’s previous sibling.
             * 2.2. While sibling is non-null:
             */
            var sibling = node._previousSibling;
            while (sibling) {
                /**
                 * 2.2.1. Set node to sibling.
                 * 2.2.2. Let result be the result of filtering node within the context
                 * object.
                 */
                node = sibling;
                var result = algorithm_1.traversal_filter(this, node);
                /**
                 * 2.2.3. While result is not FILTER_REJECT and node has a child:
                 */
                while (result !== interfaces_1.FilterResult.Reject && node._lastChild) {
                    /**
                     * 2.2.3.1. Set node to node’s last child.
                     * 2.2.3.2. Set result to the result of filtering node within the
                     * context object.
                     */
                    node = node._lastChild;
                    result = algorithm_1.traversal_filter(this, node);
                }
                /**
                 * 2.2.4. If result is FILTER_ACCEPT, then set the context object’s
                 * current to node and return node.
                 */
                if (result === interfaces_1.FilterResult.Accept) {
                    this._current = node;
                    return node;
                }
                /**
                 * 2.2.5. Set sibling to node’s previous sibling.
                 */
                sibling = node._previousSibling;
            }
            /**
             * 2.3. If node is the context object’s root or node’s parent is null,
             * then return null.
             */
            if (node === this._root || node._parent === null) {
                return null;
            }
            /**
             * 2.4. Set node to node’s parent.
             */
            node = node._parent;
            /**
             * 2.5. If the return value of filtering node within the context object is
             * FILTER_ACCEPT, then set the context object’s current to node and
             * return node.
             */
            if (algorithm_1.traversal_filter(this, node) === interfaces_1.FilterResult.Accept) {
                this._current = node;
                return node;
            }
        }
        /**
         * 3. Return null.
         */
        return null;
    };
    /** @inheritdoc */
    TreeWalkerImpl.prototype.previousSibling = function () {
        /**
         * The previousSibling() method, when invoked, must traverse siblings with
         * the context object and previous.
         */
        return algorithm_1.treeWalker_traverseSiblings(this, false);
    };
    /** @inheritdoc */
    TreeWalkerImpl.prototype.nextNode = function () {
        /**
         * 1. Let node be the context object’s current.
         * 2. Let result be FILTER_ACCEPT.
         * 3. While true:
         */
        var node = this._current;
        var result = interfaces_1.FilterResult.Accept;
        while (true) {
            /**
             * 3.1. While result is not FILTER_REJECT and node has a child:
             */
            while (result !== interfaces_1.FilterResult.Reject && node._firstChild) {
                /**
                 * 3.1.1. Set node to its first child.
                 * 3.1.2. Set result to the result of filtering node within the context
                 * object.
                 * 3.1.3. If result is FILTER_ACCEPT, then set the context object’s
                 * current to node and return node.
                 */
                node = node._firstChild;
                result = algorithm_1.traversal_filter(this, node);
                if (result === interfaces_1.FilterResult.Accept) {
                    this._current = node;
                    return node;
                }
            }
            /**
             * 3.2. Let sibling be null.
             * 3.3. Let temporary be node.
             * 3.4. While temporary is non-null:
             */
            var sibling = null;
            var temporary = node;
            while (temporary !== null) {
                /**
                 * 3.4.1. If temporary is the context object’s root, then return null.
                 */
                if (temporary === this._root) {
                    return null;
                }
                /**
                 * 3.4.2. Set sibling to temporary’s next sibling.
                 * 3.4.3. If sibling is non-null, then break.
                 */
                sibling = temporary._nextSibling;
                if (sibling !== null) {
                    node = sibling;
                    break;
                }
                /**
                 * 3.4.4. Set temporary to temporary’s parent.
                 */
                temporary = temporary._parent;
            }
            /**
             * 3.5. Set result to the result of filtering node within the context object.
             * 3.6. If result is FILTER_ACCEPT, then set the context object’s current
             * to node and return node.
             */
            result = algorithm_1.traversal_filter(this, node);
            if (result === interfaces_1.FilterResult.Accept) {
                this._current = node;
                return node;
            }
        }
    };
    /**
     * Creates a new `TreeWalker`.
     *
     * @param root - iterator's root node
     * @param current - current node
     */
    TreeWalkerImpl._create = function (root, current) {
        return new TreeWalkerImpl(root, current);
    };
    return TreeWalkerImpl;
}(TraverserImpl_1.TraverserImpl));
exports.TreeWalkerImpl = TreeWalkerImpl;
//# sourceMappingURL=TreeWalkerImpl.js.map

/***/ }),

/***/ 1448:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
var EventTargetImpl_1 = __nccwpck_require__(3611);
var util_1 = __nccwpck_require__(7061);
var algorithm_1 = __nccwpck_require__(6573);
/**
 * Represents a window containing a DOM document.
 */
var WindowImpl = /** @class */ (function (_super) {
    __extends(WindowImpl, _super);
    /**
     * Initializes a new instance of `Window`.
     */
    function WindowImpl() {
        var _this = _super.call(this) || this;
        _this._signalSlots = new Set();
        _this._mutationObserverMicrotaskQueued = false;
        _this._mutationObservers = new Set();
        _this._iteratorList = new util_1.FixedSizeSet();
        _this._associatedDocument = algorithm_1.create_document();
        return _this;
    }
    Object.defineProperty(WindowImpl.prototype, "document", {
        /** @inheritdoc */
        get: function () { return this._associatedDocument; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WindowImpl.prototype, "event", {
        /** @inheritdoc */
        get: function () { return this._currentEvent; },
        enumerable: true,
        configurable: true
    });
    /**
     * Creates a new window with a blank document.
     */
    WindowImpl._create = function () {
        return new WindowImpl();
    };
    return WindowImpl;
}(EventTargetImpl_1.EventTargetImpl));
exports.WindowImpl = WindowImpl;
//# sourceMappingURL=WindowImpl.js.map

/***/ }),

/***/ 4602:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
var DocumentImpl_1 = __nccwpck_require__(2113);
/**
 * Represents an XML document.
 */
var XMLDocumentImpl = /** @class */ (function (_super) {
    __extends(XMLDocumentImpl, _super);
    /**
     * Initializes a new instance of `XMLDocument`.
     */
    function XMLDocumentImpl() {
        return _super.call(this) || this;
    }
    return XMLDocumentImpl;
}(DocumentImpl_1.DocumentImpl));
exports.XMLDocumentImpl = XMLDocumentImpl;
//# sourceMappingURL=XMLDocumentImpl.js.map

/***/ }),

/***/ 4204:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
var util_1 = __nccwpck_require__(7061);
// Import implementation classes
var AbortControllerImpl_1 = __nccwpck_require__(7528);
exports.AbortController = AbortControllerImpl_1.AbortControllerImpl;
var AbortSignalImpl_1 = __nccwpck_require__(4560);
exports.AbortSignal = AbortSignalImpl_1.AbortSignalImpl;
var AbstractRangeImpl_1 = __nccwpck_require__(3773);
exports.AbstractRange = AbstractRangeImpl_1.AbstractRangeImpl;
var AttrImpl_1 = __nccwpck_require__(2875);
exports.Attr = AttrImpl_1.AttrImpl;
var CDATASectionImpl_1 = __nccwpck_require__(4104);
exports.CDATASection = CDATASectionImpl_1.CDATASectionImpl;
var CharacterDataImpl_1 = __nccwpck_require__(765);
exports.CharacterData = CharacterDataImpl_1.CharacterDataImpl;
var ChildNodeImpl_1 = __nccwpck_require__(3728);
var CommentImpl_1 = __nccwpck_require__(8223);
exports.Comment = CommentImpl_1.CommentImpl;
var CustomEventImpl_1 = __nccwpck_require__(3171);
exports.CustomEvent = CustomEventImpl_1.CustomEventImpl;
var DocumentFragmentImpl_1 = __nccwpck_require__(9793);
exports.DocumentFragment = DocumentFragmentImpl_1.DocumentFragmentImpl;
var DocumentImpl_1 = __nccwpck_require__(2113);
exports.Document = DocumentImpl_1.DocumentImpl;
var DocumentOrShadowRootImpl_1 = __nccwpck_require__(8024);
var DocumentTypeImpl_1 = __nccwpck_require__(1401);
exports.DocumentType = DocumentTypeImpl_1.DocumentTypeImpl;
var DOMImpl_1 = __nccwpck_require__(698);
exports.dom = DOMImpl_1.dom;
var DOMImplementationImpl_1 = __nccwpck_require__(6348);
exports.DOMImplementation = DOMImplementationImpl_1.DOMImplementationImpl;
var DOMTokenListImpl_1 = __nccwpck_require__(6629);
exports.DOMTokenList = DOMTokenListImpl_1.DOMTokenListImpl;
var ElementImpl_1 = __nccwpck_require__(1342);
exports.Element = ElementImpl_1.ElementImpl;
var EventImpl_1 = __nccwpck_require__(2390);
exports.Event = EventImpl_1.EventImpl;
var EventTargetImpl_1 = __nccwpck_require__(3611);
exports.EventTarget = EventTargetImpl_1.EventTargetImpl;
var HTMLCollectionImpl_1 = __nccwpck_require__(9065);
exports.HTMLCollection = HTMLCollectionImpl_1.HTMLCollectionImpl;
var MutationObserverImpl_1 = __nccwpck_require__(9137);
exports.MutationObserver = MutationObserverImpl_1.MutationObserverImpl;
var MutationRecordImpl_1 = __nccwpck_require__(2414);
exports.MutationRecord = MutationRecordImpl_1.MutationRecordImpl;
var NamedNodeMapImpl_1 = __nccwpck_require__(3145);
exports.NamedNodeMap = NamedNodeMapImpl_1.NamedNodeMapImpl;
var NodeFilterImpl_1 = __nccwpck_require__(7030);
exports.NodeFilter = NodeFilterImpl_1.NodeFilterImpl;
var NodeImpl_1 = __nccwpck_require__(2280);
exports.Node = NodeImpl_1.NodeImpl;
var NodeIteratorImpl_1 = __nccwpck_require__(4142);
exports.NodeIterator = NodeIteratorImpl_1.NodeIteratorImpl;
var NodeListImpl_1 = __nccwpck_require__(5788);
exports.NodeList = NodeListImpl_1.NodeListImpl;
var NodeListStaticImpl_1 = __nccwpck_require__(7654);
exports.NodeListStatic = NodeListStaticImpl_1.NodeListStaticImpl;
var NonDocumentTypeChildNodeImpl_1 = __nccwpck_require__(2256);
var NonElementParentNodeImpl_1 = __nccwpck_require__(5325);
var ParentNodeImpl_1 = __nccwpck_require__(1824);
var ProcessingInstructionImpl_1 = __nccwpck_require__(2755);
exports.ProcessingInstruction = ProcessingInstructionImpl_1.ProcessingInstructionImpl;
var RangeImpl_1 = __nccwpck_require__(3691);
exports.Range = RangeImpl_1.RangeImpl;
var ShadowRootImpl_1 = __nccwpck_require__(6092);
exports.ShadowRoot = ShadowRootImpl_1.ShadowRootImpl;
var SlotableImpl_1 = __nccwpck_require__(3940);
var StaticRangeImpl_1 = __nccwpck_require__(7685);
exports.StaticRange = StaticRangeImpl_1.StaticRangeImpl;
var TextImpl_1 = __nccwpck_require__(4063);
exports.Text = TextImpl_1.TextImpl;
var TraverserImpl_1 = __nccwpck_require__(8506);
exports.Traverser = TraverserImpl_1.TraverserImpl;
var TreeWalkerImpl_1 = __nccwpck_require__(6254);
exports.TreeWalker = TreeWalkerImpl_1.TreeWalkerImpl;
var WindowImpl_1 = __nccwpck_require__(1448);
exports.Window = WindowImpl_1.WindowImpl;
var XMLDocumentImpl_1 = __nccwpck_require__(4602);
exports.XMLDocument = XMLDocumentImpl_1.XMLDocumentImpl;
// Apply mixins
// ChildNode
util_1.applyMixin(ElementImpl_1.ElementImpl, ChildNodeImpl_1.ChildNodeImpl);
util_1.applyMixin(CharacterDataImpl_1.CharacterDataImpl, ChildNodeImpl_1.ChildNodeImpl);
util_1.applyMixin(DocumentTypeImpl_1.DocumentTypeImpl, ChildNodeImpl_1.ChildNodeImpl);
// DocumentOrShadowRoot
util_1.applyMixin(DocumentImpl_1.DocumentImpl, DocumentOrShadowRootImpl_1.DocumentOrShadowRootImpl);
util_1.applyMixin(ShadowRootImpl_1.ShadowRootImpl, DocumentOrShadowRootImpl_1.DocumentOrShadowRootImpl);
// NonDocumentTypeChildNode
util_1.applyMixin(ElementImpl_1.ElementImpl, NonDocumentTypeChildNodeImpl_1.NonDocumentTypeChildNodeImpl);
util_1.applyMixin(CharacterDataImpl_1.CharacterDataImpl, NonDocumentTypeChildNodeImpl_1.NonDocumentTypeChildNodeImpl);
// NonElementParentNode
util_1.applyMixin(DocumentImpl_1.DocumentImpl, NonElementParentNodeImpl_1.NonElementParentNodeImpl);
util_1.applyMixin(DocumentFragmentImpl_1.DocumentFragmentImpl, NonElementParentNodeImpl_1.NonElementParentNodeImpl);
// ParentNode
util_1.applyMixin(DocumentImpl_1.DocumentImpl, ParentNodeImpl_1.ParentNodeImpl);
util_1.applyMixin(DocumentFragmentImpl_1.DocumentFragmentImpl, ParentNodeImpl_1.ParentNodeImpl);
util_1.applyMixin(ElementImpl_1.ElementImpl, ParentNodeImpl_1.ParentNodeImpl);
// Slotable
util_1.applyMixin(TextImpl_1.TextImpl, SlotableImpl_1.SlotableImpl);
util_1.applyMixin(ElementImpl_1.ElementImpl, SlotableImpl_1.SlotableImpl);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 9454:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * Defines the position of a boundary point relative to another.
 */
var BoundaryPosition;
(function (BoundaryPosition) {
    BoundaryPosition[BoundaryPosition["Before"] = 0] = "Before";
    BoundaryPosition[BoundaryPosition["Equal"] = 1] = "Equal";
    BoundaryPosition[BoundaryPosition["After"] = 2] = "After";
})(BoundaryPosition = exports.BoundaryPosition || (exports.BoundaryPosition = {}));
/**
 * Defines the event phase.
 */
var EventPhase;
(function (EventPhase) {
    EventPhase[EventPhase["None"] = 0] = "None";
    EventPhase[EventPhase["Capturing"] = 1] = "Capturing";
    EventPhase[EventPhase["AtTarget"] = 2] = "AtTarget";
    EventPhase[EventPhase["Bubbling"] = 3] = "Bubbling";
})(EventPhase = exports.EventPhase || (exports.EventPhase = {}));
/**
 * Defines the type of a node object.
 */
var NodeType;
(function (NodeType) {
    NodeType[NodeType["Element"] = 1] = "Element";
    NodeType[NodeType["Attribute"] = 2] = "Attribute";
    NodeType[NodeType["Text"] = 3] = "Text";
    NodeType[NodeType["CData"] = 4] = "CData";
    NodeType[NodeType["EntityReference"] = 5] = "EntityReference";
    NodeType[NodeType["Entity"] = 6] = "Entity";
    NodeType[NodeType["ProcessingInstruction"] = 7] = "ProcessingInstruction";
    NodeType[NodeType["Comment"] = 8] = "Comment";
    NodeType[NodeType["Document"] = 9] = "Document";
    NodeType[NodeType["DocumentType"] = 10] = "DocumentType";
    NodeType[NodeType["DocumentFragment"] = 11] = "DocumentFragment";
    NodeType[NodeType["Notation"] = 12] = "Notation"; // historical
})(NodeType = exports.NodeType || (exports.NodeType = {}));
/**
 * Defines the position of a node in the document relative to another
 * node.
 */
var Position;
(function (Position) {
    Position[Position["Disconnected"] = 1] = "Disconnected";
    Position[Position["Preceding"] = 2] = "Preceding";
    Position[Position["Following"] = 4] = "Following";
    Position[Position["Contains"] = 8] = "Contains";
    Position[Position["ContainedBy"] = 16] = "ContainedBy";
    Position[Position["ImplementationSpecific"] = 32] = "ImplementationSpecific";
})(Position = exports.Position || (exports.Position = {}));
/**
 * Defines the return value of a filter callback.
 */
var FilterResult;
(function (FilterResult) {
    FilterResult[FilterResult["Accept"] = 1] = "Accept";
    FilterResult[FilterResult["Reject"] = 2] = "Reject";
    FilterResult[FilterResult["Skip"] = 3] = "Skip";
})(FilterResult = exports.FilterResult || (exports.FilterResult = {}));
/**
 * Defines what to show in node filter.
 */
var WhatToShow;
(function (WhatToShow) {
    WhatToShow[WhatToShow["All"] = 4294967295] = "All";
    WhatToShow[WhatToShow["Element"] = 1] = "Element";
    WhatToShow[WhatToShow["Attribute"] = 2] = "Attribute";
    WhatToShow[WhatToShow["Text"] = 4] = "Text";
    WhatToShow[WhatToShow["CDataSection"] = 8] = "CDataSection";
    WhatToShow[WhatToShow["EntityReference"] = 16] = "EntityReference";
    WhatToShow[WhatToShow["Entity"] = 32] = "Entity";
    WhatToShow[WhatToShow["ProcessingInstruction"] = 64] = "ProcessingInstruction";
    WhatToShow[WhatToShow["Comment"] = 128] = "Comment";
    WhatToShow[WhatToShow["Document"] = 256] = "Document";
    WhatToShow[WhatToShow["DocumentType"] = 512] = "DocumentType";
    WhatToShow[WhatToShow["DocumentFragment"] = 1024] = "DocumentFragment";
    WhatToShow[WhatToShow["Notation"] = 2048] = "Notation";
})(WhatToShow = exports.WhatToShow || (exports.WhatToShow = {}));
/**
 * Defines how boundary points are compared.
 */
var HowToCompare;
(function (HowToCompare) {
    HowToCompare[HowToCompare["StartToStart"] = 0] = "StartToStart";
    HowToCompare[HowToCompare["StartToEnd"] = 1] = "StartToEnd";
    HowToCompare[HowToCompare["EndToEnd"] = 2] = "EndToEnd";
    HowToCompare[HowToCompare["EndToStart"] = 3] = "EndToStart";
})(HowToCompare = exports.HowToCompare || (exports.HowToCompare = {}));
//# sourceMappingURL=interfaces.js.map

/***/ }),

/***/ 6371:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
var dom_1 = __nccwpck_require__(4204);
dom_1.dom.setFeatures(true);
var dom_2 = __nccwpck_require__(4204);
exports.DOMImplementation = dom_2.DOMImplementation;
var parser_1 = __nccwpck_require__(8531);
exports.DOMParser = parser_1.DOMParser;
var serializer_1 = __nccwpck_require__(6052);
exports.XMLSerializer = serializer_1.XMLSerializer;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 6182:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
var algorithm_1 = __nccwpck_require__(6573);
var XMLParserImpl_1 = __nccwpck_require__(3515);
/**
 * Represents a parser for XML and HTML content.
 *
 * See: https://w3c.github.io/DOM-Parsing/#the-domparser-interface
 */
var DOMParserImpl = /** @class */ (function () {
    function DOMParserImpl() {
    }
    /** @inheritdoc */
    DOMParserImpl.prototype.parseFromString = function (source, mimeType) {
        if (mimeType === "text/html")
            throw new Error('HTML parser not implemented.');
        try {
            var parser = new XMLParserImpl_1.XMLParserImpl();
            var doc = parser.parse(source);
            doc._contentType = mimeType;
            return doc;
        }
        catch (e) {
            var errorNS = "http://www.mozilla.org/newlayout/xml/parsererror.xml";
            var doc = algorithm_1.create_xmlDocument();
            var root = doc.createElementNS(errorNS, "parsererror");
            var ele = doc.createElementNS(errorNS, "error");
            ele.setAttribute("message", e.message);
            root.appendChild(ele);
            doc.appendChild(root);
            return doc;
        }
    };
    return DOMParserImpl;
}());
exports.DOMParserImpl = DOMParserImpl;
//# sourceMappingURL=DOMParserImpl.js.map

/***/ }),

/***/ 3515:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {


var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var XMLStringLexer_1 = __nccwpck_require__(3529);
var interfaces_1 = __nccwpck_require__(4727);
var infra_1 = __nccwpck_require__(4737);
var algorithm_1 = __nccwpck_require__(6573);
var LocalNameSet_1 = __nccwpck_require__(7830);
/**
 * Represents a parser for XML content.
 *
 * See: https://html.spec.whatwg.org/#xml-parser
 */
var XMLParserImpl = /** @class */ (function () {
    function XMLParserImpl() {
    }
    /**
     * Parses XML content.
     *
     * @param source - a string containing XML content
     */
    XMLParserImpl.prototype.parse = function (source) {
        var e_1, _a, e_2, _b;
        var lexer = new XMLStringLexer_1.XMLStringLexer(source, { skipWhitespaceOnlyText: true });
        var doc = algorithm_1.create_document();
        var context = doc;
        var token = lexer.nextToken();
        while (token.type !== interfaces_1.TokenType.EOF) {
            switch (token.type) {
                case interfaces_1.TokenType.Declaration:
                    var declaration = token;
                    if (declaration.version !== "1.0") {
                        throw new Error("Invalid xml version: " + declaration.version);
                    }
                    break;
                case interfaces_1.TokenType.DocType:
                    var doctype = token;
                    if (!algorithm_1.xml_isPubidChar(doctype.pubId)) {
                        throw new Error("DocType public identifier does not match PubidChar construct.");
                    }
                    if (!algorithm_1.xml_isLegalChar(doctype.sysId) ||
                        (doctype.sysId.indexOf('"') !== -1 && doctype.sysId.indexOf("'") !== -1)) {
                        throw new Error("DocType system identifier contains invalid characters.");
                    }
                    context.appendChild(doc.implementation.createDocumentType(doctype.name, doctype.pubId, doctype.sysId));
                    break;
                case interfaces_1.TokenType.CDATA:
                    var cdata = token;
                    if (!algorithm_1.xml_isLegalChar(cdata.data) ||
                        cdata.data.indexOf("]]>") !== -1) {
                        throw new Error("CDATA contains invalid characters.");
                    }
                    context.appendChild(doc.createCDATASection(cdata.data));
                    break;
                case interfaces_1.TokenType.Comment:
                    var comment = token;
                    if (!algorithm_1.xml_isLegalChar(comment.data) ||
                        comment.data.indexOf("--") !== -1 || comment.data.endsWith("-")) {
                        throw new Error("Comment data contains invalid characters.");
                    }
                    context.appendChild(doc.createComment(comment.data));
                    break;
                case interfaces_1.TokenType.PI:
                    var pi = token;
                    if (pi.target.indexOf(":") !== -1 || (/^xml$/i).test(pi.target)) {
                        throw new Error("Processing instruction target contains invalid characters.");
                    }
                    if (!algorithm_1.xml_isLegalChar(pi.data) || pi.data.indexOf("?>") !== -1) {
                        throw new Error("Processing instruction data contains invalid characters.");
                    }
                    context.appendChild(doc.createProcessingInstruction(pi.target, pi.data));
                    break;
                case interfaces_1.TokenType.Text:
                    var text = token;
                    if (!algorithm_1.xml_isLegalChar(text.data)) {
                        throw new Error("Text data contains invalid characters.");
                    }
                    context.appendChild(doc.createTextNode(this._decodeText(text.data)));
                    break;
                case interfaces_1.TokenType.Element:
                    var element = token;
                    // inherit namespace from parent
                    var _c = __read(algorithm_1.namespace_extractQName(element.name), 2), prefix = _c[0], localName = _c[1];
                    if (localName.indexOf(":") !== -1 || !algorithm_1.xml_isName(localName)) {
                        throw new Error("Node local name contains invalid characters.");
                    }
                    if (prefix === "xmlns") {
                        throw new Error("An element cannot have the 'xmlns' prefix.");
                    }
                    var namespace = context.lookupNamespaceURI(prefix);
                    // override namespace if there is a namespace declaration
                    // attribute
                    // also lookup namespace declaration attributes
                    var nsDeclarations = {};
                    try {
                        for (var _d = (e_1 = void 0, __values(element.attributes)), _e = _d.next(); !_e.done; _e = _d.next()) {
                            var _f = __read(_e.value, 2), attName = _f[0], attValue = _f[1];
                            if (attName === "xmlns") {
                                namespace = attValue;
                            }
                            else {
                                var _g = __read(algorithm_1.namespace_extractQName(attName), 2), attPrefix = _g[0], attLocalName = _g[1];
                                if (attPrefix === "xmlns") {
                                    if (attLocalName === prefix) {
                                        namespace = attValue;
                                    }
                                    nsDeclarations[attLocalName] = attValue;
                                }
                            }
                        }
                    }
                    catch (e_1_1) { e_1 = { error: e_1_1 }; }
                    finally {
                        try {
                            if (_e && !_e.done && (_a = _d.return)) _a.call(_d);
                        }
                        finally { if (e_1) throw e_1.error; }
                    }
                    // create the DOM element node
                    var elementNode = (namespace !== null ?
                        doc.createElementNS(namespace, element.name) :
                        doc.createElement(element.name));
                    context.appendChild(elementNode);
                    // assign attributes
                    var localNameSet = new LocalNameSet_1.LocalNameSet();
                    try {
                        for (var _h = (e_2 = void 0, __values(element.attributes)), _j = _h.next(); !_j.done; _j = _h.next()) {
                            var _k = __read(_j.value, 2), attName = _k[0], attValue = _k[1];
                            var _l = __read(algorithm_1.namespace_extractQName(attName), 2), attPrefix = _l[0], attLocalName = _l[1];
                            var attNamespace = null;
                            if (attPrefix === "xmlns" || (attPrefix === null && attLocalName === "xmlns")) {
                                // namespace declaration attribute
                                attNamespace = infra_1.namespace.XMLNS;
                            }
                            else {
                                attNamespace = elementNode.lookupNamespaceURI(attPrefix);
                                if (attNamespace !== null && elementNode.isDefaultNamespace(attNamespace)) {
                                    attNamespace = null;
                                }
                                else if (attNamespace === null && attPrefix !== null) {
                                    attNamespace = nsDeclarations[attPrefix] || null;
                                }
                            }
                            if (localNameSet.has(attNamespace, attLocalName)) {
                                throw new Error("Element contains duplicate attributes.");
                            }
                            localNameSet.set(attNamespace, attLocalName);
                            if (attNamespace === infra_1.namespace.XMLNS) {
                                if (attValue === infra_1.namespace.XMLNS) {
                                    throw new Error("XMLNS namespace is reserved.");
                                }
                            }
                            if (attLocalName.indexOf(":") !== -1 || !algorithm_1.xml_isName(attLocalName)) {
                                throw new Error("Attribute local name contains invalid characters.");
                            }
                            if (attPrefix === "xmlns" && attValue === "") {
                                throw new Error("Empty XML namespace is not allowed.");
                            }
                            if (attNamespace !== null)
                                elementNode.setAttributeNS(attNamespace, attName, this._decodeAttributeValue(attValue));
                            else
                                elementNode.setAttribute(attName, this._decodeAttributeValue(attValue));
                        }
                    }
                    catch (e_2_1) { e_2 = { error: e_2_1 }; }
                    finally {
                        try {
                            if (_j && !_j.done && (_b = _h.return)) _b.call(_h);
                        }
                        finally { if (e_2) throw e_2.error; }
                    }
                    if (!element.selfClosing) {
                        context = elementNode;
                    }
                    break;
                case interfaces_1.TokenType.ClosingTag:
                    var closingTag = token;
                    if (closingTag.name !== context.nodeName) {
                        throw new Error('Closing tag name does not match opening tag name.');
                    }
                    /* istanbul ignore else */
                    if (context._parent) {
                        context = context._parent;
                    }
                    break;
            }
            token = lexer.nextToken();
        }
        return doc;
    };
    /**
     * Decodes serialized text.
     *
     * @param text - text value to serialize
     */
    XMLParserImpl.prototype._decodeText = function (text) {
        return text == null ? text : text.replace(/&lt;/g, '<')
            .replace(/&gt;/g, '>')
            .replace(/&amp;/g, '&');
    };
    /**
     * Decodes serialized attribute value.
     *
     * @param text - attribute value to serialize
     */
    XMLParserImpl.prototype._decodeAttributeValue = function (text) {
        return text == null ? text : text.replace(/&lt;/g, '<')
            .replace(/&gt;/g, '>')
            .replace(/&amp;/g, '&');
    };
    return XMLParserImpl;
}());
exports.XMLParserImpl = XMLParserImpl;
//# sourceMappingURL=XMLParserImpl.js.map

/***/ }),

/***/ 3529:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {


var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var interfaces_1 = __nccwpck_require__(4727);
/**
 * Represents a lexer for XML content in a string.
 */
var XMLStringLexer = /** @class */ (function () {
    /**
     * Initializes a new instance of `XMLStringLexer`.
     *
     * @param str - the string to tokenize and lex
     * @param options - lexer options
     */
    function XMLStringLexer(str, options) {
        this._options = {
            skipWhitespaceOnlyText: false
        };
        this.err = { line: -1, col: -1, index: -1, str: "" };
        this._str = str;
        this._index = 0;
        this._length = str.length;
        if (options) {
            this._options.skipWhitespaceOnlyText = options.skipWhitespaceOnlyText || false;
        }
    }
    /**
     * Returns the next token.
     */
    XMLStringLexer.prototype.nextToken = function () {
        if (this.eof()) {
            return { type: interfaces_1.TokenType.EOF };
        }
        var token = (this.skipIfStartsWith('<') ? this.openBracket() : this.text());
        if (this._options.skipWhitespaceOnlyText) {
            if (token.type === interfaces_1.TokenType.Text &&
                XMLStringLexer.isWhiteSpaceToken(token)) {
                token = this.nextToken();
            }
        }
        return token;
    };
    /**
     * Branches from an opening bracket (`<`).
     */
    XMLStringLexer.prototype.openBracket = function () {
        if (this.skipIfStartsWith('?')) {
            if (this.skipIfStartsWith('xml')) {
                if (XMLStringLexer.isSpace(this._str[this._index])) {
                    return this.declaration();
                }
                else {
                    // a processing instruction starting with xml. e.g. <?xml-stylesheet href="doc.xsl" type="text/xsl"?>
                    this.seek(-3);
                    return this.pi();
                }
            }
            else {
                return this.pi();
            }
        }
        else if (this.skipIfStartsWith('!')) {
            if (this.skipIfStartsWith('--')) {
                return this.comment();
            }
            else if (this.skipIfStartsWith('[CDATA[')) {
                return this.cdata();
            }
            else if (this.skipIfStartsWith('DOCTYPE')) {
                return this.doctype();
            }
            else {
                this.throwError("Invalid '!' in opening tag.");
            }
        }
        else if (this.skipIfStartsWith('/')) {
            return this.closeTag();
        }
        else {
            return this.openTag();
        }
    };
    /**
     * Produces an XML declaration token.
     */
    XMLStringLexer.prototype.declaration = function () {
        var version = '';
        var encoding = '';
        var standalone = '';
        while (!this.eof()) {
            this.skipSpace();
            if (this.skipIfStartsWith('?>')) {
                return { type: interfaces_1.TokenType.Declaration, version: version, encoding: encoding, standalone: standalone };
            }
            else {
                // attribute name
                var _a = __read(this.attribute(), 2), attName = _a[0], attValue = _a[1];
                if (attName === 'version')
                    version = attValue;
                else if (attName === 'encoding')
                    encoding = attValue;
                else if (attName === 'standalone')
                    standalone = attValue;
                else
                    this.throwError('Invalid attribute name: ' + attName);
            }
        }
        this.throwError('Missing declaration end symbol `?>`');
    };
    /**
     * Produces a doc type token.
     */
    XMLStringLexer.prototype.doctype = function () {
        var pubId = '';
        var sysId = '';
        // name
        this.skipSpace();
        var name = this.takeUntil2('[', '>', true);
        this.skipSpace();
        if (this.skipIfStartsWith('PUBLIC')) {
            pubId = this.quotedString();
            sysId = this.quotedString();
        }
        else if (this.skipIfStartsWith('SYSTEM')) {
            sysId = this.quotedString();
        }
        // skip internal subset
        this.skipSpace();
        if (this.skipIfStartsWith('[')) {
            // skip internal subset nodes
            this.skipUntil(']');
            if (!this.skipIfStartsWith(']')) {
                this.throwError('Missing end bracket of DTD internal subset');
            }
        }
        this.skipSpace();
        if (!this.skipIfStartsWith('>')) {
            this.throwError('Missing doctype end symbol `>`');
        }
        return { type: interfaces_1.TokenType.DocType, name: name, pubId: pubId, sysId: sysId };
    };
    /**
     * Produces a processing instruction token.
     */
    XMLStringLexer.prototype.pi = function () {
        var target = this.takeUntilStartsWith('?>', true);
        if (this.eof()) {
            this.throwError('Missing processing instruction end symbol `?>`');
        }
        this.skipSpace();
        if (this.skipIfStartsWith('?>')) {
            return { type: interfaces_1.TokenType.PI, target: target, data: '' };
        }
        var data = this.takeUntilStartsWith('?>');
        if (this.eof()) {
            this.throwError('Missing processing instruction end symbol `?>`');
        }
        this.seek(2);
        return { type: interfaces_1.TokenType.PI, target: target, data: data };
    };
    /**
     * Produces a text token.
     *
     */
    XMLStringLexer.prototype.text = function () {
        var data = this.takeUntil('<');
        return { type: interfaces_1.TokenType.Text, data: data };
    };
    /**
     * Produces a comment token.
     *
     */
    XMLStringLexer.prototype.comment = function () {
        var data = this.takeUntilStartsWith('-->');
        if (this.eof()) {
            this.throwError('Missing comment end symbol `-->`');
        }
        this.seek(3);
        return { type: interfaces_1.TokenType.Comment, data: data };
    };
    /**
     * Produces a CDATA token.
     *
     */
    XMLStringLexer.prototype.cdata = function () {
        var data = this.takeUntilStartsWith(']]>');
        if (this.eof()) {
            this.throwError('Missing CDATA end symbol `]>`');
        }
        this.seek(3);
        return { type: interfaces_1.TokenType.CDATA, data: data };
    };
    /**
     * Produces an element token.
     */
    XMLStringLexer.prototype.openTag = function () {
        // element name
        this.skipSpace();
        var name = this.takeUntil2('>', '/', true);
        this.skipSpace();
        if (this.skipIfStartsWith('>')) {
            return { type: interfaces_1.TokenType.Element, name: name, attributes: [], selfClosing: false };
        }
        else if (this.skipIfStartsWith('/>')) {
            return { type: interfaces_1.TokenType.Element, name: name, attributes: [], selfClosing: true };
        }
        // attributes
        var attributes = [];
        while (!this.eof()) {
            // end tag
            this.skipSpace();
            if (this.skipIfStartsWith('>')) {
                return { type: interfaces_1.TokenType.Element, name: name, attributes: attributes, selfClosing: false };
            }
            else if (this.skipIfStartsWith('/>')) {
                return { type: interfaces_1.TokenType.Element, name: name, attributes: attributes, selfClosing: true };
            }
            var attr = this.attribute();
            attributes.push(attr);
        }
        this.throwError('Missing opening element tag end symbol `>`');
    };
    /**
     * Produces a closing tag token.
     *
     */
    XMLStringLexer.prototype.closeTag = function () {
        this.skipSpace();
        var name = this.takeUntil('>', true);
        this.skipSpace();
        if (!this.skipIfStartsWith('>')) {
            this.throwError('Missing closing element tag end symbol `>`');
        }
        return { type: interfaces_1.TokenType.ClosingTag, name: name };
    };
    /**
     * Reads an attribute name, value pair
     */
    XMLStringLexer.prototype.attribute = function () {
        // attribute name
        this.skipSpace();
        var name = this.takeUntil('=', true);
        this.skipSpace();
        if (!this.skipIfStartsWith('=')) {
            this.throwError('Missing equals sign before attribute value');
        }
        // attribute value
        var value = this.quotedString();
        return [name, value];
    };
    /**
     * Reads a string between double or single quotes.
     */
    XMLStringLexer.prototype.quotedString = function () {
        this.skipSpace();
        var startQuote = this.take(1);
        if (!XMLStringLexer.isQuote(startQuote)) {
            this.throwError('Missing start quote character before quoted value');
        }
        var value = this.takeUntil(startQuote);
        if (!this.skipIfStartsWith(startQuote)) {
            this.throwError('Missing end quote character after quoted value');
        }
        return value;
    };
    /**
     * Determines if the current index is at or past the end of input string.
     */
    XMLStringLexer.prototype.eof = function () { return this._index >= this._length; };
    /**
     * Skips the length of the given string if the string from current position
     * starts with the given string.
     *
     * @param str - the string to match
     */
    XMLStringLexer.prototype.skipIfStartsWith = function (str) {
        var strLength = str.length;
        if (strLength === 1) {
            if (this._str[this._index] === str) {
                this._index++;
                return true;
            }
            else {
                return false;
            }
        }
        for (var i = 0; i < strLength; i++) {
            if (this._str[this._index + i] !== str[i])
                return false;
        }
        this._index += strLength;
        return true;
    };
    /**
     * Seeks a number of character codes.
     *
     * @param count - number of characters to skip
     */
    XMLStringLexer.prototype.seek = function (count) {
        this._index += count;
        if (this._index < 0)
            this._index = 0;
        if (this._index > this._length)
            this._index = this._length;
    };
    /**
     * Skips space characters.
     */
    XMLStringLexer.prototype.skipSpace = function () {
        while (!this.eof() && (XMLStringLexer.isSpace(this._str[this._index]))) {
            this._index++;
        }
    };
    /**
     * Takes a given number of characters.
     *
     * @param count - character count
     */
    XMLStringLexer.prototype.take = function (count) {
        if (count === 1) {
            return this._str[this._index++];
        }
        var startIndex = this._index;
        this.seek(count);
        return this._str.slice(startIndex, this._index);
    };
    /**
     * Takes characters until the next character matches `char`.
     *
     * @param char - a character to match
     * @param space - whether a space character stops iteration
     */
    XMLStringLexer.prototype.takeUntil = function (char, space) {
        if (space === void 0) { space = false; }
        var startIndex = this._index;
        while (this._index < this._length) {
            var c = this._str[this._index];
            if (c !== char && (!space || !XMLStringLexer.isSpace(c))) {
                this._index++;
            }
            else {
                break;
            }
        }
        return this._str.slice(startIndex, this._index);
    };
    /**
     * Takes characters until the next character matches `char1` or `char1`.
     *
     * @param char1 - a character to match
     * @param char2 - a character to match
     * @param space - whether a space character stops iteration
     */
    XMLStringLexer.prototype.takeUntil2 = function (char1, char2, space) {
        if (space === void 0) { space = false; }
        var startIndex = this._index;
        while (this._index < this._length) {
            var c = this._str[this._index];
            if (c !== char1 && c !== char2 && (!space || !XMLStringLexer.isSpace(c))) {
                this._index++;
            }
            else {
                break;
            }
        }
        return this._str.slice(startIndex, this._index);
    };
    /**
     * Takes characters until the next characters matches `str`.
     *
     * @param str - a string to match
     * @param space - whether a space character stops iteration
     */
    XMLStringLexer.prototype.takeUntilStartsWith = function (str, space) {
        if (space === void 0) { space = false; }
        var startIndex = this._index;
        var strLength = str.length;
        while (this._index < this._length) {
            var match = true;
            for (var i = 0; i < strLength; i++) {
                var c = this._str[this._index + i];
                var char = str[i];
                if (space && XMLStringLexer.isSpace(c)) {
                    return this._str.slice(startIndex, this._index);
                }
                else if (c !== char) {
                    this._index++;
                    match = false;
                    break;
                }
            }
            if (match)
                return this._str.slice(startIndex, this._index);
        }
        this._index = this._length;
        return this._str.slice(startIndex);
    };
    /**
     * Skips characters until the next character matches `char`.
     *
     * @param char - a character to match
     */
    XMLStringLexer.prototype.skipUntil = function (char) {
        while (this._index < this._length) {
            var c = this._str[this._index];
            if (c !== char) {
                this._index++;
            }
            else {
                break;
            }
        }
    };
    /**
     * Determines if the given token is entirely whitespace.
     *
     * @param token - the token to check
     */
    XMLStringLexer.isWhiteSpaceToken = function (token) {
        var str = token.data;
        for (var i = 0; i < str.length; i++) {
            var c = str[i];
            if (c !== ' ' && c !== '\n' && c !== '\r' && c !== '\t' && c !== '\f')
                return false;
        }
        return true;
    };
    /**
     * Determines if the given character is whitespace.
     *
     * @param char - the character to check
     */
    XMLStringLexer.isSpace = function (char) {
        return char === ' ' || char === '\n' || char === '\r' || char === '\t';
    };
    /**
     * Determines if the given character is a quote character.
     *
     * @param char - the character to check
     */
    XMLStringLexer.isQuote = function (char) {
        return (char === '"' || char === '\'');
    };
    /**
     * Throws a parser error and records the line and column numbers in the parsed
     * string.
     *
     * @param msg - error message
     */
    XMLStringLexer.prototype.throwError = function (msg) {
        var regexp = /\r\n|\r|\n/g;
        var match = null;
        var line = 0;
        var firstNewLineIndex = 0;
        var lastNewlineIndex = this._str.length;
        while ((match = regexp.exec(this._str)) !== null) {
            if (match === null)
                break;
            line++;
            if (match.index < this._index)
                firstNewLineIndex = regexp.lastIndex;
            if (match.index > this._index) {
                lastNewlineIndex = match.index;
                break;
            }
        }
        this.err = {
            line: line,
            col: this._index - firstNewLineIndex,
            index: this._index,
            str: this._str.substring(firstNewLineIndex, lastNewlineIndex)
        };
        throw new Error(msg + "\nIndex: " + this.err.index +
            "\nLn: " + this.err.line + ", Col: " + this.err.col +
            "\nInput: " + this.err.str);
    };
    /**
     * Returns an iterator for the lexer.
     */
    XMLStringLexer.prototype[Symbol.iterator] = function () {
        this._index = 0;
        return {
            next: function () {
                var token = this.nextToken();
                if (token.type === interfaces_1.TokenType.EOF) {
                    return { done: true, value: null };
                }
                else {
                    return { done: false, value: token };
                }
            }.bind(this)
        };
    };
    return XMLStringLexer;
}());
exports.XMLStringLexer = XMLStringLexer;
//# sourceMappingURL=XMLStringLexer.js.map

/***/ }),

/***/ 8531:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
// Export classes
var DOMParserImpl_1 = __nccwpck_require__(6182);
exports.DOMParser = DOMParserImpl_1.DOMParserImpl;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 4727:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * Defines the type of a token.
 */
var TokenType;
(function (TokenType) {
    TokenType[TokenType["EOF"] = 0] = "EOF";
    TokenType[TokenType["Declaration"] = 1] = "Declaration";
    TokenType[TokenType["DocType"] = 2] = "DocType";
    TokenType[TokenType["Element"] = 3] = "Element";
    TokenType[TokenType["Text"] = 4] = "Text";
    TokenType[TokenType["CDATA"] = 5] = "CDATA";
    TokenType[TokenType["PI"] = 6] = "PI";
    TokenType[TokenType["Comment"] = 7] = "Comment";
    TokenType[TokenType["ClosingTag"] = 8] = "ClosingTag";
})(TokenType = exports.TokenType || (exports.TokenType = {}));
//# sourceMappingURL=interfaces.js.map

/***/ }),

/***/ 7830:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * Represents a set of unique attribute namespaceURI and localName pairs.
 * This set will contain tuples of unique attribute namespaceURI and
 * localName pairs, and is populated as each attr is processed. This set is
 * used to [optionally] enforce the well-formed constraint that an element
 * cannot have two attributes with the same namespaceURI and localName.
 * This can occur when two otherwise identical attributes on the same
 * element differ only by their prefix values.
 */
var LocalNameSet = /** @class */ (function () {
    function LocalNameSet() {
        // tuple storage
        this._items = {};
        this._nullItems = {};
    }
    /**
     * Adds or replaces a tuple.
     *
     * @param ns - namespace URI
     * @param localName - attribute local name
     */
    LocalNameSet.prototype.set = function (ns, localName) {
        if (ns === null) {
            this._nullItems[localName] = true;
        }
        else if (this._items[ns]) {
            this._items[ns][localName] = true;
        }
        else {
            this._items[ns] = {};
            this._items[ns][localName] = true;
        }
    };
    /**
     * Determines if the given tuple exists in the set.
     *
     * @param ns - namespace URI
     * @param localName - attribute local name
     */
    LocalNameSet.prototype.has = function (ns, localName) {
        if (ns === null) {
            return this._nullItems[localName] === true;
        }
        else if (this._items[ns]) {
            return this._items[ns][localName] === true;
        }
        else {
            return false;
        }
    };
    return LocalNameSet;
}());
exports.LocalNameSet = LocalNameSet;
//# sourceMappingURL=LocalNameSet.js.map

/***/ }),

/***/ 8377:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * A namespace prefix map is a map that associates namespaceURI and namespace
 * prefix lists, where namespaceURI values are the map's unique keys (which can
 * include the null value representing no namespace), and ordered lists of
 * associated prefix values are the map's key values. The namespace prefix map
 * will be populated by previously seen namespaceURIs and all their previously
 * encountered prefix associations for a given node and its ancestors.
 *
 * _Note:_ The last seen prefix for a given namespaceURI is at the end of its
 * respective list. The list is searched to find potentially matching prefixes,
 * and if no matches are found for the given namespaceURI, then the last prefix
 * in the list is used. See copy a namespace prefix map and retrieve a preferred
 * prefix string for additional details.
 *
 * See: https://w3c.github.io/DOM-Parsing/#the-namespace-prefix-map
 */
var NamespacePrefixMap = /** @class */ (function () {
    function NamespacePrefixMap() {
        this._items = {};
        this._nullItems = [];
    }
    /**
     * Creates a copy of the map.
     */
    NamespacePrefixMap.prototype.copy = function () {
        /**
         * To copy a namespace prefix map map means to copy the map's keys into a
         * new empty namespace prefix map, and to copy each of the values in the
         * namespace prefix list associated with each keys' value into a new list
         * which should be associated with the respective key in the new map.
         */
        var mapCopy = new NamespacePrefixMap();
        for (var key in this._items) {
            mapCopy._items[key] = this._items[key].slice(0);
        }
        mapCopy._nullItems = this._nullItems.slice(0);
        return mapCopy;
    };
    /**
     * Retrieves a preferred prefix string from the namespace prefix map.
     *
     * @param preferredPrefix - preferred prefix string
     * @param ns - namespace
     */
    NamespacePrefixMap.prototype.get = function (preferredPrefix, ns) {
        /**
         * 1. Let candidates list be the result of retrieving a list from map where
         * there exists a key in map that matches the value of ns or if there is no
         * such key, then stop running these steps, and return the null value.
         */
        var candidatesList = ns === null ? this._nullItems : (this._items[ns] || null);
        if (candidatesList === null) {
            return null;
        }
        /**
         * 2. Otherwise, for each prefix value prefix in candidates list, iterating
         * from beginning to end:
         *
         * _Note:_ There will always be at least one prefix value in the list.
         */
        var prefix = null;
        for (var i = 0; i < candidatesList.length; i++) {
            prefix = candidatesList[i];
            /**
             * 2.1. If prefix matches preferred prefix, then stop running these steps
             * and return prefix.
             */
            if (prefix === preferredPrefix) {
                return prefix;
            }
        }
        /**
        * 2.2. If prefix is the last item in the candidates list, then stop
        * running these steps and return prefix.
        */
        return prefix;
    };
    /**
     * Checks if a prefix string is found in the namespace prefix map associated
     * with the given namespace.
     *
     * @param prefix - prefix string
     * @param ns - namespace
     */
    NamespacePrefixMap.prototype.has = function (prefix, ns) {
        /**
         * 1. Let candidates list be the result of retrieving a list from map where
         * there exists a key in map that matches the value of ns or if there is
         * no such key, then stop running these steps, and return false.
         */
        var candidatesList = ns === null ? this._nullItems : (this._items[ns] || null);
        if (candidatesList === null) {
            return false;
        }
        /**
         * 2. If the value of prefix occurs at least once in candidates list,
         * return true, otherwise return false.
         */
        return (candidatesList.indexOf(prefix) !== -1);
    };
    /**
     * Checks if a prefix string is found in the namespace prefix map.
     *
     * @param prefix - prefix string
     */
    NamespacePrefixMap.prototype.hasPrefix = function (prefix) {
        if (this._nullItems.indexOf(prefix) !== -1)
            return true;
        for (var key in this._items) {
            if (this._items[key].indexOf(prefix) !== -1)
                return true;
        }
        return false;
    };
    /**
     * Adds a prefix string associated with a namespace to the prefix map.
     *
     * @param prefix - prefix string
     * @param ns - namespace
     */
    NamespacePrefixMap.prototype.set = function (prefix, ns) {
        /**
         * 1. Let candidates list be the result of retrieving a list from map where
         * there exists a key in map that matches the value of ns or if there is
         * no such key, then let candidates list be null.
         */
        var candidatesList = ns === null ? this._nullItems : (this._items[ns] || null);
        /**
         * 2. If candidates list is null, then create a new list with prefix as the
         * only item in the list, and associate that list with a new key ns in map.
         * 3. Otherwise, append prefix to the end of candidates list.
         *
         * _Note:_ The steps in retrieve a preferred prefix string use the list to
         * track the most recently used (MRU) prefix associated with a given
         * namespace, which will be the prefix at the end of the list. This list
         * may contain duplicates of the same prefix value seen earlier
         * (and that's OK).
         */
        if (ns !== null && candidatesList === null) {
            this._items[ns] = [prefix];
        }
        else {
            candidatesList.push(prefix);
        }
    };
    return NamespacePrefixMap;
}());
exports.NamespacePrefixMap = NamespacePrefixMap;
//# sourceMappingURL=NamespacePrefixMap.js.map

/***/ }),

/***/ 6851:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {


var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var interfaces_1 = __nccwpck_require__(9454);
var LocalNameSet_1 = __nccwpck_require__(7830);
var NamespacePrefixMap_1 = __nccwpck_require__(8377);
var DOMException_1 = __nccwpck_require__(7175);
var infra_1 = __nccwpck_require__(4737);
var algorithm_1 = __nccwpck_require__(6573);
/**
 * Represents an XML serializer.
 *
 * Implements: https://www.w3.org/TR/DOM-Parsing/#serializing
 */
var XMLSerializerImpl = /** @class */ (function () {
    function XMLSerializerImpl() {
    }
    /** @inheritdoc */
    XMLSerializerImpl.prototype.serializeToString = function (root) {
        /**
         * The serializeToString(root) method must produce an XML serialization
         * of root passing a value of false for the require well-formed parameter,
         * and return the result.
         */
        return this._xmlSerialization(root, false);
    };
    /**
     * Produces an XML serialization of the given node.
     *
     * @param node - node to serialize
     * @param requireWellFormed - whether to check conformance
     */
    XMLSerializerImpl.prototype._xmlSerialization = function (node, requireWellFormed) {
        // To increase performance, use a namespace-aware serializer only if the
        // document has namespaced elements
        if (node._nodeDocument === undefined || node._nodeDocument._hasNamespaces) {
            /** From: https://w3c.github.io/DOM-Parsing/#xml-serialization
             *
             * 1. Let namespace be a context namespace with value null.
             * The context namespace tracks the XML serialization algorithm's current
             * default namespace. The context namespace is changed when either an Element
             * Node has a default namespace declaration, or the algorithm generates a
             * default namespace declaration for the Element Node to match its own
             * namespace. The algorithm assumes no namespace (null) to start.
             * 2. Let prefix map be a new namespace prefix map.
             * 3. Add the XML namespace with prefix value "xml" to prefix map.
             * 4. Let prefix index be a generated namespace prefix index with value 1.
             * The generated namespace prefix index is used to generate a new unique
             * prefix value when no suitable existing namespace prefix is available to
             * serialize a node's namespaceURI (or the namespaceURI of one of node's
             * attributes). See the generate a prefix algorithm.
             */
            var namespace = null;
            var prefixMap = new NamespacePrefixMap_1.NamespacePrefixMap();
            prefixMap.set("xml", infra_1.namespace.XML);
            var prefixIndex = { value: 1 };
            /**
             * 5. Return the result of running the XML serialization algorithm on node
             * passing the context namespace namespace, namespace prefix map prefix map,
             * generated namespace prefix index reference to prefix index, and the
             * flag require well-formed. If an exception occurs during the execution
             * of the algorithm, then catch that exception and throw an
             * "InvalidStateError" DOMException.
             */
            try {
                return this._serializeNodeNS(node, namespace, prefixMap, prefixIndex, requireWellFormed);
            }
            catch (_a) {
                throw new DOMException_1.InvalidStateError();
            }
        }
        else {
            try {
                return this._serializeNode(node, requireWellFormed);
            }
            catch (_b) {
                throw new DOMException_1.InvalidStateError();
            }
        }
    };
    /**
     * Produces an XML serialization of a node.
     *
     * @param node - node to serialize
     * @param namespace - context namespace
     * @param prefixMap - namespace prefix map
     * @param prefixIndex - generated namespace prefix index
     * @param requireWellFormed - whether to check conformance
     */
    XMLSerializerImpl.prototype._serializeNodeNS = function (node, namespace, prefixMap, prefixIndex, requireWellFormed) {
        switch (node.nodeType) {
            case interfaces_1.NodeType.Element:
                return this._serializeElementNS(node, namespace, prefixMap, prefixIndex, requireWellFormed);
            case interfaces_1.NodeType.Document:
                return this._serializeDocumentNS(node, namespace, prefixMap, prefixIndex, requireWellFormed);
            case interfaces_1.NodeType.Comment:
                return this._serializeComment(node, requireWellFormed);
            case interfaces_1.NodeType.Text:
                return this._serializeText(node, requireWellFormed);
            case interfaces_1.NodeType.DocumentFragment:
                return this._serializeDocumentFragmentNS(node, namespace, prefixMap, prefixIndex, requireWellFormed);
            case interfaces_1.NodeType.DocumentType:
                return this._serializeDocumentType(node, requireWellFormed);
            case interfaces_1.NodeType.ProcessingInstruction:
                return this._serializeProcessingInstruction(node, requireWellFormed);
            case interfaces_1.NodeType.CData:
                return this._serializeCData(node, requireWellFormed);
            default:
                throw new Error("Unknown node type: " + node.nodeType);
        }
    };
    /**
     * Produces an XML serialization of a node.
     *
     * @param node - node to serialize
     * @param requireWellFormed - whether to check conformance
     */
    XMLSerializerImpl.prototype._serializeNode = function (node, requireWellFormed) {
        switch (node.nodeType) {
            case interfaces_1.NodeType.Element:
                return this._serializeElement(node, requireWellFormed);
            case interfaces_1.NodeType.Document:
                return this._serializeDocument(node, requireWellFormed);
            case interfaces_1.NodeType.Comment:
                return this._serializeComment(node, requireWellFormed);
            case interfaces_1.NodeType.Text:
                return this._serializeText(node, requireWellFormed);
            case interfaces_1.NodeType.DocumentFragment:
                return this._serializeDocumentFragment(node, requireWellFormed);
            case interfaces_1.NodeType.DocumentType:
                return this._serializeDocumentType(node, requireWellFormed);
            case interfaces_1.NodeType.ProcessingInstruction:
                return this._serializeProcessingInstruction(node, requireWellFormed);
            case interfaces_1.NodeType.CData:
                return this._serializeCData(node, requireWellFormed);
            default:
                throw new Error("Unknown node type: " + node.nodeType);
        }
    };
    /**
     * Produces an XML serialization of an element node.
     *
     * @param node - node to serialize
     * @param namespace - context namespace
     * @param prefixMap - namespace prefix map
     * @param prefixIndex - generated namespace prefix index
     * @param requireWellFormed - whether to check conformance
     */
    XMLSerializerImpl.prototype._serializeElementNS = function (node, namespace, prefixMap, prefixIndex, requireWellFormed) {
        var e_1, _a;
        /**
         * From: https://w3c.github.io/DOM-Parsing/#xml-serializing-an-element-node
         *
         * 1. If the require well-formed flag is set (its value is true), and this
         * node's localName attribute contains the character ":" (U+003A COLON) or
         * does not match the XML Name production, then throw an exception; the
         * serialization of this node would not be a well-formed element.
         */
        if (requireWellFormed && (node.localName.indexOf(":") !== -1 ||
            !algorithm_1.xml_isName(node.localName))) {
            throw new Error("Node local name contains invalid characters (well-formed required).");
        }
        /**
         * 2. Let markup be the string "<" (U+003C LESS-THAN SIGN).
         * 3. Let qualified name be an empty string.
         * 4. Let skip end tag be a boolean flag with value false.
         * 5. Let ignore namespace definition attribute be a boolean flag with value
         * false.
         * 6. Given prefix map, copy a namespace prefix map and let map be the
         * result.
         * 7. Let local prefixes map be an empty map. The map has unique Node prefix
         * strings as its keys, with corresponding namespaceURI Node values as the
         * map's key values (in this map, the null namespace is represented by the
         * empty string).
         *
         * _Note:_ This map is local to each element. It is used to ensure there
         * are no conflicting prefixes should a new namespace prefix attribute need
         * to be generated. It is also used to enable skipping of duplicate prefix
         * definitions when writing an element's attributes: the map allows the
         * algorithm to distinguish between a prefix in the namespace prefix map
         * that might be locally-defined (to the current Element) and one that is
         * not.
         * 8. Let local default namespace be the result of recording the namespace
         * information for node given map and local prefixes map.
         *
         * _Note:_ The above step will update map with any found namespace prefix
         * definitions, add the found prefix definitions to the local prefixes map
         * and return a local default namespace value defined by a default namespace
         * attribute if one exists. Otherwise it returns null.
         * 9. Let inherited ns be a copy of namespace.
         * 10. Let ns be the value of node's namespaceURI attribute.
         */
        var markup = "<";
        var qualifiedName = '';
        var skipEndTag = false;
        var ignoreNamespaceDefinitionAttribute = false;
        var map = prefixMap.copy();
        var localPrefixesMap = {};
        var localDefaultNamespace = this._recordNamespaceInformation(node, map, localPrefixesMap);
        var inheritedNS = namespace;
        var ns = node.namespaceURI;
        /** 11. If inherited ns is equal to ns, then: */
        if (inheritedNS === ns) {
            /**
             * 11.1. If local default namespace is not null, then set ignore
             * namespace definition attribute to true.
             */
            if (localDefaultNamespace !== null) {
                ignoreNamespaceDefinitionAttribute = true;
            }
            /**
             * 11.2. If ns is the XML namespace, then append to qualified name the
             * concatenation of the string "xml:" and the value of node's localName.
             * 11.3. Otherwise, append to qualified name the value of node's
             * localName. The node's prefix if it exists, is dropped.
             */
            if (ns === infra_1.namespace.XML) {
                qualifiedName = 'xml:' + node.localName;
            }
            else {
                qualifiedName = node.localName;
            }
            /** 11.4. Append the value of qualified name to markup. */
            markup += qualifiedName;
        }
        else {
            /**
             * 12. Otherwise, inherited ns is not equal to ns (the node's own
             * namespace is different from the context namespace of its parent).
             * Run these sub-steps:
             *
             * 12.1. Let prefix be the value of node's prefix attribute.
             * 12.2. Let candidate prefix be the result of retrieving a preferred
             * prefix string prefix from map given namespace ns. The above may return
             * null if no namespace key ns exists in map.
             */
            var prefix = node.prefix;
            /**
             * We don't need to run "retrieving a preferred prefix string" algorithm if
             * the element has no prefix and its namespace matches to the default
             * namespace.
             * See: https://github.com/web-platform-tests/wpt/pull/16703
             */
            var candidatePrefix = null;
            if (prefix !== null || ns !== localDefaultNamespace) {
                candidatePrefix = map.get(prefix, ns);
            }
            /**
             * 12.3. If the value of prefix matches "xmlns", then run the following
             * steps:
             */
            if (prefix === "xmlns") {
                /**
                 * 12.3.1. If the require well-formed flag is set, then throw an error.
                 * An Element with prefix "xmlns" will not legally round-trip in a
                 * conforming XML parser.
                 */
                if (requireWellFormed) {
                    throw new Error("An element cannot have the 'xmlns' prefix (well-formed required).");
                }
                /**
                 * 12.3.2. Let candidate prefix be the value of prefix.
                 */
                candidatePrefix = prefix;
            }
            /**
             * 12.4.Found a suitable namespace prefix: if candidate prefix is not
             * null (a namespace prefix is defined which maps to ns), then:
             */
            if (candidatePrefix !== null) {
                /**
                 * The following may serialize a different prefix than the Element's
                 * existing prefix if it already had one. However, the retrieving a
                 * preferred prefix string algorithm already tried to match the
                 * existing prefix if possible.
                 *
                 * 12.4.1. Append to qualified name the concatenation of candidate
                 * prefix, ":" (U+003A COLON), and node's localName. There exists on
                 * this node or the node's ancestry a namespace prefix definition that
                 * defines the node's namespace.
                 * 12.4.2. If the local default namespace is not null (there exists a
                 * locally-defined default namespace declaration attribute) and its
                 * value is not the XML namespace, then let inherited ns get the value
                 * of local default namespace unless the local default namespace is the
                 * empty string in which case let it get null (the context namespace
                 * is changed to the declared default, rather than this node's own
                 * namespace).
                 *
                 * _Note:_ Any default namespace definitions or namespace prefixes that
                 * define the XML namespace are omitted when serializing this node's
                 * attributes.
                 */
                qualifiedName = candidatePrefix + ':' + node.localName;
                if (localDefaultNamespace !== null && localDefaultNamespace !== infra_1.namespace.XML) {
                    inheritedNS = localDefaultNamespace || null;
                }
                /**
                 * 12.4.3. Append the value of qualified name to markup.
                 */
                markup += qualifiedName;
                /** 12.5. Otherwise, if prefix is not null, then: */
            }
            else if (prefix !== null) {
                /**
                 * _Note:_ By this step, there is no namespace or prefix mapping
                 * declaration in this node (or any parent node visited by this
                 * algorithm) that defines prefix otherwise the step labelled Found
                 * a suitable namespace prefix would have been followed. The sub-steps
                 * that follow will create a new namespace prefix declaration for prefix
                 * and ensure that prefix does not conflict with an existing namespace
                 * prefix declaration of the same localName in node's attribute list.
                 *
                 * 12.5.1. If the local prefixes map contains a key matching prefix,
                 * then let prefix be the result of generating a prefix providing as
                 * input map, ns, and prefix index.
                 */
                if (prefix in localPrefixesMap) {
                    prefix = this._generatePrefix(ns, map, prefixIndex);
                }
                /**
                 * 12.5.2. Add prefix to map given namespace ns.
                 * 12.5.3. Append to qualified name the concatenation of prefix, ":"
                 * (U+003A COLON), and node's localName.
                 * 12.5.4. Append the value of qualified name to markup.
                 */
                map.set(prefix, ns);
                qualifiedName += prefix + ':' + node.localName;
                markup += qualifiedName;
                /**
                 * 12.5.5. Append the following to markup, in the order listed:
                 *
                 * _Note:_ The following serializes a namespace prefix declaration for
                 * prefix which was just added to the map.
                 *
                 * 12.5.5.1. " " (U+0020 SPACE);
                 * 12.5.5.2. The string "xmlns:";
                 * 12.5.5.3. The value of prefix;
                 * 12.5.5.4. "="" (U+003D EQUALS SIGN, U+0022 QUOTATION MARK);
                 * 12.5.5.5. The result of serializing an attribute value given ns and
                 * the require well-formed flag as input;
                 * 12.5.5.6. """ (U+0022 QUOTATION MARK).
                 */
                markup += " xmlns:" + prefix + "=\"" +
                    this._serializeAttributeValue(ns, requireWellFormed) + "\"";
                /**
                 * 12.5.5.7. If local default namespace is not null (there exists a
                 * locally-defined default namespace declaration attribute), then
                 * let inherited ns get the value of local default namespace unless the
                 * local default namespace is the empty string in which case let it get
                 * null.
                 */
                if (localDefaultNamespace !== null) {
                    inheritedNS = localDefaultNamespace || null;
                }
                /**
                 * 12.6. Otherwise, if local default namespace is null, or local
                 * default namespace is not null and its value is not equal to ns, then:
                 */
            }
            else if (localDefaultNamespace === null ||
                (localDefaultNamespace !== null && localDefaultNamespace !== ns)) {
                /**
                 * _Note:_ At this point, the namespace for this node still needs to be
                 * serialized, but there's no prefix (or candidate prefix) available; the
                 * following uses the default namespace declaration to define the
                 * namespace--optionally replacing an existing default declaration
                 * if present.
                 *
                 * 12.6.1. Set the ignore namespace definition attribute flag to true.
                 * 12.6.2. Append to qualified name the value of node's localName.
                 * 12.6.3. Let the value of inherited ns be ns.
                 *
                 * _Note:_ The new default namespace will be used in the serialization
                 * to define this node's namespace and act as the context namespace for
                 * its children.
                 */
                ignoreNamespaceDefinitionAttribute = true;
                qualifiedName += node.localName;
                inheritedNS = ns;
                /**
                 * 12.6.4. Append the value of qualified name to markup.
                 */
                markup += qualifiedName;
                /**
                 * 12.6.5. Append the following to markup, in the order listed:
                 *
                 * _Note:_ The following serializes the new (or replacement) default
                 * namespace definition.
                 *
                 * 12.6.5.1. " " (U+0020 SPACE);
                 * 12.6.5.2. The string "xmlns";
                 * 12.6.5.3. "="" (U+003D EQUALS SIGN, U+0022 QUOTATION MARK);
                 * 12.6.5.4. The result of serializing an attribute value given ns
                 * and the require well-formed flag as input;
                 * 12.6.5.5. """ (U+0022 QUOTATION MARK).
                 */
                markup += " xmlns" + "=\"" +
                    this._serializeAttributeValue(ns, requireWellFormed) + "\"";
                /**
                 * 12.7. Otherwise, the node has a local default namespace that matches
                 * ns. Append to qualified name the value of node's localName, let the
                 * value of inherited ns be ns, and append the value of qualified name
                 * to markup.
                 */
            }
            else {
                qualifiedName += node.localName;
                inheritedNS = ns;
                markup += qualifiedName;
            }
        }
        /**
         * 13. Append to markup the result of the XML serialization of node's
         * attributes given map, prefix index, local prefixes map, ignore namespace
         * definition attribute flag, and require well-formed flag.
         */
        markup += this._serializeAttributesNS(node, map, prefixIndex, localPrefixesMap, ignoreNamespaceDefinitionAttribute, requireWellFormed);
        /**
         * 14. If ns is the HTML namespace, and the node's list of children is
         * empty, and the node's localName matches any one of the following void
         * elements: "area", "base", "basefont", "bgsound", "br", "col", "embed",
         * "frame", "hr", "img", "input", "keygen", "link", "menuitem", "meta",
         * "param", "source", "track", "wbr"; then append the following to markup,
         * in the order listed:
         * 14.1. " " (U+0020 SPACE);
         * 14.2. "/" (U+002F SOLIDUS).
         * and set the skip end tag flag to true.
         * 15. If ns is not the HTML namespace, and the node's list of children is
         * empty, then append "/" (U+002F SOLIDUS) to markup and set the skip end
         * tag flag to true.
         * 16. Append ">" (U+003E GREATER-THAN SIGN) to markup.
         */
        var isHTML = (ns === infra_1.namespace.HTML);
        if (isHTML && node.childNodes.length === 0 &&
            XMLSerializerImpl._VoidElementNames.has(node.localName)) {
            markup += " /";
            skipEndTag = true;
        }
        else if (!isHTML && node.childNodes.length === 0) {
            markup += "/";
            skipEndTag = true;
        }
        markup += ">";
        /**
         * 17. If the value of skip end tag is true, then return the value of markup
         * and skip the remaining steps. The node is a leaf-node.
         */
        if (skipEndTag)
            return markup;
        /**
         * 18. If ns is the HTML namespace, and the node's localName matches the
         * string "template", then this is a template element. Append to markup the
         * result of XML serializing a DocumentFragment node given the template
         * element's template contents (a DocumentFragment), providing inherited
         * ns, map, prefix index, and the require well-formed flag.
         *
         * _Note:_ This allows template content to round-trip, given the rules for
         * parsing XHTML documents.
         *
         * 19. Otherwise, append to markup the result of running the XML
         * serialization algorithm on each of node's children, in tree order,
         * providing inherited ns, map, prefix index, and the require well-formed
         * flag.
         */
        if (isHTML && node.localName === "template") {
            // TODO: serialize template contents
        }
        else {
            try {
                for (var _b = __values(node._children || node.childNodes), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var childNode = _c.value;
                    markup += this._serializeNodeNS(childNode, inheritedNS, map, prefixIndex, requireWellFormed);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
        }
        /**
         * 20. Append the following to markup, in the order listed:
         * 20.1. "</" (U+003C LESS-THAN SIGN, U+002F SOLIDUS);
         * 20.2. The value of qualified name;
         * 20.3. ">" (U+003E GREATER-THAN SIGN).
         */
        markup += "</" + qualifiedName + ">";
        /**
         * 21. Return the value of markup.
         */
        return markup;
    };
    /**
     * Produces an XML serialization of a document node.
     *
     * @param node - node to serialize
     * @param namespace - context namespace
     * @param prefixMap - namespace prefix map
     * @param prefixIndex - generated namespace prefix index
     * @param requireWellFormed - whether to check conformance
     */
    XMLSerializerImpl.prototype._serializeDocumentNS = function (node, namespace, prefixMap, prefixIndex, requireWellFormed) {
        var e_2, _a;
        /**
         * If the require well-formed flag is set (its value is true), and this node
         * has no documentElement (the documentElement attribute's value is null),
         * then throw an exception; the serialization of this node would not be a
         * well-formed document.
         */
        if (requireWellFormed && node.documentElement === null) {
            throw new Error("Missing document element (well-formed required).");
        }
        /**
         * Otherwise, run the following steps:
         * 1. Let serialized document be an empty string.
         * 2. For each child child of node, in tree order, run the XML
         * serialization algorithm on the child passing along the provided
         * arguments, and append the result to serialized document.
         *
         * _Note:_ This will serialize any number of ProcessingInstruction and
         * Comment nodes both before and after the Document's documentElement node,
         * including at most one DocumentType node. (Text nodes are not allowed as
         * children of the Document.)
         *
         * 3. Return the value of serialized document.
        */
        var serializedDocument = "";
        try {
            for (var _b = __values(node._children || node.childNodes), _c = _b.next(); !_c.done; _c = _b.next()) {
                var childNode = _c.value;
                serializedDocument += this._serializeNodeNS(childNode, namespace, prefixMap, prefixIndex, requireWellFormed);
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_2) throw e_2.error; }
        }
        return serializedDocument;
    };
    /**
     * Produces an XML serialization of a comment node.
     *
     * @param node - node to serialize
     * @param requireWellFormed - whether to check conformance
     */
    XMLSerializerImpl.prototype._serializeComment = function (node, requireWellFormed) {
        /**
         * If the require well-formed flag is set (its value is true), and node's
         * data contains characters that are not matched by the XML Char production
         * or contains "--" (two adjacent U+002D HYPHEN-MINUS characters) or that
         * ends with a "-" (U+002D HYPHEN-MINUS) character, then throw an exception;
         * the serialization of this node's data would not be well-formed.
         */
        if (requireWellFormed && (!algorithm_1.xml_isLegalChar(node.data) ||
            node.data.indexOf("--") !== -1 || node.data.endsWith("-"))) {
            throw new Error("Comment data contains invalid characters (well-formed required).");
        }
        /**
         * Otherwise, return the concatenation of "<!--", node's data, and "-->".
         */
        return "<!--" + node.data + "-->";
    };
    /**
     * Produces an XML serialization of a text node.
     *
     * @param node - node to serialize
     * @param requireWellFormed - whether to check conformance
     * @param level - current depth of the XML tree
     */
    XMLSerializerImpl.prototype._serializeText = function (node, requireWellFormed) {
        /**
         * 1. If the require well-formed flag is set (its value is true), and
         * node's data contains characters that are not matched by the XML Char
         * production, then throw an exception; the serialization of this node's
         * data would not be well-formed.
         */
        if (requireWellFormed && !algorithm_1.xml_isLegalChar(node.data)) {
            throw new Error("Text data contains invalid characters (well-formed required).");
        }
        /**
         * 2. Let markup be the value of node's data.
         * 3. Replace any occurrences of "&" in markup by "&amp;".
         * 4. Replace any occurrences of "<" in markup by "&lt;".
         * 5. Replace any occurrences of ">" in markup by "&gt;".
         * 6. Return the value of markup.
         */
        var result = "";
        for (var i = 0; i < node.data.length; i++) {
            var c = node.data[i];
            if (c === "&")
                result += "&amp;";
            else if (c === "<")
                result += "&lt;";
            else if (c === ">")
                result += "&gt;";
            else
                result += c;
        }
        return result;
    };
    /**
     * Produces an XML serialization of a document fragment node.
     *
     * @param node - node to serialize
     * @param namespace - context namespace
     * @param prefixMap - namespace prefix map
     * @param prefixIndex - generated namespace prefix index
     * @param requireWellFormed - whether to check conformance
     */
    XMLSerializerImpl.prototype._serializeDocumentFragmentNS = function (node, namespace, prefixMap, prefixIndex, requireWellFormed) {
        var e_3, _a;
        /**
         * 1. Let markup the empty string.
         * 2. For each child child of node, in tree order, run the XML serialization
         * algorithm on the child given namespace, prefix map, a reference to prefix
         * index, and flag require well-formed. Concatenate the result to markup.
         * 3. Return the value of markup.
         */
        var markup = "";
        try {
            for (var _b = __values(node._children || node.childNodes), _c = _b.next(); !_c.done; _c = _b.next()) {
                var childNode = _c.value;
                markup += this._serializeNodeNS(childNode, namespace, prefixMap, prefixIndex, requireWellFormed);
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_3) throw e_3.error; }
        }
        return markup;
    };
    /**
     * Produces an XML serialization of a document type node.
     *
     * @param node - node to serialize
     * @param requireWellFormed - whether to check conformance
     */
    XMLSerializerImpl.prototype._serializeDocumentType = function (node, requireWellFormed) {
        /**
         * 1. If the require well-formed flag is true and the node's publicId
         * attribute contains characters that are not matched by the XML PubidChar
         *  production, then throw an exception; the serialization of this node
         * would not be a well-formed document type declaration.
         */
        if (requireWellFormed && !algorithm_1.xml_isPubidChar(node.publicId)) {
            throw new Error("DocType public identifier does not match PubidChar construct (well-formed required).");
        }
        /**
         * 2. If the require well-formed flag is true and the node's systemId
         * attribute contains characters that are not matched by the XML Char
         * production or that contains both a """ (U+0022 QUOTATION MARK) and a
         * "'" (U+0027 APOSTROPHE), then throw an exception; the serialization
         * of this node would not be a well-formed document type declaration.
         */
        if (requireWellFormed &&
            (!algorithm_1.xml_isLegalChar(node.systemId) ||
                (node.systemId.indexOf('"') !== -1 && node.systemId.indexOf("'") !== -1))) {
            throw new Error("DocType system identifier contains invalid characters (well-formed required).");
        }
        /**
         * 3. Let markup be an empty string.
         * 4. Append the string "<!DOCTYPE" to markup.
         * 5. Append " " (U+0020 SPACE) to markup.
         * 6. Append the value of the node's name attribute to markup. For a node
         * belonging to an HTML document, the value will be all lowercase.
         * 7. If the node's publicId is not the empty string then append the
         * following, in the order listed, to markup:
         * 7.1. " " (U+0020 SPACE);
         * 7.2. The string "PUBLIC";
         * 7.3. " " (U+0020 SPACE);
         * 7.4. """ (U+0022 QUOTATION MARK);
         * 7.5. The value of the node's publicId attribute;
         * 7.6. """ (U+0022 QUOTATION MARK).
         * 8. If the node's systemId is not the empty string and the node's publicId
         * is set to the empty string, then append the following, in the order
         * listed, to markup:
         * 8.1. " " (U+0020 SPACE);
         * 8.2. The string "SYSTEM".
         * 9. If the node's systemId is not the empty string then append the
         * following, in the order listed, to markup:
         * 9.2. " " (U+0020 SPACE);
         * 9.3. """ (U+0022 QUOTATION MARK);
         * 9.3. The value of the node's systemId attribute;
         * 9.4. """ (U+0022 QUOTATION MARK).
         * 10. Append ">" (U+003E GREATER-THAN SIGN) to markup.
         * 11. Return the value of markup.
         */
        return node.publicId && node.systemId ?
            "<!DOCTYPE " + node.name + " PUBLIC \"" + node.publicId + "\" \"" + node.systemId + "\">"
            : node.publicId ?
                "<!DOCTYPE " + node.name + " PUBLIC \"" + node.publicId + "\">"
                : node.systemId ?
                    "<!DOCTYPE " + node.name + " SYSTEM \"" + node.systemId + "\">"
                    :
                        "<!DOCTYPE " + node.name + ">";
    };
    /**
     * Produces an XML serialization of a processing instruction node.
     *
     * @param node - node to serialize
     * @param requireWellFormed - whether to check conformance
     */
    XMLSerializerImpl.prototype._serializeProcessingInstruction = function (node, requireWellFormed) {
        /**
         * 1. If the require well-formed flag is set (its value is true), and node's
         * target contains a ":" (U+003A COLON) character or is an ASCII
         * case-insensitive match for the string "xml", then throw an exception;
         * the serialization of this node's target would not be well-formed.
         */
        if (requireWellFormed && (node.target.indexOf(":") !== -1 || (/^xml$/i).test(node.target))) {
            throw new Error("Processing instruction target contains invalid characters (well-formed required).");
        }
        /**
         * 2. If the require well-formed flag is set (its value is true), and node's
         * data contains characters that are not matched by the XML Char production
         * or contains the string "?>" (U+003F QUESTION MARK,
         * U+003E GREATER-THAN SIGN), then throw an exception; the serialization of
         * this node's data would not be well-formed.
         */
        if (requireWellFormed && (!algorithm_1.xml_isLegalChar(node.data) ||
            node.data.indexOf("?>") !== -1)) {
            throw new Error("Processing instruction data contains invalid characters (well-formed required).");
        }
        /**
         * 3. Let markup be the concatenation of the following, in the order listed:
         * 3.1. "<?" (U+003C LESS-THAN SIGN, U+003F QUESTION MARK);
         * 3.2. The value of node's target;
         * 3.3. " " (U+0020 SPACE);
         * 3.4. The value of node's data;
         * 3.5. "?>" (U+003F QUESTION MARK, U+003E GREATER-THAN SIGN).
         * 4. Return the value of markup.
         */
        return "<?" + (node.data === "" ? node.target : node.target + " " + node.data) + "?>";
    };
    /**
     * Produces an XML serialization of a CDATA node.
     *
     * @param node - node to serialize
     * @param requireWellFormed - whether to check conformance
     */
    XMLSerializerImpl.prototype._serializeCData = function (node, requireWellFormed) {
        if (requireWellFormed && (node.data.indexOf("]]>") !== -1)) {
            throw new Error("CDATA contains invalid characters (well-formed required).");
        }
        return "<![CDATA[" + node.data + "]]>";
    };
    /**
    * Produces an XML serialization of the attributes of an element node.
    *
     * @param node - node to serialize
     * @param map - namespace prefix map
     * @param prefixIndex - generated namespace prefix index
     * @param localPrefixesMap - local prefixes map
     * @param ignoreNamespaceDefinitionAttribute - whether to ignore namespace
     * attributes
     * @param requireWellFormed - whether to check conformance
    */
    XMLSerializerImpl.prototype._serializeAttributesNS = function (node, map, prefixIndex, localPrefixesMap, ignoreNamespaceDefinitionAttribute, requireWellFormed) {
        var e_4, _a;
        /**
         * 1. Let result be the empty string.
         * 2. Let localname set be a new empty namespace localname set. This
         * localname set will contain tuples of unique attribute namespaceURI and
         * localName pairs, and is populated as each attr is processed. This set is
         * used to [optionally] enforce the well-formed constraint that an element
         * cannot have two attributes with the same namespaceURI and localName.
         * This can occur when two otherwise identical attributes on the same
         * element differ only by their prefix values.
         */
        var result = "";
        var localNameSet = requireWellFormed ? new LocalNameSet_1.LocalNameSet() : undefined;
        try {
            /**
             * 3. Loop: For each attribute attr in element's attributes, in the order
             * they are specified in the element's attribute list:
             */
            for (var _b = __values(node.attributes), _c = _b.next(); !_c.done; _c = _b.next()) {
                var attr = _c.value;
                // Optimize common case
                if (!ignoreNamespaceDefinitionAttribute && !requireWellFormed && attr.namespaceURI === null) {
                    result += " " + attr.localName + "=\"" +
                        this._serializeAttributeValue(attr.value, requireWellFormed) + "\"";
                    continue;
                }
                /**
                 * 3.1. If the require well-formed flag is set (its value is true), and the
                 * localname set contains a tuple whose values match those of a new tuple
                 * consisting of attr's namespaceURI attribute and localName attribute,
                 * then throw an exception; the serialization of this attr would fail to
                 * produce a well-formed element serialization.
                 */
                if (requireWellFormed && localNameSet && localNameSet.has(attr.namespaceURI, attr.localName)) {
                    throw new Error("Element contains duplicate attributes (well-formed required).");
                }
                /**
                 * 3.2. Create a new tuple consisting of attr's namespaceURI attribute and
                 * localName attribute, and add it to the localname set.
                 * 3.3. Let attribute namespace be the value of attr's namespaceURI value.
                 * 3.4. Let candidate prefix be null.
                 */
                if (requireWellFormed && localNameSet)
                    localNameSet.set(attr.namespaceURI, attr.localName);
                var attributeNamespace = attr.namespaceURI;
                var candidatePrefix = null;
                /** 3.5. If attribute namespace is not null, then run these sub-steps: */
                if (attributeNamespace !== null) {
                    /**
                     * 3.5.1. Let candidate prefix be the result of retrieving a preferred
                     * prefix string from map given namespace attribute namespace with
                     * preferred prefix being attr's prefix value.
                     */
                    candidatePrefix = map.get(attr.prefix, attributeNamespace);
                    /**
                     * 3.5.2. If the value of attribute namespace is the XMLNS namespace,
                     * then run these steps:
                     */
                    if (attributeNamespace === infra_1.namespace.XMLNS) {
                        /**
                         * 3.5.2.1. If any of the following are true, then stop running these
                         * steps and goto Loop to visit the next attribute:
                         * - the attr's value is the XML namespace;
                         * _Note:_ The XML namespace cannot be redeclared and survive
                         * round-tripping (unless it defines the prefix "xml"). To avoid this
                         * problem, this algorithm always prefixes elements in the XML
                         * namespace with "xml" and drops any related definitions as seen
                         * in the above condition.
                         * - the attr's prefix is null and the ignore namespace definition
                         * attribute flag is true (the Element's default namespace attribute
                         * should be skipped);
                         * - the attr's prefix is not null and either
                         *   * the attr's localName is not a key contained in the local
                         *     prefixes map, or
                         *   * the attr's localName is present in the local prefixes map but
                         *     the value of the key does not match attr's value
                         * and furthermore that the attr's localName (as the prefix to find)
                         * is found in the namespace prefix map given the namespace consisting
                         * of the attr's value (the current namespace prefix definition was
                         * exactly defined previously--on an ancestor element not the current
                         * element whose attributes are being processed).
                         */
                        if (attr.value === infra_1.namespace.XML ||
                            (attr.prefix === null && ignoreNamespaceDefinitionAttribute) ||
                            (attr.prefix !== null && (!(attr.localName in localPrefixesMap) ||
                                localPrefixesMap[attr.localName] !== attr.value) &&
                                map.has(attr.localName, attr.value)))
                            continue;
                        /**
                         * 3.5.2.2. If the require well-formed flag is set (its value is true),
                         * and the value of attr's value attribute matches the XMLNS
                         * namespace, then throw an exception; the serialization of this
                         * attribute would produce invalid XML because the XMLNS namespace
                         * is reserved and cannot be applied as an element's namespace via
                         * XML parsing.
                         *
                         * _Note:_ DOM APIs do allow creation of elements in the XMLNS
                         * namespace but with strict qualifications.
                         */
                        if (requireWellFormed && attr.value === infra_1.namespace.XMLNS) {
                            throw new Error("XMLNS namespace is reserved (well-formed required).");
                        }
                        /**
                         * 3.5.2.3. If the require well-formed flag is set (its value is true),
                         * and the value of attr's value attribute is the empty string, then
                         * throw an exception; namespace prefix declarations cannot be used
                         * to undeclare a namespace (use a default namespace declaration
                         * instead).
                         */
                        if (requireWellFormed && attr.value === '') {
                            throw new Error("Namespace prefix declarations cannot be used to undeclare a namespace (well-formed required).");
                        }
                        /**
                         * 3.5.2.4. the attr's prefix matches the string "xmlns", then let
                         * candidate prefix be the string "xmlns".
                         */
                        if (attr.prefix === 'xmlns')
                            candidatePrefix = 'xmlns';
                        /**
                         * 3.5.3. Otherwise, the attribute namespace is not the XMLNS namespace.
                         * Run these steps:
                         *
                         * _Note:_ The (candidatePrefix === null) check is not in the spec.
                         * We deviate from the spec here. Otherwise a prefix is generated for
                         * all attributes with namespaces.
                         */
                    }
                    else if (candidatePrefix === null) {
                        if (attr.prefix !== null &&
                            (!map.hasPrefix(attr.prefix) ||
                                map.has(attr.prefix, attributeNamespace))) {
                            /**
                             * Check if we can use the attribute's own prefix.
                             * We deviate from the spec here.
                             * TODO: This is not an efficient way of searching for prefixes.
                             * Follow developments to the spec.
                             */
                            candidatePrefix = attr.prefix;
                        }
                        else {
                            /**
                             * 3.5.3.1. Let candidate prefix be the result of generating a prefix
                             * providing map, attribute namespace, and prefix index as input.
                             */
                            candidatePrefix = this._generatePrefix(attributeNamespace, map, prefixIndex);
                        }
                        /**
                         * 3.5.3.2. Append the following to result, in the order listed:
                         * 3.5.3.2.1. " " (U+0020 SPACE);
                         * 3.5.3.2.2. The string "xmlns:";
                         * 3.5.3.2.3. The value of candidate prefix;
                         * 3.5.3.2.4. "="" (U+003D EQUALS SIGN, U+0022 QUOTATION MARK);
                         * 3.5.3.2.5. The result of serializing an attribute value given
                         * attribute namespace and the require well-formed flag as input;
                         * 3.5.3.2.6. """ (U+0022 QUOTATION MARK).
                        */
                        result += " xmlns:" + candidatePrefix + "=\"" +
                            this._serializeAttributeValue(attributeNamespace, requireWellFormed) + "\"";
                    }
                }
                /**
                 * 3.6. Append a " " (U+0020 SPACE) to result.
                 * 3.7. If candidate prefix is not null, then append to result the
                 * concatenation of candidate prefix with ":" (U+003A COLON).
                 */
                result += " ";
                if (candidatePrefix !== null) {
                    result += candidatePrefix + ':';
                }
                /**
                 * 3.8. If the require well-formed flag is set (its value is true), and
                 * this attr's localName attribute contains the character
                 * ":" (U+003A COLON) or does not match the XML Name production or
                 * equals "xmlns" and attribute namespace is null, then throw an
                 * exception; the serialization of this attr would not be a
                 * well-formed attribute.
                 */
                if (requireWellFormed && (attr.localName.indexOf(":") !== -1 ||
                    !algorithm_1.xml_isName(attr.localName) ||
                    (attr.localName === "xmlns" && attributeNamespace === null))) {
                    throw new Error("Attribute local name contains invalid characters (well-formed required).");
                }
                /**
                 * 3.9. Append the following strings to result, in the order listed:
                 * 3.9.1. The value of attr's localName;
                 * 3.9.2. "="" (U+003D EQUALS SIGN, U+0022 QUOTATION MARK);
                 * 3.9.3. The result of serializing an attribute value given attr's value
                 * attribute and the require well-formed flag as input;
                 * 3.9.4. """ (U+0022 QUOTATION MARK).
                 */
                result += attr.localName + "=\"" +
                    this._serializeAttributeValue(attr.value, requireWellFormed) + "\"";
            }
        }
        catch (e_4_1) { e_4 = { error: e_4_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_4) throw e_4.error; }
        }
        /**
         * 4. Return the value of result.
         */
        return result;
    };
    /**
    * Records namespace information for the given element and returns the
    * default namespace attribute value.
    *
    * @param node - element node to process
    * @param map - namespace prefix map
    * @param localPrefixesMap - local prefixes map
    */
    XMLSerializerImpl.prototype._recordNamespaceInformation = function (node, map, localPrefixesMap) {
        var e_5, _a;
        /**
         * 1. Let default namespace attr value be null.
         */
        var defaultNamespaceAttrValue = null;
        try {
            /**
             * 2. Main: For each attribute attr in element's attributes, in the order
             * they are specified in the element's attribute list:
             */
            for (var _b = __values(node.attributes), _c = _b.next(); !_c.done; _c = _b.next()) {
                var attr = _c.value;
                /**
                 * _Note:_ The following conditional steps find namespace prefixes. Only
                 * attributes in the XMLNS namespace are considered (e.g., attributes made
                 * to look like namespace declarations via
                 * setAttribute("xmlns:pretend-prefix", "pretend-namespace") are not
                 * included).
                 */
                /** 2.1. Let attribute namespace be the value of attr's namespaceURI value. */
                var attributeNamespace = attr.namespaceURI;
                /** 2.2. Let attribute prefix be the value of attr's prefix. */
                var attributePrefix = attr.prefix;
                /** 2.3. If the attribute namespace is the XMLNS namespace, then: */
                if (attributeNamespace === infra_1.namespace.XMLNS) {
                    /**
                     * 2.3.1. If attribute prefix is null, then attr is a default namespace
                     * declaration. Set the default namespace attr value to attr's value and
                     * stop running these steps, returning to Main to visit the next
                     * attribute.
                     */
                    if (attributePrefix === null) {
                        defaultNamespaceAttrValue = attr.value;
                        continue;
                        /**
                         * 2.3.2. Otherwise, the attribute prefix is not null and attr is a
                         * namespace prefix definition. Run the following steps:
                         */
                    }
                    else {
                        /** 2.3.2.1. Let prefix definition be the value of attr's localName. */
                        var prefixDefinition = attr.localName;
                        /** 2.3.2.2. Let namespace definition be the value of attr's value. */
                        var namespaceDefinition = attr.value;
                        /**
                         * 2.3.2.3. If namespace definition is the XML namespace, then stop
                         * running these steps, and return to Main to visit the next
                         * attribute.
                         *
                         * _Note:_ XML namespace definitions in prefixes are completely
                         * ignored (in order to avoid unnecessary work when there might be
                         * prefix conflicts). XML namespaced elements are always handled
                         * uniformly by prefixing (and overriding if necessary) the element's
                         * localname with the reserved "xml" prefix.
                         */
                        if (namespaceDefinition === infra_1.namespace.XML) {
                            continue;
                        }
                        /**
                         * 2.3.2.4. If namespace definition is the empty string (the
                         * declarative form of having no namespace), then let namespace
                         * definition be null instead.
                         */
                        if (namespaceDefinition === '') {
                            namespaceDefinition = null;
                        }
                        /**
                         * 2.3.2.5. If prefix definition is found in map given the namespace
                         * namespace definition, then stop running these steps, and return to
                         * Main to visit the next attribute.
                         *
                         * _Note:_ This step avoids adding duplicate prefix definitions for
                         * the same namespace in the map. This has the side-effect of avoiding
                         * later serialization of duplicate namespace prefix declarations in
                         * any descendant nodes.
                         */
                        if (map.has(prefixDefinition, namespaceDefinition)) {
                            continue;
                        }
                        /**
                         * 2.3.2.6. Add the prefix prefix definition to map given namespace
                         * namespace definition.
                         */
                        map.set(prefixDefinition, namespaceDefinition);
                        /**
                         * 2.3.2.7. Add the value of prefix definition as a new key to the
                         * local prefixes map, with the namespace definition as the key's
                         * value replacing the value of null with the empty string if
                         * applicable.
                         */
                        localPrefixesMap[prefixDefinition] = namespaceDefinition || '';
                    }
                }
            }
        }
        catch (e_5_1) { e_5 = { error: e_5_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_5) throw e_5.error; }
        }
        /**
         * 3. Return the value of default namespace attr value.
         *
         * _Note:_ The empty string is a legitimate return value and is not
         * converted to null.
         */
        return defaultNamespaceAttrValue;
    };
    /**
    * Generates a new prefix for the given namespace.
    *
    * @param newNamespace - a namespace to generate prefix for
    * @param prefixMap - namespace prefix map
    * @param prefixIndex - generated namespace prefix index
    */
    XMLSerializerImpl.prototype._generatePrefix = function (newNamespace, prefixMap, prefixIndex) {
        /**
         * 1. Let generated prefix be the concatenation of the string "ns" and the
         * current numerical value of prefix index.
         * 2. Let the value of prefix index be incremented by one.
         * 3. Add to map the generated prefix given the new namespace namespace.
         * 4. Return the value of generated prefix.
         */
        var generatedPrefix = "ns" + prefixIndex.value;
        prefixIndex.value++;
        prefixMap.set(generatedPrefix, newNamespace);
        return generatedPrefix;
    };
    /**
     * Produces an XML serialization of an attribute value.
     *
     * @param value - attribute value
     * @param requireWellFormed - whether to check conformance
     */
    XMLSerializerImpl.prototype._serializeAttributeValue = function (value, requireWellFormed) {
        /**
         * From: https://w3c.github.io/DOM-Parsing/#dfn-serializing-an-attribute-value
         *
         * 1. If the require well-formed flag is set (its value is true), and
         * attribute value contains characters that are not matched by the XML Char
         * production, then throw an exception; the serialization of this attribute
         * value would fail to produce a well-formed element serialization.
         */
        if (requireWellFormed && value !== null && !algorithm_1.xml_isLegalChar(value)) {
            throw new Error("Invalid characters in attribute value.");
        }
        /**
         * 2. If attribute value is null, then return the empty string.
         */
        if (value === null)
            return "";
        /**
         * 3. Otherwise, attribute value is a string. Return the value of attribute
         * value, first replacing any occurrences of the following:
         * - "&" with "&amp;"
         * - """ with "&quot;"
         * - "<" with "&lt;"
         * - ">" with "&gt;"
         * NOTE
         * This matches behavior present in browsers, and goes above and beyond the
         * grammar requirement in the XML specification's AttValue production by
         * also replacing ">" characters.
         */
        var result = "";
        for (var i = 0; i < value.length; i++) {
            var c = value[i];
            if (c === "\"")
                result += "&quot;";
            else if (c === "&")
                result += "&amp;";
            else if (c === "<")
                result += "&lt;";
            else if (c === ">")
                result += "&gt;";
            else
                result += c;
        }
        return result;
    };
    /**
     * Produces an XML serialization of an element node.
     *
     * @param node - node to serialize
     * @param requireWellFormed - whether to check conformance
     */
    XMLSerializerImpl.prototype._serializeElement = function (node, requireWellFormed) {
        var e_6, _a;
        /**
         * From: https://w3c.github.io/DOM-Parsing/#xml-serializing-an-element-node
         *
         * 1. If the require well-formed flag is set (its value is true), and this
         * node's localName attribute contains the character ":" (U+003A COLON) or
         * does not match the XML Name production, then throw an exception; the
         * serialization of this node would not be a well-formed element.
         */
        if (requireWellFormed && (node.localName.indexOf(":") !== -1 ||
            !algorithm_1.xml_isName(node.localName))) {
            throw new Error("Node local name contains invalid characters (well-formed required).");
        }
        /**
         * 2. Let markup be the string "<" (U+003C LESS-THAN SIGN).
         * 3. Let qualified name be an empty string.
         * 4. Let skip end tag be a boolean flag with value false.
         * 5. Let ignore namespace definition attribute be a boolean flag with value
         * false.
         * 6. Given prefix map, copy a namespace prefix map and let map be the
         * result.
         * 7. Let local prefixes map be an empty map. The map has unique Node prefix
         * strings as its keys, with corresponding namespaceURI Node values as the
         * map's key values (in this map, the null namespace is represented by the
         * empty string).
         *
         * _Note:_ This map is local to each element. It is used to ensure there
         * are no conflicting prefixes should a new namespace prefix attribute need
         * to be generated. It is also used to enable skipping of duplicate prefix
         * definitions when writing an element's attributes: the map allows the
         * algorithm to distinguish between a prefix in the namespace prefix map
         * that might be locally-defined (to the current Element) and one that is
         * not.
         * 8. Let local default namespace be the result of recording the namespace
         * information for node given map and local prefixes map.
         *
         * _Note:_ The above step will update map with any found namespace prefix
         * definitions, add the found prefix definitions to the local prefixes map
         * and return a local default namespace value defined by a default namespace
         * attribute if one exists. Otherwise it returns null.
         * 9. Let inherited ns be a copy of namespace.
         * 10. Let ns be the value of node's namespaceURI attribute.
         */
        var skipEndTag = false;
        /** 11. If inherited ns is equal to ns, then: */
        /**
         * 11.1. If local default namespace is not null, then set ignore
         * namespace definition attribute to true.
         * 11.2. If ns is the XML namespace, then append to qualified name the
         * concatenation of the string "xml:" and the value of node's localName.
         * 11.3. Otherwise, append to qualified name the value of node's
         * localName. The node's prefix if it exists, is dropped.
         */
        var qualifiedName = node.localName;
        /** 11.4. Append the value of qualified name to markup. */
        var markup = "<" + qualifiedName;
        /**
         * 13. Append to markup the result of the XML serialization of node's
         * attributes given map, prefix index, local prefixes map, ignore namespace
         * definition attribute flag, and require well-formed flag.
         */
        markup += this._serializeAttributes(node, requireWellFormed);
        /**
         * 14. If ns is the HTML namespace, and the node's list of children is
         * empty, and the node's localName matches any one of the following void
         * elements: "area", "base", "basefont", "bgsound", "br", "col", "embed",
         * "frame", "hr", "img", "input", "keygen", "link", "menuitem", "meta",
         * "param", "source", "track", "wbr"; then append the following to markup,
         * in the order listed:
         * 14.1. " " (U+0020 SPACE);
         * 14.2. "/" (U+002F SOLIDUS).
         * and set the skip end tag flag to true.
         * 15. If ns is not the HTML namespace, and the node's list of children is
         * empty, then append "/" (U+002F SOLIDUS) to markup and set the skip end
         * tag flag to true.
         * 16. Append ">" (U+003E GREATER-THAN SIGN) to markup.
         */
        if (node._children.size === 0) {
            markup += "/";
            skipEndTag = true;
        }
        markup += ">";
        /**
         * 17. If the value of skip end tag is true, then return the value of markup
         * and skip the remaining steps. The node is a leaf-node.
         */
        if (skipEndTag)
            return markup;
        try {
            /**
             * 18. If ns is the HTML namespace, and the node's localName matches the
             * string "template", then this is a template element. Append to markup the
             * result of XML serializing a DocumentFragment node given the template
             * element's template contents (a DocumentFragment), providing inherited
             * ns, map, prefix index, and the require well-formed flag.
             *
             * _Note:_ This allows template content to round-trip, given the rules for
             * parsing XHTML documents.
             *
             * 19. Otherwise, append to markup the result of running the XML
             * serialization algorithm on each of node's children, in tree order,
             * providing inherited ns, map, prefix index, and the require well-formed
             * flag.
             */
            for (var _b = __values(node._children), _c = _b.next(); !_c.done; _c = _b.next()) {
                var childNode = _c.value;
                markup += this._serializeNode(childNode, requireWellFormed);
            }
        }
        catch (e_6_1) { e_6 = { error: e_6_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_6) throw e_6.error; }
        }
        /**
         * 20. Append the following to markup, in the order listed:
         * 20.1. "</" (U+003C LESS-THAN SIGN, U+002F SOLIDUS);
         * 20.2. The value of qualified name;
         * 20.3. ">" (U+003E GREATER-THAN SIGN).
         */
        markup += "</" + qualifiedName + ">";
        /**
         * 21. Return the value of markup.
         */
        return markup;
    };
    /**
     * Produces an XML serialization of a document node.
     *
     * @param node - node to serialize
     * @param requireWellFormed - whether to check conformance
     */
    XMLSerializerImpl.prototype._serializeDocument = function (node, requireWellFormed) {
        var e_7, _a;
        /**
         * If the require well-formed flag is set (its value is true), and this node
         * has no documentElement (the documentElement attribute's value is null),
         * then throw an exception; the serialization of this node would not be a
         * well-formed document.
         */
        if (requireWellFormed && node.documentElement === null) {
            throw new Error("Missing document element (well-formed required).");
        }
        /**
         * Otherwise, run the following steps:
         * 1. Let serialized document be an empty string.
         * 2. For each child child of node, in tree order, run the XML
         * serialization algorithm on the child passing along the provided
         * arguments, and append the result to serialized document.
         *
         * _Note:_ This will serialize any number of ProcessingInstruction and
         * Comment nodes both before and after the Document's documentElement node,
         * including at most one DocumentType node. (Text nodes are not allowed as
         * children of the Document.)
         *
         * 3. Return the value of serialized document.
        */
        var serializedDocument = "";
        try {
            for (var _b = __values(node._children), _c = _b.next(); !_c.done; _c = _b.next()) {
                var childNode = _c.value;
                serializedDocument += this._serializeNode(childNode, requireWellFormed);
            }
        }
        catch (e_7_1) { e_7 = { error: e_7_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_7) throw e_7.error; }
        }
        return serializedDocument;
    };
    /**
     * Produces an XML serialization of a document fragment node.
     *
     * @param node - node to serialize
     * @param requireWellFormed - whether to check conformance
     */
    XMLSerializerImpl.prototype._serializeDocumentFragment = function (node, requireWellFormed) {
        var e_8, _a;
        /**
         * 1. Let markup the empty string.
         * 2. For each child child of node, in tree order, run the XML serialization
         * algorithm on the child given namespace, prefix map, a reference to prefix
         * index, and flag require well-formed. Concatenate the result to markup.
         * 3. Return the value of markup.
         */
        var markup = "";
        try {
            for (var _b = __values(node._children), _c = _b.next(); !_c.done; _c = _b.next()) {
                var childNode = _c.value;
                markup += this._serializeNode(childNode, requireWellFormed);
            }
        }
        catch (e_8_1) { e_8 = { error: e_8_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_8) throw e_8.error; }
        }
        return markup;
    };
    /**
     * Produces an XML serialization of the attributes of an element node.
     *
     * @param node - node to serialize
     * @param requireWellFormed - whether to check conformance
     */
    XMLSerializerImpl.prototype._serializeAttributes = function (node, requireWellFormed) {
        var e_9, _a;
        /**
         * 1. Let result be the empty string.
         * 2. Let localname set be a new empty namespace localname set. This
         * localname set will contain tuples of unique attribute namespaceURI and
         * localName pairs, and is populated as each attr is processed. This set is
         * used to [optionally] enforce the well-formed constraint that an element
         * cannot have two attributes with the same namespaceURI and localName.
         * This can occur when two otherwise identical attributes on the same
         * element differ only by their prefix values.
         */
        var result = "";
        var localNameSet = requireWellFormed ? {} : undefined;
        try {
            /**
             * 3. Loop: For each attribute attr in element's attributes, in the order
             * they are specified in the element's attribute list:
             */
            for (var _b = __values(node.attributes), _c = _b.next(); !_c.done; _c = _b.next()) {
                var attr = _c.value;
                /**
                 * 3.1. If the require well-formed flag is set (its value is true), and the
                 * localname set contains a tuple whose values match those of a new tuple
                 * consisting of attr's namespaceURI attribute and localName attribute,
                 * then throw an exception; the serialization of this attr would fail to
                 * produce a well-formed element serialization.
                 */
                if (requireWellFormed && localNameSet && (attr.localName in localNameSet)) {
                    throw new Error("Element contains duplicate attributes (well-formed required).");
                }
                /**
                 * 3.2. Create a new tuple consisting of attr's namespaceURI attribute and
                 * localName attribute, and add it to the localname set.
                 * 3.3. Let attribute namespace be the value of attr's namespaceURI value.
                 * 3.4. Let candidate prefix be null.
                 */
                if (requireWellFormed && localNameSet)
                    localNameSet[attr.localName] = true;
                /** 3.5. If attribute namespace is not null, then run these sub-steps: */
                /**
                 * 3.6. Append a " " (U+0020 SPACE) to result.
                 * 3.7. If candidate prefix is not null, then append to result the
                 * concatenation of candidate prefix with ":" (U+003A COLON).
                 */
                /**
                 * 3.8. If the require well-formed flag is set (its value is true), and
                 * this attr's localName attribute contains the character
                 * ":" (U+003A COLON) or does not match the XML Name production or
                 * equals "xmlns" and attribute namespace is null, then throw an
                 * exception; the serialization of this attr would not be a
                 * well-formed attribute.
                 */
                if (requireWellFormed && (attr.localName.indexOf(":") !== -1 ||
                    !algorithm_1.xml_isName(attr.localName))) {
                    throw new Error("Attribute local name contains invalid characters (well-formed required).");
                }
                /**
                 * 3.9. Append the following strings to result, in the order listed:
                 * 3.9.1. The value of attr's localName;
                 * 3.9.2. "="" (U+003D EQUALS SIGN, U+0022 QUOTATION MARK);
                 * 3.9.3. The result of serializing an attribute value given attr's value
                 * attribute and the require well-formed flag as input;
                 * 3.9.4. """ (U+0022 QUOTATION MARK).
                 */
                result += " " + attr.localName + "=\"" +
                    this._serializeAttributeValue(attr.value, requireWellFormed) + "\"";
            }
        }
        catch (e_9_1) { e_9 = { error: e_9_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_9) throw e_9.error; }
        }
        /**
         * 4. Return the value of result.
         */
        return result;
    };
    XMLSerializerImpl._VoidElementNames = new Set(['area', 'base', 'basefont',
        'bgsound', 'br', 'col', 'embed', 'frame', 'hr', 'img', 'input', 'keygen',
        'link', 'menuitem', 'meta', 'param', 'source', 'track', 'wbr']);
    return XMLSerializerImpl;
}());
exports.XMLSerializerImpl = XMLSerializerImpl;
//# sourceMappingURL=XMLSerializerImpl.js.map

/***/ }),

/***/ 6052:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
// Export classes
var XMLSerializerImpl_1 = __nccwpck_require__(6851);
exports.XMLSerializer = XMLSerializerImpl_1.XMLSerializerImpl;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 7405:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
var Guard_1 = __nccwpck_require__(7773);
/**
 * Contains type casts for DOM objects.
 */
var Cast = /** @class */ (function () {
    function Cast() {
    }
    /**
     * Casts the given object to a `Node`.
     *
     * @param a - the object to cast
     */
    Cast.asNode = function (a) {
        if (Guard_1.Guard.isNode(a)) {
            return a;
        }
        else {
            throw new Error("Invalid object. Node expected.");
        }
    };
    return Cast;
}());
exports.Cast = Cast;
//# sourceMappingURL=Cast.js.map

/***/ }),

/***/ 4581:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
var EmptySet = /** @class */ (function () {
    function EmptySet() {
    }
    Object.defineProperty(EmptySet.prototype, "size", {
        get: function () {
            return 0;
        },
        enumerable: true,
        configurable: true
    });
    EmptySet.prototype.add = function (value) {
        throw new Error("Cannot add to an empty set.");
    };
    EmptySet.prototype.clear = function () {
        // no-op
    };
    EmptySet.prototype.delete = function (value) {
        return false;
    };
    EmptySet.prototype.forEach = function (callbackfn, thisArg) {
        // no-op
    };
    EmptySet.prototype.has = function (value) {
        return false;
    };
    EmptySet.prototype[Symbol.iterator] = function () {
        return new EmptySetIterator();
    };
    EmptySet.prototype.entries = function () {
        return new EmptySetIterator();
    };
    EmptySet.prototype.keys = function () {
        return new EmptySetIterator();
    };
    EmptySet.prototype.values = function () {
        return new EmptySetIterator();
    };
    Object.defineProperty(EmptySet.prototype, Symbol.toStringTag, {
        get: function () {
            return "EmptySet";
        },
        enumerable: true,
        configurable: true
    });
    return EmptySet;
}());
exports.EmptySet = EmptySet;
var EmptySetIterator = /** @class */ (function () {
    function EmptySetIterator() {
    }
    EmptySetIterator.prototype[Symbol.iterator] = function () {
        return this;
    };
    EmptySetIterator.prototype.next = function () {
        return { done: true, value: null };
    };
    return EmptySetIterator;
}());
//# sourceMappingURL=EmptySet.js.map

/***/ }),

/***/ 7773:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
var interfaces_1 = __nccwpck_require__(9454);
/**
 * Contains user-defined type guards for DOM objects.
 */
var Guard = /** @class */ (function () {
    function Guard() {
    }
    /**
     * Determines if the given object is a `Node`.
     *
     * @param a - the object to check
     */
    Guard.isNode = function (a) {
        return (!!a && a._nodeType !== undefined);
    };
    /**
     * Determines if the given object is a `Document`.
     *
     * @param a - the object to check
     */
    Guard.isDocumentNode = function (a) {
        return (Guard.isNode(a) && a._nodeType === interfaces_1.NodeType.Document);
    };
    /**
     * Determines if the given object is a `DocumentType`.
     *
     * @param a - the object to check
     */
    Guard.isDocumentTypeNode = function (a) {
        return (Guard.isNode(a) && a._nodeType === interfaces_1.NodeType.DocumentType);
    };
    /**
     * Determines if the given object is a `DocumentFragment`.
     *
     * @param a - the object to check
     */
    Guard.isDocumentFragmentNode = function (a) {
        return (Guard.isNode(a) && a._nodeType === interfaces_1.NodeType.DocumentFragment);
    };
    /**
     * Determines if the given object is a `Attr`.
     *
     * @param a - the object to check
     */
    Guard.isAttrNode = function (a) {
        return (Guard.isNode(a) && a._nodeType === interfaces_1.NodeType.Attribute);
    };
    /**
     * Determines if the given node is a `CharacterData` node.
     *
     * @param a - the object to check
     */
    Guard.isCharacterDataNode = function (a) {
        if (!Guard.isNode(a))
            return false;
        var type = a._nodeType;
        return (type === interfaces_1.NodeType.Text ||
            type === interfaces_1.NodeType.ProcessingInstruction ||
            type === interfaces_1.NodeType.Comment ||
            type === interfaces_1.NodeType.CData);
    };
    /**
     * Determines if the given object is a `Text` or a `CDATASection`.
     *
     * @param a - the object to check
     */
    Guard.isTextNode = function (a) {
        return (Guard.isNode(a) && (a._nodeType === interfaces_1.NodeType.Text || a._nodeType === interfaces_1.NodeType.CData));
    };
    /**
     * Determines if the given object is a `Text`.
     *
     * @param a - the object to check
     */
    Guard.isExclusiveTextNode = function (a) {
        return (Guard.isNode(a) && a._nodeType === interfaces_1.NodeType.Text);
    };
    /**
     * Determines if the given object is a `CDATASection`.
     *
     * @param a - the object to check
     */
    Guard.isCDATASectionNode = function (a) {
        return (Guard.isNode(a) && a._nodeType === interfaces_1.NodeType.CData);
    };
    /**
     * Determines if the given object is a `Comment`.
     *
     * @param a - the object to check
     */
    Guard.isCommentNode = function (a) {
        return (Guard.isNode(a) && a._nodeType === interfaces_1.NodeType.Comment);
    };
    /**
     * Determines if the given object is a `ProcessingInstruction`.
     *
     * @param a - the object to check
     */
    Guard.isProcessingInstructionNode = function (a) {
        return (Guard.isNode(a) && a._nodeType === interfaces_1.NodeType.ProcessingInstruction);
    };
    /**
     * Determines if the given object is an `Element`.
     *
     * @param a - the object to check
     */
    Guard.isElementNode = function (a) {
        return (Guard.isNode(a) && a._nodeType === interfaces_1.NodeType.Element);
    };
    /**
     * Determines if the given object is a custom `Element`.
     *
     * @param a - the object to check
     */
    Guard.isCustomElementNode = function (a) {
        return (Guard.isElementNode(a) && a._customElementState === "custom");
    };
    /**
     * Determines if the given object is a `ShadowRoot`.
     *
     * @param a - the object to check
     */
    Guard.isShadowRoot = function (a) {
        return (!!a && a.host !== undefined);
    };
    /**
     * Determines if the given object is a `MouseEvent`.
     *
     * @param a - the object to check
     */
    Guard.isMouseEvent = function (a) {
        return (!!a && a.screenX !== undefined && a.screenY != undefined);
    };
    /**
     * Determines if the given object is a slotable.
     *
     * Element and Text nodes are slotables. A slotable has an associated name
     * (a string).
     *
     * @param a - the object to check
     */
    Guard.isSlotable = function (a) {
        return (!!a && a._name !== undefined && a._assignedSlot !== undefined &&
            (Guard.isTextNode(a) || Guard.isElementNode(a)));
    };
    /**
     * Determines if the given object is a slot.
     *
     * @param a - the object to check
     */
    Guard.isSlot = function (a) {
        return (!!a && a._name !== undefined && a._assignedNodes !== undefined &&
            Guard.isElementNode(a));
    };
    /**
     * Determines if the given object is a `Window`.
     *
     * @param a - the object to check
     */
    Guard.isWindow = function (a) {
        return (!!a && a.navigator !== undefined);
    };
    /**
     * Determines if the given object is an `EventListener`.
     *
     * @param a - the object to check
     */
    Guard.isEventListener = function (a) {
        return (!!a && a.handleEvent !== undefined);
    };
    /**
     * Determines if the given object is a `RegisteredObserver`.
     *
     * @param a - the object to check
     */
    Guard.isRegisteredObserver = function (a) {
        return (!!a && a.observer !== undefined && a.options !== undefined);
    };
    /**
   * Determines if the given object is a `TransientRegisteredObserver`.
   *
   * @param a - the object to check
   */
    Guard.isTransientRegisteredObserver = function (a) {
        return (!!a && a.source !== undefined && Guard.isRegisteredObserver(a));
    };
    return Guard;
}());
exports.Guard = Guard;
//# sourceMappingURL=Guard.js.map

/***/ }),

/***/ 628:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
var Cast_1 = __nccwpck_require__(7405);
exports.Cast = Cast_1.Cast;
var Guard_1 = __nccwpck_require__(7773);
exports.Guard = Guard_1.Guard;
var EmptySet_1 = __nccwpck_require__(4581);
exports.EmptySet = EmptySet_1.EmptySet;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 9558:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
var CodePoints_1 = __nccwpck_require__(4467);
/**
 * Base-64 encodes the given string.
 *
 * @param input - a string
 */
function forgivingBase64Encode(input) {
    /**
     * To forgiving-base64 encode given a byte sequence data, apply the base64
     * algorithm defined in section 4 of RFC 4648 to data and return the result.
     * [RFC4648]
     */
    return Buffer.from(input).toString('base64');
}
exports.forgivingBase64Encode = forgivingBase64Encode;
/**
 * Decodes a base-64 string.
 *
 * @param input - a string
 */
function forgivingBase64Decode(input) {
    if (input === "")
        return "";
    /**
     * 1. Remove all ASCII whitespace from data.
     */
    input = input.replace(CodePoints_1.ASCIIWhiteSpace, '');
    /**
     * 2. If data’s length divides by 4 leaving no remainder, then:
     * 2.1. If data ends with one or two U+003D (=) code points, then remove them from data.
     */
    if (input.length % 4 === 0) {
        if (input.endsWith("==")) {
            input = input.substr(0, input.length - 2);
        }
        else if (input.endsWith("=")) {
            input = input.substr(0, input.length - 1);
        }
    }
    /**
     * 3. If data’s length divides by 4 leaving a remainder of 1, then return failure.
     */
    if (input.length % 4 === 1)
        return null;
    /**
     * 4. If data contains a code point that is not one of
     * - U+002B (+)
     * - U+002F (/)
     * - ASCII alphanumeric
     * then return failure.
     */
    if (!/[0-9A-Za-z+/]/.test(input))
        return null;
    /**
     * 5. Let output be an empty byte sequence.
     * 6. Let buffer be an empty buffer that can have bits appended to it.
     * 7. Let position be a position variable for data, initially pointing at the
     * start of data.
     * 8. While position does not point past the end of data:
     * 8.1. Find the code point pointed to by position in the second column of
     * Table 1: The Base 64 Alphabet of RFC 4648. Let n be the number given in the
     * first cell of the same row. [RFC4648]
     * 8.2. Append the six bits corresponding to n, most significant bit first,
     * to buffer.
     * 8.3. If buffer has accumulated 24 bits, interpret them as three 8-bit
     * big-endian numbers. Append three bytes with values equal to those numbers
     * to output, in the same order, and then empty buffer.
     * 8.4. Advance position by 1.
     * 9. If buffer is not empty, it contains either 12 or 18 bits. If it contains
     * 12 bits, then discard the last four and interpret the remaining eight as an
     * 8-bit big-endian number. If it contains 18 bits, then discard the last two
     * and interpret the remaining 16 as two 8-bit big-endian numbers. Append the
     * one or two bytes with values equal to those one or two numbers to output,
     * in the same order.
     * 10. Return output.
     */
    return Buffer.from(input, 'base64').toString('utf8');
}
exports.forgivingBase64Decode = forgivingBase64Decode;
//# sourceMappingURL=Base64.js.map

/***/ }),

/***/ 8311:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * Determines if the given number is an ASCII byte.
 *
 * @param byte - a byte
 */
function isASCIIByte(byte) {
    /**
     * An ASCII byte is a byte in the range 0x00 (NUL) to 0x7F (DEL), inclusive.
     */
    return byte >= 0x00 && byte <= 0x7F;
}
exports.isASCIIByte = isASCIIByte;
//# sourceMappingURL=Byte.js.map

/***/ }),

/***/ 4398:
/***/ (function(__unused_webpack_module, exports) {


var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * Returns the count of bytes in a sequence.
 *
 * @param list - a byte sequence
 */
function length(list) {
    /**
     * A byte sequence’s length is the number of bytes it contains.
     */
    return list.length;
}
exports.length = length;
/**
 * Converts each byte to lowercase.
 *
 * @param list - a byte sequence
 */
function byteLowercase(list) {
    /**
     * To byte-lowercase a byte sequence, increase each byte it contains, in the
     * range 0x41 (A) to 0x5A (Z), inclusive, by 0x20.
     */
    for (var i = 0; i < list.length; i++) {
        var c = list[i];
        if (c >= 0x41 && c <= 0x5A) {
            list[i] = c + 0x20;
        }
    }
}
exports.byteLowercase = byteLowercase;
/**
 * Converts each byte to uppercase.
 *
 * @param list - a byte sequence
 */
function byteUppercase(list) {
    /**
     * To byte-uppercase a byte sequence, subtract each byte it contains, in the
     * range 0x61 (a) to 0x7A (z), inclusive, by 0x20.
     */
    for (var i = 0; i < list.length; i++) {
        var c = list[i];
        if (c >= 0x61 && c <= 0x7A) {
            list[i] = c - 0x20;
        }
    }
}
exports.byteUppercase = byteUppercase;
/**
 * Compares two byte sequences.
 *
 * @param listA - a byte sequence
 * @param listB - a byte sequence
 */
function byteCaseInsensitiveMatch(listA, listB) {
    /**
     * A byte sequence A is a byte-case-insensitive match for a byte sequence B,
     * if the byte-lowercase of A is the byte-lowercase of B.
     */
    if (listA.length !== listB.length)
        return false;
    for (var i = 0; i < listA.length; i++) {
        var a = listA[i];
        var b = listB[i];
        if (a >= 0x41 && a <= 0x5A)
            a += 0x20;
        if (b >= 0x41 && b <= 0x5A)
            b += 0x20;
        if (a !== b)
            return false;
    }
    return true;
}
exports.byteCaseInsensitiveMatch = byteCaseInsensitiveMatch;
/**
 * Determines if `listA` starts with `listB`.
 *
 * @param listA - a byte sequence
 * @param listB - a byte sequence
 */
function startsWith(listA, listB) {
    /**
     * 1. Let i be 0.
     * 2. While true:
     * 2.1. Let aByte be the ith byte of a if i is less than a’s length; otherwise null.
     * 2.3. Let bByte be the ith byte of b if i is less than b’s length; otherwise null.
     * 2.4. If bByte is null, then return true.
     * 2.5. Return false if aByte is not bByte.
     * 2.6. Set i to i + 1.
     */
    var i = 0;
    while (true) {
        if (i >= listA.length)
            return false;
        if (i >= listB.length)
            return true;
        if (listA[i] !== listB[i])
            return false;
        i++;
    }
}
exports.startsWith = startsWith;
/**
 * Determines if `listA` is less than `listB`.
 *
 * @param listA - a byte sequence
 * @param listB - a byte sequence
 */
function byteLessThan(listA, listB) {
    /**
     * 1. If b starts with a, then return false.
     * 2. If a starts with b, then return true.
     * 3. Let n be the smallest index such that the nth byte of a is different
     * from the nth byte of b. (There has to be such an index, since neither byte
     * sequence starts with the other.)
     * 4. If the nth byte of a is less than the nth byte of b, then return true.
     * 5. Return false.
     */
    var i = 0;
    while (true) {
        if (i >= listA.length)
            return false;
        if (i >= listB.length)
            return true;
        var a = listA[i];
        var b = listB[i];
        if (a < b)
            return true;
        else if (a > b)
            return false;
        i++;
    }
}
exports.byteLessThan = byteLessThan;
/**
 * Decodes a byte sequence into a string.
 *
 * @param list - a byte sequence
 */
function isomorphicDecode(list) {
    /**
     * To isomorphic decode a byte sequence input, return a string whose length is
     * equal to input’s length and whose code points have the same values as
     * input’s bytes, in the same order.
     */
    return String.fromCodePoint.apply(String, __spread(list));
}
exports.isomorphicDecode = isomorphicDecode;
//# sourceMappingURL=ByteSequence.js.map

/***/ }),

/***/ 4467:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * A surrogate is a code point that is in the range U+D800 to U+DFFF, inclusive.
 */
exports.Surrogate = /[\uD800-\uDFFF]/;
/**
 * A scalar value is a code point that is not a surrogate.
 */
exports.ScalarValue = /[\uD800-\uDFFF]/;
/**
 * A noncharacter is a code point that is in the range U+FDD0 to U+FDEF,
 * inclusive, or U+FFFE, U+FFFF, U+1FFFE, U+1FFFF, U+2FFFE, U+2FFFF, U+3FFFE,
 * U+3FFFF, U+4FFFE, U+4FFFF, U+5FFFE, U+5FFFF, U+6FFFE, U+6FFFF, U+7FFFE,
 * U+7FFFF, U+8FFFE, U+8FFFF, U+9FFFE, U+9FFFF, U+AFFFE, U+AFFFF, U+BFFFE,
 * U+BFFFF, U+CFFFE, U+CFFFF, U+DFFFE, U+DFFFF, U+EFFFE, U+EFFFF, U+FFFFE,
 * U+FFFFF, U+10FFFE, or U+10FFFF.
 */
exports.NonCharacter = /[\uFDD0-\uFDEF\uFFFE\uFFFF]|[\uD83F\uD87F\uD8BF\uD8FF\uD93F\uD97F\uD9BF\uD9FF\uDA3F\uDA7F\uDABF\uDAFF\uDB3F\uDB7F\uDBBF\uDBFF][\uDFFE\uDFFF]/;
/**
 * An ASCII code point is a code point in the range U+0000 NULL to U+007F
 * DELETE, inclusive.
 */
exports.ASCIICodePoint = /[\u0000-\u007F]/;
/**
 * An ASCII tab or newline is U+0009 TAB, U+000A LF, or U+000D CR.
 */
exports.ASCIITabOrNewLine = /[\t\n\r]/;
/**
 * ASCII whitespace is U+0009 TAB, U+000A LF, U+000C FF, U+000D CR, or
 * U+0020 SPACE.
 */
exports.ASCIIWhiteSpace = /[\t\n\f\r ]/;
/**
 * A C0 control is a code point in the range U+0000 NULL to U+001F
 * INFORMATION SEPARATOR ONE, inclusive.
 */
exports.C0Control = /[\u0000-\u001F]/;
/**
 * A C0 control or space is a C0 control or U+0020 SPACE.
 */
exports.C0ControlOrSpace = /[\u0000-\u001F ]/;
/**
 * A control is a C0 control or a code point in the range U+007F DELETE to
 * U+009F APPLICATION PROGRAM COMMAND, inclusive.
 */
exports.Control = /[\u0000-\u001F\u007F-\u009F]/;
/**
 * An ASCII digit is a code point in the range U+0030 (0) to U+0039 (9),
 * inclusive.
 */
exports.ASCIIDigit = /[0-9]/;
/**
 * An ASCII upper hex digit is an ASCII digit or a code point in the range
 * U+0041 (A) to U+0046 (F), inclusive.
 */
exports.ASCIIUpperHexDigit = /[0-9A-F]/;
/**
 * An ASCII lower hex digit is an ASCII digit or a code point in the range
 * U+0061 (a) to U+0066 (f), inclusive.
 */
exports.ASCIILowerHexDigit = /[0-9a-f]/;
/**
 * An ASCII hex digit is an ASCII upper hex digit or ASCII lower hex digit.
 */
exports.ASCIIHexDigit = /[0-9A-Fa-f]/;
/**
 * An ASCII upper alpha is a code point in the range U+0041 (A) to U+005A (Z),
 * inclusive.
 */
exports.ASCIIUpperAlpha = /[A-Z]/;
/**
 * An ASCII lower alpha is a code point in the range U+0061 (a) to U+007A (z),
 * inclusive.
 */
exports.ASCIILowerAlpha = /[a-z]/;
/**
 * An ASCII alpha is an ASCII upper alpha or ASCII lower alpha.
 */
exports.ASCIIAlpha = /[A-Za-z]/;
/**
 * An ASCII alphanumeric is an ASCII digit or ASCII alpha.
 */
exports.ASCIIAlphanumeric = /[0-9A-Za-z]/;
//# sourceMappingURL=CodePoints.js.map

/***/ }),

/***/ 5475:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {


var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var util_1 = __nccwpck_require__(7061);
/**
 * Parses the given byte sequence representing a JSON string into an object.
 *
 * @param bytes - a byte sequence
 */
function parseJSONFromBytes(bytes) {
    /**
     * 1. Let jsonText be the result of running UTF-8 decode on bytes. [ENCODING]
     * 2. Return ? Call(%JSONParse%, undefined, « jsonText »).
     */
    var jsonText = util_1.utf8Decode(bytes);
    return JSON.parse.call(undefined, jsonText);
}
exports.parseJSONFromBytes = parseJSONFromBytes;
/**
 * Serialize the given JavaScript value into a byte sequence.
 *
 * @param value - a JavaScript value
 */
function serializeJSONToBytes(value) {
    /**
     * 1. Let jsonString be ? Call(%JSONStringify%, undefined, « value »).
     * 2. Return the result of running UTF-8 encode on jsonString. [ENCODING]
     */
    var jsonString = JSON.stringify.call(undefined, value);
    return util_1.utf8Encode(jsonString);
}
exports.serializeJSONToBytes = serializeJSONToBytes;
/**
 * Parses the given JSON string into a Realm-independent JavaScript value.
 *
 * @param jsonText - a JSON string
 */
function parseJSONIntoInfraValues(jsonText) {
    /**
     * 1. Let jsValue be ? Call(%JSONParse%, undefined, « jsonText »).
     * 2. Return the result of converting a JSON-derived JavaScript value to an
     * Infra value, given jsValue.
     */
    var jsValue = JSON.parse.call(undefined, jsonText);
    return convertAJSONDerivedJavaScriptValueToAnInfraValue(jsValue);
}
exports.parseJSONIntoInfraValues = parseJSONIntoInfraValues;
/**
 * Parses the value into a Realm-independent JavaScript value.
 *
 * @param jsValue - a JavaScript value
 */
function convertAJSONDerivedJavaScriptValueToAnInfraValue(jsValue) {
    var e_1, _a;
    /**
     * 1. If Type(jsValue) is Null, String, or Number, then return jsValue.
     */
    if (jsValue === null || util_1.isString(jsValue) || util_1.isNumber(jsValue))
        return jsValue;
    /**
     * 2. If IsArray(jsValue) is true, then:
     * 2.1. Let result be an empty list.
     * 2.2. Let length be ! ToLength(! Get(jsValue, "length")).
     * 2.3. For each index of the range 0 to length − 1, inclusive:
     * 2.3.1. Let indexName be ! ToString(index).
     * 2.3.2. Let jsValueAtIndex be ! Get(jsValue, indexName).
     * 2.3.3. Let infraValueAtIndex be the result of converting a JSON-derived
     * JavaScript value to an Infra value, given jsValueAtIndex.
     * 2.3.4. Append infraValueAtIndex to result.
     * 2.8. Return result.
     */
    if (util_1.isArray(jsValue)) {
        var result = new Array();
        try {
            for (var jsValue_1 = __values(jsValue), jsValue_1_1 = jsValue_1.next(); !jsValue_1_1.done; jsValue_1_1 = jsValue_1.next()) {
                var jsValueAtIndex = jsValue_1_1.value;
                result.push(convertAJSONDerivedJavaScriptValueToAnInfraValue(jsValueAtIndex));
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (jsValue_1_1 && !jsValue_1_1.done && (_a = jsValue_1.return)) _a.call(jsValue_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return result;
    }
    else if (util_1.isObject(jsValue)) {
        /**
         * 3. Let result be an empty ordered map.
         * 4. For each key of ! jsValue.[[OwnPropertyKeys]]():
         * 4.1. Let jsValueAtKey be ! Get(jsValue, key).
         * 4.2. Let infraValueAtKey be the result of converting a JSON-derived
         * JavaScript value to an Infra value, given jsValueAtKey.
         * 4.3. Set result[key] to infraValueAtKey.
         * 5. Return result.
         */
        var result = new Map();
        for (var key in jsValue) {
            /* istanbul ignore else */
            if (jsValue.hasOwnProperty(key)) {
                var jsValueAtKey = jsValue[key];
                result.set(key, convertAJSONDerivedJavaScriptValueToAnInfraValue(jsValueAtKey));
            }
        }
        return result;
    }
    /* istanbul ignore next */
    return jsValue;
}
exports.convertAJSONDerivedJavaScriptValueToAnInfraValue = convertAJSONDerivedJavaScriptValueToAnInfraValue;
//# sourceMappingURL=JSON.js.map

/***/ }),

/***/ 1193:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {


var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var util_1 = __nccwpck_require__(7061);
/**
 * Adds the given item to the end of the list.
 *
 * @param list - a list
 * @param item - an item
 */
function append(list, item) {
    list.push(item);
}
exports.append = append;
/**
 * Extends a list by appending all items from another list.
 *
 * @param listA - a list to extend
 * @param listB - a list containing items to append to `listA`
 */
function extend(listA, listB) {
    listA.push.apply(listA, __spread(listB));
}
exports.extend = extend;
/**
 * Inserts the given item to the start of the list.
 *
 * @param list - a list
 * @param item - an item
 */
function prepend(list, item) {
    list.unshift(item);
}
exports.prepend = prepend;
/**
 * Replaces the given item or all items matching condition with a new item.
 *
 * @param list - a list
 * @param conditionOrItem - an item to replace or a condition matching items
 * to replace
 * @param item - an item
 */
function replace(list, conditionOrItem, newItem) {
    var e_1, _a;
    var i = 0;
    try {
        for (var list_1 = __values(list), list_1_1 = list_1.next(); !list_1_1.done; list_1_1 = list_1.next()) {
            var oldItem = list_1_1.value;
            if (util_1.isFunction(conditionOrItem)) {
                if (!!conditionOrItem.call(null, oldItem)) {
                    list[i] = newItem;
                }
            }
            else if (oldItem === conditionOrItem) {
                list[i] = newItem;
                return;
            }
            i++;
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (list_1_1 && !list_1_1.done && (_a = list_1.return)) _a.call(list_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
}
exports.replace = replace;
/**
 * Inserts the given item before the given index.
 *
 * @param list - a list
 * @param item - an item
 */
function insert(list, item, index) {
    list.splice(index, 0, item);
}
exports.insert = insert;
/**
 * Removes the given item or all items matching condition.
 *
 * @param list - a list
 * @param conditionOrItem - an item to remove or a condition matching items
 * to remove
 */
function remove(list, conditionOrItem) {
    var i = list.length;
    while (i--) {
        var oldItem = list[i];
        if (util_1.isFunction(conditionOrItem)) {
            if (!!conditionOrItem.call(null, oldItem)) {
                list.splice(i, 1);
            }
        }
        else if (oldItem === conditionOrItem) {
            list.splice(i, 1);
            return;
        }
    }
}
exports.remove = remove;
/**
 * Removes all items from the list.
 */
function empty(list) {
    list.length = 0;
}
exports.empty = empty;
/**
 * Determines if the list contains the given item or any items matching
 * condition.
 *
 * @param list - a list
 * @param conditionOrItem - an item to a condition to match
 */
function contains(list, conditionOrItem) {
    var e_2, _a;
    try {
        for (var list_2 = __values(list), list_2_1 = list_2.next(); !list_2_1.done; list_2_1 = list_2.next()) {
            var oldItem = list_2_1.value;
            if (util_1.isFunction(conditionOrItem)) {
                if (!!conditionOrItem.call(null, oldItem)) {
                    return true;
                }
            }
            else if (oldItem === conditionOrItem) {
                return true;
            }
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (list_2_1 && !list_2_1.done && (_a = list_2.return)) _a.call(list_2);
        }
        finally { if (e_2) throw e_2.error; }
    }
    return false;
}
exports.contains = contains;
/**
 * Returns the count of items in the list matching the given condition.
 *
 * @param list - a list
 * @param condition - an optional condition to match
 */
function size(list, condition) {
    var e_3, _a;
    if (condition === undefined) {
        return list.length;
    }
    else {
        var count = 0;
        try {
            for (var list_3 = __values(list), list_3_1 = list_3.next(); !list_3_1.done; list_3_1 = list_3.next()) {
                var item = list_3_1.value;
                if (!!condition.call(null, item)) {
                    count++;
                }
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (list_3_1 && !list_3_1.done && (_a = list_3.return)) _a.call(list_3);
            }
            finally { if (e_3) throw e_3.error; }
        }
        return count;
    }
}
exports.size = size;
/**
 * Determines if the list is empty.
 *
 * @param list - a list
 */
function isEmpty(list) {
    return list.length === 0;
}
exports.isEmpty = isEmpty;
/**
 * Returns an iterator for the items of the list.
 *
 * @param list - a list
 * @param condition - an optional condition to match
 */
function forEach(list, condition) {
    var list_4, list_4_1, item, e_4_1;
    var e_4, _a;
    return __generator(this, function (_b) {
        switch (_b.label) {
            case 0:
                if (!(condition === undefined)) return [3 /*break*/, 2];
                return [5 /*yield**/, __values(list)];
            case 1:
                _b.sent();
                return [3 /*break*/, 9];
            case 2:
                _b.trys.push([2, 7, 8, 9]);
                list_4 = __values(list), list_4_1 = list_4.next();
                _b.label = 3;
            case 3:
                if (!!list_4_1.done) return [3 /*break*/, 6];
                item = list_4_1.value;
                if (!!!condition.call(null, item)) return [3 /*break*/, 5];
                return [4 /*yield*/, item];
            case 4:
                _b.sent();
                _b.label = 5;
            case 5:
                list_4_1 = list_4.next();
                return [3 /*break*/, 3];
            case 6: return [3 /*break*/, 9];
            case 7:
                e_4_1 = _b.sent();
                e_4 = { error: e_4_1 };
                return [3 /*break*/, 9];
            case 8:
                try {
                    if (list_4_1 && !list_4_1.done && (_a = list_4.return)) _a.call(list_4);
                }
                finally { if (e_4) throw e_4.error; }
                return [7 /*endfinally*/];
            case 9: return [2 /*return*/];
        }
    });
}
exports.forEach = forEach;
/**
 * Creates and returns a shallow clone of list.
 *
 * @param list - a list
 */
function clone(list) {
    return new (Array.bind.apply(Array, __spread([void 0], list)))();
}
exports.clone = clone;
/**
 * Returns a new list containing items from the list sorted in ascending
 * order.
 *
 * @param list - a list
 * @param lessThanAlgo - a function that returns `true` if its first argument
 * is less than its second argument, and `false` otherwise.
 */
function sortInAscendingOrder(list, lessThanAlgo) {
    return list.sort(function (itemA, itemB) {
        return lessThanAlgo.call(null, itemA, itemB) ? -1 : 1;
    });
}
exports.sortInAscendingOrder = sortInAscendingOrder;
/**
 * Returns a new list containing items from the list sorted in descending
 * order.
 *
 * @param list - a list
 * @param lessThanAlgo - a function that returns `true` if its first argument
 * is less than its second argument, and `false` otherwise.
 */
function sortInDescendingOrder(list, lessThanAlgo) {
    return list.sort(function (itemA, itemB) {
        return lessThanAlgo.call(null, itemA, itemB) ? 1 : -1;
    });
}
exports.sortInDescendingOrder = sortInDescendingOrder;
//# sourceMappingURL=List.js.map

/***/ }),

/***/ 6067:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {


var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var util_1 = __nccwpck_require__(7061);
/**
 * Gets the value corresponding to the given key.
 *
 * @param map - a map
 * @param key - a key
 */
function get(map, key) {
    return map.get(key);
}
exports.get = get;
/**
 * Sets the value corresponding to the given key.
 *
 * @param map - a map
 * @param key - a key
 * @param val - a value
 */
function set(map, key, val) {
    map.set(key, val);
}
exports.set = set;
/**
 * Removes the item with the given key or all items matching condition.
 *
 * @param map - a map
 * @param conditionOrItem - the key of an item to remove or a condition matching
 * items to remove
 */
function remove(map, conditionOrItem) {
    var e_1, _a, e_2, _b;
    if (!util_1.isFunction(conditionOrItem)) {
        map.delete(conditionOrItem);
    }
    else {
        var toRemove = [];
        try {
            for (var map_1 = __values(map), map_1_1 = map_1.next(); !map_1_1.done; map_1_1 = map_1.next()) {
                var item = map_1_1.value;
                if (!!conditionOrItem.call(null, item)) {
                    toRemove.push(item[0]);
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (map_1_1 && !map_1_1.done && (_a = map_1.return)) _a.call(map_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        try {
            for (var toRemove_1 = __values(toRemove), toRemove_1_1 = toRemove_1.next(); !toRemove_1_1.done; toRemove_1_1 = toRemove_1.next()) {
                var key = toRemove_1_1.value;
                map.delete(key);
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (toRemove_1_1 && !toRemove_1_1.done && (_b = toRemove_1.return)) _b.call(toRemove_1);
            }
            finally { if (e_2) throw e_2.error; }
        }
    }
}
exports.remove = remove;
/**
 * Determines if the map contains a value with the given key.
 *
 * @param map - a map
 * @param conditionOrItem - the key of an item to match or a condition matching
 * items
 */
function contains(map, conditionOrItem) {
    var e_3, _a;
    if (!util_1.isFunction(conditionOrItem)) {
        return map.has(conditionOrItem);
    }
    else {
        try {
            for (var map_2 = __values(map), map_2_1 = map_2.next(); !map_2_1.done; map_2_1 = map_2.next()) {
                var item = map_2_1.value;
                if (!!conditionOrItem.call(null, item)) {
                    return true;
                }
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (map_2_1 && !map_2_1.done && (_a = map_2.return)) _a.call(map_2);
            }
            finally { if (e_3) throw e_3.error; }
        }
        return false;
    }
}
exports.contains = contains;
/**
 * Gets the keys of the map.
 *
 * @param map - a map
 */
function keys(map) {
    return new Set(map.keys());
}
exports.keys = keys;
/**
 * Gets the values of the map.
 *
 * @param map - a map
 */
function values(map) {
    return __spread(map.values());
}
exports.values = values;
/**
 * Gets the size of the map.
 *
 * @param map - a map
 * @param condition - an optional condition to match
 */
function size(map, condition) {
    var e_4, _a;
    if (condition === undefined) {
        return map.size;
    }
    else {
        var count = 0;
        try {
            for (var map_3 = __values(map), map_3_1 = map_3.next(); !map_3_1.done; map_3_1 = map_3.next()) {
                var item = map_3_1.value;
                if (!!condition.call(null, item)) {
                    count++;
                }
            }
        }
        catch (e_4_1) { e_4 = { error: e_4_1 }; }
        finally {
            try {
                if (map_3_1 && !map_3_1.done && (_a = map_3.return)) _a.call(map_3);
            }
            finally { if (e_4) throw e_4.error; }
        }
        return count;
    }
}
exports.size = size;
/**
 * Determines if the map is empty.
 *
 * @param map - a map
 */
function isEmpty(map) {
    return map.size === 0;
}
exports.isEmpty = isEmpty;
/**
 * Returns an iterator for the items of the map.
 *
 * @param map - a map
 * @param condition - an optional condition to match
 */
function forEach(map, condition) {
    var map_4, map_4_1, item, e_5_1;
    var e_5, _a;
    return __generator(this, function (_b) {
        switch (_b.label) {
            case 0:
                if (!(condition === undefined)) return [3 /*break*/, 2];
                return [5 /*yield**/, __values(map)];
            case 1:
                _b.sent();
                return [3 /*break*/, 9];
            case 2:
                _b.trys.push([2, 7, 8, 9]);
                map_4 = __values(map), map_4_1 = map_4.next();
                _b.label = 3;
            case 3:
                if (!!map_4_1.done) return [3 /*break*/, 6];
                item = map_4_1.value;
                if (!!!condition.call(null, item)) return [3 /*break*/, 5];
                return [4 /*yield*/, item];
            case 4:
                _b.sent();
                _b.label = 5;
            case 5:
                map_4_1 = map_4.next();
                return [3 /*break*/, 3];
            case 6: return [3 /*break*/, 9];
            case 7:
                e_5_1 = _b.sent();
                e_5 = { error: e_5_1 };
                return [3 /*break*/, 9];
            case 8:
                try {
                    if (map_4_1 && !map_4_1.done && (_a = map_4.return)) _a.call(map_4);
                }
                finally { if (e_5) throw e_5.error; }
                return [7 /*endfinally*/];
            case 9: return [2 /*return*/];
        }
    });
}
exports.forEach = forEach;
/**
 * Creates and returns a shallow clone of map.
 *
 * @param map - a map
 */
function clone(map) {
    return new Map(map);
}
exports.clone = clone;
/**
 * Returns a new map containing items from the map sorted in ascending
 * order.
 *
 * @param map - a map
 * @param lessThanAlgo - a function that returns `true` if its first argument
 * is less than its second argument, and `false` otherwise.
 */
function sortInAscendingOrder(map, lessThanAlgo) {
    var list = new (Array.bind.apply(Array, __spread([void 0], map)))();
    list.sort(function (itemA, itemB) {
        return lessThanAlgo.call(null, itemA, itemB) ? -1 : 1;
    });
    return new Map(list);
}
exports.sortInAscendingOrder = sortInAscendingOrder;
/**
 * Returns a new map containing items from the map sorted in descending
 * order.
 *
 * @param map - a map
 * @param lessThanAlgo - a function that returns `true` if its first argument
 * is less than its second argument, and `false` otherwise.
 */
function sortInDescendingOrder(map, lessThanAlgo) {
    var list = new (Array.bind.apply(Array, __spread([void 0], map)))();
    list.sort(function (itemA, itemB) {
        return lessThanAlgo.call(null, itemA, itemB) ? 1 : -1;
    });
    return new Map(list);
}
exports.sortInDescendingOrder = sortInDescendingOrder;
//# sourceMappingURL=Map.js.map

/***/ }),

/***/ 9018:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HTML = "http://www.w3.org/1999/xhtml";
exports.XML = "http://www.w3.org/XML/1998/namespace";
exports.XMLNS = "http://www.w3.org/2000/xmlns/";
exports.MathML = "http://www.w3.org/1998/Math/MathML";
exports.SVG = "http://www.w3.org/2000/svg";
exports.XLink = "http://www.w3.org/1999/xlink";
//# sourceMappingURL=Namespace.js.map

/***/ }),

/***/ 7758:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * Appends the given item to the queue.
 *
 * @param list - a list
 * @param item - an item
 */
function enqueue(list, item) {
    list.push(item);
}
exports.enqueue = enqueue;
/**
 * Removes and returns an item from the queue.
 *
 * @param list - a list
 */
function dequeue(list) {
    return list.shift() || null;
}
exports.dequeue = dequeue;
//# sourceMappingURL=Queue.js.map

/***/ }),

/***/ 2237:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {


var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var util_1 = __nccwpck_require__(7061);
/**
 * Adds the given item to the end of the set.
 *
 * @param set - a set
 * @param item - an item
 */
function append(set, item) {
    set.add(item);
}
exports.append = append;
/**
 * Extends a set by appending all items from another set.
 *
 * @param setA - a list to extend
 * @param setB - a list containing items to append to `setA`
 */
function extend(setA, setB) {
    setB.forEach(setA.add, setA);
}
exports.extend = extend;
/**
 * Inserts the given item to the start of the set.
 *
 * @param set - a set
 * @param item - an item
 */
function prepend(set, item) {
    var cloned = new Set(set);
    set.clear();
    set.add(item);
    cloned.forEach(set.add, set);
}
exports.prepend = prepend;
/**
 * Replaces the given item or all items matching condition with a new item.
 *
 * @param set - a set
 * @param conditionOrItem - an item to replace or a condition matching items
 * to replace
 * @param item - an item
 */
function replace(set, conditionOrItem, newItem) {
    var e_1, _a;
    var newSet = new Set();
    try {
        for (var set_1 = __values(set), set_1_1 = set_1.next(); !set_1_1.done; set_1_1 = set_1.next()) {
            var oldItem = set_1_1.value;
            if (util_1.isFunction(conditionOrItem)) {
                if (!!conditionOrItem.call(null, oldItem)) {
                    newSet.add(newItem);
                }
                else {
                    newSet.add(oldItem);
                }
            }
            else if (oldItem === conditionOrItem) {
                newSet.add(newItem);
            }
            else {
                newSet.add(oldItem);
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (set_1_1 && !set_1_1.done && (_a = set_1.return)) _a.call(set_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    set.clear();
    newSet.forEach(set.add, set);
}
exports.replace = replace;
/**
 * Inserts the given item before the given index.
 *
 * @param set - a set
 * @param item - an item
 */
function insert(set, item, index) {
    var e_2, _a;
    var newSet = new Set();
    var i = 0;
    try {
        for (var set_2 = __values(set), set_2_1 = set_2.next(); !set_2_1.done; set_2_1 = set_2.next()) {
            var oldItem = set_2_1.value;
            if (i === index)
                newSet.add(item);
            newSet.add(oldItem);
            i++;
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (set_2_1 && !set_2_1.done && (_a = set_2.return)) _a.call(set_2);
        }
        finally { if (e_2) throw e_2.error; }
    }
    set.clear();
    newSet.forEach(set.add, set);
}
exports.insert = insert;
/**
 * Removes the given item or all items matching condition.
 *
 * @param set - a set
 * @param conditionOrItem - an item to remove or a condition matching items
 * to remove
 */
function remove(set, conditionOrItem) {
    var e_3, _a, e_4, _b;
    if (!util_1.isFunction(conditionOrItem)) {
        set.delete(conditionOrItem);
    }
    else {
        var toRemove = [];
        try {
            for (var set_3 = __values(set), set_3_1 = set_3.next(); !set_3_1.done; set_3_1 = set_3.next()) {
                var item = set_3_1.value;
                if (!!conditionOrItem.call(null, item)) {
                    toRemove.push(item);
                }
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (set_3_1 && !set_3_1.done && (_a = set_3.return)) _a.call(set_3);
            }
            finally { if (e_3) throw e_3.error; }
        }
        try {
            for (var toRemove_1 = __values(toRemove), toRemove_1_1 = toRemove_1.next(); !toRemove_1_1.done; toRemove_1_1 = toRemove_1.next()) {
                var oldItem = toRemove_1_1.value;
                set.delete(oldItem);
            }
        }
        catch (e_4_1) { e_4 = { error: e_4_1 }; }
        finally {
            try {
                if (toRemove_1_1 && !toRemove_1_1.done && (_b = toRemove_1.return)) _b.call(toRemove_1);
            }
            finally { if (e_4) throw e_4.error; }
        }
    }
}
exports.remove = remove;
/**
 * Removes all items from the set.
 */
function empty(set) {
    set.clear();
}
exports.empty = empty;
/**
 * Determines if the set contains the given item or any items matching
 * condition.
 *
 * @param set - a set
 * @param conditionOrItem - an item to a condition to match
 */
function contains(set, conditionOrItem) {
    var e_5, _a;
    if (!util_1.isFunction(conditionOrItem)) {
        return set.has(conditionOrItem);
    }
    else {
        try {
            for (var set_4 = __values(set), set_4_1 = set_4.next(); !set_4_1.done; set_4_1 = set_4.next()) {
                var oldItem = set_4_1.value;
                if (!!conditionOrItem.call(null, oldItem)) {
                    return true;
                }
            }
        }
        catch (e_5_1) { e_5 = { error: e_5_1 }; }
        finally {
            try {
                if (set_4_1 && !set_4_1.done && (_a = set_4.return)) _a.call(set_4);
            }
            finally { if (e_5) throw e_5.error; }
        }
    }
    return false;
}
exports.contains = contains;
/**
 * Returns the count of items in the set matching the given condition.
 *
 * @param set - a set
 * @param condition - an optional condition to match
 */
function size(set, condition) {
    var e_6, _a;
    if (condition === undefined) {
        return set.size;
    }
    else {
        var count = 0;
        try {
            for (var set_5 = __values(set), set_5_1 = set_5.next(); !set_5_1.done; set_5_1 = set_5.next()) {
                var item = set_5_1.value;
                if (!!condition.call(null, item)) {
                    count++;
                }
            }
        }
        catch (e_6_1) { e_6 = { error: e_6_1 }; }
        finally {
            try {
                if (set_5_1 && !set_5_1.done && (_a = set_5.return)) _a.call(set_5);
            }
            finally { if (e_6) throw e_6.error; }
        }
        return count;
    }
}
exports.size = size;
/**
 * Determines if the set is empty.
 *
 * @param set - a set
 */
function isEmpty(set) {
    return set.size === 0;
}
exports.isEmpty = isEmpty;
/**
 * Returns an iterator for the items of the set.
 *
 * @param set - a set
 * @param condition - an optional condition to match
 */
function forEach(set, condition) {
    var set_6, set_6_1, item, e_7_1;
    var e_7, _a;
    return __generator(this, function (_b) {
        switch (_b.label) {
            case 0:
                if (!(condition === undefined)) return [3 /*break*/, 2];
                return [5 /*yield**/, __values(set)];
            case 1:
                _b.sent();
                return [3 /*break*/, 9];
            case 2:
                _b.trys.push([2, 7, 8, 9]);
                set_6 = __values(set), set_6_1 = set_6.next();
                _b.label = 3;
            case 3:
                if (!!set_6_1.done) return [3 /*break*/, 6];
                item = set_6_1.value;
                if (!!!condition.call(null, item)) return [3 /*break*/, 5];
                return [4 /*yield*/, item];
            case 4:
                _b.sent();
                _b.label = 5;
            case 5:
                set_6_1 = set_6.next();
                return [3 /*break*/, 3];
            case 6: return [3 /*break*/, 9];
            case 7:
                e_7_1 = _b.sent();
                e_7 = { error: e_7_1 };
                return [3 /*break*/, 9];
            case 8:
                try {
                    if (set_6_1 && !set_6_1.done && (_a = set_6.return)) _a.call(set_6);
                }
                finally { if (e_7) throw e_7.error; }
                return [7 /*endfinally*/];
            case 9: return [2 /*return*/];
        }
    });
}
exports.forEach = forEach;
/**
 * Creates and returns a shallow clone of set.
 *
 * @param set - a set
 */
function clone(set) {
    return new Set(set);
}
exports.clone = clone;
/**
 * Returns a new set containing items from the set sorted in ascending
 * order.
 *
 * @param set - a set
 * @param lessThanAlgo - a function that returns `true` if its first argument
 * is less than its second argument, and `false` otherwise.
 */
function sortInAscendingOrder(set, lessThanAlgo) {
    var list = new (Array.bind.apply(Array, __spread([void 0], set)))();
    list.sort(function (itemA, itemB) {
        return lessThanAlgo.call(null, itemA, itemB) ? -1 : 1;
    });
    return new Set(list);
}
exports.sortInAscendingOrder = sortInAscendingOrder;
/**
 * Returns a new set containing items from the set sorted in descending
 * order.
 *
 * @param set - a set
 * @param lessThanAlgo - a function that returns `true` if its first argument
 * is less than its second argument, and `false` otherwise.
 */
function sortInDescendingOrder(set, lessThanAlgo) {
    var list = new (Array.bind.apply(Array, __spread([void 0], set)))();
    list.sort(function (itemA, itemB) {
        return lessThanAlgo.call(null, itemA, itemB) ? 1 : -1;
    });
    return new Set(list);
}
exports.sortInDescendingOrder = sortInDescendingOrder;
/**
 * Determines if a set is a subset of another set.
 *
 * @param subset - a set
 * @param superset - a superset possibly containing all items from `subset`.
 */
function isSubsetOf(subset, superset) {
    var e_8, _a;
    try {
        for (var subset_1 = __values(subset), subset_1_1 = subset_1.next(); !subset_1_1.done; subset_1_1 = subset_1.next()) {
            var item = subset_1_1.value;
            if (!superset.has(item))
                return false;
        }
    }
    catch (e_8_1) { e_8 = { error: e_8_1 }; }
    finally {
        try {
            if (subset_1_1 && !subset_1_1.done && (_a = subset_1.return)) _a.call(subset_1);
        }
        finally { if (e_8) throw e_8.error; }
    }
    return true;
}
exports.isSubsetOf = isSubsetOf;
/**
 * Determines if a set is a superset of another set.
 *
 * @param superset - a set
 * @param subset - a subset possibly contained within `superset`.
 */
function isSupersetOf(superset, subset) {
    return isSubsetOf(subset, superset);
}
exports.isSupersetOf = isSupersetOf;
/**
 * Returns a new set with items that are contained in both sets.
 *
 * @param setA - a set
 * @param setB - a set
 */
function intersection(setA, setB) {
    var e_9, _a;
    var newSet = new Set();
    try {
        for (var setA_1 = __values(setA), setA_1_1 = setA_1.next(); !setA_1_1.done; setA_1_1 = setA_1.next()) {
            var item = setA_1_1.value;
            if (setB.has(item))
                newSet.add(item);
        }
    }
    catch (e_9_1) { e_9 = { error: e_9_1 }; }
    finally {
        try {
            if (setA_1_1 && !setA_1_1.done && (_a = setA_1.return)) _a.call(setA_1);
        }
        finally { if (e_9) throw e_9.error; }
    }
    return newSet;
}
exports.intersection = intersection;
/**
 * Returns a new set with items from both sets.
 *
 * @param setA - a set
 * @param setB - a set
 */
function union(setA, setB) {
    var newSet = new Set(setA);
    setB.forEach(newSet.add, newSet);
    return newSet;
}
exports.union = union;
/**
 * Returns a set of integers from `n` to `m` inclusive.
 *
 * @param n - starting number
 * @param m - ending number
 */
function range(n, m) {
    var newSet = new Set();
    for (var i = n; i <= m; i++) {
        newSet.add(i);
    }
    return newSet;
}
exports.range = range;
//# sourceMappingURL=Set.js.map

/***/ }),

/***/ 9221:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * Pushes the given item to the stack.
 *
 * @param list - a list
 * @param item - an item
 */
function push(list, item) {
    list.push(item);
}
exports.push = push;
/**
 * Pops and returns an item from the stack.
 *
 * @param list - a list
 */
function pop(list) {
    return list.pop() || null;
}
exports.pop = pop;
//# sourceMappingURL=Stack.js.map

/***/ }),

/***/ 2472:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {


var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var CodePoints_1 = __nccwpck_require__(4467);
var ByteSequence_1 = __nccwpck_require__(4398);
var Byte_1 = __nccwpck_require__(8311);
var util_1 = __nccwpck_require__(7061);
/**
 * Determines if the string `a` is a code unit prefix of string `b`.
 *
 * @param a - a string
 * @param b - a string
 */
function isCodeUnitPrefix(a, b) {
    /**
     * 1. Let i be 0.
     * 2. While true:
     * 2.1. Let aCodeUnit be the ith code unit of a if i is less than a’s length;
     * otherwise null.
     * 2.2. Let bCodeUnit be the ith code unit of b if i is less than b’s length;
     * otherwise null.
     * 2.3. If bCodeUnit is null, then return true.
     * 2.4. Return false if aCodeUnit is different from bCodeUnit.
     * 2.5. Set i to i + 1.
     */
    var i = 0;
    while (true) {
        var aCodeUnit = i < a.length ? a.charCodeAt(i) : null;
        var bCodeUnit = i < b.length ? b.charCodeAt(i) : null;
        if (aCodeUnit === null)
            return true;
        if (aCodeUnit !== bCodeUnit)
            return false;
        i++;
    }
}
exports.isCodeUnitPrefix = isCodeUnitPrefix;
/**
 * Determines if the string `a` is a code unit less than string `b`.
 *
 * @param a - a string
 * @param b - a string
 */
function isCodeUnitLessThan(a, b) {
    /**
     * 1. If b is a code unit prefix of a, then return false.
     * 2. If a is a code unit prefix of b, then return true.
     * 3. Let n be the smallest index such that the nth code unit of a is
     * different from the nth code unit of b. (There has to be such an index,
     * since neither string is a prefix of the other.)
     * 4. If the nth code unit of a is less than the nth code unit of b, then
     * return true.
     * 5. Return false.
     */
    if (isCodeUnitPrefix(b, a))
        return false;
    if (isCodeUnitPrefix(a, b))
        return true;
    for (var i = 0; i < Math.min(a.length, b.length); i++) {
        var aCodeUnit = a.charCodeAt(i);
        var bCodeUnit = b.charCodeAt(i);
        if (aCodeUnit === bCodeUnit)
            continue;
        return (aCodeUnit < bCodeUnit);
    }
    /* istanbul ignore next */
    return false;
}
exports.isCodeUnitLessThan = isCodeUnitLessThan;
/**
 * Isomorphic encodes the given string.
 *
 * @param str - a string
 */
function isomorphicEncode(str) {
    var e_1, _a;
    /**
     * 1. Assert: input contains no code points greater than U+00FF.
     * 2. Return a byte sequence whose length is equal to input’s length and whose
     * bytes have the same values as input’s code points, in the same order.
     */
    var codePoints = Array.from(str);
    var bytes = new Uint8Array(codePoints.length);
    var i = 0;
    try {
        for (var str_1 = __values(str), str_1_1 = str_1.next(); !str_1_1.done; str_1_1 = str_1.next()) {
            var codePoint = str_1_1.value;
            var byte = codePoint.codePointAt(0);
            console.assert(byte !== undefined && byte <= 0x00FF, "isomorphicEncode requires string bytes to be less than or equal to 0x00FF.");
            if (byte !== undefined && byte <= 0x00FF) {
                bytes[i++] = byte;
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (str_1_1 && !str_1_1.done && (_a = str_1.return)) _a.call(str_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return bytes;
}
exports.isomorphicEncode = isomorphicEncode;
/**
 * Determines if the given string is An ASCII string.
 *
 * @param str - a string
 */
function isASCIIString(str) {
    /**
     * An ASCII string is a string whose code points are all ASCII code points.
     */
    return /^[\u0000-\u007F]*$/.test(str);
}
exports.isASCIIString = isASCIIString;
/**
 * Converts all uppercase ASCII code points to lowercase.
 *
 * @param str - a string
 */
function asciiLowercase(str) {
    var e_2, _a;
    /**
     * To ASCII lowercase a string, replace all ASCII upper alphas in the string
     * with their corresponding code point in ASCII lower alpha.
     */
    var result = "";
    try {
        for (var str_2 = __values(str), str_2_1 = str_2.next(); !str_2_1.done; str_2_1 = str_2.next()) {
            var c = str_2_1.value;
            var code = c.codePointAt(0);
            if (code !== undefined && code >= 0x41 && code <= 0x5A) {
                result += String.fromCodePoint(code + 0x20);
            }
            else {
                result += c;
            }
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (str_2_1 && !str_2_1.done && (_a = str_2.return)) _a.call(str_2);
        }
        finally { if (e_2) throw e_2.error; }
    }
    return result;
}
exports.asciiLowercase = asciiLowercase;
/**
 * Converts all uppercase ASCII code points to uppercase.
 *
 * @param str - a string
 */
function asciiUppercase(str) {
    var e_3, _a;
    /**
     * To ASCII uppercase a string, replace all ASCII lower alphas in the string
     * with their corresponding code point in ASCII upper alpha.
     */
    var result = "";
    try {
        for (var str_3 = __values(str), str_3_1 = str_3.next(); !str_3_1.done; str_3_1 = str_3.next()) {
            var c = str_3_1.value;
            var code = c.codePointAt(0);
            if (code !== undefined && code >= 0x61 && code <= 0x7A) {
                result += String.fromCodePoint(code - 0x20);
            }
            else {
                result += c;
            }
        }
    }
    catch (e_3_1) { e_3 = { error: e_3_1 }; }
    finally {
        try {
            if (str_3_1 && !str_3_1.done && (_a = str_3.return)) _a.call(str_3);
        }
        finally { if (e_3) throw e_3.error; }
    }
    return result;
}
exports.asciiUppercase = asciiUppercase;
/**
 * Compares two ASCII strings case-insensitively.
 *
 * @param a - a string
 * @param b - a string
 */
function asciiCaseInsensitiveMatch(a, b) {
    /**
     * A string A is an ASCII case-insensitive match for a string B, if the ASCII
     * lowercase of A is the ASCII lowercase of B.
     */
    return asciiLowercase(a) === asciiLowercase(b);
}
exports.asciiCaseInsensitiveMatch = asciiCaseInsensitiveMatch;
/**
 * ASCII encodes a string.
 *
 * @param str - a string
 */
function asciiEncode(str) {
    /**
     * 1. Assert: input is an ASCII string.
     * 2. Return the isomorphic encoding of input.
     */
    console.assert(isASCIIString(str), "asciiEncode requires an ASCII string.");
    return isomorphicEncode(str);
}
exports.asciiEncode = asciiEncode;
/**
 * ASCII decodes a byte sequence.
 *
 * @param bytes - a byte sequence
 */
function asciiDecode(bytes) {
    var e_4, _a;
    try {
        /**
         * 1. Assert: All bytes in input are ASCII bytes.
         * 2. Return the isomorphic decoding of input.
         */
        for (var bytes_1 = __values(bytes), bytes_1_1 = bytes_1.next(); !bytes_1_1.done; bytes_1_1 = bytes_1.next()) {
            var byte = bytes_1_1.value;
            console.assert(Byte_1.isASCIIByte(byte), "asciiDecode requires an ASCII byte sequence.");
        }
    }
    catch (e_4_1) { e_4 = { error: e_4_1 }; }
    finally {
        try {
            if (bytes_1_1 && !bytes_1_1.done && (_a = bytes_1.return)) _a.call(bytes_1);
        }
        finally { if (e_4) throw e_4.error; }
    }
    return ByteSequence_1.isomorphicDecode(bytes);
}
exports.asciiDecode = asciiDecode;
/**
 * Strips newline characters from a string.
 *
 * @param str - a string
 */
function stripNewlines(str) {
    /**
     * To strip newlines from a string, remove any U+000A LF and U+000D CR code
     * points from the string.
     */
    return str.replace(/[\n\r]/g, "");
}
exports.stripNewlines = stripNewlines;
/**
 * Normalizes newline characters in a string by converting consecutive
 * carriage-return newline characters and also single carriage return characters
 * into a single newline.
 *
 * @param str - a string
 */
function normalizeNewlines(str) {
    /**
     * To normalize newlines in a string, replace every U+000D CR U+000A LF code
     * point pair with a single U+000A LF code point, and then replace every
     * remaining U+000D CR code point with a U+000A LF code point.
     */
    return str.replace(/\r\n/g, "\n").replace(/\r/g, "\n");
}
exports.normalizeNewlines = normalizeNewlines;
/**
 * Removes leading and trailing whitespace characters from a string.
 *
 * @param str - a string
 */
function stripLeadingAndTrailingASCIIWhitespace(str) {
    /**
     * To strip leading and trailing ASCII whitespace from a string, remove all
     * ASCII whitespace that are at the start or the end of the string.
     */
    return str.replace(/^[\t\n\f\r ]+/, "").replace(/[\t\n\f\r ]+$/, "");
}
exports.stripLeadingAndTrailingASCIIWhitespace = stripLeadingAndTrailingASCIIWhitespace;
/**
 * Removes consecutive newline characters from a string.
 *
 * @param str - a string
 */
function stripAndCollapseASCIIWhitespace(str) {
    /**
     * To strip and collapse ASCII whitespace in a string, replace any sequence of
     * one or more consecutive code points that are ASCII whitespace in the string
     * with a single U+0020 SPACE code point, and then remove any leading and
     * trailing ASCII whitespace from that string.
     */
    return stripLeadingAndTrailingASCIIWhitespace(str.replace(/[\t\n\f\r ]{2,}/g, " "));
}
exports.stripAndCollapseASCIIWhitespace = stripAndCollapseASCIIWhitespace;
/**
 * Collects a sequence of code points matching a given condition from the input
 * string.
 *
 * @param condition - a condition to match
 * @param input - a string
 * @param options - starting position
 */
function collectASequenceOfCodePoints(condition, input, options) {
    /**
     * 1. Let result be the empty string.
     * 2. While position doesn’t point past the end of input and the code point at
     * position within input meets the condition condition:
     * 2.1. Append that code point to the end of result.
     * 2.2. Advance position by 1.
     * 3. Return result.
     */
    if (!util_1.isArray(input))
        return collectASequenceOfCodePoints(condition, Array.from(input), options);
    var result = "";
    while (options.position < input.length && !!condition.call(null, input[options.position])) {
        result += input[options.position];
        options.position++;
    }
    return result;
}
exports.collectASequenceOfCodePoints = collectASequenceOfCodePoints;
/**
 * Skips over ASCII whitespace.
 *
 * @param input - input string
 * @param options - starting position
 */
function skipASCIIWhitespace(input, options) {
    /**
     * To skip ASCII whitespace within a string input given a position variable
     * position, collect a sequence of code points that are ASCII whitespace from
     * input given position. The collected code points are not used, but position
     * is still updated.
     */
    collectASequenceOfCodePoints(function (str) { return CodePoints_1.ASCIIWhiteSpace.test(str); }, input, options);
}
exports.skipASCIIWhitespace = skipASCIIWhitespace;
/**
 * Solits a string at the given delimiter.
 *
 * @param input - input string
 * @param delimiter - a delimiter string
 */
function strictlySplit(input, delimiter) {
    /**
     * 1. Let position be a position variable for input, initially pointing at the
     * start of input.
     * 2. Let tokens be a list of strings, initially empty.
     * 3. Let token be the result of collecting a sequence of code points that are
     * not equal to delimiter from input, given position.
     * 4. Append token to tokens.
     * 5. While position is not past the end of input:
     * 5.1. Assert: the code point at position within input is delimiter.
     * 5.2. Advance position by 1.
     * 5.3. Let token be the result of collecting a sequence of code points that
     * are not equal to delimiter from input, given position.
     * 5.4. Append token to tokens.
     * 6. Return tokens.
     */
    if (!util_1.isArray(input))
        return strictlySplit(Array.from(input), delimiter);
    var options = { position: 0 };
    var tokens = [];
    var token = collectASequenceOfCodePoints(function (str) { return delimiter !== str; }, input, options);
    tokens.push(token);
    while (options.position < input.length) {
        console.assert(input[options.position] === delimiter, "strictlySplit found no delimiter in input string.");
        options.position++;
        token = collectASequenceOfCodePoints(function (str) { return delimiter !== str; }, input, options);
        tokens.push(token);
    }
    return tokens;
}
exports.strictlySplit = strictlySplit;
/**
 * Splits a string on ASCII whitespace.
 *
 * @param input - a string
 */
function splitAStringOnASCIIWhitespace(input) {
    /**
     * 1. Let position be a position variable for input, initially pointing at the
     * start of input.
     * 2. Let tokens be a list of strings, initially empty.
     * 3. Skip ASCII whitespace within input given position.
     * 4. While position is not past the end of input:
     * 4.1. Let token be the result of collecting a sequence of code points that
     * are not ASCII whitespace from input, given position.
     * 4.2. Append token to tokens.
     * 4.3. Skip ASCII whitespace within input given position.
     * 5. Return tokens.
     */
    if (!util_1.isArray(input))
        return splitAStringOnASCIIWhitespace(Array.from(input));
    var options = { position: 0 };
    var tokens = [];
    skipASCIIWhitespace(input, options);
    while (options.position < input.length) {
        var token = collectASequenceOfCodePoints(function (str) { return !CodePoints_1.ASCIIWhiteSpace.test(str); }, input, options);
        tokens.push(token);
        skipASCIIWhitespace(input, options);
    }
    return tokens;
}
exports.splitAStringOnASCIIWhitespace = splitAStringOnASCIIWhitespace;
/**
 * Splits a string on commas.
 *
 * @param input - a string
 */
function splitAStringOnCommas(input) {
    /**
     * 1. Let position be a position variable for input, initially pointing at the
     * start of input.
     * 2. Let tokens be a list of strings, initially empty.
     * 3. While position is not past the end of input:
     * 3.1. Let token be the result of collecting a sequence of code points that
     * are not U+002C (,) from input, given position.
     * 3.2. Strip leading and trailing ASCII whitespace from token.
     * 3.3. Append token to tokens.
     * 3.4. If position is not past the end of input, then:
     * 3.4.1. Assert: the code point at position within input is U+002C (,).
     * 3.4.2. Advance position by 1.
     * 4. Return tokens.
     */
    if (!util_1.isArray(input))
        return splitAStringOnCommas(Array.from(input));
    var options = { position: 0 };
    var tokens = [];
    while (options.position < input.length) {
        var token = collectASequenceOfCodePoints(function (str) { return str !== ','; }, input, options);
        tokens.push(stripLeadingAndTrailingASCIIWhitespace(token));
        if (options.position < input.length) {
            console.assert(input[options.position] === ',', "splitAStringOnCommas found no delimiter in input string.");
            options.position++;
        }
    }
    return tokens;
}
exports.splitAStringOnCommas = splitAStringOnCommas;
/**
 * Concatenates a list of strings with the given separator.
 *
 * @param list - a list of strings
 * @param separator - a separator string
 */
function concatenate(list, separator) {
    if (separator === void 0) { separator = ""; }
    /**
     * 1. If list is empty, then return the empty string.
     * 2. If separator is not given, then set separator to the empty string.
     * 3. Return a string whose contents are list’s items, in order, separated
     * from each other by separator.
     */
    if (list.length === 0)
        return "";
    return list.join(separator);
}
exports.concatenate = concatenate;
//# sourceMappingURL=String.js.map

/***/ }),

/***/ 4737:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {


var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var base64 = __importStar(__nccwpck_require__(9558));
exports.base64 = base64;
var byte = __importStar(__nccwpck_require__(8311));
exports.byte = byte;
var byteSequence = __importStar(__nccwpck_require__(4398));
exports.byteSequence = byteSequence;
var codePoint = __importStar(__nccwpck_require__(4467));
exports.codePoint = codePoint;
var json = __importStar(__nccwpck_require__(5475));
exports.json = json;
var list = __importStar(__nccwpck_require__(1193));
exports.list = list;
var map = __importStar(__nccwpck_require__(6067));
exports.map = map;
var namespace = __importStar(__nccwpck_require__(9018));
exports.namespace = namespace;
var queue = __importStar(__nccwpck_require__(7758));
exports.queue = queue;
var set = __importStar(__nccwpck_require__(2237));
exports.set = set;
var stack = __importStar(__nccwpck_require__(9221));
exports.stack = stack;
var string = __importStar(__nccwpck_require__(2472));
exports.string = string;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 3650:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {


var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var util_1 = __nccwpck_require__(7061);
var interfaces_1 = __nccwpck_require__(3904);
var infra_1 = __nccwpck_require__(4737);
var url_1 = __nccwpck_require__(7016);
var _validationErrorCallback;
/**
 * Default ports for a special URL scheme.
 */
var _defaultPorts = {
    "ftp": 21,
    "file": null,
    "http": 80,
    "https": 443,
    "ws": 80,
    "wss": 443
};
/**
 * The C0 control percent-encode set are the C0 controls and all code points
 * greater than U+007E (~).
 */
var _c0ControlPercentEncodeSet = /[\0-\x1F\x7F-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
/**
 * The fragment percent-encode set is the C0 control percent-encode set and
 * U+0020 SPACE, U+0022 ("), U+003C (<), U+003E (>), and U+0060 (`).
 */
var _fragmentPercentEncodeSet = /[ "<>`]|[\0-\x1F\x7F-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
/**
 * The path percent-encode set is the fragment percent-encode set and
 * U+0023 (#), U+003F (?), U+007B ({), and U+007D (}).
 */
var _pathPercentEncodeSet = /[ "<>`#?{}]|[\0-\x1F\x7F-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
/**
 * The userinfo percent-encode set is the path percent-encode set and
 * U+002F (/), U+003A (:), U+003B (;), U+003D (=), U+0040 (@), U+005B ([),
 * U+005C (\), U+005D (]), U+005E (^), and U+007C (|).
 */
var _userInfoPercentEncodeSet = /[ "<>`#?{}/:;=@\[\]\\\^\|]|[\0-\x1F\x7F-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
/**
 * The URL code points are ASCII alphanumeric, U+0021 (!), U+0024 ($),
 * U+0026 (&), U+0027 ('), U+0028 LEFT PARENTHESIS, U+0029 RIGHT PARENTHESIS,
 * U+002A (*), U+002B (+), U+002C (,), U+002D (-), U+002E (.), U+002F (/),
 * U+003A (:), U+003B (;), U+003D (=), U+003F (?), U+0040 (@), U+005F (_),
 * U+007E (~), and code points in the range U+00A0 to U+10FFFD, inclusive,
 * excluding surrogates and noncharacters.
 */
var _urlCodePoints = /[0-9A-Za-z!\$&-\/:;=\?@_~\xA0-\uD7FF\uE000-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uD83E\uD840-\uD87E\uD880-\uD8BE\uD8C0-\uD8FE\uD900-\uD93E\uD940-\uD97E\uD980-\uD9BE\uD9C0-\uD9FE\uDA00-\uDA3E\uDA40-\uDA7E\uDA80-\uDABE\uDAC0-\uDAFE\uDB00-\uDB3E\uDB40-\uDB7E\uDB80-\uDBBE\uDBC0-\uDBFE][\uDC00-\uDFFF]|[\uD83F\uD87F\uD8BF\uD8FF\uD93F\uD97F\uD9BF\uD9FF\uDA3F\uDA7F\uDABF\uDAFF\uDB3F\uDB7F\uDBBF\uDBFF][\uDC00-\uDFFD]/;
/**
 * A forbidden host code point is U+0000 NULL, U+0009 TAB, U+000A LF,
 * U+000D CR, U+0020 SPACE, U+0023 (#), U+0025 (%), U+002F (/), U+003A (:),
 * U+003F (?), U+0040 (@), U+005B ([), U+005C (\), or U+005D (]).
 */
var _forbiddenHostCodePoint = /[\0\t\f\r #%/:?@\[\\\]]/;
/**
 * Sets the callback function for validation errors.
 *
 * @param validationErrorCallback - a callback function to be called when a
 * validation error occurs
 */
function setValidationErrorCallback(validationErrorCallback) {
    _validationErrorCallback = validationErrorCallback;
}
exports.setValidationErrorCallback = setValidationErrorCallback;
/**
 * Generates a validation error.
 *
 * @param message - error message
 */
function validationError(message) {
    if (_validationErrorCallback !== undefined) {
        _validationErrorCallback.call(null, "Validation Error: " + message);
    }
}
/**
 * Creates a new URL.
 */
function newURL() {
    return {
        scheme: '',
        username: '',
        password: '',
        host: null,
        port: null,
        path: [],
        query: null,
        fragment: null,
        _cannotBeABaseURLFlag: false,
        _blobURLEntry: null
    };
}
exports.newURL = newURL;
/**
 * Determines if the scheme is a special scheme.
 *
 * @param scheme - a scheme
 */
function isSpecialScheme(scheme) {
    return (scheme in _defaultPorts);
}
exports.isSpecialScheme = isSpecialScheme;
/**
 * Determines if the URL has a special scheme.
 *
 * @param url - an URL
 */
function isSpecial(url) {
    return isSpecialScheme(url.scheme);
}
exports.isSpecial = isSpecial;
/**
 * Returns the default port for a special scheme.
 *
 * @param scheme - a scheme
 */
function defaultPort(scheme) {
    return _defaultPorts[scheme] || null;
}
exports.defaultPort = defaultPort;
/**
 * Determines if the URL has credentials.
 *
 * @param url - an URL
 */
function includesCredentials(url) {
    return url.username !== '' || url.password !== '';
}
exports.includesCredentials = includesCredentials;
/**
 * Determines if an URL cannot have credentials.
 *
 * @param url - an URL
 */
function cannotHaveAUsernamePasswordPort(url) {
    /**
     * A URL cannot have a username/password/port if its host is null or the
     * empty string, its cannot-be-a-base-URL flag is set, or its scheme is
     * "file".
     */
    return (url.host === null || url.host === "" || url._cannotBeABaseURLFlag ||
        url.scheme === "file");
}
exports.cannotHaveAUsernamePasswordPort = cannotHaveAUsernamePasswordPort;
/**
 * Serializes an URL into a string.
 *
 * @param url - an URL
 */
function urlSerializer(url, excludeFragmentFlag) {
    var e_1, _a;
    if (excludeFragmentFlag === void 0) { excludeFragmentFlag = false; }
    /**
     * 1. Let output be url’s scheme and U+003A (:) concatenated.
     */
    var output = url.scheme + ':';
    /**
     * 2. If url’s host is non-null:
     */
    if (url.host !== null) {
        /**
         * 2.1. Append "//" to output.
         */
        output += '//';
        /**
         * 2.2. If url includes credentials, then:
         */
        if (includesCredentials(url)) {
            /**
             * 2.2.1. Append url’s username to output.
             * 2.2.2. If url’s password is not the empty string, then append U+003A (:),
             * followed by url’s password, to output.
             * 2.2.3. Append U+0040 (@) to output.
             */
            output += url.username;
            if (url.password !== '') {
                output += ':' + url.password;
            }
            output += '@';
        }
        /**
         * 2.3. Append url’s host, serialized, to output.
         * 2.4. If url’s port is non-null, append U+003A (:) followed by url’s port,
         * serialized, to output.
         */
        output += hostSerializer(url.host);
        if (url.port !== null) {
            output += ':' + url.port;
        }
    }
    else if (url.host === null && url.scheme === "file") {
        /**
         * 3. Otherwise, if url’s host is null and url’s scheme is "file", append "//" to output.
         */
        output += '//';
    }
    /**
     * 4. If url’s cannot-be-a-base-URL flag is set, append url’s path[0] to
     * output.
     * 5. Otherwise, then for each string in url’s path, append U+002F (/)
     * followed by the string to output.
     */
    if (url._cannotBeABaseURLFlag) {
        output += url.path[0];
    }
    else {
        try {
            for (var _b = __values(url.path), _c = _b.next(); !_c.done; _c = _b.next()) {
                var str = _c.value;
                output += '/' + str;
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
    }
    /**
     * 6. If url’s query is non-null, append U+003F (?), followed by url’s
     * query, to output.
     * 7. If the exclude fragment flag is unset and url’s fragment is non-null,
     * append U+0023 (#), followed by url’s fragment, to output.
     * 8. Return output.
     */
    if (url.query !== null) {
        output += '?' + url.query;
    }
    if (!excludeFragmentFlag && url.fragment !== null) {
        output += '#' + url.fragment;
    }
    return output;
}
exports.urlSerializer = urlSerializer;
/**
 * Serializes a host into a string.
 *
 * @param host - a host
 */
function hostSerializer(host) {
    /**
     * 1. If host is an IPv4 address, return the result of running the IPv4
     * serializer on host.
     * 2. Otherwise, if host is an IPv6 address, return U+005B ([), followed
     * by the result of running the IPv6 serializer on host, followed by
     * U+005D (]).
     * 3. Otherwise, host is a domain, opaque host, or empty host, return host.
     */
    if (util_1.isNumber(host)) {
        return iPv4Serializer(host);
    }
    else if (util_1.isArray(host)) {
        return '[' + iPv6Serializer(host) + ']';
    }
    else {
        return host;
    }
}
exports.hostSerializer = hostSerializer;
/**
 * Serializes an IPv4 address into a string.
 *
 * @param address  - an IPv4 address
 */
function iPv4Serializer(address) {
    /**
     * 1. Let output be the empty string.
     * 2. Let n be the value of address.
     * 3. For each i in the range 1 to 4, inclusive:
     * 3.1. Prepend n % 256, serialized, to output.
     * 3.2. If i is not 4, then prepend U+002E (.) to output.
     * 3.3. Set n to floor(n / 256).
     * 4. Return output.
     */
    var output = "";
    var n = address;
    for (var i = 1; i <= 4; i++) {
        output = (n % 256).toString() + output;
        if (i !== 4) {
            output = '.' + output;
        }
        n = Math.floor(n / 256);
    }
    return output;
}
exports.iPv4Serializer = iPv4Serializer;
/**
 * Serializes an IPv6 address into a string.
 *
 * @param address  - an IPv6 address represented as a list of eight numbers
 */
function iPv6Serializer(address) {
    /**
     * 1. Let output be the empty string.
     * 2. Let compress be an index to the first IPv6 piece in the first longest
     * sequences of address’s IPv6 pieces that are 0.
     * In 0:f:0:0:f:f:0:0 it would point to the second 0.
     * 3. If there is no sequence of address’s IPv6 pieces that are 0 that is
     * longer than 1, then set compress to null.
     */
    var output = "";
    var compress = null;
    var lastIndex = -1;
    var count = 0;
    var lastCount = 0;
    for (var i = 0; i < 8; i++) {
        if (address[i] !== 0)
            continue;
        count = 1;
        for (var j = i + 1; j < 8; j++) {
            if (address[j] !== 0)
                break;
            count++;
            continue;
        }
        if (count > lastCount) {
            lastCount = count;
            lastIndex = i;
        }
    }
    if (lastCount > 1)
        compress = lastIndex;
    /**
     * 4. Let ignore0 be false.
     * 5. For each pieceIndex in the range 0 to 7, inclusive:
     */
    var ignore0 = false;
    for (var pieceIndex = 0; pieceIndex < 8; pieceIndex++) {
        /**
         * 5.1. If ignore0 is true and address[pieceIndex] is 0, then continue.
         * 5.2. Otherwise, if ignore0 is true, set ignore0 to false.
         * 5.3. If compress is pieceIndex, then:
         */
        if (ignore0 && address[pieceIndex] === 0)
            continue;
        if (ignore0)
            ignore0 = false;
        if (compress === pieceIndex) {
            /**
             * 5.3.1. Let separator be "::" if pieceIndex is 0, and U+003A (:) otherwise.
             * 5.3.2. Append separator to output.
             * 5.3.3. Set ignore0 to true and continue.
             */
            output += (pieceIndex === 0 ? '::' : ':');
            ignore0 = true;
            continue;
        }
        /**
         * 5.4. Append address[pieceIndex], represented as the shortest possible
         * lowercase hexadecimal number, to output.
         * 5.5. If pieceIndex is not 7, then append U+003A (:) to output.
         */
        output += address[pieceIndex].toString(16);
        if (pieceIndex !== 7)
            output += ':';
    }
    /**
     * 6. Return output.
     */
    return output;
}
exports.iPv6Serializer = iPv6Serializer;
/**
 * Parses an URL string.
 *
 * @param input - input string
 * @param baseURL - base URL
 * @param encodingOverride - encoding override
 */
function urlParser(input, baseURL, encodingOverride) {
    /**
     * 1. Let url be the result of running the basic URL parser on input with
     * base, and encoding override as provided.
     * 2. If url is failure, return failure.
     * 3. If url’s scheme is not "blob", return url.
     * 4. Set url’s blob URL entry to the result of resolving the blob URL url,
     * if that did not return failure, and null otherwise.
     * 5. Return url.
     */
    var url = basicURLParser(input, baseURL, encodingOverride);
    if (url === null)
        return null;
    if (url.scheme !== "blob")
        return url;
    var entry = resolveABlobURL(url);
    if (entry !== null) {
        url._blobURLEntry = entry;
    }
    else {
        url._blobURLEntry = null;
    }
    return url;
}
exports.urlParser = urlParser;
/**
 * Parses an URL string.
 *
 * @param input - input string
 * @param baseURL - base URL
 * @param encodingOverride - encoding override
 */
function basicURLParser(input, baseURL, encodingOverride, url, stateOverride) {
    var e_2, _a, e_3, _b;
    /**
     * 1. If url is not given:
     * 1.1. Set url to a new URL.
     * 1.2. If input contains any leading or trailing C0 control or space,
     * validation error.
     * 1.3. Remove any leading and trailing C0 control or space from input.
     */
    if (url === undefined) {
        url = newURL();
        // leading
        var leadingControlOrSpace = /^[\u0000-\u001F\u0020]+/;
        var trailingControlOrSpace = /[\u0000-\u001F\u0020]+$/;
        if (leadingControlOrSpace.test(input) || trailingControlOrSpace.test(input)) {
            validationError("Input string contains leading or trailing control characters or space.");
        }
        input = input.replace(leadingControlOrSpace, '');
        input = input.replace(trailingControlOrSpace, '');
    }
    /**
     * 2. If input contains any ASCII tab or newline, validation error.
     * 3. Remove all ASCII tab or newline from input.
     */
    var tabOrNewline = /[\u0009\u000A\u000D]/g;
    if (tabOrNewline.test(input)) {
        validationError("Input string contains tab or newline characters.");
    }
    input = input.replace(tabOrNewline, '');
    /**
     * 4. Let state be state override if given, or scheme start state otherwise.
     * 5. If base is not given, set it to null.
     * 6. Let encoding be UTF-8.
     * 7. If encoding override is given, set encoding to the result of getting
     * an output encoding from encoding override.
     */
    var state = (stateOverride === undefined ? interfaces_1.ParserState.SchemeStart : stateOverride);
    if (baseURL === undefined)
        baseURL = null;
    var encoding = (encodingOverride === undefined ||
        encodingOverride === "replacement" || encodingOverride === "UTF-16BE" ||
        encodingOverride === "UTF-16LE" ? "UTF-8" : encodingOverride);
    /**
     * 8. Let buffer be the empty string.
     * 9. Let the @ flag, [] flag, and passwordTokenSeenFlag be unset.
     * 10. Let pointer be a pointer to first code point in input.
     */
    var buffer = "";
    var atFlag = false;
    var arrayFlag = false;
    var passwordTokenSeenFlag = false;
    var EOF = "";
    var walker = new util_1.StringWalker(input);
    /**
     * 11. Keep running the following state machine by switching on state. If
     * after a run pointer points to the EOF code point, go to the next step.
     * Otherwise, increase pointer by one and continue with the state machine.
     */
    while (true) {
        switch (state) {
            case interfaces_1.ParserState.SchemeStart:
                /**
                 * 1. If c is an ASCII alpha, append c, lowercased, to buffer, and set
                 * state to scheme state.
                 * 2. Otherwise, if state override is not given, set state to no scheme
                 * state, and decrease pointer by one.
                 * 3. Otherwise, validation error, return failure.
                 */
                if (infra_1.codePoint.ASCIIAlpha.test(walker.c())) {
                    buffer += walker.c().toLowerCase();
                    state = interfaces_1.ParserState.Scheme;
                }
                else if (stateOverride === undefined) {
                    state = interfaces_1.ParserState.NoScheme;
                    walker.pointer--;
                }
                else {
                    validationError("Invalid scheme start character.");
                    return null;
                }
                break;
            case interfaces_1.ParserState.Scheme:
                /**
                 * 1. If c is an ASCII alphanumeric, U+002B (+), U+002D (-), or U+002E
                 * (.), append c, lowercased, to buffer.
                 */
                if (infra_1.codePoint.ASCIIAlphanumeric.test(walker.c()) ||
                    walker.c() === '+' || walker.c() === '-' || walker.c() === '.') {
                    buffer += walker.c().toLowerCase();
                }
                else if (walker.c() === ':') {
                    /**
                     * 2. Otherwise, if c is U+003A (:), then:
                     * 2.1. If state override is given, then:
                     * 2.1.1. If url’s scheme is a special scheme and buffer is not a
                     * special scheme, then return.
                     * 2.1.2. If url’s scheme is not a special scheme and buffer is a
                     * special scheme, then return.
                     * 2.1.3. If url includes credentials or has a non-null port, and
                     * buffer is "file", then return.
                     * 2.1.4. If url’s scheme is "file" and its host is an empty host or
                     * null, then return.
                     */
                    if (stateOverride !== undefined) {
                        if (isSpecialScheme(url.scheme) && !isSpecialScheme(buffer))
                            return url;
                        if (!isSpecialScheme(url.scheme) && isSpecialScheme(buffer))
                            return url;
                        if ((includesCredentials(url) || url.port !== null) && buffer === "file")
                            return url;
                        if (url.scheme === "file" && (url.host === "" || url.host === null))
                            return url;
                    }
                    /**
                     * 2.2. Set url’s scheme to buffer.
                     */
                    url.scheme = buffer;
                    /**
                     * 2.3. If state override is given, then:
                     * 2.3.1. If url’s port is url’s scheme’s default port, then set
                     * url’s port to null.
                     * 2.3.2. Return.
                     */
                    if (stateOverride !== undefined) {
                        if (url.port === defaultPort(url.scheme)) {
                            url.port = null;
                        }
                        return url;
                    }
                    /**
                     * 2.4. Set buffer to the empty string.
                     */
                    buffer = "";
                    if (url.scheme === "file") {
                        /**
                         * 2.5. If url’s scheme is "file", then:
                         * 2.5.1. If remaining does not start with "//", validation error.
                         * 2.5.2. Set state to file state.
                         */
                        if (!walker.remaining().startsWith("//")) {
                            validationError("Invalid file URL scheme, '//' expected.");
                        }
                        state = interfaces_1.ParserState.File;
                    }
                    else if (isSpecial(url) && baseURL !== null && baseURL.scheme === url.scheme) {
                        /**
                         * 2.6. Otherwise, if url is special, base is non-null, and base’s
                         * scheme is equal to url’s scheme, set state to special relative
                         * or authority state.
                         */
                        state = interfaces_1.ParserState.SpecialRelativeOrAuthority;
                    }
                    else if (isSpecial(url)) {
                        /**
                         * 2.7. Otherwise, if url is special, set state to special
                         * authority slashes state.
                         */
                        state = interfaces_1.ParserState.SpecialAuthoritySlashes;
                    }
                    else if (walker.remaining().startsWith("/")) {
                        /**
                         * 2.8. Otherwise, if remaining starts with an U+002F (/), set state
                         * to path or authority state and increase pointer by one.
                         */
                        state = interfaces_1.ParserState.PathOrAuthority;
                        walker.pointer++;
                    }
                    else {
                        /**
                         * 2.9. Otherwise, set url’s cannot-be-a-base-URL flag, append an
                         * empty string to url’s path, and set state to
                         * cannot-be-a-base-URL path state.
                         */
                        url._cannotBeABaseURLFlag = true;
                        url.path.push("");
                        state = interfaces_1.ParserState.CannotBeABaseURLPath;
                    }
                }
                else if (stateOverride === undefined) {
                    /**
                     * 3. Otherwise, if state override is not given, set buffer to the
                     * empty string, state to no scheme state, and start over (from the
                     * first code point in input).
                     */
                    buffer = "";
                    state = interfaces_1.ParserState.NoScheme;
                    walker.pointer = 0;
                    continue;
                }
                else {
                    /**
                     * 4. Otherwise, validation error, return failure.
                     */
                    validationError("Invalid input string.");
                    return null;
                }
                break;
            case interfaces_1.ParserState.NoScheme:
                /**
                 * 1. If base is null, or base’s cannot-be-a-base-URL flag is set
                 * and c is not U+0023 (#), validation error, return failure.
                 * 2. Otherwise, if base’s cannot-be-a-base-URL flag is set and
                 * c is U+0023 (#), set url’s scheme to base’s scheme, url’s path to
                 * a copy of base’s path, url’s query to base’s query, url’s
                 * fragment to the empty string, set url’s cannot-be-a-base-URL
                 * flag, and set state to fragment state.
                 * 3. Otherwise, if base’s scheme is not "file", set state to
                 * relative state and decrease pointer by one.
                 * 4. Otherwise, set state to file state and decrease pointer by one.
                 */
                if (baseURL === null || (baseURL._cannotBeABaseURLFlag && walker.c() !== '#')) {
                    validationError("Invalid input string.");
                    return null;
                }
                else if (baseURL._cannotBeABaseURLFlag && walker.c() === '#') {
                    url.scheme = baseURL.scheme;
                    url.path = infra_1.list.clone(baseURL.path);
                    url.query = baseURL.query;
                    url.fragment = "";
                    url._cannotBeABaseURLFlag = true;
                    state = interfaces_1.ParserState.Fragment;
                }
                else if (baseURL.scheme !== "file") {
                    state = interfaces_1.ParserState.Relative;
                    walker.pointer--;
                }
                else {
                    state = interfaces_1.ParserState.File;
                    walker.pointer--;
                }
                break;
            case interfaces_1.ParserState.SpecialRelativeOrAuthority:
                /**
                 * If c is U+002F (/) and remaining starts with U+002F (/), then set
                 * state to special authority ignore slashes state and increase
                 * pointer by one.
                 * Otherwise, validation error, set state to relative state and
                 * decrease pointer by one.
                 */
                if (walker.c() === '/' && walker.remaining().startsWith('/')) {
                    state = interfaces_1.ParserState.SpecialAuthorityIgnoreSlashes;
                    walker.pointer++;
                }
                else {
                    validationError("Invalid input string.");
                    state = interfaces_1.ParserState.Relative;
                    walker.pointer--;
                }
                break;
            case interfaces_1.ParserState.PathOrAuthority:
                /**
                 * If c is U+002F (/), then set state to authority state.
                 * Otherwise, set state to path state, and decrease pointer by one.
                 */
                if (walker.c() === '/') {
                    state = interfaces_1.ParserState.Authority;
                }
                else {
                    state = interfaces_1.ParserState.Path;
                    walker.pointer--;
                }
                break;
            case interfaces_1.ParserState.Relative:
                /**
                 * Set url’s scheme to base’s scheme, and then, switching on c:
                 */
                if (baseURL === null) {
                    throw new Error("Invalid parser state. Base URL is null.");
                }
                url.scheme = baseURL.scheme;
                switch (walker.c()) {
                    case EOF: // EOF
                        /**
                         * Set url’s username to base’s username, url’s password to base’s
                         * password, url’s host to base’s host, url’s port to base’s port,
                         * url’s path to a copy of base’s path, and url’s query to base’s
                         * query.
                         */
                        url.username = baseURL.username;
                        url.password = baseURL.password;
                        url.host = baseURL.host;
                        url.port = baseURL.port;
                        url.path = infra_1.list.clone(baseURL.path);
                        url.query = baseURL.query;
                        break;
                    case '/':
                        /**
                         * Set state to relative slash state.
                         */
                        state = interfaces_1.ParserState.RelativeSlash;
                        break;
                    case '?':
                        /**
                         * Set url’s username to base’s username, url’s password to base’s
                         * password, url’s host to base’s host, url’s port to base’s port,
                         * url’s path to a copy of base’s path, url’s query to the empty
                         * string, and state to query state.
                         */
                        url.username = baseURL.username;
                        url.password = baseURL.password;
                        url.host = baseURL.host;
                        url.port = baseURL.port;
                        url.path = infra_1.list.clone(baseURL.path);
                        url.query = "";
                        state = interfaces_1.ParserState.Query;
                        break;
                    case '#':
                        /**
                         * Set url’s username to base’s username, url’s password to base’s
                         * password, url’s host to base’s host, url’s port to base’s port,
                         * url’s path to a copy of base’s path, url’s query to base’s
                         * query, url’s fragment to the empty string, and state to
                         * fragment state.
                         */
                        url.username = baseURL.username;
                        url.password = baseURL.password;
                        url.host = baseURL.host;
                        url.port = baseURL.port;
                        url.path = infra_1.list.clone(baseURL.path);
                        url.query = baseURL.query;
                        url.fragment = "";
                        state = interfaces_1.ParserState.Fragment;
                        break;
                    default:
                        /**
                         * If url is special and c is U+005C (\), validation error,
                         * set state to relative slash state.
                         * Otherwise, run these steps:
                         * 1. Set url’s username to base’s username, url’s password to
                         * base’s password, url’s host to base’s host, url’s port to
                         * base’s port, url’s path to a copy of base’s path, and then
                         * remove url’s path’s last item, if any.
                         * 2. Set state to path state, and decrease pointer by one.
                         */
                        if (isSpecial(url) && walker.c() === '\\') {
                            validationError("Invalid input string.");
                            state = interfaces_1.ParserState.RelativeSlash;
                        }
                        else {
                            url.username = baseURL.username;
                            url.password = baseURL.password;
                            url.host = baseURL.host;
                            url.port = baseURL.port;
                            url.path = infra_1.list.clone(baseURL.path);
                            if (url.path.length !== 0)
                                url.path.splice(url.path.length - 1, 1);
                            state = interfaces_1.ParserState.Path;
                            walker.pointer--;
                        }
                        break;
                }
                break;
            case interfaces_1.ParserState.RelativeSlash:
                /**
                 * 1. If url is special and c is U+002F (/) or U+005C (\), then:
                 * 1.1. If c is U+005C (\), validation error.
                 * 1.2. Set state to special authority ignore slashes state.
                 * 2. Otherwise, if c is U+002F (/), then set state to authority state.
                 * 3. Otherwise, set url’s username to base’s username, url’s password
                 * to base’s password, url’s host to base’s host, url’s port to base’s
                 * port, state to path state, and then, decrease pointer by one.
                 */
                if (isSpecial(url) && (walker.c() === '/' || walker.c() === '\\')) {
                    if (walker.c() === '\\') {
                        validationError("Invalid input string.");
                    }
                    state = interfaces_1.ParserState.SpecialAuthorityIgnoreSlashes;
                }
                else if (walker.c() === '/') {
                    state = interfaces_1.ParserState.Authority;
                }
                else {
                    if (baseURL === null) {
                        throw new Error("Invalid parser state. Base URL is null.");
                    }
                    url.username = baseURL.username;
                    url.password = baseURL.password;
                    url.host = baseURL.host;
                    url.port = baseURL.port;
                    state = interfaces_1.ParserState.Path;
                    walker.pointer--;
                }
                break;
            case interfaces_1.ParserState.SpecialAuthoritySlashes:
                /**
                 * If c is U+002F (/) and remaining starts with U+002F (/), then set
                 * state to special authority ignore slashes state and increase
                 * pointer by one.
                 * Otherwise, validation error, set state to special authority ignore
                 * slashes state, and decrease pointer by one.
                 */
                if (walker.c() === '/' && walker.remaining().startsWith('/')) {
                    state = interfaces_1.ParserState.SpecialAuthorityIgnoreSlashes;
                    walker.pointer++;
                }
                else {
                    validationError("Expected '//'.");
                    state = interfaces_1.ParserState.SpecialAuthorityIgnoreSlashes;
                    walker.pointer--;
                }
                break;
            case interfaces_1.ParserState.SpecialAuthorityIgnoreSlashes:
                /**
                 * If c is neither U+002F (/) nor U+005C (\), then set state to
                 * authority state and decrease pointer by one.
                 * Otherwise, validation error.
                 */
                if (walker.c() !== '/' && walker.c() !== '\\') {
                    state = interfaces_1.ParserState.Authority;
                    walker.pointer--;
                }
                else {
                    validationError("Unexpected '/' or '\\'.");
                }
                break;
            case interfaces_1.ParserState.Authority:
                /**
                 * 1. If c is U+0040 (@), then:
                 */
                if (walker.c() === '@') {
                    /**
                     * 1.1. Validation error.
                     * 1.2. If the @ flag is set, prepend "%40" to buffer.
                     * 1.3. Set the @ flag.
                     * 1.4. For each codePoint in buffer:
                     */
                    validationError("Unexpected '@'.");
                    if (atFlag)
                        buffer = '%40' + buffer;
                    atFlag = true;
                    try {
                        for (var buffer_1 = (e_2 = void 0, __values(buffer)), buffer_1_1 = buffer_1.next(); !buffer_1_1.done; buffer_1_1 = buffer_1.next()) {
                            var codePoint = buffer_1_1.value;
                            /**
                             * 1.4.1. If codePoint is U+003A (:) and passwordTokenSeenFlag is
                             * unset, then set passwordTokenSeenFlag and continue.
                             * 1.4.2. Let encodedCodePoints be the result of running UTF-8
                             * percent encode codePoint using the userinfo percent-encode set.
                             * 1.4.3. If passwordTokenSeenFlag is set, then append
                             * encodedCodePoints to url’s password.
                             * 1.4.4. Otherwise, append encodedCodePoints to url’s username.
                             */
                            if (codePoint === ':' && !passwordTokenSeenFlag) {
                                passwordTokenSeenFlag = true;
                                continue;
                            }
                            var encodedCodePoints = utf8PercentEncode(codePoint, _userInfoPercentEncodeSet);
                            if (passwordTokenSeenFlag) {
                                url.password += encodedCodePoints;
                            }
                            else {
                                url.username += encodedCodePoints;
                            }
                        }
                    }
                    catch (e_2_1) { e_2 = { error: e_2_1 }; }
                    finally {
                        try {
                            if (buffer_1_1 && !buffer_1_1.done && (_a = buffer_1.return)) _a.call(buffer_1);
                        }
                        finally { if (e_2) throw e_2.error; }
                    }
                    /**
                     * 1.5. Set buffer to the empty string.
                     */
                    buffer = "";
                }
                else if (walker.c() === EOF || walker.c() === '/' || walker.c() === '?' || walker.c() === '#' ||
                    (isSpecial(url) && walker.c() === '\\')) {
                    /**
                     * 2. Otherwise, if one of the following is true
                     * - c is the EOF code point, U+002F (/), U+003F (?), or U+0023 (#)
                     * - url is special and c is U+005C (\)
                     * then:
                     * 2.1. If @ flag is set and buffer is the empty string, validation
                     * error, return failure.
                     * 2.2. Decrease pointer by the number of code points in buffer plus
                     * one, set buffer to the empty string, and set state to host state.
                     */
                    if (atFlag && buffer === "") {
                        validationError("Invalid input string.");
                        return null;
                    }
                    walker.pointer -= (buffer.length + 1);
                    buffer = "";
                    state = interfaces_1.ParserState.Host;
                }
                else {
                    /**
                     * 3. Otherwise, append c to buffer.
                     */
                    buffer += walker.c();
                }
                break;
            case interfaces_1.ParserState.Host:
            case interfaces_1.ParserState.Hostname:
                if (stateOverride !== undefined && url.scheme === "file") {
                    /**
                     * 1. If state override is given and url’s scheme is "file", then
                     * decrease pointer by one and set state to file host state.
                     */
                    walker.pointer--;
                    state = interfaces_1.ParserState.FileHost;
                }
                else if (walker.c() === ':' && !arrayFlag) {
                    /**
                     * 2. Otherwise, if c is U+003A (:) and the [] flag is unset, then:
                     * 2.1. If buffer is the empty string, validation error, return
                     * failure.
                     * 2.2. Let host be the result of host parsing buffer with url is
                     * not special.
                     * 2.3. If host is failure, then return failure.
                     * 2.4. Set url’s host to host, buffer to the empty string, and
                     * state to port state.
                     * 2.5. If state override is given and state override is hostname
                     * state, then return.
                     */
                    if (buffer === "") {
                        validationError("Invalid input string.");
                        return null;
                    }
                    var host = hostParser(buffer, !isSpecial(url));
                    if (host === null)
                        return null;
                    url.host = host;
                    buffer = "";
                    state = interfaces_1.ParserState.Port;
                    if (stateOverride === interfaces_1.ParserState.Hostname)
                        return url;
                }
                else if (walker.c() === EOF || walker.c() === '/' || walker.c() === '?' || walker.c() === '#' ||
                    (isSpecial(url) && walker.c() === '\\')) {
                    /**
                     * 3. Otherwise, if one of the following is true
                     * - c is the EOF code point, U+002F (/), U+003F (?), or U+0023 (#)
                     * - url is special and c is U+005C (\)
                     * then decrease pointer by one, and then:
                     * 3.1. If url is special and buffer is the empty string, validation
                     * error, return failure.
                     * 3.2. Otherwise, if state override is given, buffer is the empty
                     * string, and either url includes credentials or url’s port is
                     * non-null, validation error, return.
                     * 3.3. Let host be the result of host parsing buffer with url is
                     * not special.
                     * 3.4. If host is failure, then return failure.
                     * 3.5. Set url’s host to host, buffer to the empty string, and
                     * state to path start state.
                     * 3.6. If state override is given, then return.
                     */
                    walker.pointer--;
                    if (isSpecial(url) && buffer === "") {
                        validationError("Invalid input string.");
                        return null;
                    }
                    else if (stateOverride !== undefined && buffer === "" &&
                        (includesCredentials(url) || url.port !== null)) {
                        validationError("Invalid input string.");
                        return url;
                    }
                    var host = hostParser(buffer, !isSpecial(url));
                    if (host === null)
                        return null;
                    url.host = host;
                    buffer = "";
                    state = interfaces_1.ParserState.PathStart;
                    if (stateOverride !== undefined)
                        return url;
                }
                else {
                    /**
                     * 4. Otherwise:
                     * 4.1. If c is U+005B ([), then set the [] flag.
                     * 4.2. If c is U+005D (]), then unset the [] flag.
                     * 4.3. Append c to buffer.
                     */
                    if (walker.c() === '[')
                        arrayFlag = true;
                    if (walker.c() === ']')
                        arrayFlag = false;
                    buffer += walker.c();
                }
                break;
            case interfaces_1.ParserState.Port:
                if (infra_1.codePoint.ASCIIDigit.test(walker.c())) {
                    /**
                     * 1. If c is an ASCII digit, append c to buffer.
                     */
                    buffer += walker.c();
                }
                else if (walker.c() === EOF || walker.c() === '/' || walker.c() === '?' || walker.c() === '#' ||
                    (isSpecial(url) && walker.c() === '\\') || stateOverride) {
                    /**
                     * 2. Otherwise, if one of the following is true
                     * - c is the EOF code point, U+002F (/), U+003F (?), or U+0023 (#)
                     * - url is special and c is U+005C (\)
                     * - state override is given
                     * then:
                     */
                    if (buffer !== "") {
                        /**
                         * 2.1. If buffer is not the empty string, then:
                         * 2.1.1. Let port be the mathematical integer value that is
                         * represented by buffer in radix-10 using ASCII digits for digits
                         * with values 0 through 9.
                         * 2.1.2. If port is greater than 2**16 − 1, validation error,
                         * return failure.
                         * 2.1.3. Set url’s port to null, if port is url’s scheme’s default
                         * port, and to port otherwise.
                         * 2.1.4. Set buffer to the empty string.
                         */
                        if (buffer !== "") {
                            var port = parseInt(buffer, 10);
                            if (port > Math.pow(2, 16) - 1) {
                                validationError("Invalid port number.");
                                return null;
                            }
                            url.port = (port === defaultPort(url.scheme) ? null : port);
                            buffer = "";
                        }
                    }
                    /**
                     * 2.2. If state override is given, then return.
                     * 2.3. Set state to path start state, and decrease pointer by one.
                     */
                    if (stateOverride !== undefined) {
                        return url;
                    }
                    state = interfaces_1.ParserState.PathStart;
                    walker.pointer--;
                }
                else {
                    /**
                     * 3. Otherwise, validation error, return failure.
                     */
                    validationError("Invalid input string.");
                    return null;
                }
                break;
            case interfaces_1.ParserState.File:
                /**
                 * 1. Set url’s scheme to "file".
                 */
                url.scheme = "file";
                if (walker.c() === '/' || walker.c() === '\\') {
                    /**
                     * 2. If c is U+002F (/) or U+005C (\), then:
                     * 2.1. If c is U+005C (\), validation error.
                     * 2.2. Set state to file slash state.
                     */
                    if (walker.c() === '\\') {
                        validationError("Invalid input string.");
                    }
                    state = interfaces_1.ParserState.FileSlash;
                }
                else if (baseURL !== null && baseURL.scheme === "file") {
                    /**
                     * 3. Otherwise, if base is non-null and base’s scheme is "file",
                     * switch on c:
                     */
                    switch (walker.c()) {
                        case EOF:
                            /**
                             * Set url’s host to base’s host, url’s path to a copy of base’s
                             * path, and url’s query to base’s query.
                             */
                            url.host = baseURL.host;
                            url.path = infra_1.list.clone(baseURL.path);
                            url.query = baseURL.query;
                            break;
                        case '?':
                            /**
                             * Set url’s host to base’s host, url’s path to a copy of base’s
                             * path, url’s query to the empty string, and state to query
                             * state.
                             */
                            url.host = baseURL.host;
                            url.path = infra_1.list.clone(baseURL.path);
                            url.query = "";
                            state = interfaces_1.ParserState.Query;
                            break;
                        case '#':
                            /**
                             * Set url’s host to base’s host, url’s path to a copy of base’s
                             * path, url’s query to base’s query, url’s fragment to the
                             * empty string, and state to fragment state.
                             */
                            url.host = baseURL.host;
                            url.path = infra_1.list.clone(baseURL.path);
                            url.query = baseURL.query;
                            url.fragment = "";
                            state = interfaces_1.ParserState.Fragment;
                            break;
                        default:
                            /**
                             * 1. If the substring from pointer in input does not start
                             * with a Windows drive letter, then set url’s host to base’s
                             * host, url’s path to a copy of base’s path, and then shorten
                             * url’s path.
                             * _Note:_ is a (platform-independent) Windows drive letter
                             * quirk.
                             * 2. Otherwise, validation error.
                             * 3. Set state to path state, and decrease pointer by one.
                             */
                            if (!startsWithAWindowsDriveLetter(walker.substring())) {
                                url.host = baseURL.host;
                                url.path = infra_1.list.clone(baseURL.path);
                                shorten(url);
                            }
                            else {
                                validationError("Unexpected windows drive letter in input string.");
                            }
                            state = interfaces_1.ParserState.Path;
                            walker.pointer--;
                            break;
                    }
                }
                else {
                    /**
                     * 4. Otherwise, set state to path state, and decrease pointer by
                     * one.
                     */
                    state = interfaces_1.ParserState.Path;
                    walker.pointer--;
                }
                break;
            case interfaces_1.ParserState.FileSlash:
                if (walker.c() === '/' || walker.c() === '\\') {
                    /**
                     * 1. If c is U+002F (/) or U+005C (\), then:
                     * 1.1. If c is U+005C (\), validation error.
                     * 1.2. Set state to file host state.
                     */
                    if (walker.c() === '\\') {
                        validationError("Invalid input string.");
                    }
                    state = interfaces_1.ParserState.FileHost;
                }
                else {
                    /**
                     * 2. Otherwise:
                     * 2.1. If base is non-null, base’s scheme is "file", and the
                     * substring from pointer in input does not start with a Windows
                     * drive letter, then:
                     * 2.1.1. If base’s path[0] is a normalized Windows drive letter,
                     * then append base’s path[0] to url’s path.
                     * _Note:_ is a (platform-independent) Windows drive letter
                     * quirk. Both url’s and base’s host are null under these conditions
                     * and therefore not copied.
                     * 2.1.2. Otherwise, set url’s host to base’s host.
                     * 2.2. Set state to path state, and decrease pointer by one.
                     */
                    if (baseURL !== null && baseURL.scheme === "file" &&
                        !startsWithAWindowsDriveLetter(walker.substring())) {
                        if (isNormalizedWindowsDriveLetter(baseURL.path[0])) {
                            url.path.push(baseURL.path[0]);
                        }
                        else {
                            url.host = baseURL.host;
                        }
                    }
                    state = interfaces_1.ParserState.Path;
                    walker.pointer--;
                }
                break;
            case interfaces_1.ParserState.FileHost:
                if (walker.c() === EOF || walker.c() === '/' || walker.c() === '\\' ||
                    walker.c() === '?' || walker.c() === '#') {
                    /**
                     * 1. If c is the EOF code point, U+002F (/), U+005C (\), U+003F (?),
                     * or U+0023 (#), then decrease pointer by one and then:
                     */
                    walker.pointer--;
                    if (stateOverride === undefined && isWindowsDriveLetter(buffer)) {
                        /**
                         * 1.1. If state override is not given and buffer is a Windows drive
                         * letter, validation error, set state to path state.
                         * _Note:_ is a (platform-independent) Windows drive letter
                         * quirk. buffer is not reset here and instead used in the path state.
                         */
                        validationError("Unexpected windows drive letter in input string.");
                        state = interfaces_1.ParserState.Path;
                    }
                    else if (buffer === "") {
                        /**
                         * 1.2. Otherwise, if buffer is the empty string, then:
                         * 1.2.1. Set url’s host to the empty string.
                         * 1.2.2. If state override is given, then return.
                         * 1.2.3. Set state to path start state.
                         */
                        url.host = "";
                        if (stateOverride !== undefined)
                            return url;
                        state = interfaces_1.ParserState.PathStart;
                    }
                    else {
                        /**
                         * 1.3. Otherwise, run these steps:
                         * 1.3.1. Let host be the result of host parsing buffer with url
                         * is not special.
                         * 1.3.2. If host is failure, then return failure.
                         * 1.3.3. If host is "localhost", then set host to the empty
                         * string.
                         * 1.3.4. Set url’s host to host.
                         * 1.3.5. If state override is given, then return.
                         * 1.3.6. Set buffer to the empty string and state to path start
                         * state.
                         */
                        var host = hostParser(buffer, !isSpecial(url));
                        if (host === null)
                            return null;
                        if (host === "localhost")
                            host = "";
                        url.host = host;
                        if (stateOverride !== undefined)
                            return url;
                        buffer = "";
                        state = interfaces_1.ParserState.PathStart;
                    }
                }
                else {
                    /**
                     * 2. Otherwise, append c to buffer.
                     */
                    buffer += walker.c();
                }
                break;
            case interfaces_1.ParserState.PathStart:
                if (isSpecial(url)) {
                    /**
                     * 1. If url is special, then:
                     * 1.1. If c is U+005C (\), validation error.
                     * 1.2. Set state to path state.
                     * 1.3. If c is neither U+002F (/) nor U+005C (\), then decrease
                     * pointer by one.
                     */
                    if (walker.c() === '\\') {
                        validationError("Invalid input string.");
                    }
                    state = interfaces_1.ParserState.Path;
                    if (walker.c() !== '/' && walker.c() !== '\\')
                        walker.pointer--;
                }
                else if (stateOverride === undefined && walker.c() === '?') {
                    /**
                     * 2. Otherwise, if state override is not given and c is U+003F (?),
                     * set url’s query to the empty string and state to query state.
                     */
                    url.query = "";
                    state = interfaces_1.ParserState.Query;
                }
                else if (stateOverride === undefined && walker.c() === '#') {
                    /**
                     * 3. Otherwise, if state override is not given and c is U+0023 (#),
                     * set url’s fragment to the empty string and state to fragment
                     * state.
                     */
                    url.fragment = "";
                    state = interfaces_1.ParserState.Fragment;
                }
                else if (walker.c() !== EOF) {
                    /**
                     * 4. Otherwise, if c is not the EOF code point:
                     * 4.1. Set state to path state.
                     * 4.2. If c is not U+002F (/), then decrease pointer by one.
                     */
                    state = interfaces_1.ParserState.Path;
                    if (walker.c() !== '/')
                        walker.pointer--;
                }
                break;
            case interfaces_1.ParserState.Path:
                if ((walker.c() === EOF || walker.c() === '/') ||
                    (isSpecial(url) && walker.c() === '\\') ||
                    (stateOverride === undefined && (walker.c() === '?' || walker.c() === '#'))) {
                    /**
                     * 1. If one of the following is true
                     * - c is the EOF code point or U+002F (/)
                     * - url is special and c is U+005C (\)
                     * - state override is not given and c is U+003F (?) or U+0023 (#)
                     * then:
                     */
                    if (isSpecial(url) && walker.c() === '\\') {
                        /**
                         * 1.1 If url is special and c is U+005C (\), validation error.
                         */
                        validationError("Invalid input string.");
                    }
                    if (isDoubleDotPathSegment(buffer)) {
                        /**
                         * 1.2. If buffer is a double-dot path segment, shorten url’s path,
                         * and then if neither c is U+002F (/), nor url is special and c is
                         * U+005C (\), append the empty string to url’s path.
                         */
                        shorten(url);
                        if (walker.c() !== '/' && !(isSpecial(url) && walker.c() === '\\')) {
                            url.path.push("");
                        }
                    }
                    else if (isSingleDotPathSegment(buffer) && walker.c() !== '/' &&
                        !(isSpecial(url) && walker.c() === '\\')) {
                        /**
                         * 1.3. Otherwise, if buffer is a single-dot path segment and if
                         * neither c is U+002F (/), nor url is special and c is U+005C (\),
                         * append the empty string to url’s path.
                         */
                        url.path.push("");
                    }
                    else if (!isSingleDotPathSegment(buffer)) {
                        /**
                         * 1.4. Otherwise, if buffer is not a single-dot path segment, then:
                         */
                        if (url.scheme === "file" && url.path.length === 0 &&
                            isWindowsDriveLetter(buffer)) {
                            /**
                             * 1.4.1. If url’s scheme is "file", url’s path is empty, and
                             * buffer is a Windows drive letter, then:
                             * 1.4.1.1. If url’s host is neither the empty string nor null,
                             * validation error, set url’s host to the empty string.
                             * 1.4.1.2. Replace the second code point in buffer with U+003A (:).
                             * _Note:_ is a (platform-independent) Windows drive letter quirk.
                             */
                            if (url.host !== null && url.host !== "") {
                                validationError("Invalid input string.");
                                url.host = "";
                            }
                            var bufferCodePoints = Array.from(buffer);
                            buffer = bufferCodePoints.slice(0, 1) + ':' + bufferCodePoints.slice(2);
                        }
                        /**
                         * 1.4.2. Append buffer to url’s path.
                         */
                        url.path.push(buffer);
                    }
                    /**
                     * 1.5. Set buffer to the empty string.
                     */
                    buffer = "";
                    /**
                     * 1.6. If url’s scheme is "file" and c is the EOF code point,
                     * U+003F (?), or U+0023 (#), then while url’s path’s size is
                     * greater than 1 and url’s path[0] is the empty string, validation
                     * error, remove the first item from url’s path.
                     */
                    if (url.scheme === "file" && (walker.c() === EOF || walker.c() === '?' || walker.c() === '#')) {
                        while (url.path.length > 1 && url.path[0] === "") {
                            validationError("Invalid input string.");
                            url.path.splice(0, 1);
                        }
                    }
                    /**
                     * 1.7. If c is U+003F (?), then set url’s query to the empty string
                     * and state to query state.
                     * 1.8. If c is U+0023 (#), then set url’s fragment to the empty
                     * string and state to fragment state.
                     */
                    if (walker.c() === '?') {
                        url.query = "";
                        state = interfaces_1.ParserState.Query;
                    }
                    if (walker.c() === '#') {
                        url.fragment = "";
                        state = interfaces_1.ParserState.Fragment;
                    }
                }
                else {
                    /**
                     * 2. Otherwise, run these steps:
                     * 2.1. If c is not a URL code point and not U+0025 (%), validation
                     * error.
                     * 2.2. If c is U+0025 (%) and remaining does not start with two
                     * ASCII hex digits, validation error.
                     * 2.3. UTF-8 percent encode c using the path percent-encode set,
                     * and append the result to buffer.
                     */
                    if (!_urlCodePoints.test(walker.c()) && walker.c() !== '%') {
                        validationError("Character is not a URL code point or a percent encoded character.");
                    }
                    if (walker.c() === '%' && !/^[0-9a-fA-F][0-9a-fA-F]/.test(walker.remaining())) {
                        validationError("Percent encoded character must be followed by two hex digits.");
                    }
                    buffer += utf8PercentEncode(walker.c(), _pathPercentEncodeSet);
                }
                break;
            case interfaces_1.ParserState.CannotBeABaseURLPath:
                /**
                 * 1. If c is U+003F (?), then set url’s query to the empty string and
                 * state to query state.
                 * 2. Otherwise, if c is U+0023 (#), then set url’s fragment to the
                 * empty string and state to fragment state.
                 * 3. Otherwise:
                 * 3.1. If c is not the EOF code point, not a URL code point, and not
                 * U+0025 (%), validation error.
                 * 3.2. If c is U+0025 (%) and remaining does not start with two ASCII
                 * hex digits, validation error.
                 * 3.3. If c is not the EOF code point, UTF-8 percent encode c using
                 * the C0 control percent-encode set, and append the result to url’s
                 * path[0].
                 */
                if (walker.c() === '?') {
                    url.query = "";
                    state = interfaces_1.ParserState.Query;
                }
                else if (walker.c() === '#') {
                    url.fragment = "";
                    state = interfaces_1.ParserState.Fragment;
                }
                else {
                    if (walker.c() !== EOF && !_urlCodePoints.test(walker.c()) && walker.c() !== '%') {
                        validationError("Character is not a URL code point or a percent encoded character.");
                    }
                    if (walker.c() === '%' && !/^[0-9a-fA-F][0-9a-fA-F]/.test(walker.remaining())) {
                        validationError("Percent encoded character must be followed by two hex digits.");
                    }
                    if (walker.c() !== EOF) {
                        url.path[0] += utf8PercentEncode(walker.c(), _c0ControlPercentEncodeSet);
                    }
                }
                break;
            case interfaces_1.ParserState.Query:
                /**
                 * 1. If encoding is not UTF-8 and one of the following is true
                 * - url is not special
                 * - url’s scheme is "ws" or "wss"
                 * then set encoding to UTF-8.
                 */
                if (encoding !== "UTF-8" && (!isSpecial(url) ||
                    url.scheme === "ws" || url.scheme === "wss")) {
                    encoding = "UTF-8";
                }
                if (stateOverride === undefined && walker.c() === '#') {
                    /**
                     * 2. If state override is not given and c is U+0023 (#), then set
                     * url’s fragment to the empty string and state to fragment state.
                     */
                    url.fragment = "";
                    state = interfaces_1.ParserState.Fragment;
                }
                else if (walker.c() !== EOF) {
                    /**
                     * 3. Otherwise, if c is not the EOF code point:
                     * 3.1. If c is not a URL code point and not U+0025 (%), validation
                     * error.
                     */
                    if (!_urlCodePoints.test(walker.c()) && walker.c() !== '%') {
                        validationError("Character is not a URL code point or a percent encoded character.");
                    }
                    /**
                     * 3.2. If c is U+0025 (%) and remaining does not start with two
                     * ASCII hex digits, validation error.
                     */
                    if (walker.c() === '%' && !/^[0-9a-fA-F][0-9a-fA-F]/.test(walker.remaining())) {
                        validationError("Percent encoded character must be followed by two hex digits.");
                    }
                    /**
                     * 3.3. Let bytes be the result of encoding c using encoding.
                     */
                    if (encoding.toUpperCase() !== "UTF-8") {
                        throw new Error("Only UTF-8 encoding is supported.");
                    }
                    var bytes = util_1.utf8Encode(walker.c());
                    /**
                     * 3.4. If bytes starts with `&#` and ends with 0x3B (;), then:
                     */
                    if (bytes.length >= 3 && bytes[0] === 38 && bytes[1] === 35 &&
                        bytes[bytes.length - 1] === 59) {
                        /**
                         * 3.4.1. Replace `&#` at the start of bytes with `%26%23`.
                         * 3.4.2. Replace 0x3B (;) at the end of bytes with `%3B`.
                         * 3.4.4. Append bytes, isomorphic decoded, to url’s query.
                         * _Note:_ can happen when encoding code points using a
                         * non-UTF-8 encoding.
                         */
                        bytes = bytes.subarray(2, bytes.length - 1);
                        url.query += "%26%23" + infra_1.byteSequence.isomorphicDecode(bytes) + "%3B";
                    }
                    else {
                        try {
                            /**
                             * 3.5. Otherwise, for each byte in bytes:
                             * 3.5.1. If one of the following is true
                             * - byte is less than 0x21 (!)
                             * - byte is greater than 0x7E (~)
                             * - byte is 0x22 ("), 0x23 (#), 0x3C (<), or 0x3E (>)
                             * - byte is 0x27 (') and url is special
                             * then append byte, percent encoded, to url’s query.
                             * 3.5.2. Otherwise, append a code point whose value is byte to
                             * url’s query.
                             */
                            for (var bytes_1 = (e_3 = void 0, __values(bytes)), bytes_1_1 = bytes_1.next(); !bytes_1_1.done; bytes_1_1 = bytes_1.next()) {
                                var byte = bytes_1_1.value;
                                if (byte < 0x21 || byte > 0x7E || byte === 0x22 ||
                                    byte === 0x23 || byte === 0x3C || byte === 0x3E ||
                                    (byte === 0x27 && isSpecial(url))) {
                                    url.query += percentEncode(byte);
                                }
                                else {
                                    url.query += String.fromCharCode(byte);
                                }
                            }
                        }
                        catch (e_3_1) { e_3 = { error: e_3_1 }; }
                        finally {
                            try {
                                if (bytes_1_1 && !bytes_1_1.done && (_b = bytes_1.return)) _b.call(bytes_1);
                            }
                            finally { if (e_3) throw e_3.error; }
                        }
                    }
                }
                break;
            case interfaces_1.ParserState.Fragment:
                /**
                 * Switching on c:
                 * - The EOF code point
                 * Do nothing.
                 * - U+0000 NULL
                 * Validation error.
                 * - Otherwise
                 * 1. If c is not a URL code point and not U+0025 (%), validation
                 * error.
                 * 2. If c is U+0025 (%) and remaining does not start with two ASCII
                 * hex digits, validation error.
                 * 3. UTF-8 percent encode c using the fragment percent-encode set and
                 * append the result to url’s fragment.
                 */
                if (walker.c() === EOF) {
                    //
                }
                else if (walker.c() === "\u0000") {
                    validationError("NULL character in input string.");
                }
                else {
                    if (!_urlCodePoints.test(walker.c()) && walker.c() !== '%') {
                        validationError("Unexpected character in fragment string.");
                    }
                    if (walker.c() === '%' && !/^[A-Za-z0-9][A-Za-z0-9]/.test(walker.remaining())) {
                        validationError("Unexpected character in fragment string.");
                    }
                    url.fragment += utf8PercentEncode(walker.c(), _fragmentPercentEncodeSet);
                }
                break;
        }
        if (walker.eof)
            break;
        else
            walker.pointer++;
    }
    /**
     * 12. Return url.
     */
    return url;
}
exports.basicURLParser = basicURLParser;
/**
 * Sets a URL's username.
 *
 * @param url - a URL
 * @param username - username string
 */
function setTheUsername(url, username) {
    var e_4, _a;
    /**
     * 1. Set url’s username to the empty string.
     * 2. For each code point in username, UTF-8 percent encode it using the
     * userinfo percent-encode set, and append the result to url’s username.
     */
    var result = "";
    try {
        for (var username_1 = __values(username), username_1_1 = username_1.next(); !username_1_1.done; username_1_1 = username_1.next()) {
            var codePoint = username_1_1.value;
            result += utf8PercentEncode(codePoint, _userInfoPercentEncodeSet);
        }
    }
    catch (e_4_1) { e_4 = { error: e_4_1 }; }
    finally {
        try {
            if (username_1_1 && !username_1_1.done && (_a = username_1.return)) _a.call(username_1);
        }
        finally { if (e_4) throw e_4.error; }
    }
    url.username = result;
}
exports.setTheUsername = setTheUsername;
/**
 * Sets a URL's password.
 *
 * @param url - a URL
 * @param username - password string
 */
function setThePassword(url, password) {
    var e_5, _a;
    /**
     * 1. Set url’s password to the empty string.
     * 2. For each code point in password, UTF-8 percent encode it using the
     * userinfo percent-encode set, and append the result to url’s password.
     */
    var result = "";
    try {
        for (var password_1 = __values(password), password_1_1 = password_1.next(); !password_1_1.done; password_1_1 = password_1.next()) {
            var codePoint = password_1_1.value;
            result += utf8PercentEncode(codePoint, _userInfoPercentEncodeSet);
        }
    }
    catch (e_5_1) { e_5 = { error: e_5_1 }; }
    finally {
        try {
            if (password_1_1 && !password_1_1.done && (_a = password_1.return)) _a.call(password_1);
        }
        finally { if (e_5) throw e_5.error; }
    }
    url.password = result;
}
exports.setThePassword = setThePassword;
/**
 * Determines if the string represents a single dot path.
 *
 * @param str - a string
 */
function isSingleDotPathSegment(str) {
    return str === '.' || str.toLowerCase() === "%2e";
}
exports.isSingleDotPathSegment = isSingleDotPathSegment;
/**
 * Determines if the string represents a double dot path.
 *
 * @param str - a string
 */
function isDoubleDotPathSegment(str) {
    var lowerStr = str.toLowerCase();
    return lowerStr === ".." || lowerStr === ".%2e" ||
        lowerStr === "%2e." || lowerStr === "%2e%2e";
}
exports.isDoubleDotPathSegment = isDoubleDotPathSegment;
/**
 * Shorten's URL's path.
 *
 * @param url - an URL
 */
function shorten(url) {
    /**
     * 1. Let path be url’s path.
     * 2. If path is empty, then return.
     * 3. If url’s scheme is "file", path’s size is 1, and path[0] is a
     * normalized Windows drive letter, then return.
     * 4. Remove path’s last item.
     */
    var path = url.path;
    if (path.length === 0)
        return;
    if (url.scheme === "file" && path.length === 1 &&
        isNormalizedWindowsDriveLetter(path[0]))
        return;
    url.path.splice(url.path.length - 1, 1);
}
exports.shorten = shorten;
/**
 * Determines if a string is a normalized Windows drive letter.
 *
 * @param str - a string
 */
function isNormalizedWindowsDriveLetter(str) {
    /**
     * A normalized Windows drive letter is a Windows drive letter of which the
     * second code point is U+003A (:).
     */
    return str.length >= 2 && infra_1.codePoint.ASCIIAlpha.test(str[0]) &&
        str[1] === ':';
}
exports.isNormalizedWindowsDriveLetter = isNormalizedWindowsDriveLetter;
/**
 * Determines if a string is a Windows drive letter.
 *
 * @param str - a string
 */
function isWindowsDriveLetter(str) {
    /**
     * A Windows drive letter is two code points, of which the first is an ASCII
     * alpha and the second is either U+003A (:) or U+007C (|).
     */
    return str.length >= 2 && infra_1.codePoint.ASCIIAlpha.test(str[0]) &&
        (str[1] === ':' || str[1] === '|');
}
exports.isWindowsDriveLetter = isWindowsDriveLetter;
/**
 * Determines if a string starts with a Windows drive letter.
 *
 * @param str - a string
 */
function startsWithAWindowsDriveLetter(str) {
    /**
     * A string starts with a Windows drive letter if all of the following are
     * true:
     * - its length is greater than or equal to 2
     * - its first two code points are a Windows drive letter
     * - its length is 2 or its third code point is U+002F (/), U+005C (\),
     * U+003F (?), or U+0023 (#).
     */
    return str.length >= 2 && isWindowsDriveLetter(str) &&
        (str.length === 2 || (str[2] === '/' || str[2] === '\\' ||
            str[2] === '?' || str[2] === '#'));
}
exports.startsWithAWindowsDriveLetter = startsWithAWindowsDriveLetter;
/**
 * Parses a host string.
 *
 * @param input - input string
 * @param isNotSpecial - `true` if the source URL is not special; otherwise
 * `false`.
 */
function hostParser(input, isNotSpecial) {
    if (isNotSpecial === void 0) { isNotSpecial = false; }
    /**
     * 1. If isNotSpecial is not given, then set isNotSpecial to false.
     * 2. If input starts with U+005B ([), then:
     * 2.1. If input does not end with U+005D (]), validation error, return
     * failure.
     * 2.2. Return the result of IPv6 parsing input with its leading U+005B ([)
     * and trailing U+005D (]) removed.
     */
    if (input.startsWith('[')) {
        if (!input.endsWith(']')) {
            validationError("Expected ']' after '['.");
            return null;
        }
        return iPv6Parser(input.substring(1, input.length - 1));
    }
    /**
     * 3. If isNotSpecial is true, then return the result of opaque-host parsing
     * input.
     */
    if (isNotSpecial) {
        return opaqueHostParser(input);
    }
    /**
     * 4. Let domain be the result of running UTF-8 decode without BOM on the
     * string percent decoding of input.
     * _Note:_ Alternatively UTF-8 decode without BOM or fail can be used,
     * coupled with an early return for failure, as domain to ASCII fails
     * on U+FFFD REPLACEMENT CHARACTER.
     */
    var domain = util_1.utf8Decode(stringPercentDecode(input));
    /**
     * 5. Let asciiDomain be the result of running domain to ASCII on domain.
     * 6. If asciiDomain is failure, validation error, return failure.
     * 7. If asciiDomain contains a forbidden host code point, validation error,
     * return failure.
     */
    var asciiDomain = domainToASCII(domain);
    if (asciiDomain === null) {
        validationError("Invalid domain.");
        return null;
    }
    if (_forbiddenHostCodePoint.test(asciiDomain)) {
        validationError("Invalid domain.");
        return null;
    }
    /**
     * 8. Let ipv4Host be the result of IPv4 parsing asciiDomain.
     * 9. If ipv4Host is an IPv4 address or failure, return ipv4Host.
     * 10. Return asciiDomain.
     */
    var ipv4Host = iPv4Parser(asciiDomain);
    if (ipv4Host === null || util_1.isNumber(ipv4Host))
        return ipv4Host;
    return asciiDomain;
}
exports.hostParser = hostParser;
/**
 * Parses a string containing an IP v4 address.
 *
 * @param input - input string
 * @param isNotSpecial - `true` if the source URL is not special; otherwise
 * `false`.
 */
function iPv4NumberParser(input, validationErrorFlag) {
    if (validationErrorFlag === void 0) { validationErrorFlag = { value: false }; }
    /**
     * 1. Let R be 10.
     */
    var R = 10;
    if (input.startsWith("0x") || input.startsWith("0X")) {
        /**
         * 2. If input contains at least two code points and the first two code
         * points are either "0x" or "0X", then:
         * 2.1. Set validationErrorFlag.
         * 2.2. Remove the first two code points from input.
         * 2.3. Set R to 16.
         */
        validationErrorFlag.value = true;
        input = input.substr(2);
        R = 16;
    }
    else if (input.length >= 2 && input[0] === '0') {
        /**
         * 3. Otherwise, if input contains at least two code points and the first
         * code point is U+0030 (0), then:
         * 3.1. Set validationErrorFlag.
         * 3.2. Remove the first code point from input.
         * 3.3. Set R to 8.
         */
        validationErrorFlag.value = true;
        input = input.substr(1);
        R = 8;
    }
    /**
     * 4. If input is the empty string, then return zero.
     * 5. If input contains a code point that is not a radix-R digit, then
     * return failure.
     */
    if (input === "")
        return 0;
    var radixRDigits = (R === 10 ? /^[0-9]+$/ : (R === 16 ? /^[0-9A-Fa-f]+$/ : /^[0-7]+$/));
    if (!radixRDigits.test(input))
        return null;
    /**
     * 6. Return the mathematical integer value that is represented by input in
     * radix-R notation, using ASCII hex digits for digits with values
     * 0 through 15.
     */
    return parseInt(input, R);
}
exports.iPv4NumberParser = iPv4NumberParser;
/**
 * Parses a string containing an IP v4 address.
 *
 * @param input - input string
 */
function iPv4Parser(input) {
    var e_6, _a, e_7, _b;
    /**
     * 1. Let validationErrorFlag be unset.
     * 2. Let parts be input split on U+002E (.).
     */
    var validationErrorFlag = { value: false };
    var parts = input.split('.');
    /**
     * 3. If the last item in parts is the empty string, then:
     * 3.1. Set validationErrorFlag.
     * 3.2. If parts has more than one item, then remove the last item from
     * parts.
     */
    if (parts[parts.length - 1] === "") {
        validationErrorFlag.value = true;
        if (parts.length > 1)
            parts.pop();
    }
    /**
     * 4. If parts has more than four items, return input.
     */
    if (parts.length > 4)
        return input;
    /**
     * 5. Let numbers be the empty list.
     * 6. For each part in parts:
     * 6.1. If part is the empty string, return input.
     * 6.2. Let n be the result of parsing part using validationErrorFlag.
     * 6.3. If n is failure, return input.
     * 6.4. Append n to numbers.
     */
    var numbers = [];
    try {
        for (var parts_1 = __values(parts), parts_1_1 = parts_1.next(); !parts_1_1.done; parts_1_1 = parts_1.next()) {
            var part = parts_1_1.value;
            if (part === "")
                return input;
            var n = iPv4NumberParser(part, validationErrorFlag);
            if (n === null)
                return input;
            numbers.push(n);
        }
    }
    catch (e_6_1) { e_6 = { error: e_6_1 }; }
    finally {
        try {
            if (parts_1_1 && !parts_1_1.done && (_a = parts_1.return)) _a.call(parts_1);
        }
        finally { if (e_6) throw e_6.error; }
    }
    /**
     * 7. If validationErrorFlag is set, validation error.
     * 8. If any item in numbers is greater than 255, validation error.
     * 9. If any but the last item in numbers is greater than 255, return
     * failure.
     * 10. If the last item in numbers is greater than or equal to
     * 256**(5 − the number of items in numbers), validation error, return failure.
     */
    if (validationErrorFlag.value)
        validationError("Invalid IP v4 address.");
    for (var i = 0; i < numbers.length; i++) {
        var item = numbers[i];
        if (item > 255) {
            validationError("Invalid IP v4 address.");
            if (i < numbers.length - 1)
                return null;
        }
    }
    if (numbers[numbers.length - 1] >= Math.pow(256, 5 - numbers.length)) {
        validationError("Invalid IP v4 address.");
        return null;
    }
    /**
     * 11. Let ipv4 be the last item in numbers.
     * 12. Remove the last item from numbers.
     */
    var ipv4 = numbers[numbers.length - 1];
    numbers.pop();
    /**
     * 13. Let counter be zero.
     * 14. For each n in numbers:
     * 14.2. Increment ipv4 by n × 256**(3 − counter).
     * 14.2. Increment counter by 1.
     */
    var counter = 0;
    try {
        for (var numbers_1 = __values(numbers), numbers_1_1 = numbers_1.next(); !numbers_1_1.done; numbers_1_1 = numbers_1.next()) {
            var n = numbers_1_1.value;
            ipv4 += n * Math.pow(256, 3 - counter);
            counter++;
        }
    }
    catch (e_7_1) { e_7 = { error: e_7_1 }; }
    finally {
        try {
            if (numbers_1_1 && !numbers_1_1.done && (_b = numbers_1.return)) _b.call(numbers_1);
        }
        finally { if (e_7) throw e_7.error; }
    }
    /**
     * 15. Return ipv4.
     */
    return ipv4;
}
exports.iPv4Parser = iPv4Parser;
/**
 * Parses a string containing an IP v6 address.
 *
 * @param input - input string
 */
function iPv6Parser(input) {
    var _a;
    /**
     * 1. Let address be a new IPv6 address whose IPv6 pieces are all 0.
     * 2. Let pieceIndex be 0.
     * 3. Let compress be null.
     * 4. Let pointer be a pointer into input, initially 0 (pointing to the
     * first code point).
     */
    var EOF = "";
    var address = [0, 0, 0, 0, 0, 0, 0, 0];
    var pieceIndex = 0;
    var compress = null;
    var walker = new util_1.StringWalker(input);
    /**
     * 5. If c is U+003A (:), then:
     * 5.1. If remaining does not start with U+003A (:), validation error,
     * return failure.
     * 5.2. Increase pointer by 2.
     * 5.3. Increase pieceIndex by 1 and then set compress to pieceIndex.
     */
    if (walker.c() === ':') {
        if (!walker.remaining().startsWith(':')) {
            validationError("Invalid IP v6 address.");
            return null;
        }
        walker.pointer += 2;
        pieceIndex += 1;
        compress = pieceIndex;
    }
    /**
     * 6. While c is not the EOF code point:
     */
    while (walker.c() !== EOF) {
        /**
         * 6.1. If pieceIndex is 8, validation error, return failure.
         */
        if (pieceIndex === 8) {
            validationError("Invalid IP v6 address.");
            return null;
        }
        /**
         * 6.2. If c is U+003A (:), then:
         * 6.2.1. If compress is non-null, validation error, return failure.
         * 6.2.2. Increase pointer and pieceIndex by 1, set compress to pieceIndex,
         * and then continue.
         */
        if (walker.c() === ':') {
            if (compress !== null) {
                validationError("Invalid IP v6 address.");
                return null;
            }
            walker.pointer++;
            pieceIndex++;
            compress = pieceIndex;
            continue;
        }
        /**
         * 6.3. Let value and length be 0.
         * 6.4. While length is less than 4 and c is an ASCII hex digit, set value
         * to value × 0x10 + c interpreted as hexadecimal number, and increase
         * pointer and length by 1.
         */
        var value = 0;
        var length = 0;
        while (length < 4 && infra_1.codePoint.ASCIIHexDigit.test(walker.c())) {
            value = value * 0x10 + parseInt(walker.c(), 16);
            walker.pointer++;
            length++;
        }
        /**
         * 6.5. If c is U+002E (.), then:
         */
        if (walker.c() === '.') {
            /**
             * 6.5.1. If length is 0, validation error, return failure.
             * 6.5.2. Decrease pointer by length.
             * 6.5.3. If pieceIndex is greater than 6, validation error, return
             * failure.
             * 6.5.4. Let numbersSeen be 0.
             */
            if (length === 0) {
                validationError("Invalid IP v6 address.");
                return null;
            }
            walker.pointer -= length;
            if (pieceIndex > 6) {
                validationError("Invalid IP v6 address.");
                return null;
            }
            var numbersSeen = 0;
            /**
             * 6.5.5. While c is not the EOF code point:
             */
            while (walker.c() !== EOF) {
                /**
                 * 6.5.5.1. Let ipv4Piece be null.
                 */
                var ipv4Piece = null;
                /**
                 * 6.5.5.2. If numbersSeen is greater than 0, then:
                 * 6.5.5.2.1. If c is a U+002E (.) and numbersSeen is less than 4, then
                 * increase pointer by 1.
                 * 6.5.5.2.1. Otherwise, validation error, return failure.
                 */
                if (numbersSeen > 0) {
                    if (walker.c() === '.' && numbersSeen < 4) {
                        walker.pointer++;
                    }
                    else {
                        validationError("Invalid IP v6 address.");
                        return null;
                    }
                }
                /**
                 * 6.5.5.3. If c is not an ASCII digit, validation error, return
                 * failure.
                 */
                if (!infra_1.codePoint.ASCIIDigit.test(walker.c())) {
                    validationError("Invalid IP v6 address.");
                    return null;
                }
                /**
                 * 6.5.5.4. While c is an ASCII digit:
                 */
                while (infra_1.codePoint.ASCIIDigit.test(walker.c())) {
                    /**
                     * 6.5.5.4.1. Let number be c interpreted as decimal number.
                     */
                    var number = parseInt(walker.c(), 10);
                    /**
                     * 6.5.5.4.2. If ipv4Piece is null, then set ipv4Piece to number.
                     * Otherwise, if ipv4Piece is 0, validation error, return failure.
                     * Otherwise, set ipv4Piece to ipv4Piece × 10 + number.
                     */
                    if (ipv4Piece === null) {
                        ipv4Piece = number;
                    }
                    else if (ipv4Piece === 0) {
                        validationError("Invalid IP v6 address.");
                        return null;
                    }
                    else {
                        ipv4Piece = ipv4Piece * 10 + number;
                    }
                    /**
                     * 6.5.5.4.3. If ipv4Piece is greater than 255, validation error, return failure.
                     * 6.5.5.4.4. Increase pointer by 1.
                     */
                    if (ipv4Piece > 255) {
                        validationError("Invalid IP v6 address.");
                        return null;
                    }
                    walker.pointer++;
                }
                /**
                 * 6.5.5.5. Set address[pieceIndex] to address[pieceIndex] × 0x100 + ipv4Piece.
                 * 6.5.5.6. Increase numbersSeen by 1.
                 * 6.5.5.7. If numbersSeen is 2 or 4, then increase pieceIndex by 1.
                 */
                if (ipv4Piece === null) {
                    validationError("Invalid IP v6 address.");
                    return null;
                }
                address[pieceIndex] = address[pieceIndex] * 0x100 + ipv4Piece;
                numbersSeen++;
                if (numbersSeen === 2 || numbersSeen === 4)
                    pieceIndex++;
            }
            /**
             * 6.5.6. If numbersSeen is not 4, validation error, return failure.
             */
            if (numbersSeen !== 4) {
                validationError("Invalid IP v6 address.");
                return null;
            }
            /**
             * 6.5.7. Break.
             */
            break;
        }
        else if (walker.c() === ':') {
            /**
             * 6.6. Otherwise, if c is U+003A (:):
             * 6.6.1. Increase pointer by 1.
             * 6.6.2. If c is the EOF code point, validation error, return failure.
             */
            walker.pointer++;
            if (walker.c() === EOF) {
                validationError("Invalid IP v6 address.");
                return null;
            }
        }
        else if (walker.c() !== EOF) {
            /**
             * 6.7. Otherwise, if c is not the EOF code point, validation error,
             * return failure.
             */
            validationError("Invalid IP v6 address.");
            return null;
        }
        /**
         * 6.8. Set address[pieceIndex] to value.
         * 6.9. Increase pieceIndex by 1.
         */
        address[pieceIndex] = value;
        pieceIndex++;
    }
    /**
     * 7. If compress is non-null, then:
     * 7.1. Let swaps be pieceIndex − compress.
     * 7.2. Set pieceIndex to 7.
     * 7.3. While pieceIndex is not 0 and swaps is greater than 0, swap
     * address[pieceIndex] with address[compress + swaps − 1], and then decrease
     * both pieceIndex and swaps by 1.
     */
    if (compress !== null) {
        var swaps = pieceIndex - compress;
        pieceIndex = 7;
        while (pieceIndex !== 0 && swaps > 0) {
            _a = __read([address[compress + swaps - 1], address[pieceIndex]], 2), address[pieceIndex] = _a[0], address[compress + swaps - 1] = _a[1];
            pieceIndex--;
            swaps--;
        }
    }
    else if (compress === null && pieceIndex !== 8) {
        /**
         * 8. Otherwise, if compress is null and pieceIndex is not 8,
         * validation error, return failure.
         */
        validationError("Invalid IP v6 address.");
        return null;
    }
    /**
     * 9. Return address.
     */
    return address;
}
exports.iPv6Parser = iPv6Parser;
/**
 * Parses an opaque host string.
 *
 * @param input - a string
 */
function opaqueHostParser(input) {
    var e_8, _a;
    /**
     * 1. If input contains a forbidden host code point excluding U+0025 (%),
     * validation error, return failure.
     * 2. Let output be the empty string.
     * 3. For each code point in input, UTF-8 percent encode it using the C0
     * control percent-encode set, and append the result to output.
     * 4. Return output.
     */
    var forbiddenChars = /[\x00\t\f\r #/:?@\[\\\]]/;
    if (forbiddenChars.test(input)) {
        validationError("Invalid host string.");
        return null;
    }
    var output = "";
    try {
        for (var input_1 = __values(input), input_1_1 = input_1.next(); !input_1_1.done; input_1_1 = input_1.next()) {
            var codePoint = input_1_1.value;
            output += utf8PercentEncode(codePoint, _c0ControlPercentEncodeSet);
        }
    }
    catch (e_8_1) { e_8 = { error: e_8_1 }; }
    finally {
        try {
            if (input_1_1 && !input_1_1.done && (_a = input_1.return)) _a.call(input_1);
        }
        finally { if (e_8) throw e_8.error; }
    }
    return output;
}
exports.opaqueHostParser = opaqueHostParser;
/**
 * Resolves a Blob URL from the user agent's Blob URL store.
 * function is not implemented.
 * See: https://w3c.github.io/FileAPI/#blob-url-resolve
 *
 * @param url - an url
 */
function resolveABlobURL(url) {
    return null;
}
exports.resolveABlobURL = resolveABlobURL;
/**
 * Percent encodes a byte.
 *
 * @param value - a byte
 */
function percentEncode(value) {
    /**
     * To percent encode a byte into a percent-encoded byte, return a string
     * consisting of U+0025 (%), followed by two ASCII upper hex digits
     * representing byte.
     */
    return '%' + ('00' + value.toString(16).toUpperCase()).slice(-2);
}
exports.percentEncode = percentEncode;
/**
 * Percent decodes a byte sequence input.
 *
 * @param input - a byte sequence
 */
function percentDecode(input) {
    var isHexDigit = function (byte) {
        return (byte >= 0x30 && byte <= 0x39) || (byte >= 0x41 && byte <= 0x46) ||
            (byte >= 0x61 && byte <= 0x66);
    };
    /**
     * 1. Let output be an empty byte sequence.
     * 2. For each byte byte in input:
     */
    var output = new Uint8Array(input.length);
    var n = 0;
    for (var i = 0; i < input.length; i++) {
        var byte = input[i];
        /**
         * 2.1. If byte is not 0x25 (%), then append byte to output.
         * 2.2. Otherwise, if byte is 0x25 (%) and the next two bytes after byte
         * in input are not in the ranges 0x30 (0) to 0x39 (9), 0x41 (A)
         * to 0x46 (F), and 0x61 (a) to 0x66 (f), all inclusive, append byte
         * to output.
         * 2.3. Otherwise:
         * 2.3.1. Let bytePoint be the two bytes after byte in input, decoded,
         * and then interpreted as hexadecimal number.
         * 2.3.2. Append a byte whose value is bytePoint to output.
         * 2.3.3. Skip the next two bytes in input.
         */
        if (byte !== 0x25) {
            output[n] = byte;
            n++;
        }
        else if (byte === 0x25 && i >= input.length - 2) {
            output[n] = byte;
            n++;
        }
        else if (byte === 0x25 && (!isHexDigit(input[i + 1]) || !isHexDigit(input[i + 2]))) {
            output[n] = byte;
            n++;
        }
        else {
            var bytePoint = parseInt(util_1.utf8Decode(Uint8Array.of(input[i + 1], input[i + 2])), 16);
            output[n] = bytePoint;
            n++;
            i += 2;
        }
    }
    return output.subarray(0, n);
}
exports.percentDecode = percentDecode;
/**
 * String percent decodes a string.
 *
 * @param input - a string
 */
function stringPercentDecode(input) {
    /**
     * 1. Let bytes be the UTF-8 encoding of input.
     * 2. Return the percent decoding of bytes.
     */
    return percentDecode(util_1.utf8Encode(input));
}
exports.stringPercentDecode = stringPercentDecode;
/**
 * UTF-8 percent encodes a code point, using a percent encode set.
 *
 * @param codePoint - a code point
 * @param percentEncodeSet - a percent encode set
 */
function utf8PercentEncode(codePoint, percentEncodeSet) {
    var e_9, _a;
    /**
     * 1. If codePoint is not in percentEncodeSet, then return codePoint.
     * 2. Let bytes be the result of running UTF-8 encode on codePoint.
     * 3. Percent encode each byte in bytes, and then return the results
     * concatenated, in the same order.
     */
    if (!percentEncodeSet.test(codePoint))
        return codePoint;
    var bytes = util_1.utf8Encode(codePoint);
    var result = "";
    try {
        for (var bytes_2 = __values(bytes), bytes_2_1 = bytes_2.next(); !bytes_2_1.done; bytes_2_1 = bytes_2.next()) {
            var byte = bytes_2_1.value;
            result += percentEncode(byte);
        }
    }
    catch (e_9_1) { e_9 = { error: e_9_1 }; }
    finally {
        try {
            if (bytes_2_1 && !bytes_2_1.done && (_a = bytes_2.return)) _a.call(bytes_2);
        }
        finally { if (e_9) throw e_9.error; }
    }
    return result;
}
exports.utf8PercentEncode = utf8PercentEncode;
/**
 * Determines if two hosts are considered equal.
 *
 * @param hostA - a host
 * @param hostB - a host
 */
function hostEquals(hostA, hostB) {
    return hostA === hostB;
}
exports.hostEquals = hostEquals;
/**
 * Determines if two URLs are considered equal.
 *
 * @param urlA - a URL
 * @param urlB - a URL
 * @param excludeFragmentsFlag - whether to ignore fragments while comparing
 */
function urlEquals(urlA, urlB, excludeFragmentsFlag) {
    if (excludeFragmentsFlag === void 0) { excludeFragmentsFlag = false; }
    /**
     * 1. Let serializedA be the result of serializing A, with the exclude
     * fragment flag set if the exclude fragments flag is set.
     * 2. Let serializedB be the result of serializing B, with the exclude
     * fragment flag set if the exclude fragments flag is set.
     * 3. Return true if serializedA is serializedB, and false otherwise.
     */
    return urlSerializer(urlA, excludeFragmentsFlag) ===
        urlSerializer(urlB, excludeFragmentsFlag);
}
exports.urlEquals = urlEquals;
/**
 * Parses an `application/x-www-form-urlencoded` string.
 *
 * @param input - a string
 */
function urlEncodedStringParser(input) {
    /**
     * The application/x-www-form-urlencoded string parser takes a string input,
     * UTF-8 encodes it, and then returns the result of
     * application/x-www-form-urlencoded parsing it.
     */
    return urlEncodedParser(util_1.utf8Encode(input));
}
exports.urlEncodedStringParser = urlEncodedStringParser;
/**
 * Parses `application/x-www-form-urlencoded` bytes.
 *
 * @param input - a byte sequence
 */
function urlEncodedParser(input) {
    var e_10, _a, e_11, _b;
    /**
     * 1. Let sequences be the result of splitting input on 0x26 (&).
     */
    var sequences = [];
    var currentSequence = [];
    try {
        for (var input_2 = __values(input), input_2_1 = input_2.next(); !input_2_1.done; input_2_1 = input_2.next()) {
            var byte = input_2_1.value;
            if (byte === 0x26) {
                sequences.push(Uint8Array.from(currentSequence));
                currentSequence = [];
            }
            else {
                currentSequence.push(byte);
            }
        }
    }
    catch (e_10_1) { e_10 = { error: e_10_1 }; }
    finally {
        try {
            if (input_2_1 && !input_2_1.done && (_a = input_2.return)) _a.call(input_2);
        }
        finally { if (e_10) throw e_10.error; }
    }
    if (currentSequence.length !== 0) {
        sequences.push(Uint8Array.from(currentSequence));
    }
    /**
     * 2. Let output be an initially empty list of name-value tuples where both name and value hold a string.
     */
    var output = [];
    try {
        /**
         * 3. For each byte sequence bytes in sequences:
         */
        for (var sequences_1 = __values(sequences), sequences_1_1 = sequences_1.next(); !sequences_1_1.done; sequences_1_1 = sequences_1.next()) {
            var bytes = sequences_1_1.value;
            /**
             * 3.1. If bytes is the empty byte sequence, then continue.
             */
            if (bytes.length === 0)
                continue;
            /**
             * 3.2. If bytes contains a 0x3D (=), then let name be the bytes from the
             * start of bytes up to but excluding its first 0x3D (=), and let value be
             * the bytes, if any, after the first 0x3D (=) up to the end of bytes.
             * If 0x3D (=) is the first byte, then name will be the empty byte
             * sequence. If it is the last, then value will be the empty byte sequence.
             * 3.3. Otherwise, let name have the value of bytes and let value be the
             * empty byte sequence.
             */
            var index = bytes.indexOf(0x3D);
            var name = (index !== -1 ? bytes.slice(0, index) : bytes);
            var value = (index !== -1 ? bytes.slice(index + 1) : new Uint8Array());
            /**
             * 3.4. Replace any 0x2B (+) in name and value with 0x20 (SP).
             */
            for (var i = 0; i < name.length; i++)
                if (name[i] === 0x2B)
                    name[i] = 0x20;
            for (var i = 0; i < value.length; i++)
                if (value[i] === 0x2B)
                    value[i] = 0x20;
            /**
             * 3.5. Let nameString and valueString be the result of running UTF-8
             * decode without BOM on the percent decoding of name and value,
             * respectively.
             */
            var nameString = util_1.utf8Decode(name);
            var valueString = util_1.utf8Decode(value);
            /**
             * 3.6. Append (nameString, valueString) to output.
             */
            output.push([nameString, valueString]);
        }
    }
    catch (e_11_1) { e_11 = { error: e_11_1 }; }
    finally {
        try {
            if (sequences_1_1 && !sequences_1_1.done && (_b = sequences_1.return)) _b.call(sequences_1);
        }
        finally { if (e_11) throw e_11.error; }
    }
    /**
     * 4. Return output.
     */
    return output;
}
exports.urlEncodedParser = urlEncodedParser;
/**
 * Serializes `application/x-www-form-urlencoded` bytes.
 *
 * @param input - a byte sequence
 */
function urlEncodedByteSerializer(input) {
    var e_12, _a;
    /**
     * 1. Let output be the empty string.
     * 2. For each byte in input, depending on byte:
     * 0x20 (SP)
     * Append U+002B (+) to output.
     *
     * 0x2A (*)
     * 0x2D (-)
     * 0x2E (.)
     * 0x30 (0) to 0x39 (9)
     * 0x41 (A) to 0x5A (Z)
     * 0x5F (_)
     * 0x61 (a) to 0x7A (z)
     * Append a code point whose value is byte to output.
     *
     * Otherwise
     * Append byte, percent encoded, to output.
     * 3. Return output.
     */
    var output = "";
    try {
        for (var input_3 = __values(input), input_3_1 = input_3.next(); !input_3_1.done; input_3_1 = input_3.next()) {
            var byte = input_3_1.value;
            if (byte === 0x20) {
                output += '+';
            }
            else if (byte === 0x2A || byte === 0x2D || byte === 0x2E ||
                (byte >= 0x30 && byte <= 0x39) || (byte >= 0x41 && byte <= 0x5A) ||
                byte === 0x5F || (byte >= 0x61 && byte <= 0x7A)) {
                output += String.fromCodePoint(byte);
            }
            else {
                output += percentEncode(byte);
            }
        }
    }
    catch (e_12_1) { e_12 = { error: e_12_1 }; }
    finally {
        try {
            if (input_3_1 && !input_3_1.done && (_a = input_3.return)) _a.call(input_3);
        }
        finally { if (e_12) throw e_12.error; }
    }
    return output;
}
exports.urlEncodedByteSerializer = urlEncodedByteSerializer;
/**
 * Serializes `application/x-www-form-urlencoded` tuples.
 *
 * @param input - input tuple of name/value pairs
 * @param encodingOverride: encoding override
 */
function urlEncodedSerializer(tuples, encodingOverride) {
    var e_13, _a;
    /**
     * 1. Let encoding be UTF-8.
     * 2. If encoding override is given, set encoding to the result of getting
     * an output encoding from encoding override.
     */
    var encoding = (encodingOverride === undefined ||
        encodingOverride === "replacement" || encodingOverride === "UTF-16BE" ||
        encodingOverride === "UTF-16LE" ? "UTF-8" : encodingOverride);
    if (encoding.toUpperCase() !== "UTF-8") {
        throw new Error("Only UTF-8 encoding is supported.");
    }
    /**
     * 3. Let output be the empty string.
     */
    var output = "";
    try {
        /**
         * 4. For each tuple in tuples:
         */
        for (var tuples_1 = __values(tuples), tuples_1_1 = tuples_1.next(); !tuples_1_1.done; tuples_1_1 = tuples_1.next()) {
            var tuple = tuples_1_1.value;
            /**
             * 4.1. Let name be the result of serializing the result of encoding
             * tuple’s name, using encoding.
             */
            var name = urlEncodedByteSerializer(util_1.utf8Encode(tuple[0]));
            /**
             * 4.2. Let value be tuple’s value.
             */
            var value = tuple[1];
            /**
             * TODO:
             * 4.3. If value is a file, then set value to value’s filename.
             */
            /**
             * 4.4. Set value to the result of serializing the result of encoding
             * value, using encoding.
             */
            value = urlEncodedByteSerializer(util_1.utf8Encode(value));
            /**
             * 4.5. If tuple is not the first pair in tuples, then append U+0026 (&)
             * to output.
             */
            if (output !== "")
                output += '&';
            /**
             * 4.6. Append name, followed by U+003D (=), followed by value, to output.
             */
            output += name + '=' + value;
        }
    }
    catch (e_13_1) { e_13 = { error: e_13_1 }; }
    finally {
        try {
            if (tuples_1_1 && !tuples_1_1.done && (_a = tuples_1.return)) _a.call(tuples_1);
        }
        finally { if (e_13) throw e_13.error; }
    }
    /**
     * 5. Return output.
     */
    return output;
}
exports.urlEncodedSerializer = urlEncodedSerializer;
/**
 * Returns a URL's origin.
 *
 * @param url - a URL
 */
function origin(url) {
    /**
     * A URL’s origin is the origin returned by running these steps, switching
     * on URL’s scheme:
     * "blob"
     * 1. If URL’s blob URL entry is non-null, then return URL’s blob URL
     * entry’s environment’s origin.
     * 2. Let url be the result of parsing URL’s path[0].
     * 3. Return a new opaque origin, if url is failure, and url’s origin
     * otherwise.
     * "ftp"
     * "http"
     * "https"
     * "ws"
     * "wss"
     * Return a tuple consisting of URL’s scheme, URL’s host, URL’s port, and
     * null.
     * "file"
     * Unfortunate as it is, is left as an exercise to the reader. When in
     * doubt, return a new opaque origin.
     * Otherwise
     * Return a new opaque origin.
     */
    switch (url.scheme) {
        case "blob":
            if (url._blobURLEntry !== null) {
                // TODO: return URL’s blob URL entry’s environment’s origin.
            }
            var parsedURL = basicURLParser(url.path[0]);
            if (parsedURL === null)
                return interfaces_1.OpaqueOrigin;
            else
                return origin(parsedURL);
        case "ftp":
        case "http":
        case "https":
        case "ws":
        case "wss":
            return [url.scheme, url.host === null ? "" : url.host, url.port, null];
        case "file":
            return interfaces_1.OpaqueOrigin;
        default:
            return interfaces_1.OpaqueOrigin;
    }
}
exports.origin = origin;
/**
 * Converts a domain string to ASCII.
 *
 * @param domain - a domain string
 */
function domainToASCII(domain, beStrict) {
    if (beStrict === void 0) { beStrict = false; }
    /**
     * 1. If beStrict is not given, set it to false.
     * 2. Let result be the result of running Unicode ToASCII with domain_name
     * set to domain, UseSTD3ASCIIRules set to beStrict, CheckHyphens set to
     * false, CheckBidi set to true, CheckJoiners set to true,
     * Transitional_Processing set to false, and VerifyDnsLength set to beStrict.
     * 3. If result is a failure value, validation error, return failure.
     * 4. Return result.
     */
    // Use node.js function
    var result = url_1.domainToASCII(domain);
    if (result === "") {
        validationError("Invalid domain name.");
        return null;
    }
    return result;
}
exports.domainToASCII = domainToASCII;
/**
 * Converts a domain string to Unicode.
 *
 * @param domain - a domain string
 */
function domainToUnicode(domain, beStrict) {
    if (beStrict === void 0) { beStrict = false; }
    /**
     * 1. Let result be the result of running Unicode ToUnicode with domain_name
     * set to domain, CheckHyphens set to false, CheckBidi set to true,
     * CheckJoiners set to true, UseSTD3ASCIIRules set to false, and
     * Transitional_Processing set to false.
     * 2. Signify validation errors for any returned errors, and then,
     * return result.
     */
    // Use node.js function
    var result = url_1.domainToUnicode(domain);
    if (result === "") {
        validationError("Invalid domain name.");
    }
    return result;
}
exports.domainToUnicode = domainToUnicode;
/**
 * Serializes an origin.
 * function is from the HTML spec:
 * https://html.spec.whatwg.org/#ascii-serialisation-of-an-origin
 *
 * @param origin - an origin
 */
function asciiSerializationOfAnOrigin(origin) {
    /**
     * 1. If origin is an opaque origin, then return "null".
     * 2. Otherwise, let result be origin's scheme.
     * 3. Append "://" to result.
     * 4. Append origin's host, serialized, to result.
     * 5. If origin's port is non-null, append a U+003A COLON character (:),
     * and origin's port, serialized, to result.
     * 6. Return result.
     */
    if (origin[0] === "" && origin[1] === "" && origin[2] === null && origin[3] === null) {
        return "null";
    }
    var result = origin[0] + "://" + hostSerializer(origin[1]);
    if (origin[2] !== null)
        result += ":" + origin[2].toString();
    return result;
}
exports.asciiSerializationOfAnOrigin = asciiSerializationOfAnOrigin;
//# sourceMappingURL=URLAlgorithm.js.map

/***/ }),

/***/ 3904:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * Represents the state of the URL parser.
 */
var ParserState;
(function (ParserState) {
    ParserState[ParserState["SchemeStart"] = 0] = "SchemeStart";
    ParserState[ParserState["Scheme"] = 1] = "Scheme";
    ParserState[ParserState["NoScheme"] = 2] = "NoScheme";
    ParserState[ParserState["SpecialRelativeOrAuthority"] = 3] = "SpecialRelativeOrAuthority";
    ParserState[ParserState["PathOrAuthority"] = 4] = "PathOrAuthority";
    ParserState[ParserState["Relative"] = 5] = "Relative";
    ParserState[ParserState["RelativeSlash"] = 6] = "RelativeSlash";
    ParserState[ParserState["SpecialAuthoritySlashes"] = 7] = "SpecialAuthoritySlashes";
    ParserState[ParserState["SpecialAuthorityIgnoreSlashes"] = 8] = "SpecialAuthorityIgnoreSlashes";
    ParserState[ParserState["Authority"] = 9] = "Authority";
    ParserState[ParserState["Host"] = 10] = "Host";
    ParserState[ParserState["Hostname"] = 11] = "Hostname";
    ParserState[ParserState["Port"] = 12] = "Port";
    ParserState[ParserState["File"] = 13] = "File";
    ParserState[ParserState["FileSlash"] = 14] = "FileSlash";
    ParserState[ParserState["FileHost"] = 15] = "FileHost";
    ParserState[ParserState["PathStart"] = 16] = "PathStart";
    ParserState[ParserState["Path"] = 17] = "Path";
    ParserState[ParserState["CannotBeABaseURLPath"] = 18] = "CannotBeABaseURLPath";
    ParserState[ParserState["Query"] = 19] = "Query";
    ParserState[ParserState["Fragment"] = 20] = "Fragment";
})(ParserState = exports.ParserState || (exports.ParserState = {}));
exports.OpaqueOrigin = ["", "", null, null];
//# sourceMappingURL=interfaces.js.map

/***/ }),

/***/ 214:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * Represents a cache for storing order between equal objects.
 *
 * This cache is used when an algorithm compares two objects and finds them to
 * be equal but still needs to establish an order between those two objects.
 * When two such objects `a` and `b` are passed to the `check` method, a random
 * number is generated with `Math.random()`. If the random number is less than
 * `0.5` it is assumed that `a < b` otherwise `a > b`. The random number along
 * with `a` and `b` is stored in the cache, so that subsequent checks result
 * in the same consistent result.
 *
 * The cache has a size limit which is defined on initialization.
 */
var CompareCache = /** @class */ (function () {
    /**
     * Initializes a new instance of `CompareCache`.
     *
     * @param limit - maximum number of items to keep in the cache. When the limit
     * is exceeded the first item is removed from the cache.
     */
    function CompareCache(limit) {
        if (limit === void 0) { limit = 1000; }
        this._items = new Map();
        this._limit = limit;
    }
    /**
     * Compares and caches the given objects. Returns `true` if `objA < objB` and
     * `false` otherwise.
     *
     * @param objA - an item to compare
     * @param objB - an item to compare
     */
    CompareCache.prototype.check = function (objA, objB) {
        if (this._items.get(objA) === objB)
            return true;
        else if (this._items.get(objB) === objA)
            return false;
        var result = (Math.random() < 0.5);
        if (result) {
            this._items.set(objA, objB);
        }
        else {
            this._items.set(objB, objA);
        }
        if (this._items.size > this._limit) {
            var it_1 = this._items.keys().next();
            /* istanbul ignore else */
            if (!it_1.done) {
                this._items.delete(it_1.value);
            }
        }
        return result;
    };
    return CompareCache;
}());
exports.CompareCache = CompareCache;
//# sourceMappingURL=CompareCache.js.map

/***/ }),

/***/ 3004:
/***/ (function(__unused_webpack_module, exports) {


var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * Represents a set of objects with a size limit.
 */
var FixedSizeSet = /** @class */ (function () {
    /**
     * Initializes a new instance of `FixedSizeSet`.
     *
     * @param limit - maximum number of items to keep in the set. When the limit
     * is exceeded the first item is removed from the set.
     */
    function FixedSizeSet(limit) {
        if (limit === void 0) { limit = 1000; }
        this._items = new Set();
        this._limit = limit;
    }
    /**
     * Adds a new item to the set.
     *
     * @param item - an item
     */
    FixedSizeSet.prototype.add = function (item) {
        this._items.add(item);
        if (this._items.size > this._limit) {
            var it_1 = this._items.values().next();
            /* istanbul ignore else */
            if (!it_1.done) {
                this._items.delete(it_1.value);
            }
        }
        return this;
    };
    /**
     * Removes an item from the set.
     *
     * @param item - an item
     */
    FixedSizeSet.prototype.delete = function (item) {
        return this._items.delete(item);
    };
    /**
     * Determines if an item is in the set.
     *
     * @param item - an item
     */
    FixedSizeSet.prototype.has = function (item) {
        return this._items.has(item);
    };
    /**
     * Removes all items from the set.
     */
    FixedSizeSet.prototype.clear = function () {
        this._items.clear();
    };
    Object.defineProperty(FixedSizeSet.prototype, "size", {
        /**
         * Gets the number of items in the set.
         */
        get: function () { return this._items.size; },
        enumerable: true,
        configurable: true
    });
    /**
     * Applies the given callback function to all elements of the set.
     */
    FixedSizeSet.prototype.forEach = function (callback, thisArg) {
        var _this = this;
        this._items.forEach(function (e) { return callback.call(thisArg, e, e, _this); });
    };
    /**
     * Iterates through the items in the set.
     */
    FixedSizeSet.prototype.keys = function () {
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [5 /*yield**/, __values(this._items.keys())];
                case 1:
                    _a.sent();
                    return [2 /*return*/];
            }
        });
    };
    /**
     * Iterates through the items in the set.
     */
    FixedSizeSet.prototype.values = function () {
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [5 /*yield**/, __values(this._items.values())];
                case 1:
                    _a.sent();
                    return [2 /*return*/];
            }
        });
    };
    /**
     * Iterates through the items in the set.
     */
    FixedSizeSet.prototype.entries = function () {
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [5 /*yield**/, __values(this._items.entries())];
                case 1:
                    _a.sent();
                    return [2 /*return*/];
            }
        });
    };
    /**
     * Iterates through the items in the set.
     */
    FixedSizeSet.prototype[Symbol.iterator] = function () {
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [5 /*yield**/, __values(this._items)];
                case 1:
                    _a.sent();
                    return [2 /*return*/];
            }
        });
    };
    Object.defineProperty(FixedSizeSet.prototype, Symbol.toStringTag, {
        /**
         * Returns the string tag of the set.
         */
        get: function () {
            return "FixedSizeSet";
        },
        enumerable: true,
        configurable: true
    });
    return FixedSizeSet;
}());
exports.FixedSizeSet = FixedSizeSet;
//# sourceMappingURL=FixedSizeSet.js.map

/***/ }),

/***/ 1323:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * Represents an object with lazy initialization.
 */
var Lazy = /** @class */ (function () {
    /**
     * Initializes a new instance of `Lazy`.
     *
     * @param initFunc - initializer function
     */
    function Lazy(initFunc) {
        this._initialized = false;
        this._value = undefined;
        this._initFunc = initFunc;
    }
    Object.defineProperty(Lazy.prototype, "value", {
        /**
         * Gets the value of the object.
         */
        get: function () {
            if (!this._initialized) {
                this._value = this._initFunc();
                this._initialized = true;
            }
            return this._value;
        },
        enumerable: true,
        configurable: true
    });
    return Lazy;
}());
exports.Lazy = Lazy;
//# sourceMappingURL=Lazy.js.map

/***/ }),

/***/ 950:
/***/ (function(__unused_webpack_module, exports) {


var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * Represents a cache of objects with a size limit.
 */
var ObjectCache = /** @class */ (function () {
    /**
     * Initializes a new instance of `ObjectCache`.
     *
     * @param limit - maximum number of items to keep in the cache. When the limit
     * is exceeded the first item is removed from the cache.
     */
    function ObjectCache(limit) {
        if (limit === void 0) { limit = 1000; }
        this._items = new Map();
        this._limit = limit;
    }
    /**
     * Gets an item from the cache.
     *
     * @param key - object key
     */
    ObjectCache.prototype.get = function (key) {
        return this._items.get(key);
    };
    /**
     * Adds a new item to the cache.
     *
     * @param key - object key
     * @param value - object value
     */
    ObjectCache.prototype.set = function (key, value) {
        this._items.set(key, value);
        if (this._items.size > this._limit) {
            var it_1 = this._items.keys().next();
            /* istanbul ignore else */
            if (!it_1.done) {
                this._items.delete(it_1.value);
            }
        }
    };
    /**
     * Removes an item from the cache.
     *
     * @param item - an item
     */
    ObjectCache.prototype.delete = function (key) {
        return this._items.delete(key);
    };
    /**
     * Determines if an item is in the cache.
     *
     * @param item - an item
     */
    ObjectCache.prototype.has = function (key) {
        return this._items.has(key);
    };
    /**
     * Removes all items from the cache.
     */
    ObjectCache.prototype.clear = function () {
        this._items.clear();
    };
    Object.defineProperty(ObjectCache.prototype, "size", {
        /**
         * Gets the number of items in the cache.
         */
        get: function () { return this._items.size; },
        enumerable: true,
        configurable: true
    });
    /**
     * Applies the given callback function to all elements of the cache.
     */
    ObjectCache.prototype.forEach = function (callback, thisArg) {
        this._items.forEach(function (v, k) { return callback.call(thisArg, k, v); });
    };
    /**
     * Iterates through the items in the set.
     */
    ObjectCache.prototype.keys = function () {
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [5 /*yield**/, __values(this._items.keys())];
                case 1:
                    _a.sent();
                    return [2 /*return*/];
            }
        });
    };
    /**
     * Iterates through the items in the set.
     */
    ObjectCache.prototype.values = function () {
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [5 /*yield**/, __values(this._items.values())];
                case 1:
                    _a.sent();
                    return [2 /*return*/];
            }
        });
    };
    /**
     * Iterates through the items in the set.
     */
    ObjectCache.prototype.entries = function () {
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [5 /*yield**/, __values(this._items.entries())];
                case 1:
                    _a.sent();
                    return [2 /*return*/];
            }
        });
    };
    /**
     * Iterates through the items in the set.
     */
    ObjectCache.prototype[Symbol.iterator] = function () {
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [5 /*yield**/, __values(this._items)];
                case 1:
                    _a.sent();
                    return [2 /*return*/];
            }
        });
    };
    Object.defineProperty(ObjectCache.prototype, Symbol.toStringTag, {
        /**
         * Returns the string tag of the cache.
         */
        get: function () {
            return "ObjectCache";
        },
        enumerable: true,
        configurable: true
    });
    return ObjectCache;
}());
exports.ObjectCache = ObjectCache;
//# sourceMappingURL=ObjectCache.js.map

/***/ }),

/***/ 9262:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * Walks through the code points of a string.
 */
var StringWalker = /** @class */ (function () {
    /**
     * Initializes a new `StringWalker`.
     *
     * @param input - input string
     */
    function StringWalker(input) {
        this._pointer = 0;
        this._chars = Array.from(input);
        this._length = this._chars.length;
    }
    Object.defineProperty(StringWalker.prototype, "eof", {
        /**
         * Determines if the current position is beyond the end of string.
         */
        get: function () { return this._pointer >= this._length; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StringWalker.prototype, "length", {
        /**
         * Returns the number of code points in the input string.
         */
        get: function () { return this._length; },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns the current code point. Returns `-1` if the position is beyond
     * the end of string.
     */
    StringWalker.prototype.codePoint = function () {
        if (this._codePoint === undefined) {
            if (this.eof) {
                this._codePoint = -1;
            }
            else {
                var cp = this._chars[this._pointer].codePointAt(0);
                /* istanbul ignore else */
                if (cp !== undefined) {
                    this._codePoint = cp;
                }
                else {
                    this._codePoint = -1;
                }
            }
        }
        return this._codePoint;
    };
    /**
     * Returns the current character. Returns an empty string if the position is
     * beyond the end of string.
     */
    StringWalker.prototype.c = function () {
        if (this._c === undefined) {
            this._c = (this.eof ? "" : this._chars[this._pointer]);
        }
        return this._c;
    };
    /**
     * Returns the remaining string.
     */
    StringWalker.prototype.remaining = function () {
        if (this._remaining === undefined) {
            this._remaining = (this.eof ?
                "" : this._chars.slice(this._pointer + 1).join(''));
        }
        return this._remaining;
    };
    /**
     * Returns the substring from the current character to the end of string.
     */
    StringWalker.prototype.substring = function () {
        if (this._substring === undefined) {
            this._substring = (this.eof ?
                "" : this._chars.slice(this._pointer).join(''));
        }
        return this._substring;
    };
    Object.defineProperty(StringWalker.prototype, "pointer", {
        /**
         * Gets or sets the current position.
         */
        get: function () { return this._pointer; },
        set: function (val) {
            if (val === this._pointer)
                return;
            this._pointer = val;
            this._codePoint = undefined;
            this._c = undefined;
            this._remaining = undefined;
            this._substring = undefined;
        },
        enumerable: true,
        configurable: true
    });
    return StringWalker;
}());
exports.StringWalker = StringWalker;
//# sourceMappingURL=StringWalker.js.map

/***/ }),

/***/ 7061:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {


var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var FixedSizeSet_1 = __nccwpck_require__(3004);
exports.FixedSizeSet = FixedSizeSet_1.FixedSizeSet;
var ObjectCache_1 = __nccwpck_require__(950);
exports.ObjectCache = ObjectCache_1.ObjectCache;
var CompareCache_1 = __nccwpck_require__(214);
exports.CompareCache = CompareCache_1.CompareCache;
var Lazy_1 = __nccwpck_require__(1323);
exports.Lazy = Lazy_1.Lazy;
var StringWalker_1 = __nccwpck_require__(9262);
exports.StringWalker = StringWalker_1.StringWalker;
/**
 * Applies the mixin to a given class.
 *
 * @param baseClass - class to receive the mixin
 * @param mixinClass - mixin class
 * @param overrides - an array with names of function overrides. Base class
 * functions whose names are in this array will be kept by prepending an
 * underscore to their names.
 */
function applyMixin(baseClass, mixinClass) {
    var overrides = [];
    for (var _i = 2; _i < arguments.length; _i++) {
        overrides[_i - 2] = arguments[_i];
    }
    Object.getOwnPropertyNames(mixinClass.prototype).forEach(function (name) {
        if (name !== "constructor") {
            if (overrides.indexOf(name) !== -1) {
                var orgPropDesc = Object.getOwnPropertyDescriptor(baseClass.prototype, name);
                /* istanbul ignore else */
                if (orgPropDesc) {
                    Object.defineProperty(baseClass.prototype, "_" + name, orgPropDesc);
                }
            }
            var propDesc = Object.getOwnPropertyDescriptor(mixinClass.prototype, name);
            /* istanbul ignore else */
            if (propDesc) {
                Object.defineProperty(baseClass.prototype, name, propDesc);
            }
        }
    });
}
exports.applyMixin = applyMixin;
/**
 * Applies default values to the given object.
 *
 * @param obj - an object
 * @param defaults - an object with default values
 * @param overwrite - if set to `true` defaults object always overwrites object
 * values, whether they are `undefined` or not.
 */
function applyDefaults(obj, defaults, overwrite) {
    if (overwrite === void 0) { overwrite = false; }
    var result = clone(obj || {});
    forEachObject(defaults, function (key, val) {
        if (isPlainObject(val)) {
            result[key] = applyDefaults(result[key], val, overwrite);
        }
        else if (overwrite || result[key] === undefined) {
            result[key] = val;
        }
    });
    return result;
}
exports.applyDefaults = applyDefaults;
/**
 * Iterates over items of an array or set.
 *
 * @param arr - array or set to iterate
 * @param callback - a callback function which receives each array item as its
 * single argument
 * @param thisArg - the value of this inside callback
 */
function forEachArray(arr, callback, thisArg) {
    arr.forEach(callback, thisArg);
}
exports.forEachArray = forEachArray;
/**
 * Iterates over key/value pairs of a map or object.
 *
 * @param obj - map or object to iterate
 * @param callback - a callback function which receives object key as its first
 * argument and object value as its second argument
 * @param thisArg - the value of this inside callback
 */
function forEachObject(obj, callback, thisArg) {
    if (isMap(obj)) {
        obj.forEach(function (value, key) { return callback.call(thisArg, key, value); });
    }
    else {
        for (var key in obj) {
            /* istanbul ignore else */
            if (obj.hasOwnProperty(key)) {
                callback.call(thisArg, key, obj[key]);
            }
        }
    }
}
exports.forEachObject = forEachObject;
/**
 * Returns the number of entries in an array or set.
 *
 * @param arr - array or set
 */
function arrayLength(obj) {
    if (isSet(obj)) {
        return obj.size;
    }
    else {
        return obj.length;
    }
}
exports.arrayLength = arrayLength;
/**
 * Returns the number of entries in a map or object.
 *
 * @param obj - map or object
 */
function objectLength(obj) {
    if (isMap(obj)) {
        return obj.size;
    }
    else {
        return Object.keys(obj).length;
    }
}
exports.objectLength = objectLength;
/**
 * Gets the value of a key from a map or object.
 *
 * @param obj - map or object
 * @param key - the key to retrieve
 */
function getObjectValue(obj, key) {
    if (isMap(obj)) {
        return obj.get(key);
    }
    else {
        return obj[key];
    }
}
exports.getObjectValue = getObjectValue;
/**
 * Removes a property from a map or object.
 *
 * @param obj - map or object
 * @param key - the key to remove
 */
function removeObjectValue(obj, key) {
    if (isMap(obj)) {
        obj.delete(key);
    }
    else {
        delete obj[key];
    }
}
exports.removeObjectValue = removeObjectValue;
/**
 * Deep clones the given object.
 *
 * @param obj - an object
 */
function clone(obj) {
    var e_1, _a;
    if (isFunction(obj)) {
        return obj;
    }
    else if (isArray(obj)) {
        var result = [];
        try {
            for (var obj_1 = __values(obj), obj_1_1 = obj_1.next(); !obj_1_1.done; obj_1_1 = obj_1.next()) {
                var item = obj_1_1.value;
                result.push(clone(item));
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (obj_1_1 && !obj_1_1.done && (_a = obj_1.return)) _a.call(obj_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return result;
    }
    else if (isObject(obj)) {
        var result = {};
        for (var key in obj) {
            /* istanbul ignore next */
            if (obj.hasOwnProperty(key)) {
                var val = obj[key];
                result[key] = clone(val);
            }
        }
        return result;
    }
    else {
        return obj;
    }
}
exports.clone = clone;
/**
 * Type guard for boolean types
 *
 * @param x - a variable to type check
 */
function isBoolean(x) {
    return typeof x === "boolean";
}
exports.isBoolean = isBoolean;
/**
 * Type guard for numeric types
 *
 * @param x - a variable to type check
 */
function isNumber(x) {
    return typeof x === "number";
}
exports.isNumber = isNumber;
/**
 * Type guard for strings
 *
 * @param x - a variable to type check
 */
function isString(x) {
    return typeof x === "string";
}
exports.isString = isString;
/**
 * Type guard for function objects
 *
 * @param x - a variable to type check
 */
function isFunction(x) {
    return !!x && Object.prototype.toString.call(x) === '[object Function]';
}
exports.isFunction = isFunction;
/**
 * Type guard for JS objects
 *
 * _Note:_ Functions are objects too
 *
 * @param x - a variable to type check
 */
function isObject(x) {
    var type = typeof x;
    return !!x && (type === 'function' || type === 'object');
}
exports.isObject = isObject;
/**
 * Type guard for arrays
 *
 * @param x - a variable to type check
 */
function isArray(x) {
    return Array.isArray(x);
}
exports.isArray = isArray;
/**
 * Type guard for sets.
 *
 * @param x - a variable to check
 */
function isSet(x) {
    return x instanceof Set;
}
exports.isSet = isSet;
/**
 * Type guard for maps.
 *
 * @param x - a variable to check
 */
function isMap(x) {
    return x instanceof Map;
}
exports.isMap = isMap;
/**
 * Determines if `x` is an empty Array or an Object with no own properties.
 *
 * @param x - a variable to check
 */
function isEmpty(x) {
    if (isArray(x)) {
        return !x.length;
    }
    else if (isSet(x)) {
        return !x.size;
    }
    else if (isMap(x)) {
        return !x.size;
    }
    else if (isObject(x)) {
        for (var key in x) {
            if (x.hasOwnProperty(key)) {
                return false;
            }
        }
        return true;
    }
    return false;
}
exports.isEmpty = isEmpty;
/**
 * Determines if `x` is a plain Object.
 *
 * @param x - a variable to check
 */
function isPlainObject(x) {
    if (isObject(x)) {
        var proto = Object.getPrototypeOf(x);
        var ctor = proto.constructor;
        return proto && ctor &&
            (typeof ctor === 'function') && (ctor instanceof ctor) &&
            (Function.prototype.toString.call(ctor) === Function.prototype.toString.call(Object));
    }
    return false;
}
exports.isPlainObject = isPlainObject;
/**
 * Determines if `x` is an iterable Object.
 *
 * @param x - a variable to check
 */
function isIterable(x) {
    return x && (typeof x[Symbol.iterator] === 'function');
}
exports.isIterable = isIterable;
/**
 * Gets the primitive value of an object.
 */
function getValue(obj) {
    if (isFunction(obj.valueOf)) {
        return obj.valueOf();
    }
    else {
        return obj;
    }
}
exports.getValue = getValue;
/**
 * UTF-8 encodes the given string.
 *
 * @param input - a string
 */
function utf8Encode(input) {
    var bytes = new Uint8Array(input.length * 4);
    var byteIndex = 0;
    for (var i = 0; i < input.length; i++) {
        var char = input.charCodeAt(i);
        if (char < 128) {
            bytes[byteIndex++] = char;
            continue;
        }
        else if (char < 2048) {
            bytes[byteIndex++] = char >> 6 | 192;
        }
        else {
            if (char > 0xd7ff && char < 0xdc00) {
                if (++i >= input.length) {
                    throw new Error("Incomplete surrogate pair.");
                }
                var c2 = input.charCodeAt(i);
                if (c2 < 0xdc00 || c2 > 0xdfff) {
                    throw new Error("Invalid surrogate character.");
                }
                char = 0x10000 + ((char & 0x03ff) << 10) + (c2 & 0x03ff);
                bytes[byteIndex++] = char >> 18 | 240;
                bytes[byteIndex++] = char >> 12 & 63 | 128;
            }
            else {
                bytes[byteIndex++] = char >> 12 | 224;
            }
            bytes[byteIndex++] = char >> 6 & 63 | 128;
        }
        bytes[byteIndex++] = char & 63 | 128;
    }
    return bytes.subarray(0, byteIndex);
}
exports.utf8Encode = utf8Encode;
/**
 * UTF-8 decodes the given byte sequence into a string.
 *
 * @param bytes - a byte sequence
 */
function utf8Decode(bytes) {
    var result = "";
    var i = 0;
    while (i < bytes.length) {
        var c = bytes[i++];
        if (c > 127) {
            if (c > 191 && c < 224) {
                if (i >= bytes.length) {
                    throw new Error("Incomplete 2-byte sequence.");
                }
                c = (c & 31) << 6 | bytes[i++] & 63;
            }
            else if (c > 223 && c < 240) {
                if (i + 1 >= bytes.length) {
                    throw new Error("Incomplete 3-byte sequence.");
                }
                c = (c & 15) << 12 | (bytes[i++] & 63) << 6 | bytes[i++] & 63;
            }
            else if (c > 239 && c < 248) {
                if (i + 2 >= bytes.length) {
                    throw new Error("Incomplete 4-byte sequence.");
                }
                c = (c & 7) << 18 | (bytes[i++] & 63) << 12 | (bytes[i++] & 63) << 6 | bytes[i++] & 63;
            }
            else {
                throw new Error("Unknown multi-byte start.");
            }
        }
        if (c <= 0xffff) {
            result += String.fromCharCode(c);
        }
        else if (c <= 0x10ffff) {
            c -= 0x10000;
            result += String.fromCharCode(c >> 10 | 0xd800);
            result += String.fromCharCode(c & 0x3FF | 0xdc00);
        }
        else {
            throw new Error("Code point exceeds UTF-16 limit.");
        }
    }
    return result;
}
exports.utf8Decode = utf8Decode;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 1324:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

module.exports =
{
  parallel      : __nccwpck_require__(3857),
  serial        : __nccwpck_require__(1054),
  serialOrdered : __nccwpck_require__(3961)
};


/***/ }),

/***/ 4818:
/***/ ((module) => {

// API
module.exports = abort;

/**
 * Aborts leftover active jobs
 *
 * @param {object} state - current state object
 */
function abort(state)
{
  Object.keys(state.jobs).forEach(clean.bind(state));

  // reset leftover jobs
  state.jobs = {};
}

/**
 * Cleans up leftover job by invoking abort function for the provided job id
 *
 * @this  state
 * @param {string|number} key - job id to abort
 */
function clean(key)
{
  if (typeof this.jobs[key] == 'function')
  {
    this.jobs[key]();
  }
}


/***/ }),

/***/ 8452:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var defer = __nccwpck_require__(9200);

// API
module.exports = async;

/**
 * Runs provided callback asynchronously
 * even if callback itself is not
 *
 * @param   {function} callback - callback to invoke
 * @returns {function} - augmented callback
 */
function async(callback)
{
  var isAsync = false;

  // check if async happened
  defer(function() { isAsync = true; });

  return function async_callback(err, result)
  {
    if (isAsync)
    {
      callback(err, result);
    }
    else
    {
      defer(function nextTick_callback()
      {
        callback(err, result);
      });
    }
  };
}


/***/ }),

/***/ 9200:
/***/ ((module) => {

module.exports = defer;

/**
 * Runs provided function on next iteration of the event loop
 *
 * @param {function} fn - function to run
 */
function defer(fn)
{
  var nextTick = typeof setImmediate == 'function'
    ? setImmediate
    : (
      typeof process == 'object' && typeof process.nextTick == 'function'
      ? process.nextTick
      : null
    );

  if (nextTick)
  {
    nextTick(fn);
  }
  else
  {
    setTimeout(fn, 0);
  }
}


/***/ }),

/***/ 4902:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var async = __nccwpck_require__(8452)
  , abort = __nccwpck_require__(4818)
  ;

// API
module.exports = iterate;

/**
 * Iterates over each job object
 *
 * @param {array|object} list - array or object (named list) to iterate over
 * @param {function} iterator - iterator to run
 * @param {object} state - current job status
 * @param {function} callback - invoked when all elements processed
 */
function iterate(list, iterator, state, callback)
{
  // store current index
  var key = state['keyedList'] ? state['keyedList'][state.index] : state.index;

  state.jobs[key] = runJob(iterator, key, list[key], function(error, output)
  {
    // don't repeat yourself
    // skip secondary callbacks
    if (!(key in state.jobs))
    {
      return;
    }

    // clean up jobs
    delete state.jobs[key];

    if (error)
    {
      // don't process rest of the results
      // stop still active jobs
      // and reset the list
      abort(state);
    }
    else
    {
      state.results[key] = output;
    }

    // return salvaged results
    callback(error, state.results);
  });
}

/**
 * Runs iterator over provided job element
 *
 * @param   {function} iterator - iterator to invoke
 * @param   {string|number} key - key/index of the element in the list of jobs
 * @param   {mixed} item - job description
 * @param   {function} callback - invoked after iterator is done with the job
 * @returns {function|mixed} - job abort function or something else
 */
function runJob(iterator, key, item, callback)
{
  var aborter;

  // allow shortcut if iterator expects only two arguments
  if (iterator.length == 2)
  {
    aborter = iterator(item, async(callback));
  }
  // otherwise go with full three arguments
  else
  {
    aborter = iterator(item, key, async(callback));
  }

  return aborter;
}


/***/ }),

/***/ 1721:
/***/ ((module) => {

// API
module.exports = state;

/**
 * Creates initial state object
 * for iteration over list
 *
 * @param   {array|object} list - list to iterate over
 * @param   {function|null} sortMethod - function to use for keys sort,
 *                                     or `null` to keep them as is
 * @returns {object} - initial state object
 */
function state(list, sortMethod)
{
  var isNamedList = !Array.isArray(list)
    , initState =
    {
      index    : 0,
      keyedList: isNamedList || sortMethod ? Object.keys(list) : null,
      jobs     : {},
      results  : isNamedList ? {} : [],
      size     : isNamedList ? Object.keys(list).length : list.length
    }
    ;

  if (sortMethod)
  {
    // sort array keys based on it's values
    // sort object's keys just on own merit
    initState.keyedList.sort(isNamedList ? sortMethod : function(a, b)
    {
      return sortMethod(list[a], list[b]);
    });
  }

  return initState;
}


/***/ }),

/***/ 3351:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var abort = __nccwpck_require__(4818)
  , async = __nccwpck_require__(8452)
  ;

// API
module.exports = terminator;

/**
 * Terminates jobs in the attached state context
 *
 * @this  AsyncKitState#
 * @param {function} callback - final callback to invoke after termination
 */
function terminator(callback)
{
  if (!Object.keys(this.jobs).length)
  {
    return;
  }

  // fast forward iteration index
  this.index = this.size;

  // abort jobs
  abort(this);

  // send back results we have so far
  async(callback)(null, this.results);
}


/***/ }),

/***/ 3857:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var iterate    = __nccwpck_require__(4902)
  , initState  = __nccwpck_require__(1721)
  , terminator = __nccwpck_require__(3351)
  ;

// Public API
module.exports = parallel;

/**
 * Runs iterator over provided array elements in parallel
 *
 * @param   {array|object} list - array or object (named list) to iterate over
 * @param   {function} iterator - iterator to run
 * @param   {function} callback - invoked when all elements processed
 * @returns {function} - jobs terminator
 */
function parallel(list, iterator, callback)
{
  var state = initState(list);

  while (state.index < (state['keyedList'] || list).length)
  {
    iterate(list, iterator, state, function(error, result)
    {
      if (error)
      {
        callback(error, result);
        return;
      }

      // looks like it's the last one
      if (Object.keys(state.jobs).length === 0)
      {
        callback(null, state.results);
        return;
      }
    });

    state.index++;
  }

  return terminator.bind(state, callback);
}


/***/ }),

/***/ 1054:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var serialOrdered = __nccwpck_require__(3961);

// Public API
module.exports = serial;

/**
 * Runs iterator over provided array elements in series
 *
 * @param   {array|object} list - array or object (named list) to iterate over
 * @param   {function} iterator - iterator to run
 * @param   {function} callback - invoked when all elements processed
 * @returns {function} - jobs terminator
 */
function serial(list, iterator, callback)
{
  return serialOrdered(list, iterator, null, callback);
}


/***/ }),

/***/ 3961:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var iterate    = __nccwpck_require__(4902)
  , initState  = __nccwpck_require__(1721)
  , terminator = __nccwpck_require__(3351)
  ;

// Public API
module.exports = serialOrdered;
// sorting helpers
module.exports.ascending  = ascending;
module.exports.descending = descending;

/**
 * Runs iterator over provided sorted array elements in series
 *
 * @param   {array|object} list - array or object (named list) to iterate over
 * @param   {function} iterator - iterator to run
 * @param   {function} sortMethod - custom sort function
 * @param   {function} callback - invoked when all elements processed
 * @returns {function} - jobs terminator
 */
function serialOrdered(list, iterator, sortMethod, callback)
{
  var state = initState(list, sortMethod);

  iterate(list, iterator, state, function iteratorHandler(error, result)
  {
    if (error)
    {
      callback(error, result);
      return;
    }

    state.index++;

    // are we there yet?
    if (state.index < (state['keyedList'] || list).length)
    {
      iterate(list, iterator, state, iteratorHandler);
      return;
    }

    // done here
    callback(null, state.results);
  });

  return terminator.bind(state, callback);
}

/*
 * -- Sort methods
 */

/**
 * sort helper to sort array elements in ascending order
 *
 * @param   {mixed} a - an item to compare
 * @param   {mixed} b - an item to compare
 * @returns {number} - comparison result
 */
function ascending(a, b)
{
  return a < b ? -1 : a > b ? 1 : 0;
}

/**
 * sort helper to sort array elements in descending order
 *
 * @param   {mixed} a - an item to compare
 * @param   {mixed} b - an item to compare
 * @returns {number} - comparison result
 */
function descending(a, b)
{
  return -1 * ascending(a, b);
}


/***/ }),

/***/ 2639:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {



var bind = __nccwpck_require__(7564);

var $apply = __nccwpck_require__(3945);
var $call = __nccwpck_require__(8093);
var $reflectApply = __nccwpck_require__(1330);

/** @type {import('./actualApply')} */
module.exports = $reflectApply || bind.call($call, $apply);


/***/ }),

/***/ 3945:
/***/ ((module) => {



/** @type {import('./functionApply')} */
module.exports = Function.prototype.apply;


/***/ }),

/***/ 8093:
/***/ ((module) => {



/** @type {import('./functionCall')} */
module.exports = Function.prototype.call;


/***/ }),

/***/ 8705:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {



var bind = __nccwpck_require__(7564);
var $TypeError = __nccwpck_require__(3314);

var $call = __nccwpck_require__(8093);
var $actualApply = __nccwpck_require__(2639);

/** @type {(args: [Function, thisArg?: unknown, ...args: unknown[]]) => Function} TODO FIXME, find a way to use import('.') */
module.exports = function callBindBasic(args) {
	if (args.length < 1 || typeof args[0] !== 'function') {
		throw new $TypeError('a function is required');
	}
	return $actualApply(bind, $call, args);
};


/***/ }),

/***/ 1330:
/***/ ((module) => {



/** @type {import('./reflectApply')} */
module.exports = typeof Reflect !== 'undefined' && Reflect && Reflect.apply;


/***/ }),

/***/ 5630:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var util = __nccwpck_require__(9023);
var Stream = (__nccwpck_require__(2203).Stream);
var DelayedStream = __nccwpck_require__(2710);

module.exports = CombinedStream;
function CombinedStream() {
  this.writable = false;
  this.readable = true;
  this.dataSize = 0;
  this.maxDataSize = 2 * 1024 * 1024;
  this.pauseStreams = true;

  this._released = false;
  this._streams = [];
  this._currentStream = null;
  this._insideLoop = false;
  this._pendingNext = false;
}
util.inherits(CombinedStream, Stream);

CombinedStream.create = function(options) {
  var combinedStream = new this();

  options = options || {};
  for (var option in options) {
    combinedStream[option] = options[option];
  }

  return combinedStream;
};

CombinedStream.isStreamLike = function(stream) {
  return (typeof stream !== 'function')
    && (typeof stream !== 'string')
    && (typeof stream !== 'boolean')
    && (typeof stream !== 'number')
    && (!Buffer.isBuffer(stream));
};

CombinedStream.prototype.append = function(stream) {
  var isStreamLike = CombinedStream.isStreamLike(stream);

  if (isStreamLike) {
    if (!(stream instanceof DelayedStream)) {
      var newStream = DelayedStream.create(stream, {
        maxDataSize: Infinity,
        pauseStream: this.pauseStreams,
      });
      stream.on('data', this._checkDataSize.bind(this));
      stream = newStream;
    }

    this._handleErrors(stream);

    if (this.pauseStreams) {
      stream.pause();
    }
  }

  this._streams.push(stream);
  return this;
};

CombinedStream.prototype.pipe = function(dest, options) {
  Stream.prototype.pipe.call(this, dest, options);
  this.resume();
  return dest;
};

CombinedStream.prototype._getNext = function() {
  this._currentStream = null;

  if (this._insideLoop) {
    this._pendingNext = true;
    return; // defer call
  }

  this._insideLoop = true;
  try {
    do {
      this._pendingNext = false;
      this._realGetNext();
    } while (this._pendingNext);
  } finally {
    this._insideLoop = false;
  }
};

CombinedStream.prototype._realGetNext = function() {
  var stream = this._streams.shift();


  if (typeof stream == 'undefined') {
    this.end();
    return;
  }

  if (typeof stream !== 'function') {
    this._pipeNext(stream);
    return;
  }

  var getStream = stream;
  getStream(function(stream) {
    var isStreamLike = CombinedStream.isStreamLike(stream);
    if (isStreamLike) {
      stream.on('data', this._checkDataSize.bind(this));
      this._handleErrors(stream);
    }

    this._pipeNext(stream);
  }.bind(this));
};

CombinedStream.prototype._pipeNext = function(stream) {
  this._currentStream = stream;

  var isStreamLike = CombinedStream.isStreamLike(stream);
  if (isStreamLike) {
    stream.on('end', this._getNext.bind(this));
    stream.pipe(this, {end: false});
    return;
  }

  var value = stream;
  this.write(value);
  this._getNext();
};

CombinedStream.prototype._handleErrors = function(stream) {
  var self = this;
  stream.on('error', function(err) {
    self._emitError(err);
  });
};

CombinedStream.prototype.write = function(data) {
  this.emit('data', data);
};

CombinedStream.prototype.pause = function() {
  if (!this.pauseStreams) {
    return;
  }

  if(this.pauseStreams && this._currentStream && typeof(this._currentStream.pause) == 'function') this._currentStream.pause();
  this.emit('pause');
};

CombinedStream.prototype.resume = function() {
  if (!this._released) {
    this._released = true;
    this.writable = true;
    this._getNext();
  }

  if(this.pauseStreams && this._currentStream && typeof(this._currentStream.resume) == 'function') this._currentStream.resume();
  this.emit('resume');
};

CombinedStream.prototype.end = function() {
  this._reset();
  this.emit('end');
};

CombinedStream.prototype.destroy = function() {
  this._reset();
  this.emit('close');
};

CombinedStream.prototype._reset = function() {
  this.writable = false;
  this._streams = [];
  this._currentStream = null;
};

CombinedStream.prototype._checkDataSize = function() {
  this._updateDataSize();
  if (this.dataSize <= this.maxDataSize) {
    return;
  }

  var message =
    'DelayedStream#maxDataSize of ' + this.maxDataSize + ' bytes exceeded.';
  this._emitError(new Error(message));
};

CombinedStream.prototype._updateDataSize = function() {
  this.dataSize = 0;

  var self = this;
  this._streams.forEach(function(stream) {
    if (!stream.dataSize) {
      return;
    }

    self.dataSize += stream.dataSize;
  });

  if (this._currentStream && this._currentStream.dataSize) {
    this.dataSize += this._currentStream.dataSize;
  }
};

CombinedStream.prototype._emitError = function(err) {
  this._reset();
  this.emit('error', err);
};


/***/ }),

/***/ 2710:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var Stream = (__nccwpck_require__(2203).Stream);
var util = __nccwpck_require__(9023);

module.exports = DelayedStream;
function DelayedStream() {
  this.source = null;
  this.dataSize = 0;
  this.maxDataSize = 1024 * 1024;
  this.pauseStream = true;

  this._maxDataSizeExceeded = false;
  this._released = false;
  this._bufferedEvents = [];
}
util.inherits(DelayedStream, Stream);

DelayedStream.create = function(source, options) {
  var delayedStream = new this();

  options = options || {};
  for (var option in options) {
    delayedStream[option] = options[option];
  }

  delayedStream.source = source;

  var realEmit = source.emit;
  source.emit = function() {
    delayedStream._handleEmit(arguments);
    return realEmit.apply(source, arguments);
  };

  source.on('error', function() {});
  if (delayedStream.pauseStream) {
    source.pause();
  }

  return delayedStream;
};

Object.defineProperty(DelayedStream.prototype, 'readable', {
  configurable: true,
  enumerable: true,
  get: function() {
    return this.source.readable;
  }
});

DelayedStream.prototype.setEncoding = function() {
  return this.source.setEncoding.apply(this.source, arguments);
};

DelayedStream.prototype.resume = function() {
  if (!this._released) {
    this.release();
  }

  this.source.resume();
};

DelayedStream.prototype.pause = function() {
  this.source.pause();
};

DelayedStream.prototype.release = function() {
  this._released = true;

  this._bufferedEvents.forEach(function(args) {
    this.emit.apply(this, args);
  }.bind(this));
  this._bufferedEvents = [];
};

DelayedStream.prototype.pipe = function() {
  var r = Stream.prototype.pipe.apply(this, arguments);
  this.resume();
  return r;
};

DelayedStream.prototype._handleEmit = function(args) {
  if (this._released) {
    this.emit.apply(this, args);
    return;
  }

  if (args[0] === 'data') {
    this.dataSize += args[1].length;
    this._checkIfMaxDataSizeExceeded();
  }

  this._bufferedEvents.push(args);
};

DelayedStream.prototype._checkIfMaxDataSizeExceeded = function() {
  if (this._maxDataSizeExceeded) {
    return;
  }

  if (this.dataSize <= this.maxDataSize) {
    return;
  }

  this._maxDataSizeExceeded = true;
  var message =
    'DelayedStream#maxDataSize of ' + this.maxDataSize + ' bytes exceeded.'
  this.emit('error', new Error(message));
};


/***/ }),

/***/ 8889:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

const fs = __nccwpck_require__(9896)
const path = __nccwpck_require__(6928)
const os = __nccwpck_require__(857)
const crypto = __nccwpck_require__(6982)
const packageJson = __nccwpck_require__(56)

const version = packageJson.version

const LINE = /(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/mg

// Parse src into an Object
function parse (src) {
  const obj = {}

  // Convert buffer to string
  let lines = src.toString()

  // Convert line breaks to same format
  lines = lines.replace(/\r\n?/mg, '\n')

  let match
  while ((match = LINE.exec(lines)) != null) {
    const key = match[1]

    // Default undefined or null to empty string
    let value = (match[2] || '')

    // Remove whitespace
    value = value.trim()

    // Check if double quoted
    const maybeQuote = value[0]

    // Remove surrounding quotes
    value = value.replace(/^(['"`])([\s\S]*)\1$/mg, '$2')

    // Expand newlines if double quoted
    if (maybeQuote === '"') {
      value = value.replace(/\\n/g, '\n')
      value = value.replace(/\\r/g, '\r')
    }

    // Add to object
    obj[key] = value
  }

  return obj
}

function _parseVault (options) {
  const vaultPath = _vaultPath(options)

  // Parse .env.vault
  const result = DotenvModule.configDotenv({ path: vaultPath })
  if (!result.parsed) {
    const err = new Error(`MISSING_DATA: Cannot parse ${vaultPath} for an unknown reason`)
    err.code = 'MISSING_DATA'
    throw err
  }

  // handle scenario for comma separated keys - for use with key rotation
  // example: DOTENV_KEY="dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=prod,dotenv://:key_7890@dotenvx.com/vault/.env.vault?environment=prod"
  const keys = _dotenvKey(options).split(',')
  const length = keys.length

  let decrypted
  for (let i = 0; i < length; i++) {
    try {
      // Get full key
      const key = keys[i].trim()

      // Get instructions for decrypt
      const attrs = _instructions(result, key)

      // Decrypt
      decrypted = DotenvModule.decrypt(attrs.ciphertext, attrs.key)

      break
    } catch (error) {
      // last key
      if (i + 1 >= length) {
        throw error
      }
      // try next key
    }
  }

  // Parse decrypted .env string
  return DotenvModule.parse(decrypted)
}

function _log (message) {
  console.log(`[dotenv@${version}][INFO] ${message}`)
}

function _warn (message) {
  console.log(`[dotenv@${version}][WARN] ${message}`)
}

function _debug (message) {
  console.log(`[dotenv@${version}][DEBUG] ${message}`)
}

function _dotenvKey (options) {
  // prioritize developer directly setting options.DOTENV_KEY
  if (options && options.DOTENV_KEY && options.DOTENV_KEY.length > 0) {
    return options.DOTENV_KEY
  }

  // secondary infra already contains a DOTENV_KEY environment variable
  if (process.env.DOTENV_KEY && process.env.DOTENV_KEY.length > 0) {
    return process.env.DOTENV_KEY
  }

  // fallback to empty string
  return ''
}

function _instructions (result, dotenvKey) {
  // Parse DOTENV_KEY. Format is a URI
  let uri
  try {
    uri = new URL(dotenvKey)
  } catch (error) {
    if (error.code === 'ERR_INVALID_URL') {
      const err = new Error('INVALID_DOTENV_KEY: Wrong format. Must be in valid uri format like dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=development')
      err.code = 'INVALID_DOTENV_KEY'
      throw err
    }

    throw error
  }

  // Get decrypt key
  const key = uri.password
  if (!key) {
    const err = new Error('INVALID_DOTENV_KEY: Missing key part')
    err.code = 'INVALID_DOTENV_KEY'
    throw err
  }

  // Get environment
  const environment = uri.searchParams.get('environment')
  if (!environment) {
    const err = new Error('INVALID_DOTENV_KEY: Missing environment part')
    err.code = 'INVALID_DOTENV_KEY'
    throw err
  }

  // Get ciphertext payload
  const environmentKey = `DOTENV_VAULT_${environment.toUpperCase()}`
  const ciphertext = result.parsed[environmentKey] // DOTENV_VAULT_PRODUCTION
  if (!ciphertext) {
    const err = new Error(`NOT_FOUND_DOTENV_ENVIRONMENT: Cannot locate environment ${environmentKey} in your .env.vault file.`)
    err.code = 'NOT_FOUND_DOTENV_ENVIRONMENT'
    throw err
  }

  return { ciphertext, key }
}

function _vaultPath (options) {
  let possibleVaultPath = null

  if (options && options.path && options.path.length > 0) {
    if (Array.isArray(options.path)) {
      for (const filepath of options.path) {
        if (fs.existsSync(filepath)) {
          possibleVaultPath = filepath.endsWith('.vault') ? filepath : `${filepath}.vault`
        }
      }
    } else {
      possibleVaultPath = options.path.endsWith('.vault') ? options.path : `${options.path}.vault`
    }
  } else {
    possibleVaultPath = path.resolve(process.cwd(), '.env.vault')
  }

  if (fs.existsSync(possibleVaultPath)) {
    return possibleVaultPath
  }

  return null
}

function _resolveHome (envPath) {
  return envPath[0] === '~' ? path.join(os.homedir(), envPath.slice(1)) : envPath
}

function _configVault (options) {
  _log('Loading env from encrypted .env.vault')

  const parsed = DotenvModule._parseVault(options)

  let processEnv = process.env
  if (options && options.processEnv != null) {
    processEnv = options.processEnv
  }

  DotenvModule.populate(processEnv, parsed, options)

  return { parsed }
}

function configDotenv (options) {
  const dotenvPath = path.resolve(process.cwd(), '.env')
  let encoding = 'utf8'
  const debug = Boolean(options && options.debug)

  if (options && options.encoding) {
    encoding = options.encoding
  } else {
    if (debug) {
      _debug('No encoding is specified. UTF-8 is used by default')
    }
  }

  let optionPaths = [dotenvPath] // default, look for .env
  if (options && options.path) {
    if (!Array.isArray(options.path)) {
      optionPaths = [_resolveHome(options.path)]
    } else {
      optionPaths = [] // reset default
      for (const filepath of options.path) {
        optionPaths.push(_resolveHome(filepath))
      }
    }
  }

  // Build the parsed data in a temporary object (because we need to return it).  Once we have the final
  // parsed data, we will combine it with process.env (or options.processEnv if provided).
  let lastError
  const parsedAll = {}
  for (const path of optionPaths) {
    try {
      // Specifying an encoding returns a string instead of a buffer
      const parsed = DotenvModule.parse(fs.readFileSync(path, { encoding }))

      DotenvModule.populate(parsedAll, parsed, options)
    } catch (e) {
      if (debug) {
        _debug(`Failed to load ${path} ${e.message}`)
      }
      lastError = e
    }
  }

  let processEnv = process.env
  if (options && options.processEnv != null) {
    processEnv = options.processEnv
  }

  DotenvModule.populate(processEnv, parsedAll, options)

  if (lastError) {
    return { parsed: parsedAll, error: lastError }
  } else {
    return { parsed: parsedAll }
  }
}

// Populates process.env from .env file
function config (options) {
  // fallback to original dotenv if DOTENV_KEY is not set
  if (_dotenvKey(options).length === 0) {
    return DotenvModule.configDotenv(options)
  }

  const vaultPath = _vaultPath(options)

  // dotenvKey exists but .env.vault file does not exist
  if (!vaultPath) {
    _warn(`You set DOTENV_KEY but you are missing a .env.vault file at ${vaultPath}. Did you forget to build it?`)

    return DotenvModule.configDotenv(options)
  }

  return DotenvModule._configVault(options)
}

function decrypt (encrypted, keyStr) {
  const key = Buffer.from(keyStr.slice(-64), 'hex')
  let ciphertext = Buffer.from(encrypted, 'base64')

  const nonce = ciphertext.subarray(0, 12)
  const authTag = ciphertext.subarray(-16)
  ciphertext = ciphertext.subarray(12, -16)

  try {
    const aesgcm = crypto.createDecipheriv('aes-256-gcm', key, nonce)
    aesgcm.setAuthTag(authTag)
    return `${aesgcm.update(ciphertext)}${aesgcm.final()}`
  } catch (error) {
    const isRange = error instanceof RangeError
    const invalidKeyLength = error.message === 'Invalid key length'
    const decryptionFailed = error.message === 'Unsupported state or unable to authenticate data'

    if (isRange || invalidKeyLength) {
      const err = new Error('INVALID_DOTENV_KEY: It must be 64 characters long (or more)')
      err.code = 'INVALID_DOTENV_KEY'
      throw err
    } else if (decryptionFailed) {
      const err = new Error('DECRYPTION_FAILED: Please check your DOTENV_KEY')
      err.code = 'DECRYPTION_FAILED'
      throw err
    } else {
      throw error
    }
  }
}

// Populate process.env with parsed values
function populate (processEnv, parsed, options = {}) {
  const debug = Boolean(options && options.debug)
  const override = Boolean(options && options.override)

  if (typeof parsed !== 'object') {
    const err = new Error('OBJECT_REQUIRED: Please check the processEnv argument being passed to populate')
    err.code = 'OBJECT_REQUIRED'
    throw err
  }

  // Set process.env
  for (const key of Object.keys(parsed)) {
    if (Object.prototype.hasOwnProperty.call(processEnv, key)) {
      if (override === true) {
        processEnv[key] = parsed[key]
      }

      if (debug) {
        if (override === true) {
          _debug(`"${key}" is already defined and WAS overwritten`)
        } else {
          _debug(`"${key}" is already defined and was NOT overwritten`)
        }
      }
    } else {
      processEnv[key] = parsed[key]
    }
  }
}

const DotenvModule = {
  configDotenv,
  _configVault,
  _parseVault,
  config,
  decrypt,
  parse,
  populate
}

module.exports.configDotenv = DotenvModule.configDotenv
module.exports._configVault = DotenvModule._configVault
module.exports._parseVault = DotenvModule._parseVault
module.exports.config = DotenvModule.config
module.exports.decrypt = DotenvModule.decrypt
module.exports.parse = DotenvModule.parse
module.exports.populate = DotenvModule.populate

module.exports = DotenvModule


/***/ }),

/***/ 6669:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {



var callBind = __nccwpck_require__(8705);
var gOPD = __nccwpck_require__(3170);

var hasProtoAccessor;
try {
	// eslint-disable-next-line no-extra-parens, no-proto
	hasProtoAccessor = /** @type {{ __proto__?: typeof Array.prototype }} */ ([]).__proto__ === Array.prototype;
} catch (e) {
	if (!e || typeof e !== 'object' || !('code' in e) || e.code !== 'ERR_PROTO_ACCESS') {
		throw e;
	}
}

// eslint-disable-next-line no-extra-parens
var desc = !!hasProtoAccessor && gOPD && gOPD(Object.prototype, /** @type {keyof typeof Object.prototype} */ ('__proto__'));

var $Object = Object;
var $getPrototypeOf = $Object.getPrototypeOf;

/** @type {import('./get')} */
module.exports = desc && typeof desc.get === 'function'
	? callBind([desc.get])
	: typeof $getPrototypeOf === 'function'
		? /** @type {import('./get')} */ function getDunder(value) {
			// eslint-disable-next-line eqeqeq
			return $getPrototypeOf(value == null ? value : $Object(value));
		}
		: false;


/***/ }),

/***/ 9094:
/***/ ((module) => {



/** @type {import('.')} */
var $defineProperty = Object.defineProperty || false;
if ($defineProperty) {
	try {
		$defineProperty({}, 'a', { value: 1 });
	} catch (e) {
		// IE 8 has a broken defineProperty
		$defineProperty = false;
	}
}

module.exports = $defineProperty;


/***/ }),

/***/ 3056:
/***/ ((module) => {



/** @type {import('./eval')} */
module.exports = EvalError;


/***/ }),

/***/ 1620:
/***/ ((module) => {



/** @type {import('.')} */
module.exports = Error;


/***/ }),

/***/ 4585:
/***/ ((module) => {



/** @type {import('./range')} */
module.exports = RangeError;


/***/ }),

/***/ 6905:
/***/ ((module) => {



/** @type {import('./ref')} */
module.exports = ReferenceError;


/***/ }),

/***/ 105:
/***/ ((module) => {



/** @type {import('./syntax')} */
module.exports = SyntaxError;


/***/ }),

/***/ 3314:
/***/ ((module) => {



/** @type {import('./type')} */
module.exports = TypeError;


/***/ }),

/***/ 2578:
/***/ ((module) => {



/** @type {import('./uri')} */
module.exports = URIError;


/***/ }),

/***/ 5399:
/***/ ((module) => {



/** @type {import('.')} */
module.exports = Object;


/***/ }),

/***/ 8700:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {



var GetIntrinsic = __nccwpck_require__(470);

var $defineProperty = GetIntrinsic('%Object.defineProperty%', true);

var hasToStringTag = __nccwpck_require__(5479)();
var hasOwn = __nccwpck_require__(4076);
var $TypeError = __nccwpck_require__(3314);

var toStringTag = hasToStringTag ? Symbol.toStringTag : null;

/** @type {import('.')} */
module.exports = function setToStringTag(object, value) {
	var overrideIfSet = arguments.length > 2 && !!arguments[2] && arguments[2].force;
	var nonConfigurable = arguments.length > 2 && !!arguments[2] && arguments[2].nonConfigurable;
	if (
		(typeof overrideIfSet !== 'undefined' && typeof overrideIfSet !== 'boolean')
		|| (typeof nonConfigurable !== 'undefined' && typeof nonConfigurable !== 'boolean')
	) {
		throw new $TypeError('if provided, the `overrideIfSet` and `nonConfigurable` options must be booleans');
	}
	if (toStringTag && (overrideIfSet || !hasOwn(object, toStringTag))) {
		if ($defineProperty) {
			$defineProperty(object, toStringTag, {
				configurable: !nonConfigurable,
				enumerable: false,
				value: value,
				writable: false
			});
		} else {
			object[toStringTag] = value; // eslint-disable-line no-param-reassign
		}
	}
};


/***/ }),

/***/ 6454:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var CombinedStream = __nccwpck_require__(5630);
var util = __nccwpck_require__(9023);
var path = __nccwpck_require__(6928);
var http = __nccwpck_require__(8611);
var https = __nccwpck_require__(5692);
var parseUrl = (__nccwpck_require__(7016).parse);
var fs = __nccwpck_require__(9896);
var Stream = (__nccwpck_require__(2203).Stream);
var mime = __nccwpck_require__(4096);
var asynckit = __nccwpck_require__(1324);
var setToStringTag = __nccwpck_require__(8700);
var populate = __nccwpck_require__(1835);

// Public API
module.exports = FormData;

// make it a Stream
util.inherits(FormData, CombinedStream);

/**
 * Create readable "multipart/form-data" streams.
 * Can be used to submit forms
 * and file uploads to other web applications.
 *
 * @constructor
 * @param {Object} options - Properties to be added/overriden for FormData and CombinedStream
 */
function FormData(options) {
  if (!(this instanceof FormData)) {
    return new FormData(options);
  }

  this._overheadLength = 0;
  this._valueLength = 0;
  this._valuesToMeasure = [];

  CombinedStream.call(this);

  options = options || {};
  for (var option in options) {
    this[option] = options[option];
  }
}

FormData.LINE_BREAK = '\r\n';
FormData.DEFAULT_CONTENT_TYPE = 'application/octet-stream';

FormData.prototype.append = function(field, value, options) {

  options = options || {};

  // allow filename as single option
  if (typeof options == 'string') {
    options = {filename: options};
  }

  var append = CombinedStream.prototype.append.bind(this);

  // all that streamy business can't handle numbers
  if (typeof value == 'number') {
    value = '' + value;
  }

  // https://github.com/felixge/node-form-data/issues/38
  if (Array.isArray(value)) {
    // Please convert your array into string
    // the way web server expects it
    this._error(new Error('Arrays are not supported.'));
    return;
  }

  var header = this._multiPartHeader(field, value, options);
  var footer = this._multiPartFooter();

  append(header);
  append(value);
  append(footer);

  // pass along options.knownLength
  this._trackLength(header, value, options);
};

FormData.prototype._trackLength = function(header, value, options) {
  var valueLength = 0;

  // used w/ getLengthSync(), when length is known.
  // e.g. for streaming directly from a remote server,
  // w/ a known file a size, and not wanting to wait for
  // incoming file to finish to get its size.
  if (options.knownLength != null) {
    valueLength += +options.knownLength;
  } else if (Buffer.isBuffer(value)) {
    valueLength = value.length;
  } else if (typeof value === 'string') {
    valueLength = Buffer.byteLength(value);
  }

  this._valueLength += valueLength;

  // @check why add CRLF? does this account for custom/multiple CRLFs?
  this._overheadLength +=
    Buffer.byteLength(header) +
    FormData.LINE_BREAK.length;

  // empty or either doesn't have path or not an http response or not a stream
  if (!value || ( !value.path && !(value.readable && Object.prototype.hasOwnProperty.call(value, 'httpVersion')) && !(value instanceof Stream))) {
    return;
  }

  // no need to bother with the length
  if (!options.knownLength) {
    this._valuesToMeasure.push(value);
  }
};

FormData.prototype._lengthRetriever = function(value, callback) {
  if (Object.prototype.hasOwnProperty.call(value, 'fd')) {

    // take read range into a account
    // `end` = Infinity –> read file till the end
    //
    // TODO: Looks like there is bug in Node fs.createReadStream
    // it doesn't respect `end` options without `start` options
    // Fix it when node fixes it.
    // https://github.com/joyent/node/issues/7819
    if (value.end != undefined && value.end != Infinity && value.start != undefined) {

      // when end specified
      // no need to calculate range
      // inclusive, starts with 0
      callback(null, value.end + 1 - (value.start ? value.start : 0));

    // not that fast snoopy
    } else {
      // still need to fetch file size from fs
      fs.stat(value.path, function(err, stat) {

        var fileSize;

        if (err) {
          callback(err);
          return;
        }

        // update final size based on the range options
        fileSize = stat.size - (value.start ? value.start : 0);
        callback(null, fileSize);
      });
    }

  // or http response
  } else if (Object.prototype.hasOwnProperty.call(value, 'httpVersion')) {
    callback(null, +value.headers['content-length']);

  // or request stream http://github.com/mikeal/request
  } else if (Object.prototype.hasOwnProperty.call(value, 'httpModule')) {
    // wait till response come back
    value.on('response', function(response) {
      value.pause();
      callback(null, +response.headers['content-length']);
    });
    value.resume();

  // something else
  } else {
    callback('Unknown stream');
  }
};

FormData.prototype._multiPartHeader = function(field, value, options) {
  // custom header specified (as string)?
  // it becomes responsible for boundary
  // (e.g. to handle extra CRLFs on .NET servers)
  if (typeof options.header == 'string') {
    return options.header;
  }

  var contentDisposition = this._getContentDisposition(value, options);
  var contentType = this._getContentType(value, options);

  var contents = '';
  var headers  = {
    // add custom disposition as third element or keep it two elements if not
    'Content-Disposition': ['form-data', 'name="' + field + '"'].concat(contentDisposition || []),
    // if no content type. allow it to be empty array
    'Content-Type': [].concat(contentType || [])
  };

  // allow custom headers.
  if (typeof options.header == 'object') {
    populate(headers, options.header);
  }

  var header;
  for (var prop in headers) {
    if (Object.prototype.hasOwnProperty.call(headers, prop)) {
      header = headers[prop];

      // skip nullish headers.
      if (header == null) {
        continue;
      }

      // convert all headers to arrays.
      if (!Array.isArray(header)) {
        header = [header];
      }

      // add non-empty headers.
      if (header.length) {
        contents += prop + ': ' + header.join('; ') + FormData.LINE_BREAK;
      }
    }
  }

  return '--' + this.getBoundary() + FormData.LINE_BREAK + contents + FormData.LINE_BREAK;
};

FormData.prototype._getContentDisposition = function(value, options) {

  var filename
    , contentDisposition
    ;

  if (typeof options.filepath === 'string') {
    // custom filepath for relative paths
    filename = path.normalize(options.filepath).replace(/\\/g, '/');
  } else if (options.filename || value.name || value.path) {
    // custom filename take precedence
    // formidable and the browser add a name property
    // fs- and request- streams have path property
    filename = path.basename(options.filename || value.name || value.path);
  } else if (value.readable && Object.prototype.hasOwnProperty.call(value, 'httpVersion')) {
    // or try http response
    filename = path.basename(value.client._httpMessage.path || '');
  }

  if (filename) {
    contentDisposition = 'filename="' + filename + '"';
  }

  return contentDisposition;
};

FormData.prototype._getContentType = function(value, options) {

  // use custom content-type above all
  var contentType = options.contentType;

  // or try `name` from formidable, browser
  if (!contentType && value.name) {
    contentType = mime.lookup(value.name);
  }

  // or try `path` from fs-, request- streams
  if (!contentType && value.path) {
    contentType = mime.lookup(value.path);
  }

  // or if it's http-reponse
  if (!contentType && value.readable && Object.prototype.hasOwnProperty.call(value, 'httpVersion')) {
    contentType = value.headers['content-type'];
  }

  // or guess it from the filepath or filename
  if (!contentType && (options.filepath || options.filename)) {
    contentType = mime.lookup(options.filepath || options.filename);
  }

  // fallback to the default content type if `value` is not simple value
  if (!contentType && typeof value == 'object') {
    contentType = FormData.DEFAULT_CONTENT_TYPE;
  }

  return contentType;
};

FormData.prototype._multiPartFooter = function() {
  return function(next) {
    var footer = FormData.LINE_BREAK;

    var lastPart = (this._streams.length === 0);
    if (lastPart) {
      footer += this._lastBoundary();
    }

    next(footer);
  }.bind(this);
};

FormData.prototype._lastBoundary = function() {
  return '--' + this.getBoundary() + '--' + FormData.LINE_BREAK;
};

FormData.prototype.getHeaders = function(userHeaders) {
  var header;
  var formHeaders = {
    'content-type': 'multipart/form-data; boundary=' + this.getBoundary()
  };

  for (header in userHeaders) {
    if (Object.prototype.hasOwnProperty.call(userHeaders, header)) {
      formHeaders[header.toLowerCase()] = userHeaders[header];
    }
  }

  return formHeaders;
};

FormData.prototype.setBoundary = function(boundary) {
  this._boundary = boundary;
};

FormData.prototype.getBoundary = function() {
  if (!this._boundary) {
    this._generateBoundary();
  }

  return this._boundary;
};

FormData.prototype.getBuffer = function() {
  var dataBuffer = new Buffer.alloc(0);
  var boundary = this.getBoundary();

  // Create the form content. Add Line breaks to the end of data.
  for (var i = 0, len = this._streams.length; i < len; i++) {
    if (typeof this._streams[i] !== 'function') {

      // Add content to the buffer.
      if(Buffer.isBuffer(this._streams[i])) {
        dataBuffer = Buffer.concat( [dataBuffer, this._streams[i]]);
      }else {
        dataBuffer = Buffer.concat( [dataBuffer, Buffer.from(this._streams[i])]);
      }

      // Add break after content.
      if (typeof this._streams[i] !== 'string' || this._streams[i].substring( 2, boundary.length + 2 ) !== boundary) {
        dataBuffer = Buffer.concat( [dataBuffer, Buffer.from(FormData.LINE_BREAK)] );
      }
    }
  }

  // Add the footer and return the Buffer object.
  return Buffer.concat( [dataBuffer, Buffer.from(this._lastBoundary())] );
};

FormData.prototype._generateBoundary = function() {
  // This generates a 50 character boundary similar to those used by Firefox.
  // They are optimized for boyer-moore parsing.
  var boundary = '--------------------------';
  for (var i = 0; i < 24; i++) {
    boundary += Math.floor(Math.random() * 10).toString(16);
  }

  this._boundary = boundary;
};

// Note: getLengthSync DOESN'T calculate streams length
// As workaround one can calculate file size manually
// and add it as knownLength option
FormData.prototype.getLengthSync = function() {
  var knownLength = this._overheadLength + this._valueLength;

  // Don't get confused, there are 3 "internal" streams for each keyval pair
  // so it basically checks if there is any value added to the form
  if (this._streams.length) {
    knownLength += this._lastBoundary().length;
  }

  // https://github.com/form-data/form-data/issues/40
  if (!this.hasKnownLength()) {
    // Some async length retrievers are present
    // therefore synchronous length calculation is false.
    // Please use getLength(callback) to get proper length
    this._error(new Error('Cannot calculate proper length in synchronous way.'));
  }

  return knownLength;
};

// Public API to check if length of added values is known
// https://github.com/form-data/form-data/issues/196
// https://github.com/form-data/form-data/issues/262
FormData.prototype.hasKnownLength = function() {
  var hasKnownLength = true;

  if (this._valuesToMeasure.length) {
    hasKnownLength = false;
  }

  return hasKnownLength;
};

FormData.prototype.getLength = function(cb) {
  var knownLength = this._overheadLength + this._valueLength;

  if (this._streams.length) {
    knownLength += this._lastBoundary().length;
  }

  if (!this._valuesToMeasure.length) {
    process.nextTick(cb.bind(this, null, knownLength));
    return;
  }

  asynckit.parallel(this._valuesToMeasure, this._lengthRetriever, function(err, values) {
    if (err) {
      cb(err);
      return;
    }

    values.forEach(function(length) {
      knownLength += length;
    });

    cb(null, knownLength);
  });
};

FormData.prototype.submit = function(params, cb) {
  var request
    , options
    , defaults = {method: 'post'}
    ;

  // parse provided url if it's string
  // or treat it as options object
  if (typeof params == 'string') {

    params = parseUrl(params);
    options = populate({
      port: params.port,
      path: params.pathname,
      host: params.hostname,
      protocol: params.protocol
    }, defaults);

  // use custom params
  } else {

    options = populate(params, defaults);
    // if no port provided use default one
    if (!options.port) {
      options.port = options.protocol == 'https:' ? 443 : 80;
    }
  }

  // put that good code in getHeaders to some use
  options.headers = this.getHeaders(params.headers);

  // https if specified, fallback to http in any other case
  if (options.protocol == 'https:') {
    request = https.request(options);
  } else {
    request = http.request(options);
  }

  // get content length and fire away
  this.getLength(function(err, length) {
    if (err && err !== 'Unknown stream') {
      this._error(err);
      return;
    }

    // add content length
    if (length) {
      request.setHeader('Content-Length', length);
    }

    this.pipe(request);
    if (cb) {
      var onResponse;

      var callback = function (error, responce) {
        request.removeListener('error', callback);
        request.removeListener('response', onResponse);

        return cb.call(this, error, responce);
      };

      onResponse = callback.bind(this, null);

      request.on('error', callback);
      request.on('response', onResponse);
    }
  }.bind(this));

  return request;
};

FormData.prototype._error = function(err) {
  if (!this.error) {
    this.error = err;
    this.pause();
    this.emit('error', err);
  }
};

FormData.prototype.toString = function () {
  return '[object FormData]';
};
setToStringTag(FormData, 'FormData');


/***/ }),

/***/ 1835:
/***/ ((module) => {

// populates missing values
module.exports = function(dst, src) {

  Object.keys(src).forEach(function(prop)
  {
    dst[prop] = dst[prop] || src[prop];
  });

  return dst;
};


/***/ }),

/***/ 9808:
/***/ ((module) => {



/* eslint no-invalid-this: 1 */

var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
var toStr = Object.prototype.toString;
var max = Math.max;
var funcType = '[object Function]';

var concatty = function concatty(a, b) {
    var arr = [];

    for (var i = 0; i < a.length; i += 1) {
        arr[i] = a[i];
    }
    for (var j = 0; j < b.length; j += 1) {
        arr[j + a.length] = b[j];
    }

    return arr;
};

var slicy = function slicy(arrLike, offset) {
    var arr = [];
    for (var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1) {
        arr[j] = arrLike[i];
    }
    return arr;
};

var joiny = function (arr, joiner) {
    var str = '';
    for (var i = 0; i < arr.length; i += 1) {
        str += arr[i];
        if (i + 1 < arr.length) {
            str += joiner;
        }
    }
    return str;
};

module.exports = function bind(that) {
    var target = this;
    if (typeof target !== 'function' || toStr.apply(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slicy(arguments, 1);

    var bound;
    var binder = function () {
        if (this instanceof bound) {
            var result = target.apply(
                this,
                concatty(args, arguments)
            );
            if (Object(result) === result) {
                return result;
            }
            return this;
        }
        return target.apply(
            that,
            concatty(args, arguments)
        );

    };

    var boundLength = max(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0; i < boundLength; i++) {
        boundArgs[i] = '$' + i;
    }

    bound = Function('binder', 'return function (' + joiny(boundArgs, ',') + '){ return binder.apply(this,arguments); }')(binder);

    if (target.prototype) {
        var Empty = function Empty() {};
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
    }

    return bound;
};


/***/ }),

/***/ 7564:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {



var implementation = __nccwpck_require__(9808);

module.exports = Function.prototype.bind || implementation;


/***/ }),

/***/ 470:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {



var undefined;

var $Object = __nccwpck_require__(5399);

var $Error = __nccwpck_require__(1620);
var $EvalError = __nccwpck_require__(3056);
var $RangeError = __nccwpck_require__(4585);
var $ReferenceError = __nccwpck_require__(6905);
var $SyntaxError = __nccwpck_require__(105);
var $TypeError = __nccwpck_require__(3314);
var $URIError = __nccwpck_require__(2578);

var abs = __nccwpck_require__(5641);
var floor = __nccwpck_require__(6171);
var max = __nccwpck_require__(7147);
var min = __nccwpck_require__(1017);
var pow = __nccwpck_require__(6947);
var round = __nccwpck_require__(2621);
var sign = __nccwpck_require__(156);

var $Function = Function;

// eslint-disable-next-line consistent-return
var getEvalledConstructor = function (expressionSyntax) {
	try {
		return $Function('"use strict"; return (' + expressionSyntax + ').constructor;')();
	} catch (e) {}
};

var $gOPD = __nccwpck_require__(3170);
var $defineProperty = __nccwpck_require__(9094);

var throwTypeError = function () {
	throw new $TypeError();
};
var ThrowTypeError = $gOPD
	? (function () {
		try {
			// eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
			arguments.callee; // IE 8 does not throw here
			return throwTypeError;
		} catch (calleeThrows) {
			try {
				// IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
				return $gOPD(arguments, 'callee').get;
			} catch (gOPDthrows) {
				return throwTypeError;
			}
		}
	}())
	: throwTypeError;

var hasSymbols = __nccwpck_require__(3336)();

var getProto = __nccwpck_require__(1967);
var $ObjectGPO = __nccwpck_require__(1311);
var $ReflectGPO = __nccwpck_require__(8681);

var $apply = __nccwpck_require__(3945);
var $call = __nccwpck_require__(8093);

var needsEval = {};

var TypedArray = typeof Uint8Array === 'undefined' || !getProto ? undefined : getProto(Uint8Array);

var INTRINSICS = {
	__proto__: null,
	'%AggregateError%': typeof AggregateError === 'undefined' ? undefined : AggregateError,
	'%Array%': Array,
	'%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,
	'%ArrayIteratorPrototype%': hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined,
	'%AsyncFromSyncIteratorPrototype%': undefined,
	'%AsyncFunction%': needsEval,
	'%AsyncGenerator%': needsEval,
	'%AsyncGeneratorFunction%': needsEval,
	'%AsyncIteratorPrototype%': needsEval,
	'%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,
	'%BigInt%': typeof BigInt === 'undefined' ? undefined : BigInt,
	'%BigInt64Array%': typeof BigInt64Array === 'undefined' ? undefined : BigInt64Array,
	'%BigUint64Array%': typeof BigUint64Array === 'undefined' ? undefined : BigUint64Array,
	'%Boolean%': Boolean,
	'%DataView%': typeof DataView === 'undefined' ? undefined : DataView,
	'%Date%': Date,
	'%decodeURI%': decodeURI,
	'%decodeURIComponent%': decodeURIComponent,
	'%encodeURI%': encodeURI,
	'%encodeURIComponent%': encodeURIComponent,
	'%Error%': $Error,
	'%eval%': eval, // eslint-disable-line no-eval
	'%EvalError%': $EvalError,
	'%Float16Array%': typeof Float16Array === 'undefined' ? undefined : Float16Array,
	'%Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,
	'%Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,
	'%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined : FinalizationRegistry,
	'%Function%': $Function,
	'%GeneratorFunction%': needsEval,
	'%Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,
	'%Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,
	'%Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,
	'%isFinite%': isFinite,
	'%isNaN%': isNaN,
	'%IteratorPrototype%': hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined,
	'%JSON%': typeof JSON === 'object' ? JSON : undefined,
	'%Map%': typeof Map === 'undefined' ? undefined : Map,
	'%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Map()[Symbol.iterator]()),
	'%Math%': Math,
	'%Number%': Number,
	'%Object%': $Object,
	'%Object.getOwnPropertyDescriptor%': $gOPD,
	'%parseFloat%': parseFloat,
	'%parseInt%': parseInt,
	'%Promise%': typeof Promise === 'undefined' ? undefined : Promise,
	'%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,
	'%RangeError%': $RangeError,
	'%ReferenceError%': $ReferenceError,
	'%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,
	'%RegExp%': RegExp,
	'%Set%': typeof Set === 'undefined' ? undefined : Set,
	'%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Set()[Symbol.iterator]()),
	'%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,
	'%String%': String,
	'%StringIteratorPrototype%': hasSymbols && getProto ? getProto(''[Symbol.iterator]()) : undefined,
	'%Symbol%': hasSymbols ? Symbol : undefined,
	'%SyntaxError%': $SyntaxError,
	'%ThrowTypeError%': ThrowTypeError,
	'%TypedArray%': TypedArray,
	'%TypeError%': $TypeError,
	'%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,
	'%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,
	'%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,
	'%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,
	'%URIError%': $URIError,
	'%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,
	'%WeakRef%': typeof WeakRef === 'undefined' ? undefined : WeakRef,
	'%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet,

	'%Function.prototype.call%': $call,
	'%Function.prototype.apply%': $apply,
	'%Object.defineProperty%': $defineProperty,
	'%Object.getPrototypeOf%': $ObjectGPO,
	'%Math.abs%': abs,
	'%Math.floor%': floor,
	'%Math.max%': max,
	'%Math.min%': min,
	'%Math.pow%': pow,
	'%Math.round%': round,
	'%Math.sign%': sign,
	'%Reflect.getPrototypeOf%': $ReflectGPO
};

if (getProto) {
	try {
		null.error; // eslint-disable-line no-unused-expressions
	} catch (e) {
		// https://github.com/tc39/proposal-shadowrealm/pull/384#issuecomment-1364264229
		var errorProto = getProto(getProto(e));
		INTRINSICS['%Error.prototype%'] = errorProto;
	}
}

var doEval = function doEval(name) {
	var value;
	if (name === '%AsyncFunction%') {
		value = getEvalledConstructor('async function () {}');
	} else if (name === '%GeneratorFunction%') {
		value = getEvalledConstructor('function* () {}');
	} else if (name === '%AsyncGeneratorFunction%') {
		value = getEvalledConstructor('async function* () {}');
	} else if (name === '%AsyncGenerator%') {
		var fn = doEval('%AsyncGeneratorFunction%');
		if (fn) {
			value = fn.prototype;
		}
	} else if (name === '%AsyncIteratorPrototype%') {
		var gen = doEval('%AsyncGenerator%');
		if (gen && getProto) {
			value = getProto(gen.prototype);
		}
	}

	INTRINSICS[name] = value;

	return value;
};

var LEGACY_ALIASES = {
	__proto__: null,
	'%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],
	'%ArrayPrototype%': ['Array', 'prototype'],
	'%ArrayProto_entries%': ['Array', 'prototype', 'entries'],
	'%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],
	'%ArrayProto_keys%': ['Array', 'prototype', 'keys'],
	'%ArrayProto_values%': ['Array', 'prototype', 'values'],
	'%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],
	'%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],
	'%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],
	'%BooleanPrototype%': ['Boolean', 'prototype'],
	'%DataViewPrototype%': ['DataView', 'prototype'],
	'%DatePrototype%': ['Date', 'prototype'],
	'%ErrorPrototype%': ['Error', 'prototype'],
	'%EvalErrorPrototype%': ['EvalError', 'prototype'],
	'%Float32ArrayPrototype%': ['Float32Array', 'prototype'],
	'%Float64ArrayPrototype%': ['Float64Array', 'prototype'],
	'%FunctionPrototype%': ['Function', 'prototype'],
	'%Generator%': ['GeneratorFunction', 'prototype'],
	'%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],
	'%Int8ArrayPrototype%': ['Int8Array', 'prototype'],
	'%Int16ArrayPrototype%': ['Int16Array', 'prototype'],
	'%Int32ArrayPrototype%': ['Int32Array', 'prototype'],
	'%JSONParse%': ['JSON', 'parse'],
	'%JSONStringify%': ['JSON', 'stringify'],
	'%MapPrototype%': ['Map', 'prototype'],
	'%NumberPrototype%': ['Number', 'prototype'],
	'%ObjectPrototype%': ['Object', 'prototype'],
	'%ObjProto_toString%': ['Object', 'prototype', 'toString'],
	'%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],
	'%PromisePrototype%': ['Promise', 'prototype'],
	'%PromiseProto_then%': ['Promise', 'prototype', 'then'],
	'%Promise_all%': ['Promise', 'all'],
	'%Promise_reject%': ['Promise', 'reject'],
	'%Promise_resolve%': ['Promise', 'resolve'],
	'%RangeErrorPrototype%': ['RangeError', 'prototype'],
	'%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],
	'%RegExpPrototype%': ['RegExp', 'prototype'],
	'%SetPrototype%': ['Set', 'prototype'],
	'%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],
	'%StringPrototype%': ['String', 'prototype'],
	'%SymbolPrototype%': ['Symbol', 'prototype'],
	'%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],
	'%TypedArrayPrototype%': ['TypedArray', 'prototype'],
	'%TypeErrorPrototype%': ['TypeError', 'prototype'],
	'%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],
	'%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],
	'%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],
	'%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],
	'%URIErrorPrototype%': ['URIError', 'prototype'],
	'%WeakMapPrototype%': ['WeakMap', 'prototype'],
	'%WeakSetPrototype%': ['WeakSet', 'prototype']
};

var bind = __nccwpck_require__(7564);
var hasOwn = __nccwpck_require__(4076);
var $concat = bind.call($call, Array.prototype.concat);
var $spliceApply = bind.call($apply, Array.prototype.splice);
var $replace = bind.call($call, String.prototype.replace);
var $strSlice = bind.call($call, String.prototype.slice);
var $exec = bind.call($call, RegExp.prototype.exec);

/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */
var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar = /\\(\\)?/g; /** Used to match backslashes in property paths. */
var stringToPath = function stringToPath(string) {
	var first = $strSlice(string, 0, 1);
	var last = $strSlice(string, -1);
	if (first === '%' && last !== '%') {
		throw new $SyntaxError('invalid intrinsic syntax, expected closing `%`');
	} else if (last === '%' && first !== '%') {
		throw new $SyntaxError('invalid intrinsic syntax, expected opening `%`');
	}
	var result = [];
	$replace(string, rePropName, function (match, number, quote, subString) {
		result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;
	});
	return result;
};
/* end adaptation */

var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
	var intrinsicName = name;
	var alias;
	if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
		alias = LEGACY_ALIASES[intrinsicName];
		intrinsicName = '%' + alias[0] + '%';
	}

	if (hasOwn(INTRINSICS, intrinsicName)) {
		var value = INTRINSICS[intrinsicName];
		if (value === needsEval) {
			value = doEval(intrinsicName);
		}
		if (typeof value === 'undefined' && !allowMissing) {
			throw new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
		}

		return {
			alias: alias,
			name: intrinsicName,
			value: value
		};
	}

	throw new $SyntaxError('intrinsic ' + name + ' does not exist!');
};

module.exports = function GetIntrinsic(name, allowMissing) {
	if (typeof name !== 'string' || name.length === 0) {
		throw new $TypeError('intrinsic name must be a non-empty string');
	}
	if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
		throw new $TypeError('"allowMissing" argument must be a boolean');
	}

	if ($exec(/^%?[^%]*%?$/, name) === null) {
		throw new $SyntaxError('`%` may not be present anywhere but at the beginning and end of the intrinsic name');
	}
	var parts = stringToPath(name);
	var intrinsicBaseName = parts.length > 0 ? parts[0] : '';

	var intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);
	var intrinsicRealName = intrinsic.name;
	var value = intrinsic.value;
	var skipFurtherCaching = false;

	var alias = intrinsic.alias;
	if (alias) {
		intrinsicBaseName = alias[0];
		$spliceApply(parts, $concat([0, 1], alias));
	}

	for (var i = 1, isOwn = true; i < parts.length; i += 1) {
		var part = parts[i];
		var first = $strSlice(part, 0, 1);
		var last = $strSlice(part, -1);
		if (
			(
				(first === '"' || first === "'" || first === '`')
				|| (last === '"' || last === "'" || last === '`')
			)
			&& first !== last
		) {
			throw new $SyntaxError('property names with quotes must have matching quotes');
		}
		if (part === 'constructor' || !isOwn) {
			skipFurtherCaching = true;
		}

		intrinsicBaseName += '.' + part;
		intrinsicRealName = '%' + intrinsicBaseName + '%';

		if (hasOwn(INTRINSICS, intrinsicRealName)) {
			value = INTRINSICS[intrinsicRealName];
		} else if (value != null) {
			if (!(part in value)) {
				if (!allowMissing) {
					throw new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');
				}
				return void undefined;
			}
			if ($gOPD && (i + 1) >= parts.length) {
				var desc = $gOPD(value, part);
				isOwn = !!desc;

				// By convention, when a data property is converted to an accessor
				// property to emulate a data property that does not suffer from
				// the override mistake, that accessor's getter is marked with
				// an `originalValue` property. Here, when we detect this, we
				// uphold the illusion by pretending to see that original data
				// property, i.e., returning the value rather than the getter
				// itself.
				if (isOwn && 'get' in desc && !('originalValue' in desc.get)) {
					value = desc.get;
				} else {
					value = value[part];
				}
			} else {
				isOwn = hasOwn(value, part);
				value = value[part];
			}

			if (isOwn && !skipFurtherCaching) {
				INTRINSICS[intrinsicRealName] = value;
			}
		}
	}
	return value;
};


/***/ }),

/***/ 1311:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {



var $Object = __nccwpck_require__(5399);

/** @type {import('./Object.getPrototypeOf')} */
module.exports = $Object.getPrototypeOf || null;


/***/ }),

/***/ 8681:
/***/ ((module) => {



/** @type {import('./Reflect.getPrototypeOf')} */
module.exports = (typeof Reflect !== 'undefined' && Reflect.getPrototypeOf) || null;


/***/ }),

/***/ 1967:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {



var reflectGetProto = __nccwpck_require__(8681);
var originalGetProto = __nccwpck_require__(1311);

var getDunderProto = __nccwpck_require__(6669);

/** @type {import('.')} */
module.exports = reflectGetProto
	? function getProto(O) {
		// @ts-expect-error TS can't narrow inside a closure, for some reason
		return reflectGetProto(O);
	}
	: originalGetProto
		? function getProto(O) {
			if (!O || (typeof O !== 'object' && typeof O !== 'function')) {
				throw new TypeError('getProto: not an object');
			}
			// @ts-expect-error TS can't narrow inside a closure, for some reason
			return originalGetProto(O);
		}
		: getDunderProto
			? function getProto(O) {
				// @ts-expect-error TS can't narrow inside a closure, for some reason
				return getDunderProto(O);
			}
			: null;


/***/ }),

/***/ 1174:
/***/ ((module) => {



/** @type {import('./gOPD')} */
module.exports = Object.getOwnPropertyDescriptor;


/***/ }),

/***/ 3170:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {



/** @type {import('.')} */
var $gOPD = __nccwpck_require__(1174);

if ($gOPD) {
	try {
		$gOPD([], 'length');
	} catch (e) {
		// IE 8 has a broken gOPD
		$gOPD = null;
	}
}

module.exports = $gOPD;


/***/ }),

/***/ 3336:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {



var origSymbol = typeof Symbol !== 'undefined' && Symbol;
var hasSymbolSham = __nccwpck_require__(1114);

/** @type {import('.')} */
module.exports = function hasNativeSymbols() {
	if (typeof origSymbol !== 'function') { return false; }
	if (typeof Symbol !== 'function') { return false; }
	if (typeof origSymbol('foo') !== 'symbol') { return false; }
	if (typeof Symbol('bar') !== 'symbol') { return false; }

	return hasSymbolSham();
};


/***/ }),

/***/ 1114:
/***/ ((module) => {



/** @type {import('./shams')} */
/* eslint complexity: [2, 18], max-statements: [2, 33] */
module.exports = function hasSymbols() {
	if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') { return false; }
	if (typeof Symbol.iterator === 'symbol') { return true; }

	/** @type {{ [k in symbol]?: unknown }} */
	var obj = {};
	var sym = Symbol('test');
	var symObj = Object(sym);
	if (typeof sym === 'string') { return false; }

	if (Object.prototype.toString.call(sym) !== '[object Symbol]') { return false; }
	if (Object.prototype.toString.call(symObj) !== '[object Symbol]') { return false; }

	// temp disabled per https://github.com/ljharb/object.assign/issues/17
	// if (sym instanceof Symbol) { return false; }
	// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
	// if (!(symObj instanceof Symbol)) { return false; }

	// if (typeof Symbol.prototype.toString !== 'function') { return false; }
	// if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }

	var symVal = 42;
	obj[sym] = symVal;
	for (var _ in obj) { return false; } // eslint-disable-line no-restricted-syntax, no-unreachable-loop
	if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) { return false; }

	if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) { return false; }

	var syms = Object.getOwnPropertySymbols(obj);
	if (syms.length !== 1 || syms[0] !== sym) { return false; }

	if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) { return false; }

	if (typeof Object.getOwnPropertyDescriptor === 'function') {
		// eslint-disable-next-line no-extra-parens
		var descriptor = /** @type {PropertyDescriptor} */ (Object.getOwnPropertyDescriptor(obj, sym));
		if (descriptor.value !== symVal || descriptor.enumerable !== true) { return false; }
	}

	return true;
};


/***/ }),

/***/ 5479:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {



var hasSymbols = __nccwpck_require__(1114);

/** @type {import('.')} */
module.exports = function hasToStringTagShams() {
	return hasSymbols() && !!Symbol.toStringTag;
};


/***/ }),

/***/ 4076:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {



var call = Function.prototype.call;
var $hasOwn = Object.prototype.hasOwnProperty;
var bind = __nccwpck_require__(7564);

/** @type {import('.')} */
module.exports = bind.call(call, $hasOwn);


/***/ }),

/***/ 4281:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {




var yaml = __nccwpck_require__(4040);


module.exports = yaml;


/***/ }),

/***/ 4040:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {




var loader = __nccwpck_require__(5868);
var dumper = __nccwpck_require__(5078);


function deprecated(name) {
  return function () {
    throw new Error('Function ' + name + ' is deprecated and cannot be used.');
  };
}


module.exports.Type = __nccwpck_require__(323);
module.exports.Schema = __nccwpck_require__(3487);
module.exports.FAILSAFE_SCHEMA = __nccwpck_require__(6810);
module.exports.JSON_SCHEMA = __nccwpck_require__(6613);
module.exports.CORE_SCHEMA = __nccwpck_require__(5116);
module.exports.DEFAULT_SAFE_SCHEMA = __nccwpck_require__(6032);
module.exports.DEFAULT_FULL_SCHEMA = __nccwpck_require__(948);
module.exports.load                = loader.load;
module.exports.loadAll             = loader.loadAll;
module.exports.safeLoad            = loader.safeLoad;
module.exports.safeLoadAll         = loader.safeLoadAll;
module.exports.dump                = dumper.dump;
module.exports.safeDump            = dumper.safeDump;
module.exports.YAMLException = __nccwpck_require__(5622);

// Deprecated schema names from JS-YAML 2.0.x
module.exports.MINIMAL_SCHEMA = __nccwpck_require__(6810);
module.exports.SAFE_SCHEMA = __nccwpck_require__(6032);
module.exports.DEFAULT_SCHEMA = __nccwpck_require__(948);

// Deprecated functions from JS-YAML 1.x.x
module.exports.scan           = deprecated('scan');
module.exports.parse          = deprecated('parse');
module.exports.compose        = deprecated('compose');
module.exports.addConstructor = deprecated('addConstructor');


/***/ }),

/***/ 4206:
/***/ ((module) => {




function isNothing(subject) {
  return (typeof subject === 'undefined') || (subject === null);
}


function isObject(subject) {
  return (typeof subject === 'object') && (subject !== null);
}


function toArray(sequence) {
  if (Array.isArray(sequence)) return sequence;
  else if (isNothing(sequence)) return [];

  return [ sequence ];
}


function extend(target, source) {
  var index, length, key, sourceKeys;

  if (source) {
    sourceKeys = Object.keys(source);

    for (index = 0, length = sourceKeys.length; index < length; index += 1) {
      key = sourceKeys[index];
      target[key] = source[key];
    }
  }

  return target;
}


function repeat(string, count) {
  var result = '', cycle;

  for (cycle = 0; cycle < count; cycle += 1) {
    result += string;
  }

  return result;
}


function isNegativeZero(number) {
  return (number === 0) && (Number.NEGATIVE_INFINITY === 1 / number);
}


module.exports.isNothing      = isNothing;
module.exports.isObject       = isObject;
module.exports.toArray        = toArray;
module.exports.repeat         = repeat;
module.exports.isNegativeZero = isNegativeZero;
module.exports.extend         = extend;


/***/ }),

/***/ 5078:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {



/*eslint-disable no-use-before-define*/

var common              = __nccwpck_require__(4206);
var YAMLException       = __nccwpck_require__(5622);
var DEFAULT_FULL_SCHEMA = __nccwpck_require__(948);
var DEFAULT_SAFE_SCHEMA = __nccwpck_require__(6032);

var _toString       = Object.prototype.toString;
var _hasOwnProperty = Object.prototype.hasOwnProperty;

var CHAR_TAB                  = 0x09; /* Tab */
var CHAR_LINE_FEED            = 0x0A; /* LF */
var CHAR_CARRIAGE_RETURN      = 0x0D; /* CR */
var CHAR_SPACE                = 0x20; /* Space */
var CHAR_EXCLAMATION          = 0x21; /* ! */
var CHAR_DOUBLE_QUOTE         = 0x22; /* " */
var CHAR_SHARP                = 0x23; /* # */
var CHAR_PERCENT              = 0x25; /* % */
var CHAR_AMPERSAND            = 0x26; /* & */
var CHAR_SINGLE_QUOTE         = 0x27; /* ' */
var CHAR_ASTERISK             = 0x2A; /* * */
var CHAR_COMMA                = 0x2C; /* , */
var CHAR_MINUS                = 0x2D; /* - */
var CHAR_COLON                = 0x3A; /* : */
var CHAR_EQUALS               = 0x3D; /* = */
var CHAR_GREATER_THAN         = 0x3E; /* > */
var CHAR_QUESTION             = 0x3F; /* ? */
var CHAR_COMMERCIAL_AT        = 0x40; /* @ */
var CHAR_LEFT_SQUARE_BRACKET  = 0x5B; /* [ */
var CHAR_RIGHT_SQUARE_BRACKET = 0x5D; /* ] */
var CHAR_GRAVE_ACCENT         = 0x60; /* ` */
var CHAR_LEFT_CURLY_BRACKET   = 0x7B; /* { */
var CHAR_VERTICAL_LINE        = 0x7C; /* | */
var CHAR_RIGHT_CURLY_BRACKET  = 0x7D; /* } */

var ESCAPE_SEQUENCES = {};

ESCAPE_SEQUENCES[0x00]   = '\\0';
ESCAPE_SEQUENCES[0x07]   = '\\a';
ESCAPE_SEQUENCES[0x08]   = '\\b';
ESCAPE_SEQUENCES[0x09]   = '\\t';
ESCAPE_SEQUENCES[0x0A]   = '\\n';
ESCAPE_SEQUENCES[0x0B]   = '\\v';
ESCAPE_SEQUENCES[0x0C]   = '\\f';
ESCAPE_SEQUENCES[0x0D]   = '\\r';
ESCAPE_SEQUENCES[0x1B]   = '\\e';
ESCAPE_SEQUENCES[0x22]   = '\\"';
ESCAPE_SEQUENCES[0x5C]   = '\\\\';
ESCAPE_SEQUENCES[0x85]   = '\\N';
ESCAPE_SEQUENCES[0xA0]   = '\\_';
ESCAPE_SEQUENCES[0x2028] = '\\L';
ESCAPE_SEQUENCES[0x2029] = '\\P';

var DEPRECATED_BOOLEANS_SYNTAX = [
  'y', 'Y', 'yes', 'Yes', 'YES', 'on', 'On', 'ON',
  'n', 'N', 'no', 'No', 'NO', 'off', 'Off', 'OFF'
];

function compileStyleMap(schema, map) {
  var result, keys, index, length, tag, style, type;

  if (map === null) return {};

  result = {};
  keys = Object.keys(map);

  for (index = 0, length = keys.length; index < length; index += 1) {
    tag = keys[index];
    style = String(map[tag]);

    if (tag.slice(0, 2) === '!!') {
      tag = 'tag:yaml.org,2002:' + tag.slice(2);
    }
    type = schema.compiledTypeMap['fallback'][tag];

    if (type && _hasOwnProperty.call(type.styleAliases, style)) {
      style = type.styleAliases[style];
    }

    result[tag] = style;
  }

  return result;
}

function encodeHex(character) {
  var string, handle, length;

  string = character.toString(16).toUpperCase();

  if (character <= 0xFF) {
    handle = 'x';
    length = 2;
  } else if (character <= 0xFFFF) {
    handle = 'u';
    length = 4;
  } else if (character <= 0xFFFFFFFF) {
    handle = 'U';
    length = 8;
  } else {
    throw new YAMLException('code point within a string may not be greater than 0xFFFFFFFF');
  }

  return '\\' + handle + common.repeat('0', length - string.length) + string;
}

function State(options) {
  this.schema        = options['schema'] || DEFAULT_FULL_SCHEMA;
  this.indent        = Math.max(1, (options['indent'] || 2));
  this.noArrayIndent = options['noArrayIndent'] || false;
  this.skipInvalid   = options['skipInvalid'] || false;
  this.flowLevel     = (common.isNothing(options['flowLevel']) ? -1 : options['flowLevel']);
  this.styleMap      = compileStyleMap(this.schema, options['styles'] || null);
  this.sortKeys      = options['sortKeys'] || false;
  this.lineWidth     = options['lineWidth'] || 80;
  this.noRefs        = options['noRefs'] || false;
  this.noCompatMode  = options['noCompatMode'] || false;
  this.condenseFlow  = options['condenseFlow'] || false;

  this.implicitTypes = this.schema.compiledImplicit;
  this.explicitTypes = this.schema.compiledExplicit;

  this.tag = null;
  this.result = '';

  this.duplicates = [];
  this.usedDuplicates = null;
}

// Indents every line in a string. Empty lines (\n only) are not indented.
function indentString(string, spaces) {
  var ind = common.repeat(' ', spaces),
      position = 0,
      next = -1,
      result = '',
      line,
      length = string.length;

  while (position < length) {
    next = string.indexOf('\n', position);
    if (next === -1) {
      line = string.slice(position);
      position = length;
    } else {
      line = string.slice(position, next + 1);
      position = next + 1;
    }

    if (line.length && line !== '\n') result += ind;

    result += line;
  }

  return result;
}

function generateNextLine(state, level) {
  return '\n' + common.repeat(' ', state.indent * level);
}

function testImplicitResolving(state, str) {
  var index, length, type;

  for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {
    type = state.implicitTypes[index];

    if (type.resolve(str)) {
      return true;
    }
  }

  return false;
}

// [33] s-white ::= s-space | s-tab
function isWhitespace(c) {
  return c === CHAR_SPACE || c === CHAR_TAB;
}

// Returns true if the character can be printed without escaping.
// From YAML 1.2: "any allowed characters known to be non-printable
// should also be escaped. [However,] This isn’t mandatory"
// Derived from nb-char - \t - #x85 - #xA0 - #x2028 - #x2029.
function isPrintable(c) {
  return  (0x00020 <= c && c <= 0x00007E)
      || ((0x000A1 <= c && c <= 0x00D7FF) && c !== 0x2028 && c !== 0x2029)
      || ((0x0E000 <= c && c <= 0x00FFFD) && c !== 0xFEFF /* BOM */)
      ||  (0x10000 <= c && c <= 0x10FFFF);
}

// [34] ns-char ::= nb-char - s-white
// [27] nb-char ::= c-printable - b-char - c-byte-order-mark
// [26] b-char  ::= b-line-feed | b-carriage-return
// [24] b-line-feed       ::=     #xA    /* LF */
// [25] b-carriage-return ::=     #xD    /* CR */
// [3]  c-byte-order-mark ::=     #xFEFF
function isNsChar(c) {
  return isPrintable(c) && !isWhitespace(c)
    // byte-order-mark
    && c !== 0xFEFF
    // b-char
    && c !== CHAR_CARRIAGE_RETURN
    && c !== CHAR_LINE_FEED;
}

// Simplified test for values allowed after the first character in plain style.
function isPlainSafe(c, prev) {
  // Uses a subset of nb-char - c-flow-indicator - ":" - "#"
  // where nb-char ::= c-printable - b-char - c-byte-order-mark.
  return isPrintable(c) && c !== 0xFEFF
    // - c-flow-indicator
    && c !== CHAR_COMMA
    && c !== CHAR_LEFT_SQUARE_BRACKET
    && c !== CHAR_RIGHT_SQUARE_BRACKET
    && c !== CHAR_LEFT_CURLY_BRACKET
    && c !== CHAR_RIGHT_CURLY_BRACKET
    // - ":" - "#"
    // /* An ns-char preceding */ "#"
    && c !== CHAR_COLON
    && ((c !== CHAR_SHARP) || (prev && isNsChar(prev)));
}

// Simplified test for values allowed as the first character in plain style.
function isPlainSafeFirst(c) {
  // Uses a subset of ns-char - c-indicator
  // where ns-char = nb-char - s-white.
  return isPrintable(c) && c !== 0xFEFF
    && !isWhitespace(c) // - s-white
    // - (c-indicator ::=
    // “-” | “?” | “:” | “,” | “[” | “]” | “{” | “}”
    && c !== CHAR_MINUS
    && c !== CHAR_QUESTION
    && c !== CHAR_COLON
    && c !== CHAR_COMMA
    && c !== CHAR_LEFT_SQUARE_BRACKET
    && c !== CHAR_RIGHT_SQUARE_BRACKET
    && c !== CHAR_LEFT_CURLY_BRACKET
    && c !== CHAR_RIGHT_CURLY_BRACKET
    // | “#” | “&” | “*” | “!” | “|” | “=” | “>” | “'” | “"”
    && c !== CHAR_SHARP
    && c !== CHAR_AMPERSAND
    && c !== CHAR_ASTERISK
    && c !== CHAR_EXCLAMATION
    && c !== CHAR_VERTICAL_LINE
    && c !== CHAR_EQUALS
    && c !== CHAR_GREATER_THAN
    && c !== CHAR_SINGLE_QUOTE
    && c !== CHAR_DOUBLE_QUOTE
    // | “%” | “@” | “`”)
    && c !== CHAR_PERCENT
    && c !== CHAR_COMMERCIAL_AT
    && c !== CHAR_GRAVE_ACCENT;
}

// Determines whether block indentation indicator is required.
function needIndentIndicator(string) {
  var leadingSpaceRe = /^\n* /;
  return leadingSpaceRe.test(string);
}

var STYLE_PLAIN   = 1,
    STYLE_SINGLE  = 2,
    STYLE_LITERAL = 3,
    STYLE_FOLDED  = 4,
    STYLE_DOUBLE  = 5;

// Determines which scalar styles are possible and returns the preferred style.
// lineWidth = -1 => no limit.
// Pre-conditions: str.length > 0.
// Post-conditions:
//    STYLE_PLAIN or STYLE_SINGLE => no \n are in the string.
//    STYLE_LITERAL => no lines are suitable for folding (or lineWidth is -1).
//    STYLE_FOLDED => a line > lineWidth and can be folded (and lineWidth != -1).
function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType) {
  var i;
  var char, prev_char;
  var hasLineBreak = false;
  var hasFoldableLine = false; // only checked if shouldTrackWidth
  var shouldTrackWidth = lineWidth !== -1;
  var previousLineBreak = -1; // count the first line correctly
  var plain = isPlainSafeFirst(string.charCodeAt(0))
          && !isWhitespace(string.charCodeAt(string.length - 1));

  if (singleLineOnly) {
    // Case: no block styles.
    // Check for disallowed characters to rule out plain and single.
    for (i = 0; i < string.length; i++) {
      char = string.charCodeAt(i);
      if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      prev_char = i > 0 ? string.charCodeAt(i - 1) : null;
      plain = plain && isPlainSafe(char, prev_char);
    }
  } else {
    // Case: block styles permitted.
    for (i = 0; i < string.length; i++) {
      char = string.charCodeAt(i);
      if (char === CHAR_LINE_FEED) {
        hasLineBreak = true;
        // Check if any line can be folded.
        if (shouldTrackWidth) {
          hasFoldableLine = hasFoldableLine ||
            // Foldable line = too long, and not more-indented.
            (i - previousLineBreak - 1 > lineWidth &&
             string[previousLineBreak + 1] !== ' ');
          previousLineBreak = i;
        }
      } else if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      prev_char = i > 0 ? string.charCodeAt(i - 1) : null;
      plain = plain && isPlainSafe(char, prev_char);
    }
    // in case the end is missing a \n
    hasFoldableLine = hasFoldableLine || (shouldTrackWidth &&
      (i - previousLineBreak - 1 > lineWidth &&
       string[previousLineBreak + 1] !== ' '));
  }
  // Although every style can represent \n without escaping, prefer block styles
  // for multiline, since they're more readable and they don't add empty lines.
  // Also prefer folding a super-long line.
  if (!hasLineBreak && !hasFoldableLine) {
    // Strings interpretable as another type have to be quoted;
    // e.g. the string 'true' vs. the boolean true.
    return plain && !testAmbiguousType(string)
      ? STYLE_PLAIN : STYLE_SINGLE;
  }
  // Edge case: block indentation indicator can only have one digit.
  if (indentPerLevel > 9 && needIndentIndicator(string)) {
    return STYLE_DOUBLE;
  }
  // At this point we know block styles are valid.
  // Prefer literal style unless we want to fold.
  return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
}

// Note: line breaking/folding is implemented for only the folded style.
// NB. We drop the last trailing newline (if any) of a returned block scalar
//  since the dumper adds its own newline. This always works:
//    • No ending newline => unaffected; already using strip "-" chomping.
//    • Ending newline    => removed then restored.
//  Importantly, this keeps the "+" chomp indicator from gaining an extra line.
function writeScalar(state, string, level, iskey) {
  state.dump = (function () {
    if (string.length === 0) {
      return "''";
    }
    if (!state.noCompatMode &&
        DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1) {
      return "'" + string + "'";
    }

    var indent = state.indent * Math.max(1, level); // no 0-indent scalars
    // As indentation gets deeper, let the width decrease monotonically
    // to the lower bound min(state.lineWidth, 40).
    // Note that this implies
    //  state.lineWidth ≤ 40 + state.indent: width is fixed at the lower bound.
    //  state.lineWidth > 40 + state.indent: width decreases until the lower bound.
    // This behaves better than a constant minimum width which disallows narrower options,
    // or an indent threshold which causes the width to suddenly increase.
    var lineWidth = state.lineWidth === -1
      ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);

    // Without knowing if keys are implicit/explicit, assume implicit for safety.
    var singleLineOnly = iskey
      // No block styles in flow mode.
      || (state.flowLevel > -1 && level >= state.flowLevel);
    function testAmbiguity(string) {
      return testImplicitResolving(state, string);
    }

    switch (chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth, testAmbiguity)) {
      case STYLE_PLAIN:
        return string;
      case STYLE_SINGLE:
        return "'" + string.replace(/'/g, "''") + "'";
      case STYLE_LITERAL:
        return '|' + blockHeader(string, state.indent)
          + dropEndingNewline(indentString(string, indent));
      case STYLE_FOLDED:
        return '>' + blockHeader(string, state.indent)
          + dropEndingNewline(indentString(foldString(string, lineWidth), indent));
      case STYLE_DOUBLE:
        return '"' + escapeString(string, lineWidth) + '"';
      default:
        throw new YAMLException('impossible error: invalid scalar style');
    }
  }());
}

// Pre-conditions: string is valid for a block scalar, 1 <= indentPerLevel <= 9.
function blockHeader(string, indentPerLevel) {
  var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : '';

  // note the special case: the string '\n' counts as a "trailing" empty line.
  var clip =          string[string.length - 1] === '\n';
  var keep = clip && (string[string.length - 2] === '\n' || string === '\n');
  var chomp = keep ? '+' : (clip ? '' : '-');

  return indentIndicator + chomp + '\n';
}

// (See the note for writeScalar.)
function dropEndingNewline(string) {
  return string[string.length - 1] === '\n' ? string.slice(0, -1) : string;
}

// Note: a long line without a suitable break point will exceed the width limit.
// Pre-conditions: every char in str isPrintable, str.length > 0, width > 0.
function foldString(string, width) {
  // In folded style, $k$ consecutive newlines output as $k+1$ newlines—
  // unless they're before or after a more-indented line, or at the very
  // beginning or end, in which case $k$ maps to $k$.
  // Therefore, parse each chunk as newline(s) followed by a content line.
  var lineRe = /(\n+)([^\n]*)/g;

  // first line (possibly an empty line)
  var result = (function () {
    var nextLF = string.indexOf('\n');
    nextLF = nextLF !== -1 ? nextLF : string.length;
    lineRe.lastIndex = nextLF;
    return foldLine(string.slice(0, nextLF), width);
  }());
  // If we haven't reached the first content line yet, don't add an extra \n.
  var prevMoreIndented = string[0] === '\n' || string[0] === ' ';
  var moreIndented;

  // rest of the lines
  var match;
  while ((match = lineRe.exec(string))) {
    var prefix = match[1], line = match[2];
    moreIndented = (line[0] === ' ');
    result += prefix
      + (!prevMoreIndented && !moreIndented && line !== ''
        ? '\n' : '')
      + foldLine(line, width);
    prevMoreIndented = moreIndented;
  }

  return result;
}

// Greedy line breaking.
// Picks the longest line under the limit each time,
// otherwise settles for the shortest line over the limit.
// NB. More-indented lines *cannot* be folded, as that would add an extra \n.
function foldLine(line, width) {
  if (line === '' || line[0] === ' ') return line;

  // Since a more-indented line adds a \n, breaks can't be followed by a space.
  var breakRe = / [^ ]/g; // note: the match index will always be <= length-2.
  var match;
  // start is an inclusive index. end, curr, and next are exclusive.
  var start = 0, end, curr = 0, next = 0;
  var result = '';

  // Invariants: 0 <= start <= length-1.
  //   0 <= curr <= next <= max(0, length-2). curr - start <= width.
  // Inside the loop:
  //   A match implies length >= 2, so curr and next are <= length-2.
  while ((match = breakRe.exec(line))) {
    next = match.index;
    // maintain invariant: curr - start <= width
    if (next - start > width) {
      end = (curr > start) ? curr : next; // derive end <= length-2
      result += '\n' + line.slice(start, end);
      // skip the space that was output as \n
      start = end + 1;                    // derive start <= length-1
    }
    curr = next;
  }

  // By the invariants, start <= length-1, so there is something left over.
  // It is either the whole string or a part starting from non-whitespace.
  result += '\n';
  // Insert a break if the remainder is too long and there is a break available.
  if (line.length - start > width && curr > start) {
    result += line.slice(start, curr) + '\n' + line.slice(curr + 1);
  } else {
    result += line.slice(start);
  }

  return result.slice(1); // drop extra \n joiner
}

// Escapes a double-quoted string.
function escapeString(string) {
  var result = '';
  var char, nextChar;
  var escapeSeq;

  for (var i = 0; i < string.length; i++) {
    char = string.charCodeAt(i);
    // Check for surrogate pairs (reference Unicode 3.0 section "3.7 Surrogates").
    if (char >= 0xD800 && char <= 0xDBFF/* high surrogate */) {
      nextChar = string.charCodeAt(i + 1);
      if (nextChar >= 0xDC00 && nextChar <= 0xDFFF/* low surrogate */) {
        // Combine the surrogate pair and store it escaped.
        result += encodeHex((char - 0xD800) * 0x400 + nextChar - 0xDC00 + 0x10000);
        // Advance index one extra since we already used that char here.
        i++; continue;
      }
    }
    escapeSeq = ESCAPE_SEQUENCES[char];
    result += !escapeSeq && isPrintable(char)
      ? string[i]
      : escapeSeq || encodeHex(char);
  }

  return result;
}

function writeFlowSequence(state, level, object) {
  var _result = '',
      _tag    = state.tag,
      index,
      length;

  for (index = 0, length = object.length; index < length; index += 1) {
    // Write only valid elements.
    if (writeNode(state, level, object[index], false, false)) {
      if (index !== 0) _result += ',' + (!state.condenseFlow ? ' ' : '');
      _result += state.dump;
    }
  }

  state.tag = _tag;
  state.dump = '[' + _result + ']';
}

function writeBlockSequence(state, level, object, compact) {
  var _result = '',
      _tag    = state.tag,
      index,
      length;

  for (index = 0, length = object.length; index < length; index += 1) {
    // Write only valid elements.
    if (writeNode(state, level + 1, object[index], true, true)) {
      if (!compact || index !== 0) {
        _result += generateNextLine(state, level);
      }

      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        _result += '-';
      } else {
        _result += '- ';
      }

      _result += state.dump;
    }
  }

  state.tag = _tag;
  state.dump = _result || '[]'; // Empty sequence if no valid values.
}

function writeFlowMapping(state, level, object) {
  var _result       = '',
      _tag          = state.tag,
      objectKeyList = Object.keys(object),
      index,
      length,
      objectKey,
      objectValue,
      pairBuffer;

  for (index = 0, length = objectKeyList.length; index < length; index += 1) {

    pairBuffer = '';
    if (index !== 0) pairBuffer += ', ';

    if (state.condenseFlow) pairBuffer += '"';

    objectKey = objectKeyList[index];
    objectValue = object[objectKey];

    if (!writeNode(state, level, objectKey, false, false)) {
      continue; // Skip this pair because of invalid key;
    }

    if (state.dump.length > 1024) pairBuffer += '? ';

    pairBuffer += state.dump + (state.condenseFlow ? '"' : '') + ':' + (state.condenseFlow ? '' : ' ');

    if (!writeNode(state, level, objectValue, false, false)) {
      continue; // Skip this pair because of invalid value.
    }

    pairBuffer += state.dump;

    // Both key and value are valid.
    _result += pairBuffer;
  }

  state.tag = _tag;
  state.dump = '{' + _result + '}';
}

function writeBlockMapping(state, level, object, compact) {
  var _result       = '',
      _tag          = state.tag,
      objectKeyList = Object.keys(object),
      index,
      length,
      objectKey,
      objectValue,
      explicitPair,
      pairBuffer;

  // Allow sorting keys so that the output file is deterministic
  if (state.sortKeys === true) {
    // Default sorting
    objectKeyList.sort();
  } else if (typeof state.sortKeys === 'function') {
    // Custom sort function
    objectKeyList.sort(state.sortKeys);
  } else if (state.sortKeys) {
    // Something is wrong
    throw new YAMLException('sortKeys must be a boolean or a function');
  }

  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
    pairBuffer = '';

    if (!compact || index !== 0) {
      pairBuffer += generateNextLine(state, level);
    }

    objectKey = objectKeyList[index];
    objectValue = object[objectKey];

    if (!writeNode(state, level + 1, objectKey, true, true, true)) {
      continue; // Skip this pair because of invalid key.
    }

    explicitPair = (state.tag !== null && state.tag !== '?') ||
                   (state.dump && state.dump.length > 1024);

    if (explicitPair) {
      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        pairBuffer += '?';
      } else {
        pairBuffer += '? ';
      }
    }

    pairBuffer += state.dump;

    if (explicitPair) {
      pairBuffer += generateNextLine(state, level);
    }

    if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
      continue; // Skip this pair because of invalid value.
    }

    if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
      pairBuffer += ':';
    } else {
      pairBuffer += ': ';
    }

    pairBuffer += state.dump;

    // Both key and value are valid.
    _result += pairBuffer;
  }

  state.tag = _tag;
  state.dump = _result || '{}'; // Empty mapping if no valid pairs.
}

function detectType(state, object, explicit) {
  var _result, typeList, index, length, type, style;

  typeList = explicit ? state.explicitTypes : state.implicitTypes;

  for (index = 0, length = typeList.length; index < length; index += 1) {
    type = typeList[index];

    if ((type.instanceOf  || type.predicate) &&
        (!type.instanceOf || ((typeof object === 'object') && (object instanceof type.instanceOf))) &&
        (!type.predicate  || type.predicate(object))) {

      state.tag = explicit ? type.tag : '?';

      if (type.represent) {
        style = state.styleMap[type.tag] || type.defaultStyle;

        if (_toString.call(type.represent) === '[object Function]') {
          _result = type.represent(object, style);
        } else if (_hasOwnProperty.call(type.represent, style)) {
          _result = type.represent[style](object, style);
        } else {
          throw new YAMLException('!<' + type.tag + '> tag resolver accepts not "' + style + '" style');
        }

        state.dump = _result;
      }

      return true;
    }
  }

  return false;
}

// Serializes `object` and writes it to global `result`.
// Returns true on success, or false on invalid object.
//
function writeNode(state, level, object, block, compact, iskey) {
  state.tag = null;
  state.dump = object;

  if (!detectType(state, object, false)) {
    detectType(state, object, true);
  }

  var type = _toString.call(state.dump);

  if (block) {
    block = (state.flowLevel < 0 || state.flowLevel > level);
  }

  var objectOrArray = type === '[object Object]' || type === '[object Array]',
      duplicateIndex,
      duplicate;

  if (objectOrArray) {
    duplicateIndex = state.duplicates.indexOf(object);
    duplicate = duplicateIndex !== -1;
  }

  if ((state.tag !== null && state.tag !== '?') || duplicate || (state.indent !== 2 && level > 0)) {
    compact = false;
  }

  if (duplicate && state.usedDuplicates[duplicateIndex]) {
    state.dump = '*ref_' + duplicateIndex;
  } else {
    if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
      state.usedDuplicates[duplicateIndex] = true;
    }
    if (type === '[object Object]') {
      if (block && (Object.keys(state.dump).length !== 0)) {
        writeBlockMapping(state, level, state.dump, compact);
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + state.dump;
        }
      } else {
        writeFlowMapping(state, level, state.dump);
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
        }
      }
    } else if (type === '[object Array]') {
      var arrayLevel = (state.noArrayIndent && (level > 0)) ? level - 1 : level;
      if (block && (state.dump.length !== 0)) {
        writeBlockSequence(state, arrayLevel, state.dump, compact);
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + state.dump;
        }
      } else {
        writeFlowSequence(state, arrayLevel, state.dump);
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
        }
      }
    } else if (type === '[object String]') {
      if (state.tag !== '?') {
        writeScalar(state, state.dump, level, iskey);
      }
    } else {
      if (state.skipInvalid) return false;
      throw new YAMLException('unacceptable kind of an object to dump ' + type);
    }

    if (state.tag !== null && state.tag !== '?') {
      state.dump = '!<' + state.tag + '> ' + state.dump;
    }
  }

  return true;
}

function getDuplicateReferences(object, state) {
  var objects = [],
      duplicatesIndexes = [],
      index,
      length;

  inspectNode(object, objects, duplicatesIndexes);

  for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {
    state.duplicates.push(objects[duplicatesIndexes[index]]);
  }
  state.usedDuplicates = new Array(length);
}

function inspectNode(object, objects, duplicatesIndexes) {
  var objectKeyList,
      index,
      length;

  if (object !== null && typeof object === 'object') {
    index = objects.indexOf(object);
    if (index !== -1) {
      if (duplicatesIndexes.indexOf(index) === -1) {
        duplicatesIndexes.push(index);
      }
    } else {
      objects.push(object);

      if (Array.isArray(object)) {
        for (index = 0, length = object.length; index < length; index += 1) {
          inspectNode(object[index], objects, duplicatesIndexes);
        }
      } else {
        objectKeyList = Object.keys(object);

        for (index = 0, length = objectKeyList.length; index < length; index += 1) {
          inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
        }
      }
    }
  }
}

function dump(input, options) {
  options = options || {};

  var state = new State(options);

  if (!state.noRefs) getDuplicateReferences(input, state);

  if (writeNode(state, 0, input, true, true)) return state.dump + '\n';

  return '';
}

function safeDump(input, options) {
  return dump(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
}

module.exports.dump     = dump;
module.exports.safeDump = safeDump;


/***/ }),

/***/ 5622:
/***/ ((module) => {

// YAML error class. http://stackoverflow.com/questions/8458984
//


function YAMLException(reason, mark) {
  // Super constructor
  Error.call(this);

  this.name = 'YAMLException';
  this.reason = reason;
  this.mark = mark;
  this.message = (this.reason || '(unknown reason)') + (this.mark ? ' ' + this.mark.toString() : '');

  // Include stack trace in error object
  if (Error.captureStackTrace) {
    // Chrome and NodeJS
    Error.captureStackTrace(this, this.constructor);
  } else {
    // FF, IE 10+ and Safari 6+. Fallback for others
    this.stack = (new Error()).stack || '';
  }
}


// Inherit from Error
YAMLException.prototype = Object.create(Error.prototype);
YAMLException.prototype.constructor = YAMLException;


YAMLException.prototype.toString = function toString(compact) {
  var result = this.name + ': ';

  result += this.reason || '(unknown reason)';

  if (!compact && this.mark) {
    result += ' ' + this.mark.toString();
  }

  return result;
};


module.exports = YAMLException;


/***/ }),

/***/ 5868:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {



/*eslint-disable max-len,no-use-before-define*/

var common              = __nccwpck_require__(4206);
var YAMLException       = __nccwpck_require__(5622);
var Mark                = __nccwpck_require__(3241);
var DEFAULT_SAFE_SCHEMA = __nccwpck_require__(6032);
var DEFAULT_FULL_SCHEMA = __nccwpck_require__(948);


var _hasOwnProperty = Object.prototype.hasOwnProperty;


var CONTEXT_FLOW_IN   = 1;
var CONTEXT_FLOW_OUT  = 2;
var CONTEXT_BLOCK_IN  = 3;
var CONTEXT_BLOCK_OUT = 4;


var CHOMPING_CLIP  = 1;
var CHOMPING_STRIP = 2;
var CHOMPING_KEEP  = 3;


var PATTERN_NON_PRINTABLE         = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
var PATTERN_FLOW_INDICATORS       = /[,\[\]\{\}]/;
var PATTERN_TAG_HANDLE            = /^(?:!|!!|![a-z\-]+!)$/i;
var PATTERN_TAG_URI               = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;


function _class(obj) { return Object.prototype.toString.call(obj); }

function is_EOL(c) {
  return (c === 0x0A/* LF */) || (c === 0x0D/* CR */);
}

function is_WHITE_SPACE(c) {
  return (c === 0x09/* Tab */) || (c === 0x20/* Space */);
}

function is_WS_OR_EOL(c) {
  return (c === 0x09/* Tab */) ||
         (c === 0x20/* Space */) ||
         (c === 0x0A/* LF */) ||
         (c === 0x0D/* CR */);
}

function is_FLOW_INDICATOR(c) {
  return c === 0x2C/* , */ ||
         c === 0x5B/* [ */ ||
         c === 0x5D/* ] */ ||
         c === 0x7B/* { */ ||
         c === 0x7D/* } */;
}

function fromHexCode(c) {
  var lc;

  if ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) {
    return c - 0x30;
  }

  /*eslint-disable no-bitwise*/
  lc = c | 0x20;

  if ((0x61/* a */ <= lc) && (lc <= 0x66/* f */)) {
    return lc - 0x61 + 10;
  }

  return -1;
}

function escapedHexLen(c) {
  if (c === 0x78/* x */) { return 2; }
  if (c === 0x75/* u */) { return 4; }
  if (c === 0x55/* U */) { return 8; }
  return 0;
}

function fromDecimalCode(c) {
  if ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) {
    return c - 0x30;
  }

  return -1;
}

function simpleEscapeSequence(c) {
  /* eslint-disable indent */
  return (c === 0x30/* 0 */) ? '\x00' :
        (c === 0x61/* a */) ? '\x07' :
        (c === 0x62/* b */) ? '\x08' :
        (c === 0x74/* t */) ? '\x09' :
        (c === 0x09/* Tab */) ? '\x09' :
        (c === 0x6E/* n */) ? '\x0A' :
        (c === 0x76/* v */) ? '\x0B' :
        (c === 0x66/* f */) ? '\x0C' :
        (c === 0x72/* r */) ? '\x0D' :
        (c === 0x65/* e */) ? '\x1B' :
        (c === 0x20/* Space */) ? ' ' :
        (c === 0x22/* " */) ? '\x22' :
        (c === 0x2F/* / */) ? '/' :
        (c === 0x5C/* \ */) ? '\x5C' :
        (c === 0x4E/* N */) ? '\x85' :
        (c === 0x5F/* _ */) ? '\xA0' :
        (c === 0x4C/* L */) ? '\u2028' :
        (c === 0x50/* P */) ? '\u2029' : '';
}

function charFromCodepoint(c) {
  if (c <= 0xFFFF) {
    return String.fromCharCode(c);
  }
  // Encode UTF-16 surrogate pair
  // https://en.wikipedia.org/wiki/UTF-16#Code_points_U.2B010000_to_U.2B10FFFF
  return String.fromCharCode(
    ((c - 0x010000) >> 10) + 0xD800,
    ((c - 0x010000) & 0x03FF) + 0xDC00
  );
}

var simpleEscapeCheck = new Array(256); // integer, for fast access
var simpleEscapeMap = new Array(256);
for (var i = 0; i < 256; i++) {
  simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
  simpleEscapeMap[i] = simpleEscapeSequence(i);
}


function State(input, options) {
  this.input = input;

  this.filename  = options['filename']  || null;
  this.schema    = options['schema']    || DEFAULT_FULL_SCHEMA;
  this.onWarning = options['onWarning'] || null;
  this.legacy    = options['legacy']    || false;
  this.json      = options['json']      || false;
  this.listener  = options['listener']  || null;

  this.implicitTypes = this.schema.compiledImplicit;
  this.typeMap       = this.schema.compiledTypeMap;

  this.length     = input.length;
  this.position   = 0;
  this.line       = 0;
  this.lineStart  = 0;
  this.lineIndent = 0;

  this.documents = [];

  /*
  this.version;
  this.checkLineBreaks;
  this.tagMap;
  this.anchorMap;
  this.tag;
  this.anchor;
  this.kind;
  this.result;*/

}


function generateError(state, message) {
  return new YAMLException(
    message,
    new Mark(state.filename, state.input, state.position, state.line, (state.position - state.lineStart)));
}

function throwError(state, message) {
  throw generateError(state, message);
}

function throwWarning(state, message) {
  if (state.onWarning) {
    state.onWarning.call(null, generateError(state, message));
  }
}


var directiveHandlers = {

  YAML: function handleYamlDirective(state, name, args) {

    var match, major, minor;

    if (state.version !== null) {
      throwError(state, 'duplication of %YAML directive');
    }

    if (args.length !== 1) {
      throwError(state, 'YAML directive accepts exactly one argument');
    }

    match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);

    if (match === null) {
      throwError(state, 'ill-formed argument of the YAML directive');
    }

    major = parseInt(match[1], 10);
    minor = parseInt(match[2], 10);

    if (major !== 1) {
      throwError(state, 'unacceptable YAML version of the document');
    }

    state.version = args[0];
    state.checkLineBreaks = (minor < 2);

    if (minor !== 1 && minor !== 2) {
      throwWarning(state, 'unsupported YAML version of the document');
    }
  },

  TAG: function handleTagDirective(state, name, args) {

    var handle, prefix;

    if (args.length !== 2) {
      throwError(state, 'TAG directive accepts exactly two arguments');
    }

    handle = args[0];
    prefix = args[1];

    if (!PATTERN_TAG_HANDLE.test(handle)) {
      throwError(state, 'ill-formed tag handle (first argument) of the TAG directive');
    }

    if (_hasOwnProperty.call(state.tagMap, handle)) {
      throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
    }

    if (!PATTERN_TAG_URI.test(prefix)) {
      throwError(state, 'ill-formed tag prefix (second argument) of the TAG directive');
    }

    state.tagMap[handle] = prefix;
  }
};


function captureSegment(state, start, end, checkJson) {
  var _position, _length, _character, _result;

  if (start < end) {
    _result = state.input.slice(start, end);

    if (checkJson) {
      for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
        _character = _result.charCodeAt(_position);
        if (!(_character === 0x09 ||
              (0x20 <= _character && _character <= 0x10FFFF))) {
          throwError(state, 'expected valid JSON character');
        }
      }
    } else if (PATTERN_NON_PRINTABLE.test(_result)) {
      throwError(state, 'the stream contains non-printable characters');
    }

    state.result += _result;
  }
}

function mergeMappings(state, destination, source, overridableKeys) {
  var sourceKeys, key, index, quantity;

  if (!common.isObject(source)) {
    throwError(state, 'cannot merge mappings; the provided source object is unacceptable');
  }

  sourceKeys = Object.keys(source);

  for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
    key = sourceKeys[index];

    if (!_hasOwnProperty.call(destination, key)) {
      destination[key] = source[key];
      overridableKeys[key] = true;
    }
  }
}

function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startPos) {
  var index, quantity;

  // The output is a plain object here, so keys can only be strings.
  // We need to convert keyNode to a string, but doing so can hang the process
  // (deeply nested arrays that explode exponentially using aliases).
  if (Array.isArray(keyNode)) {
    keyNode = Array.prototype.slice.call(keyNode);

    for (index = 0, quantity = keyNode.length; index < quantity; index += 1) {
      if (Array.isArray(keyNode[index])) {
        throwError(state, 'nested arrays are not supported inside keys');
      }

      if (typeof keyNode === 'object' && _class(keyNode[index]) === '[object Object]') {
        keyNode[index] = '[object Object]';
      }
    }
  }

  // Avoid code execution in load() via toString property
  // (still use its own toString for arrays, timestamps,
  // and whatever user schema extensions happen to have @@toStringTag)
  if (typeof keyNode === 'object' && _class(keyNode) === '[object Object]') {
    keyNode = '[object Object]';
  }


  keyNode = String(keyNode);

  if (_result === null) {
    _result = {};
  }

  if (keyTag === 'tag:yaml.org,2002:merge') {
    if (Array.isArray(valueNode)) {
      for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {
        mergeMappings(state, _result, valueNode[index], overridableKeys);
      }
    } else {
      mergeMappings(state, _result, valueNode, overridableKeys);
    }
  } else {
    if (!state.json &&
        !_hasOwnProperty.call(overridableKeys, keyNode) &&
        _hasOwnProperty.call(_result, keyNode)) {
      state.line = startLine || state.line;
      state.position = startPos || state.position;
      throwError(state, 'duplicated mapping key');
    }
    _result[keyNode] = valueNode;
    delete overridableKeys[keyNode];
  }

  return _result;
}

function readLineBreak(state) {
  var ch;

  ch = state.input.charCodeAt(state.position);

  if (ch === 0x0A/* LF */) {
    state.position++;
  } else if (ch === 0x0D/* CR */) {
    state.position++;
    if (state.input.charCodeAt(state.position) === 0x0A/* LF */) {
      state.position++;
    }
  } else {
    throwError(state, 'a line break is expected');
  }

  state.line += 1;
  state.lineStart = state.position;
}

function skipSeparationSpace(state, allowComments, checkIndent) {
  var lineBreaks = 0,
      ch = state.input.charCodeAt(state.position);

  while (ch !== 0) {
    while (is_WHITE_SPACE(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }

    if (allowComments && ch === 0x23/* # */) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (ch !== 0x0A/* LF */ && ch !== 0x0D/* CR */ && ch !== 0);
    }

    if (is_EOL(ch)) {
      readLineBreak(state);

      ch = state.input.charCodeAt(state.position);
      lineBreaks++;
      state.lineIndent = 0;

      while (ch === 0x20/* Space */) {
        state.lineIndent++;
        ch = state.input.charCodeAt(++state.position);
      }
    } else {
      break;
    }
  }

  if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
    throwWarning(state, 'deficient indentation');
  }

  return lineBreaks;
}

function testDocumentSeparator(state) {
  var _position = state.position,
      ch;

  ch = state.input.charCodeAt(_position);

  // Condition state.position === state.lineStart is tested
  // in parent on each call, for efficiency. No needs to test here again.
  if ((ch === 0x2D/* - */ || ch === 0x2E/* . */) &&
      ch === state.input.charCodeAt(_position + 1) &&
      ch === state.input.charCodeAt(_position + 2)) {

    _position += 3;

    ch = state.input.charCodeAt(_position);

    if (ch === 0 || is_WS_OR_EOL(ch)) {
      return true;
    }
  }

  return false;
}

function writeFoldedLines(state, count) {
  if (count === 1) {
    state.result += ' ';
  } else if (count > 1) {
    state.result += common.repeat('\n', count - 1);
  }
}


function readPlainScalar(state, nodeIndent, withinFlowCollection) {
  var preceding,
      following,
      captureStart,
      captureEnd,
      hasPendingContent,
      _line,
      _lineStart,
      _lineIndent,
      _kind = state.kind,
      _result = state.result,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (is_WS_OR_EOL(ch)      ||
      is_FLOW_INDICATOR(ch) ||
      ch === 0x23/* # */    ||
      ch === 0x26/* & */    ||
      ch === 0x2A/* * */    ||
      ch === 0x21/* ! */    ||
      ch === 0x7C/* | */    ||
      ch === 0x3E/* > */    ||
      ch === 0x27/* ' */    ||
      ch === 0x22/* " */    ||
      ch === 0x25/* % */    ||
      ch === 0x40/* @ */    ||
      ch === 0x60/* ` */) {
    return false;
  }

  if (ch === 0x3F/* ? */ || ch === 0x2D/* - */) {
    following = state.input.charCodeAt(state.position + 1);

    if (is_WS_OR_EOL(following) ||
        withinFlowCollection && is_FLOW_INDICATOR(following)) {
      return false;
    }
  }

  state.kind = 'scalar';
  state.result = '';
  captureStart = captureEnd = state.position;
  hasPendingContent = false;

  while (ch !== 0) {
    if (ch === 0x3A/* : */) {
      following = state.input.charCodeAt(state.position + 1);

      if (is_WS_OR_EOL(following) ||
          withinFlowCollection && is_FLOW_INDICATOR(following)) {
        break;
      }

    } else if (ch === 0x23/* # */) {
      preceding = state.input.charCodeAt(state.position - 1);

      if (is_WS_OR_EOL(preceding)) {
        break;
      }

    } else if ((state.position === state.lineStart && testDocumentSeparator(state)) ||
               withinFlowCollection && is_FLOW_INDICATOR(ch)) {
      break;

    } else if (is_EOL(ch)) {
      _line = state.line;
      _lineStart = state.lineStart;
      _lineIndent = state.lineIndent;
      skipSeparationSpace(state, false, -1);

      if (state.lineIndent >= nodeIndent) {
        hasPendingContent = true;
        ch = state.input.charCodeAt(state.position);
        continue;
      } else {
        state.position = captureEnd;
        state.line = _line;
        state.lineStart = _lineStart;
        state.lineIndent = _lineIndent;
        break;
      }
    }

    if (hasPendingContent) {
      captureSegment(state, captureStart, captureEnd, false);
      writeFoldedLines(state, state.line - _line);
      captureStart = captureEnd = state.position;
      hasPendingContent = false;
    }

    if (!is_WHITE_SPACE(ch)) {
      captureEnd = state.position + 1;
    }

    ch = state.input.charCodeAt(++state.position);
  }

  captureSegment(state, captureStart, captureEnd, false);

  if (state.result) {
    return true;
  }

  state.kind = _kind;
  state.result = _result;
  return false;
}

function readSingleQuotedScalar(state, nodeIndent) {
  var ch,
      captureStart, captureEnd;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x27/* ' */) {
    return false;
  }

  state.kind = 'scalar';
  state.result = '';
  state.position++;
  captureStart = captureEnd = state.position;

  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 0x27/* ' */) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);

      if (ch === 0x27/* ' */) {
        captureStart = state.position;
        state.position++;
        captureEnd = state.position;
      } else {
        return true;
      }

    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;

    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, 'unexpected end of the document within a single quoted scalar');

    } else {
      state.position++;
      captureEnd = state.position;
    }
  }

  throwError(state, 'unexpected end of the stream within a single quoted scalar');
}

function readDoubleQuotedScalar(state, nodeIndent) {
  var captureStart,
      captureEnd,
      hexLength,
      hexResult,
      tmp,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x22/* " */) {
    return false;
  }

  state.kind = 'scalar';
  state.result = '';
  state.position++;
  captureStart = captureEnd = state.position;

  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 0x22/* " */) {
      captureSegment(state, captureStart, state.position, true);
      state.position++;
      return true;

    } else if (ch === 0x5C/* \ */) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);

      if (is_EOL(ch)) {
        skipSeparationSpace(state, false, nodeIndent);

        // TODO: rework to inline fn with no type cast?
      } else if (ch < 256 && simpleEscapeCheck[ch]) {
        state.result += simpleEscapeMap[ch];
        state.position++;

      } else if ((tmp = escapedHexLen(ch)) > 0) {
        hexLength = tmp;
        hexResult = 0;

        for (; hexLength > 0; hexLength--) {
          ch = state.input.charCodeAt(++state.position);

          if ((tmp = fromHexCode(ch)) >= 0) {
            hexResult = (hexResult << 4) + tmp;

          } else {
            throwError(state, 'expected hexadecimal character');
          }
        }

        state.result += charFromCodepoint(hexResult);

        state.position++;

      } else {
        throwError(state, 'unknown escape sequence');
      }

      captureStart = captureEnd = state.position;

    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;

    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, 'unexpected end of the document within a double quoted scalar');

    } else {
      state.position++;
      captureEnd = state.position;
    }
  }

  throwError(state, 'unexpected end of the stream within a double quoted scalar');
}

function readFlowCollection(state, nodeIndent) {
  var readNext = true,
      _line,
      _tag     = state.tag,
      _result,
      _anchor  = state.anchor,
      following,
      terminator,
      isPair,
      isExplicitPair,
      isMapping,
      overridableKeys = {},
      keyNode,
      keyTag,
      valueNode,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch === 0x5B/* [ */) {
    terminator = 0x5D;/* ] */
    isMapping = false;
    _result = [];
  } else if (ch === 0x7B/* { */) {
    terminator = 0x7D;/* } */
    isMapping = true;
    _result = {};
  } else {
    return false;
  }

  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }

  ch = state.input.charCodeAt(++state.position);

  while (ch !== 0) {
    skipSeparationSpace(state, true, nodeIndent);

    ch = state.input.charCodeAt(state.position);

    if (ch === terminator) {
      state.position++;
      state.tag = _tag;
      state.anchor = _anchor;
      state.kind = isMapping ? 'mapping' : 'sequence';
      state.result = _result;
      return true;
    } else if (!readNext) {
      throwError(state, 'missed comma between flow collection entries');
    }

    keyTag = keyNode = valueNode = null;
    isPair = isExplicitPair = false;

    if (ch === 0x3F/* ? */) {
      following = state.input.charCodeAt(state.position + 1);

      if (is_WS_OR_EOL(following)) {
        isPair = isExplicitPair = true;
        state.position++;
        skipSeparationSpace(state, true, nodeIndent);
      }
    }

    _line = state.line;
    composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
    keyTag = state.tag;
    keyNode = state.result;
    skipSeparationSpace(state, true, nodeIndent);

    ch = state.input.charCodeAt(state.position);

    if ((isExplicitPair || state.line === _line) && ch === 0x3A/* : */) {
      isPair = true;
      ch = state.input.charCodeAt(++state.position);
      skipSeparationSpace(state, true, nodeIndent);
      composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
      valueNode = state.result;
    }

    if (isMapping) {
      storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode);
    } else if (isPair) {
      _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode));
    } else {
      _result.push(keyNode);
    }

    skipSeparationSpace(state, true, nodeIndent);

    ch = state.input.charCodeAt(state.position);

    if (ch === 0x2C/* , */) {
      readNext = true;
      ch = state.input.charCodeAt(++state.position);
    } else {
      readNext = false;
    }
  }

  throwError(state, 'unexpected end of the stream within a flow collection');
}

function readBlockScalar(state, nodeIndent) {
  var captureStart,
      folding,
      chomping       = CHOMPING_CLIP,
      didReadContent = false,
      detectedIndent = false,
      textIndent     = nodeIndent,
      emptyLines     = 0,
      atMoreIndented = false,
      tmp,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch === 0x7C/* | */) {
    folding = false;
  } else if (ch === 0x3E/* > */) {
    folding = true;
  } else {
    return false;
  }

  state.kind = 'scalar';
  state.result = '';

  while (ch !== 0) {
    ch = state.input.charCodeAt(++state.position);

    if (ch === 0x2B/* + */ || ch === 0x2D/* - */) {
      if (CHOMPING_CLIP === chomping) {
        chomping = (ch === 0x2B/* + */) ? CHOMPING_KEEP : CHOMPING_STRIP;
      } else {
        throwError(state, 'repeat of a chomping mode identifier');
      }

    } else if ((tmp = fromDecimalCode(ch)) >= 0) {
      if (tmp === 0) {
        throwError(state, 'bad explicit indentation width of a block scalar; it cannot be less than one');
      } else if (!detectedIndent) {
        textIndent = nodeIndent + tmp - 1;
        detectedIndent = true;
      } else {
        throwError(state, 'repeat of an indentation width identifier');
      }

    } else {
      break;
    }
  }

  if (is_WHITE_SPACE(ch)) {
    do { ch = state.input.charCodeAt(++state.position); }
    while (is_WHITE_SPACE(ch));

    if (ch === 0x23/* # */) {
      do { ch = state.input.charCodeAt(++state.position); }
      while (!is_EOL(ch) && (ch !== 0));
    }
  }

  while (ch !== 0) {
    readLineBreak(state);
    state.lineIndent = 0;

    ch = state.input.charCodeAt(state.position);

    while ((!detectedIndent || state.lineIndent < textIndent) &&
           (ch === 0x20/* Space */)) {
      state.lineIndent++;
      ch = state.input.charCodeAt(++state.position);
    }

    if (!detectedIndent && state.lineIndent > textIndent) {
      textIndent = state.lineIndent;
    }

    if (is_EOL(ch)) {
      emptyLines++;
      continue;
    }

    // End of the scalar.
    if (state.lineIndent < textIndent) {

      // Perform the chomping.
      if (chomping === CHOMPING_KEEP) {
        state.result += common.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);
      } else if (chomping === CHOMPING_CLIP) {
        if (didReadContent) { // i.e. only if the scalar is not empty.
          state.result += '\n';
        }
      }

      // Break this `while` cycle and go to the funciton's epilogue.
      break;
    }

    // Folded style: use fancy rules to handle line breaks.
    if (folding) {

      // Lines starting with white space characters (more-indented lines) are not folded.
      if (is_WHITE_SPACE(ch)) {
        atMoreIndented = true;
        // except for the first content line (cf. Example 8.1)
        state.result += common.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);

      // End of more-indented block.
      } else if (atMoreIndented) {
        atMoreIndented = false;
        state.result += common.repeat('\n', emptyLines + 1);

      // Just one line break - perceive as the same line.
      } else if (emptyLines === 0) {
        if (didReadContent) { // i.e. only if we have already read some scalar content.
          state.result += ' ';
        }

      // Several line breaks - perceive as different lines.
      } else {
        state.result += common.repeat('\n', emptyLines);
      }

    // Literal style: just add exact number of line breaks between content lines.
    } else {
      // Keep all line breaks except the header line break.
      state.result += common.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);
    }

    didReadContent = true;
    detectedIndent = true;
    emptyLines = 0;
    captureStart = state.position;

    while (!is_EOL(ch) && (ch !== 0)) {
      ch = state.input.charCodeAt(++state.position);
    }

    captureSegment(state, captureStart, state.position, false);
  }

  return true;
}

function readBlockSequence(state, nodeIndent) {
  var _line,
      _tag      = state.tag,
      _anchor   = state.anchor,
      _result   = [],
      following,
      detected  = false,
      ch;

  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }

  ch = state.input.charCodeAt(state.position);

  while (ch !== 0) {

    if (ch !== 0x2D/* - */) {
      break;
    }

    following = state.input.charCodeAt(state.position + 1);

    if (!is_WS_OR_EOL(following)) {
      break;
    }

    detected = true;
    state.position++;

    if (skipSeparationSpace(state, true, -1)) {
      if (state.lineIndent <= nodeIndent) {
        _result.push(null);
        ch = state.input.charCodeAt(state.position);
        continue;
      }
    }

    _line = state.line;
    composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
    _result.push(state.result);
    skipSeparationSpace(state, true, -1);

    ch = state.input.charCodeAt(state.position);

    if ((state.line === _line || state.lineIndent > nodeIndent) && (ch !== 0)) {
      throwError(state, 'bad indentation of a sequence entry');
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }

  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = 'sequence';
    state.result = _result;
    return true;
  }
  return false;
}

function readBlockMapping(state, nodeIndent, flowIndent) {
  var following,
      allowCompact,
      _line,
      _pos,
      _tag          = state.tag,
      _anchor       = state.anchor,
      _result       = {},
      overridableKeys = {},
      keyTag        = null,
      keyNode       = null,
      valueNode     = null,
      atExplicitKey = false,
      detected      = false,
      ch;

  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }

  ch = state.input.charCodeAt(state.position);

  while (ch !== 0) {
    following = state.input.charCodeAt(state.position + 1);
    _line = state.line; // Save the current line.
    _pos = state.position;

    //
    // Explicit notation case. There are two separate blocks:
    // first for the key (denoted by "?") and second for the value (denoted by ":")
    //
    if ((ch === 0x3F/* ? */ || ch === 0x3A/* : */) && is_WS_OR_EOL(following)) {

      if (ch === 0x3F/* ? */) {
        if (atExplicitKey) {
          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
          keyTag = keyNode = valueNode = null;
        }

        detected = true;
        atExplicitKey = true;
        allowCompact = true;

      } else if (atExplicitKey) {
        // i.e. 0x3A/* : */ === character after the explicit key.
        atExplicitKey = false;
        allowCompact = true;

      } else {
        throwError(state, 'incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line');
      }

      state.position += 1;
      ch = following;

    //
    // Implicit notation case. Flow-style node as the key first, then ":", and the value.
    //
    } else if (composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {

      if (state.line === _line) {
        ch = state.input.charCodeAt(state.position);

        while (is_WHITE_SPACE(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }

        if (ch === 0x3A/* : */) {
          ch = state.input.charCodeAt(++state.position);

          if (!is_WS_OR_EOL(ch)) {
            throwError(state, 'a whitespace character is expected after the key-value separator within a block mapping');
          }

          if (atExplicitKey) {
            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
            keyTag = keyNode = valueNode = null;
          }

          detected = true;
          atExplicitKey = false;
          allowCompact = false;
          keyTag = state.tag;
          keyNode = state.result;

        } else if (detected) {
          throwError(state, 'can not read an implicit mapping pair; a colon is missed');

        } else {
          state.tag = _tag;
          state.anchor = _anchor;
          return true; // Keep the result of `composeNode`.
        }

      } else if (detected) {
        throwError(state, 'can not read a block mapping entry; a multiline key may not be an implicit key');

      } else {
        state.tag = _tag;
        state.anchor = _anchor;
        return true; // Keep the result of `composeNode`.
      }

    } else {
      break; // Reading is done. Go to the epilogue.
    }

    //
    // Common reading code for both explicit and implicit notations.
    //
    if (state.line === _line || state.lineIndent > nodeIndent) {
      if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
        if (atExplicitKey) {
          keyNode = state.result;
        } else {
          valueNode = state.result;
        }
      }

      if (!atExplicitKey) {
        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _pos);
        keyTag = keyNode = valueNode = null;
      }

      skipSeparationSpace(state, true, -1);
      ch = state.input.charCodeAt(state.position);
    }

    if (state.lineIndent > nodeIndent && (ch !== 0)) {
      throwError(state, 'bad indentation of a mapping entry');
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }

  //
  // Epilogue.
  //

  // Special case: last mapping's node contains only the key in explicit notation.
  if (atExplicitKey) {
    storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
  }

  // Expose the resulting mapping.
  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = 'mapping';
    state.result = _result;
  }

  return detected;
}

function readTagProperty(state) {
  var _position,
      isVerbatim = false,
      isNamed    = false,
      tagHandle,
      tagName,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x21/* ! */) return false;

  if (state.tag !== null) {
    throwError(state, 'duplication of a tag property');
  }

  ch = state.input.charCodeAt(++state.position);

  if (ch === 0x3C/* < */) {
    isVerbatim = true;
    ch = state.input.charCodeAt(++state.position);

  } else if (ch === 0x21/* ! */) {
    isNamed = true;
    tagHandle = '!!';
    ch = state.input.charCodeAt(++state.position);

  } else {
    tagHandle = '!';
  }

  _position = state.position;

  if (isVerbatim) {
    do { ch = state.input.charCodeAt(++state.position); }
    while (ch !== 0 && ch !== 0x3E/* > */);

    if (state.position < state.length) {
      tagName = state.input.slice(_position, state.position);
      ch = state.input.charCodeAt(++state.position);
    } else {
      throwError(state, 'unexpected end of the stream within a verbatim tag');
    }
  } else {
    while (ch !== 0 && !is_WS_OR_EOL(ch)) {

      if (ch === 0x21/* ! */) {
        if (!isNamed) {
          tagHandle = state.input.slice(_position - 1, state.position + 1);

          if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
            throwError(state, 'named tag handle cannot contain such characters');
          }

          isNamed = true;
          _position = state.position + 1;
        } else {
          throwError(state, 'tag suffix cannot contain exclamation marks');
        }
      }

      ch = state.input.charCodeAt(++state.position);
    }

    tagName = state.input.slice(_position, state.position);

    if (PATTERN_FLOW_INDICATORS.test(tagName)) {
      throwError(state, 'tag suffix cannot contain flow indicator characters');
    }
  }

  if (tagName && !PATTERN_TAG_URI.test(tagName)) {
    throwError(state, 'tag name cannot contain such characters: ' + tagName);
  }

  if (isVerbatim) {
    state.tag = tagName;

  } else if (_hasOwnProperty.call(state.tagMap, tagHandle)) {
    state.tag = state.tagMap[tagHandle] + tagName;

  } else if (tagHandle === '!') {
    state.tag = '!' + tagName;

  } else if (tagHandle === '!!') {
    state.tag = 'tag:yaml.org,2002:' + tagName;

  } else {
    throwError(state, 'undeclared tag handle "' + tagHandle + '"');
  }

  return true;
}

function readAnchorProperty(state) {
  var _position,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x26/* & */) return false;

  if (state.anchor !== null) {
    throwError(state, 'duplication of an anchor property');
  }

  ch = state.input.charCodeAt(++state.position);
  _position = state.position;

  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }

  if (state.position === _position) {
    throwError(state, 'name of an anchor node must contain at least one character');
  }

  state.anchor = state.input.slice(_position, state.position);
  return true;
}

function readAlias(state) {
  var _position, alias,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x2A/* * */) return false;

  ch = state.input.charCodeAt(++state.position);
  _position = state.position;

  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }

  if (state.position === _position) {
    throwError(state, 'name of an alias node must contain at least one character');
  }

  alias = state.input.slice(_position, state.position);

  if (!_hasOwnProperty.call(state.anchorMap, alias)) {
    throwError(state, 'unidentified alias "' + alias + '"');
  }

  state.result = state.anchorMap[alias];
  skipSeparationSpace(state, true, -1);
  return true;
}

function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
  var allowBlockStyles,
      allowBlockScalars,
      allowBlockCollections,
      indentStatus = 1, // 1: this>parent, 0: this=parent, -1: this<parent
      atNewLine  = false,
      hasContent = false,
      typeIndex,
      typeQuantity,
      type,
      flowIndent,
      blockIndent;

  if (state.listener !== null) {
    state.listener('open', state);
  }

  state.tag    = null;
  state.anchor = null;
  state.kind   = null;
  state.result = null;

  allowBlockStyles = allowBlockScalars = allowBlockCollections =
    CONTEXT_BLOCK_OUT === nodeContext ||
    CONTEXT_BLOCK_IN  === nodeContext;

  if (allowToSeek) {
    if (skipSeparationSpace(state, true, -1)) {
      atNewLine = true;

      if (state.lineIndent > parentIndent) {
        indentStatus = 1;
      } else if (state.lineIndent === parentIndent) {
        indentStatus = 0;
      } else if (state.lineIndent < parentIndent) {
        indentStatus = -1;
      }
    }
  }

  if (indentStatus === 1) {
    while (readTagProperty(state) || readAnchorProperty(state)) {
      if (skipSeparationSpace(state, true, -1)) {
        atNewLine = true;
        allowBlockCollections = allowBlockStyles;

        if (state.lineIndent > parentIndent) {
          indentStatus = 1;
        } else if (state.lineIndent === parentIndent) {
          indentStatus = 0;
        } else if (state.lineIndent < parentIndent) {
          indentStatus = -1;
        }
      } else {
        allowBlockCollections = false;
      }
    }
  }

  if (allowBlockCollections) {
    allowBlockCollections = atNewLine || allowCompact;
  }

  if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
    if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
      flowIndent = parentIndent;
    } else {
      flowIndent = parentIndent + 1;
    }

    blockIndent = state.position - state.lineStart;

    if (indentStatus === 1) {
      if (allowBlockCollections &&
          (readBlockSequence(state, blockIndent) ||
           readBlockMapping(state, blockIndent, flowIndent)) ||
          readFlowCollection(state, flowIndent)) {
        hasContent = true;
      } else {
        if ((allowBlockScalars && readBlockScalar(state, flowIndent)) ||
            readSingleQuotedScalar(state, flowIndent) ||
            readDoubleQuotedScalar(state, flowIndent)) {
          hasContent = true;

        } else if (readAlias(state)) {
          hasContent = true;

          if (state.tag !== null || state.anchor !== null) {
            throwError(state, 'alias node should not have any properties');
          }

        } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
          hasContent = true;

          if (state.tag === null) {
            state.tag = '?';
          }
        }

        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    } else if (indentStatus === 0) {
      // Special case: block sequences are allowed to have same indentation level as the parent.
      // http://www.yaml.org/spec/1.2/spec.html#id2799784
      hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
    }
  }

  if (state.tag !== null && state.tag !== '!') {
    if (state.tag === '?') {
      // Implicit resolving is not allowed for non-scalar types, and '?'
      // non-specific tag is only automatically assigned to plain scalars.
      //
      // We only need to check kind conformity in case user explicitly assigns '?'
      // tag, for example like this: "!<?> [0]"
      //
      if (state.result !== null && state.kind !== 'scalar') {
        throwError(state, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state.kind + '"');
      }

      for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
        type = state.implicitTypes[typeIndex];

        if (type.resolve(state.result)) { // `state.result` updated in resolver if matched
          state.result = type.construct(state.result);
          state.tag = type.tag;
          if (state.anchor !== null) {
            state.anchorMap[state.anchor] = state.result;
          }
          break;
        }
      }
    } else if (_hasOwnProperty.call(state.typeMap[state.kind || 'fallback'], state.tag)) {
      type = state.typeMap[state.kind || 'fallback'][state.tag];

      if (state.result !== null && type.kind !== state.kind) {
        throwError(state, 'unacceptable node kind for !<' + state.tag + '> tag; it should be "' + type.kind + '", not "' + state.kind + '"');
      }

      if (!type.resolve(state.result)) { // `state.result` updated in resolver if matched
        throwError(state, 'cannot resolve a node with !<' + state.tag + '> explicit tag');
      } else {
        state.result = type.construct(state.result);
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    } else {
      throwError(state, 'unknown tag !<' + state.tag + '>');
    }
  }

  if (state.listener !== null) {
    state.listener('close', state);
  }
  return state.tag !== null ||  state.anchor !== null || hasContent;
}

function readDocument(state) {
  var documentStart = state.position,
      _position,
      directiveName,
      directiveArgs,
      hasDirectives = false,
      ch;

  state.version = null;
  state.checkLineBreaks = state.legacy;
  state.tagMap = {};
  state.anchorMap = {};

  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    skipSeparationSpace(state, true, -1);

    ch = state.input.charCodeAt(state.position);

    if (state.lineIndent > 0 || ch !== 0x25/* % */) {
      break;
    }

    hasDirectives = true;
    ch = state.input.charCodeAt(++state.position);
    _position = state.position;

    while (ch !== 0 && !is_WS_OR_EOL(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }

    directiveName = state.input.slice(_position, state.position);
    directiveArgs = [];

    if (directiveName.length < 1) {
      throwError(state, 'directive name must not be less than one character in length');
    }

    while (ch !== 0) {
      while (is_WHITE_SPACE(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }

      if (ch === 0x23/* # */) {
        do { ch = state.input.charCodeAt(++state.position); }
        while (ch !== 0 && !is_EOL(ch));
        break;
      }

      if (is_EOL(ch)) break;

      _position = state.position;

      while (ch !== 0 && !is_WS_OR_EOL(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }

      directiveArgs.push(state.input.slice(_position, state.position));
    }

    if (ch !== 0) readLineBreak(state);

    if (_hasOwnProperty.call(directiveHandlers, directiveName)) {
      directiveHandlers[directiveName](state, directiveName, directiveArgs);
    } else {
      throwWarning(state, 'unknown document directive "' + directiveName + '"');
    }
  }

  skipSeparationSpace(state, true, -1);

  if (state.lineIndent === 0 &&
      state.input.charCodeAt(state.position)     === 0x2D/* - */ &&
      state.input.charCodeAt(state.position + 1) === 0x2D/* - */ &&
      state.input.charCodeAt(state.position + 2) === 0x2D/* - */) {
    state.position += 3;
    skipSeparationSpace(state, true, -1);

  } else if (hasDirectives) {
    throwError(state, 'directives end mark is expected');
  }

  composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
  skipSeparationSpace(state, true, -1);

  if (state.checkLineBreaks &&
      PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
    throwWarning(state, 'non-ASCII line breaks are interpreted as content');
  }

  state.documents.push(state.result);

  if (state.position === state.lineStart && testDocumentSeparator(state)) {

    if (state.input.charCodeAt(state.position) === 0x2E/* . */) {
      state.position += 3;
      skipSeparationSpace(state, true, -1);
    }
    return;
  }

  if (state.position < (state.length - 1)) {
    throwError(state, 'end of the stream or a document separator is expected');
  } else {
    return;
  }
}


function loadDocuments(input, options) {
  input = String(input);
  options = options || {};

  if (input.length !== 0) {

    // Add tailing `\n` if not exists
    if (input.charCodeAt(input.length - 1) !== 0x0A/* LF */ &&
        input.charCodeAt(input.length - 1) !== 0x0D/* CR */) {
      input += '\n';
    }

    // Strip BOM
    if (input.charCodeAt(0) === 0xFEFF) {
      input = input.slice(1);
    }
  }

  var state = new State(input, options);

  var nullpos = input.indexOf('\0');

  if (nullpos !== -1) {
    state.position = nullpos;
    throwError(state, 'null byte is not allowed in input');
  }

  // Use 0 as string terminator. That significantly simplifies bounds check.
  state.input += '\0';

  while (state.input.charCodeAt(state.position) === 0x20/* Space */) {
    state.lineIndent += 1;
    state.position += 1;
  }

  while (state.position < (state.length - 1)) {
    readDocument(state);
  }

  return state.documents;
}


function loadAll(input, iterator, options) {
  if (iterator !== null && typeof iterator === 'object' && typeof options === 'undefined') {
    options = iterator;
    iterator = null;
  }

  var documents = loadDocuments(input, options);

  if (typeof iterator !== 'function') {
    return documents;
  }

  for (var index = 0, length = documents.length; index < length; index += 1) {
    iterator(documents[index]);
  }
}


function load(input, options) {
  var documents = loadDocuments(input, options);

  if (documents.length === 0) {
    /*eslint-disable no-undefined*/
    return undefined;
  } else if (documents.length === 1) {
    return documents[0];
  }
  throw new YAMLException('expected a single document in the stream, but found more');
}


function safeLoadAll(input, iterator, options) {
  if (typeof iterator === 'object' && iterator !== null && typeof options === 'undefined') {
    options = iterator;
    iterator = null;
  }

  return loadAll(input, iterator, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
}


function safeLoad(input, options) {
  return load(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
}


module.exports.loadAll     = loadAll;
module.exports.load        = load;
module.exports.safeLoadAll = safeLoadAll;
module.exports.safeLoad    = safeLoad;


/***/ }),

/***/ 3241:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {




var common = __nccwpck_require__(4206);


function Mark(name, buffer, position, line, column) {
  this.name     = name;
  this.buffer   = buffer;
  this.position = position;
  this.line     = line;
  this.column   = column;
}


Mark.prototype.getSnippet = function getSnippet(indent, maxLength) {
  var head, start, tail, end, snippet;

  if (!this.buffer) return null;

  indent = indent || 4;
  maxLength = maxLength || 75;

  head = '';
  start = this.position;

  while (start > 0 && '\x00\r\n\x85\u2028\u2029'.indexOf(this.buffer.charAt(start - 1)) === -1) {
    start -= 1;
    if (this.position - start > (maxLength / 2 - 1)) {
      head = ' ... ';
      start += 5;
      break;
    }
  }

  tail = '';
  end = this.position;

  while (end < this.buffer.length && '\x00\r\n\x85\u2028\u2029'.indexOf(this.buffer.charAt(end)) === -1) {
    end += 1;
    if (end - this.position > (maxLength / 2 - 1)) {
      tail = ' ... ';
      end -= 5;
      break;
    }
  }

  snippet = this.buffer.slice(start, end);

  return common.repeat(' ', indent) + head + snippet + tail + '\n' +
         common.repeat(' ', indent + this.position - start + head.length) + '^';
};


Mark.prototype.toString = function toString(compact) {
  var snippet, where = '';

  if (this.name) {
    where += 'in "' + this.name + '" ';
  }

  where += 'at line ' + (this.line + 1) + ', column ' + (this.column + 1);

  if (!compact) {
    snippet = this.getSnippet();

    if (snippet) {
      where += ':\n' + snippet;
    }
  }

  return where;
};


module.exports = Mark;


/***/ }),

/***/ 3487:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {



/*eslint-disable max-len*/

var common        = __nccwpck_require__(4206);
var YAMLException = __nccwpck_require__(5622);
var Type          = __nccwpck_require__(323);


function compileList(schema, name, result) {
  var exclude = [];

  schema.include.forEach(function (includedSchema) {
    result = compileList(includedSchema, name, result);
  });

  schema[name].forEach(function (currentType) {
    result.forEach(function (previousType, previousIndex) {
      if (previousType.tag === currentType.tag && previousType.kind === currentType.kind) {
        exclude.push(previousIndex);
      }
    });

    result.push(currentType);
  });

  return result.filter(function (type, index) {
    return exclude.indexOf(index) === -1;
  });
}


function compileMap(/* lists... */) {
  var result = {
        scalar: {},
        sequence: {},
        mapping: {},
        fallback: {}
      }, index, length;

  function collectType(type) {
    result[type.kind][type.tag] = result['fallback'][type.tag] = type;
  }

  for (index = 0, length = arguments.length; index < length; index += 1) {
    arguments[index].forEach(collectType);
  }
  return result;
}


function Schema(definition) {
  this.include  = definition.include  || [];
  this.implicit = definition.implicit || [];
  this.explicit = definition.explicit || [];

  this.implicit.forEach(function (type) {
    if (type.loadKind && type.loadKind !== 'scalar') {
      throw new YAMLException('There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.');
    }
  });

  this.compiledImplicit = compileList(this, 'implicit', []);
  this.compiledExplicit = compileList(this, 'explicit', []);
  this.compiledTypeMap  = compileMap(this.compiledImplicit, this.compiledExplicit);
}


Schema.DEFAULT = null;


Schema.create = function createSchema() {
  var schemas, types;

  switch (arguments.length) {
    case 1:
      schemas = Schema.DEFAULT;
      types = arguments[0];
      break;

    case 2:
      schemas = arguments[0];
      types = arguments[1];
      break;

    default:
      throw new YAMLException('Wrong number of arguments for Schema.create function');
  }

  schemas = common.toArray(schemas);
  types = common.toArray(types);

  if (!schemas.every(function (schema) { return schema instanceof Schema; })) {
    throw new YAMLException('Specified list of super schemas (or a single Schema object) contains a non-Schema object.');
  }

  if (!types.every(function (type) { return type instanceof Type; })) {
    throw new YAMLException('Specified list of YAML types (or a single Type object) contains a non-Type object.');
  }

  return new Schema({
    include: schemas,
    explicit: types
  });
};


module.exports = Schema;


/***/ }),

/***/ 5116:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

// Standard YAML's Core schema.
// http://www.yaml.org/spec/1.2/spec.html#id2804923
//
// NOTE: JS-YAML does not support schema-specific tag resolution restrictions.
// So, Core schema has no distinctions from JSON schema is JS-YAML.





var Schema = __nccwpck_require__(3487);


module.exports = new Schema({
  include: [
    __nccwpck_require__(6613)
  ]
});


/***/ }),

/***/ 948:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

// JS-YAML's default schema for `load` function.
// It is not described in the YAML specification.
//
// This schema is based on JS-YAML's default safe schema and includes
// JavaScript-specific types: !!js/undefined, !!js/regexp and !!js/function.
//
// Also this schema is used as default base schema at `Schema.create` function.





var Schema = __nccwpck_require__(3487);


module.exports = Schema.DEFAULT = new Schema({
  include: [
    __nccwpck_require__(6032)
  ],
  explicit: [
    __nccwpck_require__(9178),
    __nccwpck_require__(8953),
    __nccwpck_require__(1832)
  ]
});


/***/ }),

/***/ 6032:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

// JS-YAML's default schema for `safeLoad` function.
// It is not described in the YAML specification.
//
// This schema is based on standard YAML's Core schema and includes most of
// extra types described at YAML tag repository. (http://yaml.org/type/)





var Schema = __nccwpck_require__(3487);


module.exports = new Schema({
  include: [
    __nccwpck_require__(5116)
  ],
  implicit: [
    __nccwpck_require__(7044),
    __nccwpck_require__(112)
  ],
  explicit: [
    __nccwpck_require__(5295),
    __nccwpck_require__(7395),
    __nccwpck_require__(9117),
    __nccwpck_require__(7812)
  ]
});


/***/ }),

/***/ 6810:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

// Standard YAML's Failsafe schema.
// http://www.yaml.org/spec/1.2/spec.html#id2802346





var Schema = __nccwpck_require__(3487);


module.exports = new Schema({
  explicit: [
    __nccwpck_require__(4107),
    __nccwpck_require__(2863),
    __nccwpck_require__(4278)
  ]
});


/***/ }),

/***/ 6613:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

// Standard YAML's JSON schema.
// http://www.yaml.org/spec/1.2/spec.html#id2803231
//
// NOTE: JS-YAML does not support schema-specific tag resolution restrictions.
// So, this schema is not such strict as defined in the YAML specification.
// It allows numbers in binary notaion, use `Null` and `NULL` as `null`, etc.





var Schema = __nccwpck_require__(3487);


module.exports = new Schema({
  include: [
    __nccwpck_require__(6810)
  ],
  implicit: [
    __nccwpck_require__(7767),
    __nccwpck_require__(3066),
    __nccwpck_require__(53),
    __nccwpck_require__(3122)
  ]
});


/***/ }),

/***/ 323:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {



var YAMLException = __nccwpck_require__(5622);

var TYPE_CONSTRUCTOR_OPTIONS = [
  'kind',
  'resolve',
  'construct',
  'instanceOf',
  'predicate',
  'represent',
  'defaultStyle',
  'styleAliases'
];

var YAML_NODE_KINDS = [
  'scalar',
  'sequence',
  'mapping'
];

function compileStyleAliases(map) {
  var result = {};

  if (map !== null) {
    Object.keys(map).forEach(function (style) {
      map[style].forEach(function (alias) {
        result[String(alias)] = style;
      });
    });
  }

  return result;
}

function Type(tag, options) {
  options = options || {};

  Object.keys(options).forEach(function (name) {
    if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
      throw new YAMLException('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
    }
  });

  // TODO: Add tag format check.
  this.tag          = tag;
  this.kind         = options['kind']         || null;
  this.resolve      = options['resolve']      || function () { return true; };
  this.construct    = options['construct']    || function (data) { return data; };
  this.instanceOf   = options['instanceOf']   || null;
  this.predicate    = options['predicate']    || null;
  this.represent    = options['represent']    || null;
  this.defaultStyle = options['defaultStyle'] || null;
  this.styleAliases = compileStyleAliases(options['styleAliases'] || null);

  if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
    throw new YAMLException('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
  }
}

module.exports = Type;


/***/ }),

/***/ 5295:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {



/*eslint-disable no-bitwise*/

var NodeBuffer;

try {
  // A trick for browserified version, to not include `Buffer` shim
  var _require = __WEBPACK_EXTERNAL_createRequire(import.meta.url);
  NodeBuffer = _require('buffer').Buffer;
} catch (__) {}

var Type       = __nccwpck_require__(323);


// [ 64, 65, 66 ] -> [ padding, CR, LF ]
var BASE64_MAP = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r';


function resolveYamlBinary(data) {
  if (data === null) return false;

  var code, idx, bitlen = 0, max = data.length, map = BASE64_MAP;

  // Convert one by one.
  for (idx = 0; idx < max; idx++) {
    code = map.indexOf(data.charAt(idx));

    // Skip CR/LF
    if (code > 64) continue;

    // Fail on illegal characters
    if (code < 0) return false;

    bitlen += 6;
  }

  // If there are any bits left, source was corrupted
  return (bitlen % 8) === 0;
}

function constructYamlBinary(data) {
  var idx, tailbits,
      input = data.replace(/[\r\n=]/g, ''), // remove CR/LF & padding to simplify scan
      max = input.length,
      map = BASE64_MAP,
      bits = 0,
      result = [];

  // Collect by 6*4 bits (3 bytes)

  for (idx = 0; idx < max; idx++) {
    if ((idx % 4 === 0) && idx) {
      result.push((bits >> 16) & 0xFF);
      result.push((bits >> 8) & 0xFF);
      result.push(bits & 0xFF);
    }

    bits = (bits << 6) | map.indexOf(input.charAt(idx));
  }

  // Dump tail

  tailbits = (max % 4) * 6;

  if (tailbits === 0) {
    result.push((bits >> 16) & 0xFF);
    result.push((bits >> 8) & 0xFF);
    result.push(bits & 0xFF);
  } else if (tailbits === 18) {
    result.push((bits >> 10) & 0xFF);
    result.push((bits >> 2) & 0xFF);
  } else if (tailbits === 12) {
    result.push((bits >> 4) & 0xFF);
  }

  // Wrap into Buffer for NodeJS and leave Array for browser
  if (NodeBuffer) {
    // Support node 6.+ Buffer API when available
    return NodeBuffer.from ? NodeBuffer.from(result) : new NodeBuffer(result);
  }

  return result;
}

function representYamlBinary(object /*, style*/) {
  var result = '', bits = 0, idx, tail,
      max = object.length,
      map = BASE64_MAP;

  // Convert every three bytes to 4 ASCII characters.

  for (idx = 0; idx < max; idx++) {
    if ((idx % 3 === 0) && idx) {
      result += map[(bits >> 18) & 0x3F];
      result += map[(bits >> 12) & 0x3F];
      result += map[(bits >> 6) & 0x3F];
      result += map[bits & 0x3F];
    }

    bits = (bits << 8) + object[idx];
  }

  // Dump tail

  tail = max % 3;

  if (tail === 0) {
    result += map[(bits >> 18) & 0x3F];
    result += map[(bits >> 12) & 0x3F];
    result += map[(bits >> 6) & 0x3F];
    result += map[bits & 0x3F];
  } else if (tail === 2) {
    result += map[(bits >> 10) & 0x3F];
    result += map[(bits >> 4) & 0x3F];
    result += map[(bits << 2) & 0x3F];
    result += map[64];
  } else if (tail === 1) {
    result += map[(bits >> 2) & 0x3F];
    result += map[(bits << 4) & 0x3F];
    result += map[64];
    result += map[64];
  }

  return result;
}

function isBinary(object) {
  return NodeBuffer && NodeBuffer.isBuffer(object);
}

module.exports = new Type('tag:yaml.org,2002:binary', {
  kind: 'scalar',
  resolve: resolveYamlBinary,
  construct: constructYamlBinary,
  predicate: isBinary,
  represent: representYamlBinary
});


/***/ }),

/***/ 3066:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {



var Type = __nccwpck_require__(323);

function resolveYamlBoolean(data) {
  if (data === null) return false;

  var max = data.length;

  return (max === 4 && (data === 'true' || data === 'True' || data === 'TRUE')) ||
         (max === 5 && (data === 'false' || data === 'False' || data === 'FALSE'));
}

function constructYamlBoolean(data) {
  return data === 'true' ||
         data === 'True' ||
         data === 'TRUE';
}

function isBoolean(object) {
  return Object.prototype.toString.call(object) === '[object Boolean]';
}

module.exports = new Type('tag:yaml.org,2002:bool', {
  kind: 'scalar',
  resolve: resolveYamlBoolean,
  construct: constructYamlBoolean,
  predicate: isBoolean,
  represent: {
    lowercase: function (object) { return object ? 'true' : 'false'; },
    uppercase: function (object) { return object ? 'TRUE' : 'FALSE'; },
    camelcase: function (object) { return object ? 'True' : 'False'; }
  },
  defaultStyle: 'lowercase'
});


/***/ }),

/***/ 3122:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {



var common = __nccwpck_require__(4206);
var Type   = __nccwpck_require__(323);

var YAML_FLOAT_PATTERN = new RegExp(
  // 2.5e4, 2.5 and integers
  '^(?:[-+]?(?:0|[1-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?' +
  // .2e4, .2
  // special case, seems not from spec
  '|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?' +
  // 20:59
  '|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*' +
  // .inf
  '|[-+]?\\.(?:inf|Inf|INF)' +
  // .nan
  '|\\.(?:nan|NaN|NAN))$');

function resolveYamlFloat(data) {
  if (data === null) return false;

  if (!YAML_FLOAT_PATTERN.test(data) ||
      // Quick hack to not allow integers end with `_`
      // Probably should update regexp & check speed
      data[data.length - 1] === '_') {
    return false;
  }

  return true;
}

function constructYamlFloat(data) {
  var value, sign, base, digits;

  value  = data.replace(/_/g, '').toLowerCase();
  sign   = value[0] === '-' ? -1 : 1;
  digits = [];

  if ('+-'.indexOf(value[0]) >= 0) {
    value = value.slice(1);
  }

  if (value === '.inf') {
    return (sign === 1) ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;

  } else if (value === '.nan') {
    return NaN;

  } else if (value.indexOf(':') >= 0) {
    value.split(':').forEach(function (v) {
      digits.unshift(parseFloat(v, 10));
    });

    value = 0.0;
    base = 1;

    digits.forEach(function (d) {
      value += d * base;
      base *= 60;
    });

    return sign * value;

  }
  return sign * parseFloat(value, 10);
}


var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;

function representYamlFloat(object, style) {
  var res;

  if (isNaN(object)) {
    switch (style) {
      case 'lowercase': return '.nan';
      case 'uppercase': return '.NAN';
      case 'camelcase': return '.NaN';
    }
  } else if (Number.POSITIVE_INFINITY === object) {
    switch (style) {
      case 'lowercase': return '.inf';
      case 'uppercase': return '.INF';
      case 'camelcase': return '.Inf';
    }
  } else if (Number.NEGATIVE_INFINITY === object) {
    switch (style) {
      case 'lowercase': return '-.inf';
      case 'uppercase': return '-.INF';
      case 'camelcase': return '-.Inf';
    }
  } else if (common.isNegativeZero(object)) {
    return '-0.0';
  }

  res = object.toString(10);

  // JS stringifier can build scientific format without dots: 5e-100,
  // while YAML requres dot: 5.e-100. Fix it with simple hack

  return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace('e', '.e') : res;
}

function isFloat(object) {
  return (Object.prototype.toString.call(object) === '[object Number]') &&
         (object % 1 !== 0 || common.isNegativeZero(object));
}

module.exports = new Type('tag:yaml.org,2002:float', {
  kind: 'scalar',
  resolve: resolveYamlFloat,
  construct: constructYamlFloat,
  predicate: isFloat,
  represent: representYamlFloat,
  defaultStyle: 'lowercase'
});


/***/ }),

/***/ 53:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {



var common = __nccwpck_require__(4206);
var Type   = __nccwpck_require__(323);

function isHexCode(c) {
  return ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) ||
         ((0x41/* A */ <= c) && (c <= 0x46/* F */)) ||
         ((0x61/* a */ <= c) && (c <= 0x66/* f */));
}

function isOctCode(c) {
  return ((0x30/* 0 */ <= c) && (c <= 0x37/* 7 */));
}

function isDecCode(c) {
  return ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */));
}

function resolveYamlInteger(data) {
  if (data === null) return false;

  var max = data.length,
      index = 0,
      hasDigits = false,
      ch;

  if (!max) return false;

  ch = data[index];

  // sign
  if (ch === '-' || ch === '+') {
    ch = data[++index];
  }

  if (ch === '0') {
    // 0
    if (index + 1 === max) return true;
    ch = data[++index];

    // base 2, base 8, base 16

    if (ch === 'b') {
      // base 2
      index++;

      for (; index < max; index++) {
        ch = data[index];
        if (ch === '_') continue;
        if (ch !== '0' && ch !== '1') return false;
        hasDigits = true;
      }
      return hasDigits && ch !== '_';
    }


    if (ch === 'x') {
      // base 16
      index++;

      for (; index < max; index++) {
        ch = data[index];
        if (ch === '_') continue;
        if (!isHexCode(data.charCodeAt(index))) return false;
        hasDigits = true;
      }
      return hasDigits && ch !== '_';
    }

    // base 8
    for (; index < max; index++) {
      ch = data[index];
      if (ch === '_') continue;
      if (!isOctCode(data.charCodeAt(index))) return false;
      hasDigits = true;
    }
    return hasDigits && ch !== '_';
  }

  // base 10 (except 0) or base 60

  // value should not start with `_`;
  if (ch === '_') return false;

  for (; index < max; index++) {
    ch = data[index];
    if (ch === '_') continue;
    if (ch === ':') break;
    if (!isDecCode(data.charCodeAt(index))) {
      return false;
    }
    hasDigits = true;
  }

  // Should have digits and should not end with `_`
  if (!hasDigits || ch === '_') return false;

  // if !base60 - done;
  if (ch !== ':') return true;

  // base60 almost not used, no needs to optimize
  return /^(:[0-5]?[0-9])+$/.test(data.slice(index));
}

function constructYamlInteger(data) {
  var value = data, sign = 1, ch, base, digits = [];

  if (value.indexOf('_') !== -1) {
    value = value.replace(/_/g, '');
  }

  ch = value[0];

  if (ch === '-' || ch === '+') {
    if (ch === '-') sign = -1;
    value = value.slice(1);
    ch = value[0];
  }

  if (value === '0') return 0;

  if (ch === '0') {
    if (value[1] === 'b') return sign * parseInt(value.slice(2), 2);
    if (value[1] === 'x') return sign * parseInt(value, 16);
    return sign * parseInt(value, 8);
  }

  if (value.indexOf(':') !== -1) {
    value.split(':').forEach(function (v) {
      digits.unshift(parseInt(v, 10));
    });

    value = 0;
    base = 1;

    digits.forEach(function (d) {
      value += (d * base);
      base *= 60;
    });

    return sign * value;

  }

  return sign * parseInt(value, 10);
}

function isInteger(object) {
  return (Object.prototype.toString.call(object)) === '[object Number]' &&
         (object % 1 === 0 && !common.isNegativeZero(object));
}

module.exports = new Type('tag:yaml.org,2002:int', {
  kind: 'scalar',
  resolve: resolveYamlInteger,
  construct: constructYamlInteger,
  predicate: isInteger,
  represent: {
    binary:      function (obj) { return obj >= 0 ? '0b' + obj.toString(2) : '-0b' + obj.toString(2).slice(1); },
    octal:       function (obj) { return obj >= 0 ? '0'  + obj.toString(8) : '-0'  + obj.toString(8).slice(1); },
    decimal:     function (obj) { return obj.toString(10); },
    /* eslint-disable max-len */
    hexadecimal: function (obj) { return obj >= 0 ? '0x' + obj.toString(16).toUpperCase() :  '-0x' + obj.toString(16).toUpperCase().slice(1); }
  },
  defaultStyle: 'decimal',
  styleAliases: {
    binary:      [ 2,  'bin' ],
    octal:       [ 8,  'oct' ],
    decimal:     [ 10, 'dec' ],
    hexadecimal: [ 16, 'hex' ]
  }
});


/***/ }),

/***/ 1832:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {



var esprima;

// Browserified version does not have esprima
//
// 1. For node.js just require module as deps
// 2. For browser try to require mudule via external AMD system.
//    If not found - try to fallback to window.esprima. If not
//    found too - then fail to parse.
//
try {
  // workaround to exclude package from browserify list.
  var _require = __WEBPACK_EXTERNAL_createRequire(import.meta.url);
  esprima = _require('esprima');
} catch (_) {
  /* eslint-disable no-redeclare */
  /* global window */
  if (typeof window !== 'undefined') esprima = window.esprima;
}

var Type = __nccwpck_require__(323);

function resolveJavascriptFunction(data) {
  if (data === null) return false;

  try {
    var source = '(' + data + ')',
        ast    = esprima.parse(source, { range: true });

    if (ast.type                    !== 'Program'             ||
        ast.body.length             !== 1                     ||
        ast.body[0].type            !== 'ExpressionStatement' ||
        (ast.body[0].expression.type !== 'ArrowFunctionExpression' &&
          ast.body[0].expression.type !== 'FunctionExpression')) {
      return false;
    }

    return true;
  } catch (err) {
    return false;
  }
}

function constructJavascriptFunction(data) {
  /*jslint evil:true*/

  var source = '(' + data + ')',
      ast    = esprima.parse(source, { range: true }),
      params = [],
      body;

  if (ast.type                    !== 'Program'             ||
      ast.body.length             !== 1                     ||
      ast.body[0].type            !== 'ExpressionStatement' ||
      (ast.body[0].expression.type !== 'ArrowFunctionExpression' &&
        ast.body[0].expression.type !== 'FunctionExpression')) {
    throw new Error('Failed to resolve function');
  }

  ast.body[0].expression.params.forEach(function (param) {
    params.push(param.name);
  });

  body = ast.body[0].expression.body.range;

  // Esprima's ranges include the first '{' and the last '}' characters on
  // function expressions. So cut them out.
  if (ast.body[0].expression.body.type === 'BlockStatement') {
    /*eslint-disable no-new-func*/
    return new Function(params, source.slice(body[0] + 1, body[1] - 1));
  }
  // ES6 arrow functions can omit the BlockStatement. In that case, just return
  // the body.
  /*eslint-disable no-new-func*/
  return new Function(params, 'return ' + source.slice(body[0], body[1]));
}

function representJavascriptFunction(object /*, style*/) {
  return object.toString();
}

function isFunction(object) {
  return Object.prototype.toString.call(object) === '[object Function]';
}

module.exports = new Type('tag:yaml.org,2002:js/function', {
  kind: 'scalar',
  resolve: resolveJavascriptFunction,
  construct: constructJavascriptFunction,
  predicate: isFunction,
  represent: representJavascriptFunction
});


/***/ }),

/***/ 8953:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {



var Type = __nccwpck_require__(323);

function resolveJavascriptRegExp(data) {
  if (data === null) return false;
  if (data.length === 0) return false;

  var regexp = data,
      tail   = /\/([gim]*)$/.exec(data),
      modifiers = '';

  // if regexp starts with '/' it can have modifiers and must be properly closed
  // `/foo/gim` - modifiers tail can be maximum 3 chars
  if (regexp[0] === '/') {
    if (tail) modifiers = tail[1];

    if (modifiers.length > 3) return false;
    // if expression starts with /, is should be properly terminated
    if (regexp[regexp.length - modifiers.length - 1] !== '/') return false;
  }

  return true;
}

function constructJavascriptRegExp(data) {
  var regexp = data,
      tail   = /\/([gim]*)$/.exec(data),
      modifiers = '';

  // `/foo/gim` - tail can be maximum 4 chars
  if (regexp[0] === '/') {
    if (tail) modifiers = tail[1];
    regexp = regexp.slice(1, regexp.length - modifiers.length - 1);
  }

  return new RegExp(regexp, modifiers);
}

function representJavascriptRegExp(object /*, style*/) {
  var result = '/' + object.source + '/';

  if (object.global) result += 'g';
  if (object.multiline) result += 'm';
  if (object.ignoreCase) result += 'i';

  return result;
}

function isRegExp(object) {
  return Object.prototype.toString.call(object) === '[object RegExp]';
}

module.exports = new Type('tag:yaml.org,2002:js/regexp', {
  kind: 'scalar',
  resolve: resolveJavascriptRegExp,
  construct: constructJavascriptRegExp,
  predicate: isRegExp,
  represent: representJavascriptRegExp
});


/***/ }),

/***/ 9178:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {



var Type = __nccwpck_require__(323);

function resolveJavascriptUndefined() {
  return true;
}

function constructJavascriptUndefined() {
  /*eslint-disable no-undefined*/
  return undefined;
}

function representJavascriptUndefined() {
  return '';
}

function isUndefined(object) {
  return typeof object === 'undefined';
}

module.exports = new Type('tag:yaml.org,2002:js/undefined', {
  kind: 'scalar',
  resolve: resolveJavascriptUndefined,
  construct: constructJavascriptUndefined,
  predicate: isUndefined,
  represent: representJavascriptUndefined
});


/***/ }),

/***/ 4278:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {



var Type = __nccwpck_require__(323);

module.exports = new Type('tag:yaml.org,2002:map', {
  kind: 'mapping',
  construct: function (data) { return data !== null ? data : {}; }
});


/***/ }),

/***/ 112:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {



var Type = __nccwpck_require__(323);

function resolveYamlMerge(data) {
  return data === '<<' || data === null;
}

module.exports = new Type('tag:yaml.org,2002:merge', {
  kind: 'scalar',
  resolve: resolveYamlMerge
});


/***/ }),

/***/ 7767:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {



var Type = __nccwpck_require__(323);

function resolveYamlNull(data) {
  if (data === null) return true;

  var max = data.length;

  return (max === 1 && data === '~') ||
         (max === 4 && (data === 'null' || data === 'Null' || data === 'NULL'));
}

function constructYamlNull() {
  return null;
}

function isNull(object) {
  return object === null;
}

module.exports = new Type('tag:yaml.org,2002:null', {
  kind: 'scalar',
  resolve: resolveYamlNull,
  construct: constructYamlNull,
  predicate: isNull,
  represent: {
    canonical: function () { return '~';    },
    lowercase: function () { return 'null'; },
    uppercase: function () { return 'NULL'; },
    camelcase: function () { return 'Null'; }
  },
  defaultStyle: 'lowercase'
});


/***/ }),

/***/ 7395:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {



var Type = __nccwpck_require__(323);

var _hasOwnProperty = Object.prototype.hasOwnProperty;
var _toString       = Object.prototype.toString;

function resolveYamlOmap(data) {
  if (data === null) return true;

  var objectKeys = [], index, length, pair, pairKey, pairHasKey,
      object = data;

  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    pairHasKey = false;

    if (_toString.call(pair) !== '[object Object]') return false;

    for (pairKey in pair) {
      if (_hasOwnProperty.call(pair, pairKey)) {
        if (!pairHasKey) pairHasKey = true;
        else return false;
      }
    }

    if (!pairHasKey) return false;

    if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);
    else return false;
  }

  return true;
}

function constructYamlOmap(data) {
  return data !== null ? data : [];
}

module.exports = new Type('tag:yaml.org,2002:omap', {
  kind: 'sequence',
  resolve: resolveYamlOmap,
  construct: constructYamlOmap
});


/***/ }),

/***/ 9117:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {



var Type = __nccwpck_require__(323);

var _toString = Object.prototype.toString;

function resolveYamlPairs(data) {
  if (data === null) return true;

  var index, length, pair, keys, result,
      object = data;

  result = new Array(object.length);

  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];

    if (_toString.call(pair) !== '[object Object]') return false;

    keys = Object.keys(pair);

    if (keys.length !== 1) return false;

    result[index] = [ keys[0], pair[keys[0]] ];
  }

  return true;
}

function constructYamlPairs(data) {
  if (data === null) return [];

  var index, length, pair, keys, result,
      object = data;

  result = new Array(object.length);

  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];

    keys = Object.keys(pair);

    result[index] = [ keys[0], pair[keys[0]] ];
  }

  return result;
}

module.exports = new Type('tag:yaml.org,2002:pairs', {
  kind: 'sequence',
  resolve: resolveYamlPairs,
  construct: constructYamlPairs
});


/***/ }),

/***/ 2863:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {



var Type = __nccwpck_require__(323);

module.exports = new Type('tag:yaml.org,2002:seq', {
  kind: 'sequence',
  construct: function (data) { return data !== null ? data : []; }
});


/***/ }),

/***/ 7812:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {



var Type = __nccwpck_require__(323);

var _hasOwnProperty = Object.prototype.hasOwnProperty;

function resolveYamlSet(data) {
  if (data === null) return true;

  var key, object = data;

  for (key in object) {
    if (_hasOwnProperty.call(object, key)) {
      if (object[key] !== null) return false;
    }
  }

  return true;
}

function constructYamlSet(data) {
  return data !== null ? data : {};
}

module.exports = new Type('tag:yaml.org,2002:set', {
  kind: 'mapping',
  resolve: resolveYamlSet,
  construct: constructYamlSet
});


/***/ }),

/***/ 4107:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {



var Type = __nccwpck_require__(323);

module.exports = new Type('tag:yaml.org,2002:str', {
  kind: 'scalar',
  construct: function (data) { return data !== null ? data : ''; }
});


/***/ }),

/***/ 7044:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {



var Type = __nccwpck_require__(323);

var YAML_DATE_REGEXP = new RegExp(
  '^([0-9][0-9][0-9][0-9])'          + // [1] year
  '-([0-9][0-9])'                    + // [2] month
  '-([0-9][0-9])$');                   // [3] day

var YAML_TIMESTAMP_REGEXP = new RegExp(
  '^([0-9][0-9][0-9][0-9])'          + // [1] year
  '-([0-9][0-9]?)'                   + // [2] month
  '-([0-9][0-9]?)'                   + // [3] day
  '(?:[Tt]|[ \\t]+)'                 + // ...
  '([0-9][0-9]?)'                    + // [4] hour
  ':([0-9][0-9])'                    + // [5] minute
  ':([0-9][0-9])'                    + // [6] second
  '(?:\\.([0-9]*))?'                 + // [7] fraction
  '(?:[ \\t]*(Z|([-+])([0-9][0-9]?)' + // [8] tz [9] tz_sign [10] tz_hour
  '(?::([0-9][0-9]))?))?$');           // [11] tz_minute

function resolveYamlTimestamp(data) {
  if (data === null) return false;
  if (YAML_DATE_REGEXP.exec(data) !== null) return true;
  if (YAML_TIMESTAMP_REGEXP.exec(data) !== null) return true;
  return false;
}

function constructYamlTimestamp(data) {
  var match, year, month, day, hour, minute, second, fraction = 0,
      delta = null, tz_hour, tz_minute, date;

  match = YAML_DATE_REGEXP.exec(data);
  if (match === null) match = YAML_TIMESTAMP_REGEXP.exec(data);

  if (match === null) throw new Error('Date resolve error');

  // match: [1] year [2] month [3] day

  year = +(match[1]);
  month = +(match[2]) - 1; // JS month starts with 0
  day = +(match[3]);

  if (!match[4]) { // no hour
    return new Date(Date.UTC(year, month, day));
  }

  // match: [4] hour [5] minute [6] second [7] fraction

  hour = +(match[4]);
  minute = +(match[5]);
  second = +(match[6]);

  if (match[7]) {
    fraction = match[7].slice(0, 3);
    while (fraction.length < 3) { // milli-seconds
      fraction += '0';
    }
    fraction = +fraction;
  }

  // match: [8] tz [9] tz_sign [10] tz_hour [11] tz_minute

  if (match[9]) {
    tz_hour = +(match[10]);
    tz_minute = +(match[11] || 0);
    delta = (tz_hour * 60 + tz_minute) * 60000; // delta in mili-seconds
    if (match[9] === '-') delta = -delta;
  }

  date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));

  if (delta) date.setTime(date.getTime() - delta);

  return date;
}

function representYamlTimestamp(object /*, style*/) {
  return object.toISOString();
}

module.exports = new Type('tag:yaml.org,2002:timestamp', {
  kind: 'scalar',
  resolve: resolveYamlTimestamp,
  construct: constructYamlTimestamp,
  instanceOf: Date,
  represent: representYamlTimestamp
});


/***/ }),

/***/ 5641:
/***/ ((module) => {



/** @type {import('./abs')} */
module.exports = Math.abs;


/***/ }),

/***/ 6171:
/***/ ((module) => {



/** @type {import('./floor')} */
module.exports = Math.floor;


/***/ }),

/***/ 4663:
/***/ ((module) => {



/** @type {import('./isNaN')} */
module.exports = Number.isNaN || function isNaN(a) {
	return a !== a;
};


/***/ }),

/***/ 7147:
/***/ ((module) => {



/** @type {import('./max')} */
module.exports = Math.max;


/***/ }),

/***/ 1017:
/***/ ((module) => {



/** @type {import('./min')} */
module.exports = Math.min;


/***/ }),

/***/ 6947:
/***/ ((module) => {



/** @type {import('./pow')} */
module.exports = Math.pow;


/***/ }),

/***/ 2621:
/***/ ((module) => {



/** @type {import('./round')} */
module.exports = Math.round;


/***/ }),

/***/ 156:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {



var $isNaN = __nccwpck_require__(4663);

/** @type {import('./sign')} */
module.exports = function sign(number) {
	if ($isNaN(number) || number === 0) {
		return number;
	}
	return number < 0 ? -1 : +1;
};


/***/ }),

/***/ 9829:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

/*!
 * mime-db
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015-2022 Douglas Christopher Wilson
 * MIT Licensed
 */

/**
 * Module exports.
 */

module.exports = __nccwpck_require__(1813)


/***/ }),

/***/ 4096:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

/*!
 * mime-types
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var db = __nccwpck_require__(9829)
var extname = (__nccwpck_require__(6928).extname)

/**
 * Module variables.
 * @private
 */

var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/
var TEXT_TYPE_REGEXP = /^text\//i

/**
 * Module exports.
 * @public
 */

exports.charset = charset
exports.charsets = { lookup: charset }
exports.contentType = contentType
exports.extension = extension
exports.extensions = Object.create(null)
exports.lookup = lookup
exports.types = Object.create(null)

// Populate the extensions/types maps
populateMaps(exports.extensions, exports.types)

/**
 * Get the default charset for a MIME type.
 *
 * @param {string} type
 * @return {boolean|string}
 */

function charset (type) {
  if (!type || typeof type !== 'string') {
    return false
  }

  // TODO: use media-typer
  var match = EXTRACT_TYPE_REGEXP.exec(type)
  var mime = match && db[match[1].toLowerCase()]

  if (mime && mime.charset) {
    return mime.charset
  }

  // default text/* to utf-8
  if (match && TEXT_TYPE_REGEXP.test(match[1])) {
    return 'UTF-8'
  }

  return false
}

/**
 * Create a full Content-Type header given a MIME type or extension.
 *
 * @param {string} str
 * @return {boolean|string}
 */

function contentType (str) {
  // TODO: should this even be in this module?
  if (!str || typeof str !== 'string') {
    return false
  }

  var mime = str.indexOf('/') === -1
    ? exports.lookup(str)
    : str

  if (!mime) {
    return false
  }

  // TODO: use content-type or other module
  if (mime.indexOf('charset') === -1) {
    var charset = exports.charset(mime)
    if (charset) mime += '; charset=' + charset.toLowerCase()
  }

  return mime
}

/**
 * Get the default extension for a MIME type.
 *
 * @param {string} type
 * @return {boolean|string}
 */

function extension (type) {
  if (!type || typeof type !== 'string') {
    return false
  }

  // TODO: use media-typer
  var match = EXTRACT_TYPE_REGEXP.exec(type)

  // get extensions
  var exts = match && exports.extensions[match[1].toLowerCase()]

  if (!exts || !exts.length) {
    return false
  }

  return exts[0]
}

/**
 * Lookup the MIME type for a file path/extension.
 *
 * @param {string} path
 * @return {boolean|string}
 */

function lookup (path) {
  if (!path || typeof path !== 'string') {
    return false
  }

  // get the extension ("ext" or ".ext" or full path)
  var extension = extname('x.' + path)
    .toLowerCase()
    .substr(1)

  if (!extension) {
    return false
  }

  return exports.types[extension] || false
}

/**
 * Populate the extensions and types maps.
 * @private
 */

function populateMaps (extensions, types) {
  // source preference (least -> most)
  var preference = ['nginx', 'apache', undefined, 'iana']

  Object.keys(db).forEach(function forEachMimeType (type) {
    var mime = db[type]
    var exts = mime.extensions

    if (!exts || !exts.length) {
      return
    }

    // mime -> extensions
    extensions[type] = exts

    // extension -> mime
    for (var i = 0; i < exts.length; i++) {
      var extension = exts[i]

      if (types[extension]) {
        var from = preference.indexOf(db[types[extension]].source)
        var to = preference.indexOf(mime.source)

        if (types[extension] !== 'application/octet-stream' &&
          (from > to || (from === to && types[extension].substr(0, 12) === 'application/'))) {
          // skip the remapping
          continue
        }
      }

      // set the extension -> mime
      types[extension] = type
    }
  })
}


/***/ }),

/***/ 7666:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

/*! node-domexception. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> */

if (!globalThis.DOMException) {
  try {
    const { MessageChannel } = __nccwpck_require__(8167),
    port = new MessageChannel().port1,
    ab = new ArrayBuffer()
    port.postMessage(ab, [ab, ab])
  } catch (err) {
    err.constructor.name === 'DOMException' && (
      globalThis.DOMException = err.constructor
    )
  }
}

module.exports = globalThis.DOMException


/***/ }),

/***/ 3585:
/***/ (function(__unused_webpack_module, exports) {

/**
 * @license
 * web-streams-polyfill v3.3.3
 * Copyright 2024 Mattias Buelens, Diwank Singh Tomer and other contributors.
 * This code is released under the MIT license.
 * SPDX-License-Identifier: MIT
 */
(function (global, factory) {
     true ? factory(exports) :
    0;
})(this, (function (exports) { 'use strict';

    function noop() {
        return undefined;
    }

    function typeIsObject(x) {
        return (typeof x === 'object' && x !== null) || typeof x === 'function';
    }
    const rethrowAssertionErrorRejection = noop;
    function setFunctionName(fn, name) {
        try {
            Object.defineProperty(fn, 'name', {
                value: name,
                configurable: true
            });
        }
        catch (_a) {
            // This property is non-configurable in older browsers, so ignore if this throws.
            // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name#browser_compatibility
        }
    }

    const originalPromise = Promise;
    const originalPromiseThen = Promise.prototype.then;
    const originalPromiseReject = Promise.reject.bind(originalPromise);
    // https://webidl.spec.whatwg.org/#a-new-promise
    function newPromise(executor) {
        return new originalPromise(executor);
    }
    // https://webidl.spec.whatwg.org/#a-promise-resolved-with
    function promiseResolvedWith(value) {
        return newPromise(resolve => resolve(value));
    }
    // https://webidl.spec.whatwg.org/#a-promise-rejected-with
    function promiseRejectedWith(reason) {
        return originalPromiseReject(reason);
    }
    function PerformPromiseThen(promise, onFulfilled, onRejected) {
        // There doesn't appear to be any way to correctly emulate the behaviour from JavaScript, so this is just an
        // approximation.
        return originalPromiseThen.call(promise, onFulfilled, onRejected);
    }
    // Bluebird logs a warning when a promise is created within a fulfillment handler, but then isn't returned
    // from that handler. To prevent this, return null instead of void from all handlers.
    // http://bluebirdjs.com/docs/warning-explanations.html#warning-a-promise-was-created-in-a-handler-but-was-not-returned-from-it
    function uponPromise(promise, onFulfilled, onRejected) {
        PerformPromiseThen(PerformPromiseThen(promise, onFulfilled, onRejected), undefined, rethrowAssertionErrorRejection);
    }
    function uponFulfillment(promise, onFulfilled) {
        uponPromise(promise, onFulfilled);
    }
    function uponRejection(promise, onRejected) {
        uponPromise(promise, undefined, onRejected);
    }
    function transformPromiseWith(promise, fulfillmentHandler, rejectionHandler) {
        return PerformPromiseThen(promise, fulfillmentHandler, rejectionHandler);
    }
    function setPromiseIsHandledToTrue(promise) {
        PerformPromiseThen(promise, undefined, rethrowAssertionErrorRejection);
    }
    let _queueMicrotask = callback => {
        if (typeof queueMicrotask === 'function') {
            _queueMicrotask = queueMicrotask;
        }
        else {
            const resolvedPromise = promiseResolvedWith(undefined);
            _queueMicrotask = cb => PerformPromiseThen(resolvedPromise, cb);
        }
        return _queueMicrotask(callback);
    };
    function reflectCall(F, V, args) {
        if (typeof F !== 'function') {
            throw new TypeError('Argument is not a function');
        }
        return Function.prototype.apply.call(F, V, args);
    }
    function promiseCall(F, V, args) {
        try {
            return promiseResolvedWith(reflectCall(F, V, args));
        }
        catch (value) {
            return promiseRejectedWith(value);
        }
    }

    // Original from Chromium
    // https://chromium.googlesource.com/chromium/src/+/0aee4434a4dba42a42abaea9bfbc0cd196a63bc1/third_party/blink/renderer/core/streams/SimpleQueue.js
    const QUEUE_MAX_ARRAY_SIZE = 16384;
    /**
     * Simple queue structure.
     *
     * Avoids scalability issues with using a packed array directly by using
     * multiple arrays in a linked list and keeping the array size bounded.
     */
    class SimpleQueue {
        constructor() {
            this._cursor = 0;
            this._size = 0;
            // _front and _back are always defined.
            this._front = {
                _elements: [],
                _next: undefined
            };
            this._back = this._front;
            // The cursor is used to avoid calling Array.shift().
            // It contains the index of the front element of the array inside the
            // front-most node. It is always in the range [0, QUEUE_MAX_ARRAY_SIZE).
            this._cursor = 0;
            // When there is only one node, size === elements.length - cursor.
            this._size = 0;
        }
        get length() {
            return this._size;
        }
        // For exception safety, this method is structured in order:
        // 1. Read state
        // 2. Calculate required state mutations
        // 3. Perform state mutations
        push(element) {
            const oldBack = this._back;
            let newBack = oldBack;
            if (oldBack._elements.length === QUEUE_MAX_ARRAY_SIZE - 1) {
                newBack = {
                    _elements: [],
                    _next: undefined
                };
            }
            // push() is the mutation most likely to throw an exception, so it
            // goes first.
            oldBack._elements.push(element);
            if (newBack !== oldBack) {
                this._back = newBack;
                oldBack._next = newBack;
            }
            ++this._size;
        }
        // Like push(), shift() follows the read -> calculate -> mutate pattern for
        // exception safety.
        shift() { // must not be called on an empty queue
            const oldFront = this._front;
            let newFront = oldFront;
            const oldCursor = this._cursor;
            let newCursor = oldCursor + 1;
            const elements = oldFront._elements;
            const element = elements[oldCursor];
            if (newCursor === QUEUE_MAX_ARRAY_SIZE) {
                newFront = oldFront._next;
                newCursor = 0;
            }
            // No mutations before this point.
            --this._size;
            this._cursor = newCursor;
            if (oldFront !== newFront) {
                this._front = newFront;
            }
            // Permit shifted element to be garbage collected.
            elements[oldCursor] = undefined;
            return element;
        }
        // The tricky thing about forEach() is that it can be called
        // re-entrantly. The queue may be mutated inside the callback. It is easy to
        // see that push() within the callback has no negative effects since the end
        // of the queue is checked for on every iteration. If shift() is called
        // repeatedly within the callback then the next iteration may return an
        // element that has been removed. In this case the callback will be called
        // with undefined values until we either "catch up" with elements that still
        // exist or reach the back of the queue.
        forEach(callback) {
            let i = this._cursor;
            let node = this._front;
            let elements = node._elements;
            while (i !== elements.length || node._next !== undefined) {
                if (i === elements.length) {
                    node = node._next;
                    elements = node._elements;
                    i = 0;
                    if (elements.length === 0) {
                        break;
                    }
                }
                callback(elements[i]);
                ++i;
            }
        }
        // Return the element that would be returned if shift() was called now,
        // without modifying the queue.
        peek() { // must not be called on an empty queue
            const front = this._front;
            const cursor = this._cursor;
            return front._elements[cursor];
        }
    }

    const AbortSteps = Symbol('[[AbortSteps]]');
    const ErrorSteps = Symbol('[[ErrorSteps]]');
    const CancelSteps = Symbol('[[CancelSteps]]');
    const PullSteps = Symbol('[[PullSteps]]');
    const ReleaseSteps = Symbol('[[ReleaseSteps]]');

    function ReadableStreamReaderGenericInitialize(reader, stream) {
        reader._ownerReadableStream = stream;
        stream._reader = reader;
        if (stream._state === 'readable') {
            defaultReaderClosedPromiseInitialize(reader);
        }
        else if (stream._state === 'closed') {
            defaultReaderClosedPromiseInitializeAsResolved(reader);
        }
        else {
            defaultReaderClosedPromiseInitializeAsRejected(reader, stream._storedError);
        }
    }
    // A client of ReadableStreamDefaultReader and ReadableStreamBYOBReader may use these functions directly to bypass state
    // check.
    function ReadableStreamReaderGenericCancel(reader, reason) {
        const stream = reader._ownerReadableStream;
        return ReadableStreamCancel(stream, reason);
    }
    function ReadableStreamReaderGenericRelease(reader) {
        const stream = reader._ownerReadableStream;
        if (stream._state === 'readable') {
            defaultReaderClosedPromiseReject(reader, new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));
        }
        else {
            defaultReaderClosedPromiseResetToRejected(reader, new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));
        }
        stream._readableStreamController[ReleaseSteps]();
        stream._reader = undefined;
        reader._ownerReadableStream = undefined;
    }
    // Helper functions for the readers.
    function readerLockException(name) {
        return new TypeError('Cannot ' + name + ' a stream using a released reader');
    }
    // Helper functions for the ReadableStreamDefaultReader.
    function defaultReaderClosedPromiseInitialize(reader) {
        reader._closedPromise = newPromise((resolve, reject) => {
            reader._closedPromise_resolve = resolve;
            reader._closedPromise_reject = reject;
        });
    }
    function defaultReaderClosedPromiseInitializeAsRejected(reader, reason) {
        defaultReaderClosedPromiseInitialize(reader);
        defaultReaderClosedPromiseReject(reader, reason);
    }
    function defaultReaderClosedPromiseInitializeAsResolved(reader) {
        defaultReaderClosedPromiseInitialize(reader);
        defaultReaderClosedPromiseResolve(reader);
    }
    function defaultReaderClosedPromiseReject(reader, reason) {
        if (reader._closedPromise_reject === undefined) {
            return;
        }
        setPromiseIsHandledToTrue(reader._closedPromise);
        reader._closedPromise_reject(reason);
        reader._closedPromise_resolve = undefined;
        reader._closedPromise_reject = undefined;
    }
    function defaultReaderClosedPromiseResetToRejected(reader, reason) {
        defaultReaderClosedPromiseInitializeAsRejected(reader, reason);
    }
    function defaultReaderClosedPromiseResolve(reader) {
        if (reader._closedPromise_resolve === undefined) {
            return;
        }
        reader._closedPromise_resolve(undefined);
        reader._closedPromise_resolve = undefined;
        reader._closedPromise_reject = undefined;
    }

    /// <reference lib="es2015.core" />
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isFinite#Polyfill
    const NumberIsFinite = Number.isFinite || function (x) {
        return typeof x === 'number' && isFinite(x);
    };

    /// <reference lib="es2015.core" />
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/trunc#Polyfill
    const MathTrunc = Math.trunc || function (v) {
        return v < 0 ? Math.ceil(v) : Math.floor(v);
    };

    // https://heycam.github.io/webidl/#idl-dictionaries
    function isDictionary(x) {
        return typeof x === 'object' || typeof x === 'function';
    }
    function assertDictionary(obj, context) {
        if (obj !== undefined && !isDictionary(obj)) {
            throw new TypeError(`${context} is not an object.`);
        }
    }
    // https://heycam.github.io/webidl/#idl-callback-functions
    function assertFunction(x, context) {
        if (typeof x !== 'function') {
            throw new TypeError(`${context} is not a function.`);
        }
    }
    // https://heycam.github.io/webidl/#idl-object
    function isObject(x) {
        return (typeof x === 'object' && x !== null) || typeof x === 'function';
    }
    function assertObject(x, context) {
        if (!isObject(x)) {
            throw new TypeError(`${context} is not an object.`);
        }
    }
    function assertRequiredArgument(x, position, context) {
        if (x === undefined) {
            throw new TypeError(`Parameter ${position} is required in '${context}'.`);
        }
    }
    function assertRequiredField(x, field, context) {
        if (x === undefined) {
            throw new TypeError(`${field} is required in '${context}'.`);
        }
    }
    // https://heycam.github.io/webidl/#idl-unrestricted-double
    function convertUnrestrictedDouble(value) {
        return Number(value);
    }
    function censorNegativeZero(x) {
        return x === 0 ? 0 : x;
    }
    function integerPart(x) {
        return censorNegativeZero(MathTrunc(x));
    }
    // https://heycam.github.io/webidl/#idl-unsigned-long-long
    function convertUnsignedLongLongWithEnforceRange(value, context) {
        const lowerBound = 0;
        const upperBound = Number.MAX_SAFE_INTEGER;
        let x = Number(value);
        x = censorNegativeZero(x);
        if (!NumberIsFinite(x)) {
            throw new TypeError(`${context} is not a finite number`);
        }
        x = integerPart(x);
        if (x < lowerBound || x > upperBound) {
            throw new TypeError(`${context} is outside the accepted range of ${lowerBound} to ${upperBound}, inclusive`);
        }
        if (!NumberIsFinite(x) || x === 0) {
            return 0;
        }
        // TODO Use BigInt if supported?
        // let xBigInt = BigInt(integerPart(x));
        // xBigInt = BigInt.asUintN(64, xBigInt);
        // return Number(xBigInt);
        return x;
    }

    function assertReadableStream(x, context) {
        if (!IsReadableStream(x)) {
            throw new TypeError(`${context} is not a ReadableStream.`);
        }
    }

    // Abstract operations for the ReadableStream.
    function AcquireReadableStreamDefaultReader(stream) {
        return new ReadableStreamDefaultReader(stream);
    }
    // ReadableStream API exposed for controllers.
    function ReadableStreamAddReadRequest(stream, readRequest) {
        stream._reader._readRequests.push(readRequest);
    }
    function ReadableStreamFulfillReadRequest(stream, chunk, done) {
        const reader = stream._reader;
        const readRequest = reader._readRequests.shift();
        if (done) {
            readRequest._closeSteps();
        }
        else {
            readRequest._chunkSteps(chunk);
        }
    }
    function ReadableStreamGetNumReadRequests(stream) {
        return stream._reader._readRequests.length;
    }
    function ReadableStreamHasDefaultReader(stream) {
        const reader = stream._reader;
        if (reader === undefined) {
            return false;
        }
        if (!IsReadableStreamDefaultReader(reader)) {
            return false;
        }
        return true;
    }
    /**
     * A default reader vended by a {@link ReadableStream}.
     *
     * @public
     */
    class ReadableStreamDefaultReader {
        constructor(stream) {
            assertRequiredArgument(stream, 1, 'ReadableStreamDefaultReader');
            assertReadableStream(stream, 'First parameter');
            if (IsReadableStreamLocked(stream)) {
                throw new TypeError('This stream has already been locked for exclusive reading by another reader');
            }
            ReadableStreamReaderGenericInitialize(this, stream);
            this._readRequests = new SimpleQueue();
        }
        /**
         * Returns a promise that will be fulfilled when the stream becomes closed,
         * or rejected if the stream ever errors or the reader's lock is released before the stream finishes closing.
         */
        get closed() {
            if (!IsReadableStreamDefaultReader(this)) {
                return promiseRejectedWith(defaultReaderBrandCheckException('closed'));
            }
            return this._closedPromise;
        }
        /**
         * If the reader is active, behaves the same as {@link ReadableStream.cancel | stream.cancel(reason)}.
         */
        cancel(reason = undefined) {
            if (!IsReadableStreamDefaultReader(this)) {
                return promiseRejectedWith(defaultReaderBrandCheckException('cancel'));
            }
            if (this._ownerReadableStream === undefined) {
                return promiseRejectedWith(readerLockException('cancel'));
            }
            return ReadableStreamReaderGenericCancel(this, reason);
        }
        /**
         * Returns a promise that allows access to the next chunk from the stream's internal queue, if available.
         *
         * If reading a chunk causes the queue to become empty, more data will be pulled from the underlying source.
         */
        read() {
            if (!IsReadableStreamDefaultReader(this)) {
                return promiseRejectedWith(defaultReaderBrandCheckException('read'));
            }
            if (this._ownerReadableStream === undefined) {
                return promiseRejectedWith(readerLockException('read from'));
            }
            let resolvePromise;
            let rejectPromise;
            const promise = newPromise((resolve, reject) => {
                resolvePromise = resolve;
                rejectPromise = reject;
            });
            const readRequest = {
                _chunkSteps: chunk => resolvePromise({ value: chunk, done: false }),
                _closeSteps: () => resolvePromise({ value: undefined, done: true }),
                _errorSteps: e => rejectPromise(e)
            };
            ReadableStreamDefaultReaderRead(this, readRequest);
            return promise;
        }
        /**
         * Releases the reader's lock on the corresponding stream. After the lock is released, the reader is no longer active.
         * If the associated stream is errored when the lock is released, the reader will appear errored in the same way
         * from now on; otherwise, the reader will appear closed.
         *
         * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by
         * the reader's {@link ReadableStreamDefaultReader.read | read()} method has not yet been settled. Attempting to
         * do so will throw a `TypeError` and leave the reader locked to the stream.
         */
        releaseLock() {
            if (!IsReadableStreamDefaultReader(this)) {
                throw defaultReaderBrandCheckException('releaseLock');
            }
            if (this._ownerReadableStream === undefined) {
                return;
            }
            ReadableStreamDefaultReaderRelease(this);
        }
    }
    Object.defineProperties(ReadableStreamDefaultReader.prototype, {
        cancel: { enumerable: true },
        read: { enumerable: true },
        releaseLock: { enumerable: true },
        closed: { enumerable: true }
    });
    setFunctionName(ReadableStreamDefaultReader.prototype.cancel, 'cancel');
    setFunctionName(ReadableStreamDefaultReader.prototype.read, 'read');
    setFunctionName(ReadableStreamDefaultReader.prototype.releaseLock, 'releaseLock');
    if (typeof Symbol.toStringTag === 'symbol') {
        Object.defineProperty(ReadableStreamDefaultReader.prototype, Symbol.toStringTag, {
            value: 'ReadableStreamDefaultReader',
            configurable: true
        });
    }
    // Abstract operations for the readers.
    function IsReadableStreamDefaultReader(x) {
        if (!typeIsObject(x)) {
            return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, '_readRequests')) {
            return false;
        }
        return x instanceof ReadableStreamDefaultReader;
    }
    function ReadableStreamDefaultReaderRead(reader, readRequest) {
        const stream = reader._ownerReadableStream;
        stream._disturbed = true;
        if (stream._state === 'closed') {
            readRequest._closeSteps();
        }
        else if (stream._state === 'errored') {
            readRequest._errorSteps(stream._storedError);
        }
        else {
            stream._readableStreamController[PullSteps](readRequest);
        }
    }
    function ReadableStreamDefaultReaderRelease(reader) {
        ReadableStreamReaderGenericRelease(reader);
        const e = new TypeError('Reader was released');
        ReadableStreamDefaultReaderErrorReadRequests(reader, e);
    }
    function ReadableStreamDefaultReaderErrorReadRequests(reader, e) {
        const readRequests = reader._readRequests;
        reader._readRequests = new SimpleQueue();
        readRequests.forEach(readRequest => {
            readRequest._errorSteps(e);
        });
    }
    // Helper functions for the ReadableStreamDefaultReader.
    function defaultReaderBrandCheckException(name) {
        return new TypeError(`ReadableStreamDefaultReader.prototype.${name} can only be used on a ReadableStreamDefaultReader`);
    }

    /// <reference lib="es2018.asynciterable" />
    /* eslint-disable @typescript-eslint/no-empty-function */
    const AsyncIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf(async function* () { }).prototype);

    /// <reference lib="es2018.asynciterable" />
    class ReadableStreamAsyncIteratorImpl {
        constructor(reader, preventCancel) {
            this._ongoingPromise = undefined;
            this._isFinished = false;
            this._reader = reader;
            this._preventCancel = preventCancel;
        }
        next() {
            const nextSteps = () => this._nextSteps();
            this._ongoingPromise = this._ongoingPromise ?
                transformPromiseWith(this._ongoingPromise, nextSteps, nextSteps) :
                nextSteps();
            return this._ongoingPromise;
        }
        return(value) {
            const returnSteps = () => this._returnSteps(value);
            return this._ongoingPromise ?
                transformPromiseWith(this._ongoingPromise, returnSteps, returnSteps) :
                returnSteps();
        }
        _nextSteps() {
            if (this._isFinished) {
                return Promise.resolve({ value: undefined, done: true });
            }
            const reader = this._reader;
            let resolvePromise;
            let rejectPromise;
            const promise = newPromise((resolve, reject) => {
                resolvePromise = resolve;
                rejectPromise = reject;
            });
            const readRequest = {
                _chunkSteps: chunk => {
                    this._ongoingPromise = undefined;
                    // This needs to be delayed by one microtask, otherwise we stop pulling too early which breaks a test.
                    // FIXME Is this a bug in the specification, or in the test?
                    _queueMicrotask(() => resolvePromise({ value: chunk, done: false }));
                },
                _closeSteps: () => {
                    this._ongoingPromise = undefined;
                    this._isFinished = true;
                    ReadableStreamReaderGenericRelease(reader);
                    resolvePromise({ value: undefined, done: true });
                },
                _errorSteps: reason => {
                    this._ongoingPromise = undefined;
                    this._isFinished = true;
                    ReadableStreamReaderGenericRelease(reader);
                    rejectPromise(reason);
                }
            };
            ReadableStreamDefaultReaderRead(reader, readRequest);
            return promise;
        }
        _returnSteps(value) {
            if (this._isFinished) {
                return Promise.resolve({ value, done: true });
            }
            this._isFinished = true;
            const reader = this._reader;
            if (!this._preventCancel) {
                const result = ReadableStreamReaderGenericCancel(reader, value);
                ReadableStreamReaderGenericRelease(reader);
                return transformPromiseWith(result, () => ({ value, done: true }));
            }
            ReadableStreamReaderGenericRelease(reader);
            return promiseResolvedWith({ value, done: true });
        }
    }
    const ReadableStreamAsyncIteratorPrototype = {
        next() {
            if (!IsReadableStreamAsyncIterator(this)) {
                return promiseRejectedWith(streamAsyncIteratorBrandCheckException('next'));
            }
            return this._asyncIteratorImpl.next();
        },
        return(value) {
            if (!IsReadableStreamAsyncIterator(this)) {
                return promiseRejectedWith(streamAsyncIteratorBrandCheckException('return'));
            }
            return this._asyncIteratorImpl.return(value);
        }
    };
    Object.setPrototypeOf(ReadableStreamAsyncIteratorPrototype, AsyncIteratorPrototype);
    // Abstract operations for the ReadableStream.
    function AcquireReadableStreamAsyncIterator(stream, preventCancel) {
        const reader = AcquireReadableStreamDefaultReader(stream);
        const impl = new ReadableStreamAsyncIteratorImpl(reader, preventCancel);
        const iterator = Object.create(ReadableStreamAsyncIteratorPrototype);
        iterator._asyncIteratorImpl = impl;
        return iterator;
    }
    function IsReadableStreamAsyncIterator(x) {
        if (!typeIsObject(x)) {
            return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, '_asyncIteratorImpl')) {
            return false;
        }
        try {
            // noinspection SuspiciousTypeOfGuard
            return x._asyncIteratorImpl instanceof
                ReadableStreamAsyncIteratorImpl;
        }
        catch (_a) {
            return false;
        }
    }
    // Helper functions for the ReadableStream.
    function streamAsyncIteratorBrandCheckException(name) {
        return new TypeError(`ReadableStreamAsyncIterator.${name} can only be used on a ReadableSteamAsyncIterator`);
    }

    /// <reference lib="es2015.core" />
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN#Polyfill
    const NumberIsNaN = Number.isNaN || function (x) {
        // eslint-disable-next-line no-self-compare
        return x !== x;
    };

    var _a, _b, _c;
    function CreateArrayFromList(elements) {
        // We use arrays to represent lists, so this is basically a no-op.
        // Do a slice though just in case we happen to depend on the unique-ness.
        return elements.slice();
    }
    function CopyDataBlockBytes(dest, destOffset, src, srcOffset, n) {
        new Uint8Array(dest).set(new Uint8Array(src, srcOffset, n), destOffset);
    }
    let TransferArrayBuffer = (O) => {
        if (typeof O.transfer === 'function') {
            TransferArrayBuffer = buffer => buffer.transfer();
        }
        else if (typeof structuredClone === 'function') {
            TransferArrayBuffer = buffer => structuredClone(buffer, { transfer: [buffer] });
        }
        else {
            // Not implemented correctly
            TransferArrayBuffer = buffer => buffer;
        }
        return TransferArrayBuffer(O);
    };
    let IsDetachedBuffer = (O) => {
        if (typeof O.detached === 'boolean') {
            IsDetachedBuffer = buffer => buffer.detached;
        }
        else {
            // Not implemented correctly
            IsDetachedBuffer = buffer => buffer.byteLength === 0;
        }
        return IsDetachedBuffer(O);
    };
    function ArrayBufferSlice(buffer, begin, end) {
        // ArrayBuffer.prototype.slice is not available on IE10
        // https://www.caniuse.com/mdn-javascript_builtins_arraybuffer_slice
        if (buffer.slice) {
            return buffer.slice(begin, end);
        }
        const length = end - begin;
        const slice = new ArrayBuffer(length);
        CopyDataBlockBytes(slice, 0, buffer, begin, length);
        return slice;
    }
    function GetMethod(receiver, prop) {
        const func = receiver[prop];
        if (func === undefined || func === null) {
            return undefined;
        }
        if (typeof func !== 'function') {
            throw new TypeError(`${String(prop)} is not a function`);
        }
        return func;
    }
    function CreateAsyncFromSyncIterator(syncIteratorRecord) {
        // Instead of re-implementing CreateAsyncFromSyncIterator and %AsyncFromSyncIteratorPrototype%,
        // we use yield* inside an async generator function to achieve the same result.
        // Wrap the sync iterator inside a sync iterable, so we can use it with yield*.
        const syncIterable = {
            [Symbol.iterator]: () => syncIteratorRecord.iterator
        };
        // Create an async generator function and immediately invoke it.
        const asyncIterator = (async function* () {
            return yield* syncIterable;
        }());
        // Return as an async iterator record.
        const nextMethod = asyncIterator.next;
        return { iterator: asyncIterator, nextMethod, done: false };
    }
    // Aligns with core-js/modules/es.symbol.async-iterator.js
    const SymbolAsyncIterator = (_c = (_a = Symbol.asyncIterator) !== null && _a !== void 0 ? _a : (_b = Symbol.for) === null || _b === void 0 ? void 0 : _b.call(Symbol, 'Symbol.asyncIterator')) !== null && _c !== void 0 ? _c : '@@asyncIterator';
    function GetIterator(obj, hint = 'sync', method) {
        if (method === undefined) {
            if (hint === 'async') {
                method = GetMethod(obj, SymbolAsyncIterator);
                if (method === undefined) {
                    const syncMethod = GetMethod(obj, Symbol.iterator);
                    const syncIteratorRecord = GetIterator(obj, 'sync', syncMethod);
                    return CreateAsyncFromSyncIterator(syncIteratorRecord);
                }
            }
            else {
                method = GetMethod(obj, Symbol.iterator);
            }
        }
        if (method === undefined) {
            throw new TypeError('The object is not iterable');
        }
        const iterator = reflectCall(method, obj, []);
        if (!typeIsObject(iterator)) {
            throw new TypeError('The iterator method must return an object');
        }
        const nextMethod = iterator.next;
        return { iterator, nextMethod, done: false };
    }
    function IteratorNext(iteratorRecord) {
        const result = reflectCall(iteratorRecord.nextMethod, iteratorRecord.iterator, []);
        if (!typeIsObject(result)) {
            throw new TypeError('The iterator.next() method must return an object');
        }
        return result;
    }
    function IteratorComplete(iterResult) {
        return Boolean(iterResult.done);
    }
    function IteratorValue(iterResult) {
        return iterResult.value;
    }

    function IsNonNegativeNumber(v) {
        if (typeof v !== 'number') {
            return false;
        }
        if (NumberIsNaN(v)) {
            return false;
        }
        if (v < 0) {
            return false;
        }
        return true;
    }
    function CloneAsUint8Array(O) {
        const buffer = ArrayBufferSlice(O.buffer, O.byteOffset, O.byteOffset + O.byteLength);
        return new Uint8Array(buffer);
    }

    function DequeueValue(container) {
        const pair = container._queue.shift();
        container._queueTotalSize -= pair.size;
        if (container._queueTotalSize < 0) {
            container._queueTotalSize = 0;
        }
        return pair.value;
    }
    function EnqueueValueWithSize(container, value, size) {
        if (!IsNonNegativeNumber(size) || size === Infinity) {
            throw new RangeError('Size must be a finite, non-NaN, non-negative number.');
        }
        container._queue.push({ value, size });
        container._queueTotalSize += size;
    }
    function PeekQueueValue(container) {
        const pair = container._queue.peek();
        return pair.value;
    }
    function ResetQueue(container) {
        container._queue = new SimpleQueue();
        container._queueTotalSize = 0;
    }

    function isDataViewConstructor(ctor) {
        return ctor === DataView;
    }
    function isDataView(view) {
        return isDataViewConstructor(view.constructor);
    }
    function arrayBufferViewElementSize(ctor) {
        if (isDataViewConstructor(ctor)) {
            return 1;
        }
        return ctor.BYTES_PER_ELEMENT;
    }

    /**
     * A pull-into request in a {@link ReadableByteStreamController}.
     *
     * @public
     */
    class ReadableStreamBYOBRequest {
        constructor() {
            throw new TypeError('Illegal constructor');
        }
        /**
         * Returns the view for writing in to, or `null` if the BYOB request has already been responded to.
         */
        get view() {
            if (!IsReadableStreamBYOBRequest(this)) {
                throw byobRequestBrandCheckException('view');
            }
            return this._view;
        }
        respond(bytesWritten) {
            if (!IsReadableStreamBYOBRequest(this)) {
                throw byobRequestBrandCheckException('respond');
            }
            assertRequiredArgument(bytesWritten, 1, 'respond');
            bytesWritten = convertUnsignedLongLongWithEnforceRange(bytesWritten, 'First parameter');
            if (this._associatedReadableByteStreamController === undefined) {
                throw new TypeError('This BYOB request has been invalidated');
            }
            if (IsDetachedBuffer(this._view.buffer)) {
                throw new TypeError(`The BYOB request's buffer has been detached and so cannot be used as a response`);
            }
            ReadableByteStreamControllerRespond(this._associatedReadableByteStreamController, bytesWritten);
        }
        respondWithNewView(view) {
            if (!IsReadableStreamBYOBRequest(this)) {
                throw byobRequestBrandCheckException('respondWithNewView');
            }
            assertRequiredArgument(view, 1, 'respondWithNewView');
            if (!ArrayBuffer.isView(view)) {
                throw new TypeError('You can only respond with array buffer views');
            }
            if (this._associatedReadableByteStreamController === undefined) {
                throw new TypeError('This BYOB request has been invalidated');
            }
            if (IsDetachedBuffer(view.buffer)) {
                throw new TypeError('The given view\'s buffer has been detached and so cannot be used as a response');
            }
            ReadableByteStreamControllerRespondWithNewView(this._associatedReadableByteStreamController, view);
        }
    }
    Object.defineProperties(ReadableStreamBYOBRequest.prototype, {
        respond: { enumerable: true },
        respondWithNewView: { enumerable: true },
        view: { enumerable: true }
    });
    setFunctionName(ReadableStreamBYOBRequest.prototype.respond, 'respond');
    setFunctionName(ReadableStreamBYOBRequest.prototype.respondWithNewView, 'respondWithNewView');
    if (typeof Symbol.toStringTag === 'symbol') {
        Object.defineProperty(ReadableStreamBYOBRequest.prototype, Symbol.toStringTag, {
            value: 'ReadableStreamBYOBRequest',
            configurable: true
        });
    }
    /**
     * Allows control of a {@link ReadableStream | readable byte stream}'s state and internal queue.
     *
     * @public
     */
    class ReadableByteStreamController {
        constructor() {
            throw new TypeError('Illegal constructor');
        }
        /**
         * Returns the current BYOB pull request, or `null` if there isn't one.
         */
        get byobRequest() {
            if (!IsReadableByteStreamController(this)) {
                throw byteStreamControllerBrandCheckException('byobRequest');
            }
            return ReadableByteStreamControllerGetBYOBRequest(this);
        }
        /**
         * Returns the desired size to fill the controlled stream's internal queue. It can be negative, if the queue is
         * over-full. An underlying byte source ought to use this information to determine when and how to apply backpressure.
         */
        get desiredSize() {
            if (!IsReadableByteStreamController(this)) {
                throw byteStreamControllerBrandCheckException('desiredSize');
            }
            return ReadableByteStreamControllerGetDesiredSize(this);
        }
        /**
         * Closes the controlled readable stream. Consumers will still be able to read any previously-enqueued chunks from
         * the stream, but once those are read, the stream will become closed.
         */
        close() {
            if (!IsReadableByteStreamController(this)) {
                throw byteStreamControllerBrandCheckException('close');
            }
            if (this._closeRequested) {
                throw new TypeError('The stream has already been closed; do not close it again!');
            }
            const state = this._controlledReadableByteStream._state;
            if (state !== 'readable') {
                throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be closed`);
            }
            ReadableByteStreamControllerClose(this);
        }
        enqueue(chunk) {
            if (!IsReadableByteStreamController(this)) {
                throw byteStreamControllerBrandCheckException('enqueue');
            }
            assertRequiredArgument(chunk, 1, 'enqueue');
            if (!ArrayBuffer.isView(chunk)) {
                throw new TypeError('chunk must be an array buffer view');
            }
            if (chunk.byteLength === 0) {
                throw new TypeError('chunk must have non-zero byteLength');
            }
            if (chunk.buffer.byteLength === 0) {
                throw new TypeError(`chunk's buffer must have non-zero byteLength`);
            }
            if (this._closeRequested) {
                throw new TypeError('stream is closed or draining');
            }
            const state = this._controlledReadableByteStream._state;
            if (state !== 'readable') {
                throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be enqueued to`);
            }
            ReadableByteStreamControllerEnqueue(this, chunk);
        }
        /**
         * Errors the controlled readable stream, making all future interactions with it fail with the given error `e`.
         */
        error(e = undefined) {
            if (!IsReadableByteStreamController(this)) {
                throw byteStreamControllerBrandCheckException('error');
            }
            ReadableByteStreamControllerError(this, e);
        }
        /** @internal */
        [CancelSteps](reason) {
            ReadableByteStreamControllerClearPendingPullIntos(this);
            ResetQueue(this);
            const result = this._cancelAlgorithm(reason);
            ReadableByteStreamControllerClearAlgorithms(this);
            return result;
        }
        /** @internal */
        [PullSteps](readRequest) {
            const stream = this._controlledReadableByteStream;
            if (this._queueTotalSize > 0) {
                ReadableByteStreamControllerFillReadRequestFromQueue(this, readRequest);
                return;
            }
            const autoAllocateChunkSize = this._autoAllocateChunkSize;
            if (autoAllocateChunkSize !== undefined) {
                let buffer;
                try {
                    buffer = new ArrayBuffer(autoAllocateChunkSize);
                }
                catch (bufferE) {
                    readRequest._errorSteps(bufferE);
                    return;
                }
                const pullIntoDescriptor = {
                    buffer,
                    bufferByteLength: autoAllocateChunkSize,
                    byteOffset: 0,
                    byteLength: autoAllocateChunkSize,
                    bytesFilled: 0,
                    minimumFill: 1,
                    elementSize: 1,
                    viewConstructor: Uint8Array,
                    readerType: 'default'
                };
                this._pendingPullIntos.push(pullIntoDescriptor);
            }
            ReadableStreamAddReadRequest(stream, readRequest);
            ReadableByteStreamControllerCallPullIfNeeded(this);
        }
        /** @internal */
        [ReleaseSteps]() {
            if (this._pendingPullIntos.length > 0) {
                const firstPullInto = this._pendingPullIntos.peek();
                firstPullInto.readerType = 'none';
                this._pendingPullIntos = new SimpleQueue();
                this._pendingPullIntos.push(firstPullInto);
            }
        }
    }
    Object.defineProperties(ReadableByteStreamController.prototype, {
        close: { enumerable: true },
        enqueue: { enumerable: true },
        error: { enumerable: true },
        byobRequest: { enumerable: true },
        desiredSize: { enumerable: true }
    });
    setFunctionName(ReadableByteStreamController.prototype.close, 'close');
    setFunctionName(ReadableByteStreamController.prototype.enqueue, 'enqueue');
    setFunctionName(ReadableByteStreamController.prototype.error, 'error');
    if (typeof Symbol.toStringTag === 'symbol') {
        Object.defineProperty(ReadableByteStreamController.prototype, Symbol.toStringTag, {
            value: 'ReadableByteStreamController',
            configurable: true
        });
    }
    // Abstract operations for the ReadableByteStreamController.
    function IsReadableByteStreamController(x) {
        if (!typeIsObject(x)) {
            return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, '_controlledReadableByteStream')) {
            return false;
        }
        return x instanceof ReadableByteStreamController;
    }
    function IsReadableStreamBYOBRequest(x) {
        if (!typeIsObject(x)) {
            return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, '_associatedReadableByteStreamController')) {
            return false;
        }
        return x instanceof ReadableStreamBYOBRequest;
    }
    function ReadableByteStreamControllerCallPullIfNeeded(controller) {
        const shouldPull = ReadableByteStreamControllerShouldCallPull(controller);
        if (!shouldPull) {
            return;
        }
        if (controller._pulling) {
            controller._pullAgain = true;
            return;
        }
        controller._pulling = true;
        // TODO: Test controller argument
        const pullPromise = controller._pullAlgorithm();
        uponPromise(pullPromise, () => {
            controller._pulling = false;
            if (controller._pullAgain) {
                controller._pullAgain = false;
                ReadableByteStreamControllerCallPullIfNeeded(controller);
            }
            return null;
        }, e => {
            ReadableByteStreamControllerError(controller, e);
            return null;
        });
    }
    function ReadableByteStreamControllerClearPendingPullIntos(controller) {
        ReadableByteStreamControllerInvalidateBYOBRequest(controller);
        controller._pendingPullIntos = new SimpleQueue();
    }
    function ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor) {
        let done = false;
        if (stream._state === 'closed') {
            done = true;
        }
        const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
        if (pullIntoDescriptor.readerType === 'default') {
            ReadableStreamFulfillReadRequest(stream, filledView, done);
        }
        else {
            ReadableStreamFulfillReadIntoRequest(stream, filledView, done);
        }
    }
    function ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor) {
        const bytesFilled = pullIntoDescriptor.bytesFilled;
        const elementSize = pullIntoDescriptor.elementSize;
        return new pullIntoDescriptor.viewConstructor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, bytesFilled / elementSize);
    }
    function ReadableByteStreamControllerEnqueueChunkToQueue(controller, buffer, byteOffset, byteLength) {
        controller._queue.push({ buffer, byteOffset, byteLength });
        controller._queueTotalSize += byteLength;
    }
    function ReadableByteStreamControllerEnqueueClonedChunkToQueue(controller, buffer, byteOffset, byteLength) {
        let clonedChunk;
        try {
            clonedChunk = ArrayBufferSlice(buffer, byteOffset, byteOffset + byteLength);
        }
        catch (cloneE) {
            ReadableByteStreamControllerError(controller, cloneE);
            throw cloneE;
        }
        ReadableByteStreamControllerEnqueueChunkToQueue(controller, clonedChunk, 0, byteLength);
    }
    function ReadableByteStreamControllerEnqueueDetachedPullIntoToQueue(controller, firstDescriptor) {
        if (firstDescriptor.bytesFilled > 0) {
            ReadableByteStreamControllerEnqueueClonedChunkToQueue(controller, firstDescriptor.buffer, firstDescriptor.byteOffset, firstDescriptor.bytesFilled);
        }
        ReadableByteStreamControllerShiftPendingPullInto(controller);
    }
    function ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) {
        const maxBytesToCopy = Math.min(controller._queueTotalSize, pullIntoDescriptor.byteLength - pullIntoDescriptor.bytesFilled);
        const maxBytesFilled = pullIntoDescriptor.bytesFilled + maxBytesToCopy;
        let totalBytesToCopyRemaining = maxBytesToCopy;
        let ready = false;
        const remainderBytes = maxBytesFilled % pullIntoDescriptor.elementSize;
        const maxAlignedBytes = maxBytesFilled - remainderBytes;
        // A descriptor for a read() request that is not yet filled up to its minimum length will stay at the head
        // of the queue, so the underlying source can keep filling it.
        if (maxAlignedBytes >= pullIntoDescriptor.minimumFill) {
            totalBytesToCopyRemaining = maxAlignedBytes - pullIntoDescriptor.bytesFilled;
            ready = true;
        }
        const queue = controller._queue;
        while (totalBytesToCopyRemaining > 0) {
            const headOfQueue = queue.peek();
            const bytesToCopy = Math.min(totalBytesToCopyRemaining, headOfQueue.byteLength);
            const destStart = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;
            CopyDataBlockBytes(pullIntoDescriptor.buffer, destStart, headOfQueue.buffer, headOfQueue.byteOffset, bytesToCopy);
            if (headOfQueue.byteLength === bytesToCopy) {
                queue.shift();
            }
            else {
                headOfQueue.byteOffset += bytesToCopy;
                headOfQueue.byteLength -= bytesToCopy;
            }
            controller._queueTotalSize -= bytesToCopy;
            ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesToCopy, pullIntoDescriptor);
            totalBytesToCopyRemaining -= bytesToCopy;
        }
        return ready;
    }
    function ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, size, pullIntoDescriptor) {
        pullIntoDescriptor.bytesFilled += size;
    }
    function ReadableByteStreamControllerHandleQueueDrain(controller) {
        if (controller._queueTotalSize === 0 && controller._closeRequested) {
            ReadableByteStreamControllerClearAlgorithms(controller);
            ReadableStreamClose(controller._controlledReadableByteStream);
        }
        else {
            ReadableByteStreamControllerCallPullIfNeeded(controller);
        }
    }
    function ReadableByteStreamControllerInvalidateBYOBRequest(controller) {
        if (controller._byobRequest === null) {
            return;
        }
        controller._byobRequest._associatedReadableByteStreamController = undefined;
        controller._byobRequest._view = null;
        controller._byobRequest = null;
    }
    function ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller) {
        while (controller._pendingPullIntos.length > 0) {
            if (controller._queueTotalSize === 0) {
                return;
            }
            const pullIntoDescriptor = controller._pendingPullIntos.peek();
            if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {
                ReadableByteStreamControllerShiftPendingPullInto(controller);
                ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);
            }
        }
    }
    function ReadableByteStreamControllerProcessReadRequestsUsingQueue(controller) {
        const reader = controller._controlledReadableByteStream._reader;
        while (reader._readRequests.length > 0) {
            if (controller._queueTotalSize === 0) {
                return;
            }
            const readRequest = reader._readRequests.shift();
            ReadableByteStreamControllerFillReadRequestFromQueue(controller, readRequest);
        }
    }
    function ReadableByteStreamControllerPullInto(controller, view, min, readIntoRequest) {
        const stream = controller._controlledReadableByteStream;
        const ctor = view.constructor;
        const elementSize = arrayBufferViewElementSize(ctor);
        const { byteOffset, byteLength } = view;
        const minimumFill = min * elementSize;
        let buffer;
        try {
            buffer = TransferArrayBuffer(view.buffer);
        }
        catch (e) {
            readIntoRequest._errorSteps(e);
            return;
        }
        const pullIntoDescriptor = {
            buffer,
            bufferByteLength: buffer.byteLength,
            byteOffset,
            byteLength,
            bytesFilled: 0,
            minimumFill,
            elementSize,
            viewConstructor: ctor,
            readerType: 'byob'
        };
        if (controller._pendingPullIntos.length > 0) {
            controller._pendingPullIntos.push(pullIntoDescriptor);
            // No ReadableByteStreamControllerCallPullIfNeeded() call since:
            // - No change happens on desiredSize
            // - The source has already been notified of that there's at least 1 pending read(view)
            ReadableStreamAddReadIntoRequest(stream, readIntoRequest);
            return;
        }
        if (stream._state === 'closed') {
            const emptyView = new ctor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, 0);
            readIntoRequest._closeSteps(emptyView);
            return;
        }
        if (controller._queueTotalSize > 0) {
            if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {
                const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
                ReadableByteStreamControllerHandleQueueDrain(controller);
                readIntoRequest._chunkSteps(filledView);
                return;
            }
            if (controller._closeRequested) {
                const e = new TypeError('Insufficient bytes to fill elements in the given buffer');
                ReadableByteStreamControllerError(controller, e);
                readIntoRequest._errorSteps(e);
                return;
            }
        }
        controller._pendingPullIntos.push(pullIntoDescriptor);
        ReadableStreamAddReadIntoRequest(stream, readIntoRequest);
        ReadableByteStreamControllerCallPullIfNeeded(controller);
    }
    function ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor) {
        if (firstDescriptor.readerType === 'none') {
            ReadableByteStreamControllerShiftPendingPullInto(controller);
        }
        const stream = controller._controlledReadableByteStream;
        if (ReadableStreamHasBYOBReader(stream)) {
            while (ReadableStreamGetNumReadIntoRequests(stream) > 0) {
                const pullIntoDescriptor = ReadableByteStreamControllerShiftPendingPullInto(controller);
                ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor);
            }
        }
    }
    function ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, pullIntoDescriptor) {
        ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesWritten, pullIntoDescriptor);
        if (pullIntoDescriptor.readerType === 'none') {
            ReadableByteStreamControllerEnqueueDetachedPullIntoToQueue(controller, pullIntoDescriptor);
            ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
            return;
        }
        if (pullIntoDescriptor.bytesFilled < pullIntoDescriptor.minimumFill) {
            // A descriptor for a read() request that is not yet filled up to its minimum length will stay at the head
            // of the queue, so the underlying source can keep filling it.
            return;
        }
        ReadableByteStreamControllerShiftPendingPullInto(controller);
        const remainderSize = pullIntoDescriptor.bytesFilled % pullIntoDescriptor.elementSize;
        if (remainderSize > 0) {
            const end = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;
            ReadableByteStreamControllerEnqueueClonedChunkToQueue(controller, pullIntoDescriptor.buffer, end - remainderSize, remainderSize);
        }
        pullIntoDescriptor.bytesFilled -= remainderSize;
        ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);
        ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
    }
    function ReadableByteStreamControllerRespondInternal(controller, bytesWritten) {
        const firstDescriptor = controller._pendingPullIntos.peek();
        ReadableByteStreamControllerInvalidateBYOBRequest(controller);
        const state = controller._controlledReadableByteStream._state;
        if (state === 'closed') {
            ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor);
        }
        else {
            ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, firstDescriptor);
        }
        ReadableByteStreamControllerCallPullIfNeeded(controller);
    }
    function ReadableByteStreamControllerShiftPendingPullInto(controller) {
        const descriptor = controller._pendingPullIntos.shift();
        return descriptor;
    }
    function ReadableByteStreamControllerShouldCallPull(controller) {
        const stream = controller._controlledReadableByteStream;
        if (stream._state !== 'readable') {
            return false;
        }
        if (controller._closeRequested) {
            return false;
        }
        if (!controller._started) {
            return false;
        }
        if (ReadableStreamHasDefaultReader(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
            return true;
        }
        if (ReadableStreamHasBYOBReader(stream) && ReadableStreamGetNumReadIntoRequests(stream) > 0) {
            return true;
        }
        const desiredSize = ReadableByteStreamControllerGetDesiredSize(controller);
        if (desiredSize > 0) {
            return true;
        }
        return false;
    }
    function ReadableByteStreamControllerClearAlgorithms(controller) {
        controller._pullAlgorithm = undefined;
        controller._cancelAlgorithm = undefined;
    }
    // A client of ReadableByteStreamController may use these functions directly to bypass state check.
    function ReadableByteStreamControllerClose(controller) {
        const stream = controller._controlledReadableByteStream;
        if (controller._closeRequested || stream._state !== 'readable') {
            return;
        }
        if (controller._queueTotalSize > 0) {
            controller._closeRequested = true;
            return;
        }
        if (controller._pendingPullIntos.length > 0) {
            const firstPendingPullInto = controller._pendingPullIntos.peek();
            if (firstPendingPullInto.bytesFilled % firstPendingPullInto.elementSize !== 0) {
                const e = new TypeError('Insufficient bytes to fill elements in the given buffer');
                ReadableByteStreamControllerError(controller, e);
                throw e;
            }
        }
        ReadableByteStreamControllerClearAlgorithms(controller);
        ReadableStreamClose(stream);
    }
    function ReadableByteStreamControllerEnqueue(controller, chunk) {
        const stream = controller._controlledReadableByteStream;
        if (controller._closeRequested || stream._state !== 'readable') {
            return;
        }
        const { buffer, byteOffset, byteLength } = chunk;
        if (IsDetachedBuffer(buffer)) {
            throw new TypeError('chunk\'s buffer is detached and so cannot be enqueued');
        }
        const transferredBuffer = TransferArrayBuffer(buffer);
        if (controller._pendingPullIntos.length > 0) {
            const firstPendingPullInto = controller._pendingPullIntos.peek();
            if (IsDetachedBuffer(firstPendingPullInto.buffer)) {
                throw new TypeError('The BYOB request\'s buffer has been detached and so cannot be filled with an enqueued chunk');
            }
            ReadableByteStreamControllerInvalidateBYOBRequest(controller);
            firstPendingPullInto.buffer = TransferArrayBuffer(firstPendingPullInto.buffer);
            if (firstPendingPullInto.readerType === 'none') {
                ReadableByteStreamControllerEnqueueDetachedPullIntoToQueue(controller, firstPendingPullInto);
            }
        }
        if (ReadableStreamHasDefaultReader(stream)) {
            ReadableByteStreamControllerProcessReadRequestsUsingQueue(controller);
            if (ReadableStreamGetNumReadRequests(stream) === 0) {
                ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
            }
            else {
                if (controller._pendingPullIntos.length > 0) {
                    ReadableByteStreamControllerShiftPendingPullInto(controller);
                }
                const transferredView = new Uint8Array(transferredBuffer, byteOffset, byteLength);
                ReadableStreamFulfillReadRequest(stream, transferredView, false);
            }
        }
        else if (ReadableStreamHasBYOBReader(stream)) {
            // TODO: Ideally in this branch detaching should happen only if the buffer is not consumed fully.
            ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
            ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
        }
        else {
            ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
        }
        ReadableByteStreamControllerCallPullIfNeeded(controller);
    }
    function ReadableByteStreamControllerError(controller, e) {
        const stream = controller._controlledReadableByteStream;
        if (stream._state !== 'readable') {
            return;
        }
        ReadableByteStreamControllerClearPendingPullIntos(controller);
        ResetQueue(controller);
        ReadableByteStreamControllerClearAlgorithms(controller);
        ReadableStreamError(stream, e);
    }
    function ReadableByteStreamControllerFillReadRequestFromQueue(controller, readRequest) {
        const entry = controller._queue.shift();
        controller._queueTotalSize -= entry.byteLength;
        ReadableByteStreamControllerHandleQueueDrain(controller);
        const view = new Uint8Array(entry.buffer, entry.byteOffset, entry.byteLength);
        readRequest._chunkSteps(view);
    }
    function ReadableByteStreamControllerGetBYOBRequest(controller) {
        if (controller._byobRequest === null && controller._pendingPullIntos.length > 0) {
            const firstDescriptor = controller._pendingPullIntos.peek();
            const view = new Uint8Array(firstDescriptor.buffer, firstDescriptor.byteOffset + firstDescriptor.bytesFilled, firstDescriptor.byteLength - firstDescriptor.bytesFilled);
            const byobRequest = Object.create(ReadableStreamBYOBRequest.prototype);
            SetUpReadableStreamBYOBRequest(byobRequest, controller, view);
            controller._byobRequest = byobRequest;
        }
        return controller._byobRequest;
    }
    function ReadableByteStreamControllerGetDesiredSize(controller) {
        const state = controller._controlledReadableByteStream._state;
        if (state === 'errored') {
            return null;
        }
        if (state === 'closed') {
            return 0;
        }
        return controller._strategyHWM - controller._queueTotalSize;
    }
    function ReadableByteStreamControllerRespond(controller, bytesWritten) {
        const firstDescriptor = controller._pendingPullIntos.peek();
        const state = controller._controlledReadableByteStream._state;
        if (state === 'closed') {
            if (bytesWritten !== 0) {
                throw new TypeError('bytesWritten must be 0 when calling respond() on a closed stream');
            }
        }
        else {
            if (bytesWritten === 0) {
                throw new TypeError('bytesWritten must be greater than 0 when calling respond() on a readable stream');
            }
            if (firstDescriptor.bytesFilled + bytesWritten > firstDescriptor.byteLength) {
                throw new RangeError('bytesWritten out of range');
            }
        }
        firstDescriptor.buffer = TransferArrayBuffer(firstDescriptor.buffer);
        ReadableByteStreamControllerRespondInternal(controller, bytesWritten);
    }
    function ReadableByteStreamControllerRespondWithNewView(controller, view) {
        const firstDescriptor = controller._pendingPullIntos.peek();
        const state = controller._controlledReadableByteStream._state;
        if (state === 'closed') {
            if (view.byteLength !== 0) {
                throw new TypeError('The view\'s length must be 0 when calling respondWithNewView() on a closed stream');
            }
        }
        else {
            if (view.byteLength === 0) {
                throw new TypeError('The view\'s length must be greater than 0 when calling respondWithNewView() on a readable stream');
            }
        }
        if (firstDescriptor.byteOffset + firstDescriptor.bytesFilled !== view.byteOffset) {
            throw new RangeError('The region specified by view does not match byobRequest');
        }
        if (firstDescriptor.bufferByteLength !== view.buffer.byteLength) {
            throw new RangeError('The buffer of view has different capacity than byobRequest');
        }
        if (firstDescriptor.bytesFilled + view.byteLength > firstDescriptor.byteLength) {
            throw new RangeError('The region specified by view is larger than byobRequest');
        }
        const viewByteLength = view.byteLength;
        firstDescriptor.buffer = TransferArrayBuffer(view.buffer);
        ReadableByteStreamControllerRespondInternal(controller, viewByteLength);
    }
    function SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize) {
        controller._controlledReadableByteStream = stream;
        controller._pullAgain = false;
        controller._pulling = false;
        controller._byobRequest = null;
        // Need to set the slots so that the assert doesn't fire. In the spec the slots already exist implicitly.
        controller._queue = controller._queueTotalSize = undefined;
        ResetQueue(controller);
        controller._closeRequested = false;
        controller._started = false;
        controller._strategyHWM = highWaterMark;
        controller._pullAlgorithm = pullAlgorithm;
        controller._cancelAlgorithm = cancelAlgorithm;
        controller._autoAllocateChunkSize = autoAllocateChunkSize;
        controller._pendingPullIntos = new SimpleQueue();
        stream._readableStreamController = controller;
        const startResult = startAlgorithm();
        uponPromise(promiseResolvedWith(startResult), () => {
            controller._started = true;
            ReadableByteStreamControllerCallPullIfNeeded(controller);
            return null;
        }, r => {
            ReadableByteStreamControllerError(controller, r);
            return null;
        });
    }
    function SetUpReadableByteStreamControllerFromUnderlyingSource(stream, underlyingByteSource, highWaterMark) {
        const controller = Object.create(ReadableByteStreamController.prototype);
        let startAlgorithm;
        let pullAlgorithm;
        let cancelAlgorithm;
        if (underlyingByteSource.start !== undefined) {
            startAlgorithm = () => underlyingByteSource.start(controller);
        }
        else {
            startAlgorithm = () => undefined;
        }
        if (underlyingByteSource.pull !== undefined) {
            pullAlgorithm = () => underlyingByteSource.pull(controller);
        }
        else {
            pullAlgorithm = () => promiseResolvedWith(undefined);
        }
        if (underlyingByteSource.cancel !== undefined) {
            cancelAlgorithm = reason => underlyingByteSource.cancel(reason);
        }
        else {
            cancelAlgorithm = () => promiseResolvedWith(undefined);
        }
        const autoAllocateChunkSize = underlyingByteSource.autoAllocateChunkSize;
        if (autoAllocateChunkSize === 0) {
            throw new TypeError('autoAllocateChunkSize must be greater than 0');
        }
        SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize);
    }
    function SetUpReadableStreamBYOBRequest(request, controller, view) {
        request._associatedReadableByteStreamController = controller;
        request._view = view;
    }
    // Helper functions for the ReadableStreamBYOBRequest.
    function byobRequestBrandCheckException(name) {
        return new TypeError(`ReadableStreamBYOBRequest.prototype.${name} can only be used on a ReadableStreamBYOBRequest`);
    }
    // Helper functions for the ReadableByteStreamController.
    function byteStreamControllerBrandCheckException(name) {
        return new TypeError(`ReadableByteStreamController.prototype.${name} can only be used on a ReadableByteStreamController`);
    }

    function convertReaderOptions(options, context) {
        assertDictionary(options, context);
        const mode = options === null || options === void 0 ? void 0 : options.mode;
        return {
            mode: mode === undefined ? undefined : convertReadableStreamReaderMode(mode, `${context} has member 'mode' that`)
        };
    }
    function convertReadableStreamReaderMode(mode, context) {
        mode = `${mode}`;
        if (mode !== 'byob') {
            throw new TypeError(`${context} '${mode}' is not a valid enumeration value for ReadableStreamReaderMode`);
        }
        return mode;
    }
    function convertByobReadOptions(options, context) {
        var _a;
        assertDictionary(options, context);
        const min = (_a = options === null || options === void 0 ? void 0 : options.min) !== null && _a !== void 0 ? _a : 1;
        return {
            min: convertUnsignedLongLongWithEnforceRange(min, `${context} has member 'min' that`)
        };
    }

    // Abstract operations for the ReadableStream.
    function AcquireReadableStreamBYOBReader(stream) {
        return new ReadableStreamBYOBReader(stream);
    }
    // ReadableStream API exposed for controllers.
    function ReadableStreamAddReadIntoRequest(stream, readIntoRequest) {
        stream._reader._readIntoRequests.push(readIntoRequest);
    }
    function ReadableStreamFulfillReadIntoRequest(stream, chunk, done) {
        const reader = stream._reader;
        const readIntoRequest = reader._readIntoRequests.shift();
        if (done) {
            readIntoRequest._closeSteps(chunk);
        }
        else {
            readIntoRequest._chunkSteps(chunk);
        }
    }
    function ReadableStreamGetNumReadIntoRequests(stream) {
        return stream._reader._readIntoRequests.length;
    }
    function ReadableStreamHasBYOBReader(stream) {
        const reader = stream._reader;
        if (reader === undefined) {
            return false;
        }
        if (!IsReadableStreamBYOBReader(reader)) {
            return false;
        }
        return true;
    }
    /**
     * A BYOB reader vended by a {@link ReadableStream}.
     *
     * @public
     */
    class ReadableStreamBYOBReader {
        constructor(stream) {
            assertRequiredArgument(stream, 1, 'ReadableStreamBYOBReader');
            assertReadableStream(stream, 'First parameter');
            if (IsReadableStreamLocked(stream)) {
                throw new TypeError('This stream has already been locked for exclusive reading by another reader');
            }
            if (!IsReadableByteStreamController(stream._readableStreamController)) {
                throw new TypeError('Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte ' +
                    'source');
            }
            ReadableStreamReaderGenericInitialize(this, stream);
            this._readIntoRequests = new SimpleQueue();
        }
        /**
         * Returns a promise that will be fulfilled when the stream becomes closed, or rejected if the stream ever errors or
         * the reader's lock is released before the stream finishes closing.
         */
        get closed() {
            if (!IsReadableStreamBYOBReader(this)) {
                return promiseRejectedWith(byobReaderBrandCheckException('closed'));
            }
            return this._closedPromise;
        }
        /**
         * If the reader is active, behaves the same as {@link ReadableStream.cancel | stream.cancel(reason)}.
         */
        cancel(reason = undefined) {
            if (!IsReadableStreamBYOBReader(this)) {
                return promiseRejectedWith(byobReaderBrandCheckException('cancel'));
            }
            if (this._ownerReadableStream === undefined) {
                return promiseRejectedWith(readerLockException('cancel'));
            }
            return ReadableStreamReaderGenericCancel(this, reason);
        }
        read(view, rawOptions = {}) {
            if (!IsReadableStreamBYOBReader(this)) {
                return promiseRejectedWith(byobReaderBrandCheckException('read'));
            }
            if (!ArrayBuffer.isView(view)) {
                return promiseRejectedWith(new TypeError('view must be an array buffer view'));
            }
            if (view.byteLength === 0) {
                return promiseRejectedWith(new TypeError('view must have non-zero byteLength'));
            }
            if (view.buffer.byteLength === 0) {
                return promiseRejectedWith(new TypeError(`view's buffer must have non-zero byteLength`));
            }
            if (IsDetachedBuffer(view.buffer)) {
                return promiseRejectedWith(new TypeError('view\'s buffer has been detached'));
            }
            let options;
            try {
                options = convertByobReadOptions(rawOptions, 'options');
            }
            catch (e) {
                return promiseRejectedWith(e);
            }
            const min = options.min;
            if (min === 0) {
                return promiseRejectedWith(new TypeError('options.min must be greater than 0'));
            }
            if (!isDataView(view)) {
                if (min > view.length) {
                    return promiseRejectedWith(new RangeError('options.min must be less than or equal to view\'s length'));
                }
            }
            else if (min > view.byteLength) {
                return promiseRejectedWith(new RangeError('options.min must be less than or equal to view\'s byteLength'));
            }
            if (this._ownerReadableStream === undefined) {
                return promiseRejectedWith(readerLockException('read from'));
            }
            let resolvePromise;
            let rejectPromise;
            const promise = newPromise((resolve, reject) => {
                resolvePromise = resolve;
                rejectPromise = reject;
            });
            const readIntoRequest = {
                _chunkSteps: chunk => resolvePromise({ value: chunk, done: false }),
                _closeSteps: chunk => resolvePromise({ value: chunk, done: true }),
                _errorSteps: e => rejectPromise(e)
            };
            ReadableStreamBYOBReaderRead(this, view, min, readIntoRequest);
            return promise;
        }
        /**
         * Releases the reader's lock on the corresponding stream. After the lock is released, the reader is no longer active.
         * If the associated stream is errored when the lock is released, the reader will appear errored in the same way
         * from now on; otherwise, the reader will appear closed.
         *
         * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by
         * the reader's {@link ReadableStreamBYOBReader.read | read()} method has not yet been settled. Attempting to
         * do so will throw a `TypeError` and leave the reader locked to the stream.
         */
        releaseLock() {
            if (!IsReadableStreamBYOBReader(this)) {
                throw byobReaderBrandCheckException('releaseLock');
            }
            if (this._ownerReadableStream === undefined) {
                return;
            }
            ReadableStreamBYOBReaderRelease(this);
        }
    }
    Object.defineProperties(ReadableStreamBYOBReader.prototype, {
        cancel: { enumerable: true },
        read: { enumerable: true },
        releaseLock: { enumerable: true },
        closed: { enumerable: true }
    });
    setFunctionName(ReadableStreamBYOBReader.prototype.cancel, 'cancel');
    setFunctionName(ReadableStreamBYOBReader.prototype.read, 'read');
    setFunctionName(ReadableStreamBYOBReader.prototype.releaseLock, 'releaseLock');
    if (typeof Symbol.toStringTag === 'symbol') {
        Object.defineProperty(ReadableStreamBYOBReader.prototype, Symbol.toStringTag, {
            value: 'ReadableStreamBYOBReader',
            configurable: true
        });
    }
    // Abstract operations for the readers.
    function IsReadableStreamBYOBReader(x) {
        if (!typeIsObject(x)) {
            return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, '_readIntoRequests')) {
            return false;
        }
        return x instanceof ReadableStreamBYOBReader;
    }
    function ReadableStreamBYOBReaderRead(reader, view, min, readIntoRequest) {
        const stream = reader._ownerReadableStream;
        stream._disturbed = true;
        if (stream._state === 'errored') {
            readIntoRequest._errorSteps(stream._storedError);
        }
        else {
            ReadableByteStreamControllerPullInto(stream._readableStreamController, view, min, readIntoRequest);
        }
    }
    function ReadableStreamBYOBReaderRelease(reader) {
        ReadableStreamReaderGenericRelease(reader);
        const e = new TypeError('Reader was released');
        ReadableStreamBYOBReaderErrorReadIntoRequests(reader, e);
    }
    function ReadableStreamBYOBReaderErrorReadIntoRequests(reader, e) {
        const readIntoRequests = reader._readIntoRequests;
        reader._readIntoRequests = new SimpleQueue();
        readIntoRequests.forEach(readIntoRequest => {
            readIntoRequest._errorSteps(e);
        });
    }
    // Helper functions for the ReadableStreamBYOBReader.
    function byobReaderBrandCheckException(name) {
        return new TypeError(`ReadableStreamBYOBReader.prototype.${name} can only be used on a ReadableStreamBYOBReader`);
    }

    function ExtractHighWaterMark(strategy, defaultHWM) {
        const { highWaterMark } = strategy;
        if (highWaterMark === undefined) {
            return defaultHWM;
        }
        if (NumberIsNaN(highWaterMark) || highWaterMark < 0) {
            throw new RangeError('Invalid highWaterMark');
        }
        return highWaterMark;
    }
    function ExtractSizeAlgorithm(strategy) {
        const { size } = strategy;
        if (!size) {
            return () => 1;
        }
        return size;
    }

    function convertQueuingStrategy(init, context) {
        assertDictionary(init, context);
        const highWaterMark = init === null || init === void 0 ? void 0 : init.highWaterMark;
        const size = init === null || init === void 0 ? void 0 : init.size;
        return {
            highWaterMark: highWaterMark === undefined ? undefined : convertUnrestrictedDouble(highWaterMark),
            size: size === undefined ? undefined : convertQueuingStrategySize(size, `${context} has member 'size' that`)
        };
    }
    function convertQueuingStrategySize(fn, context) {
        assertFunction(fn, context);
        return chunk => convertUnrestrictedDouble(fn(chunk));
    }

    function convertUnderlyingSink(original, context) {
        assertDictionary(original, context);
        const abort = original === null || original === void 0 ? void 0 : original.abort;
        const close = original === null || original === void 0 ? void 0 : original.close;
        const start = original === null || original === void 0 ? void 0 : original.start;
        const type = original === null || original === void 0 ? void 0 : original.type;
        const write = original === null || original === void 0 ? void 0 : original.write;
        return {
            abort: abort === undefined ?
                undefined :
                convertUnderlyingSinkAbortCallback(abort, original, `${context} has member 'abort' that`),
            close: close === undefined ?
                undefined :
                convertUnderlyingSinkCloseCallback(close, original, `${context} has member 'close' that`),
            start: start === undefined ?
                undefined :
                convertUnderlyingSinkStartCallback(start, original, `${context} has member 'start' that`),
            write: write === undefined ?
                undefined :
                convertUnderlyingSinkWriteCallback(write, original, `${context} has member 'write' that`),
            type
        };
    }
    function convertUnderlyingSinkAbortCallback(fn, original, context) {
        assertFunction(fn, context);
        return (reason) => promiseCall(fn, original, [reason]);
    }
    function convertUnderlyingSinkCloseCallback(fn, original, context) {
        assertFunction(fn, context);
        return () => promiseCall(fn, original, []);
    }
    function convertUnderlyingSinkStartCallback(fn, original, context) {
        assertFunction(fn, context);
        return (controller) => reflectCall(fn, original, [controller]);
    }
    function convertUnderlyingSinkWriteCallback(fn, original, context) {
        assertFunction(fn, context);
        return (chunk, controller) => promiseCall(fn, original, [chunk, controller]);
    }

    function assertWritableStream(x, context) {
        if (!IsWritableStream(x)) {
            throw new TypeError(`${context} is not a WritableStream.`);
        }
    }

    function isAbortSignal(value) {
        if (typeof value !== 'object' || value === null) {
            return false;
        }
        try {
            return typeof value.aborted === 'boolean';
        }
        catch (_a) {
            // AbortSignal.prototype.aborted throws if its brand check fails
            return false;
        }
    }
    const supportsAbortController = typeof AbortController === 'function';
    /**
     * Construct a new AbortController, if supported by the platform.
     *
     * @internal
     */
    function createAbortController() {
        if (supportsAbortController) {
            return new AbortController();
        }
        return undefined;
    }

    /**
     * A writable stream represents a destination for data, into which you can write.
     *
     * @public
     */
    class WritableStream {
        constructor(rawUnderlyingSink = {}, rawStrategy = {}) {
            if (rawUnderlyingSink === undefined) {
                rawUnderlyingSink = null;
            }
            else {
                assertObject(rawUnderlyingSink, 'First parameter');
            }
            const strategy = convertQueuingStrategy(rawStrategy, 'Second parameter');
            const underlyingSink = convertUnderlyingSink(rawUnderlyingSink, 'First parameter');
            InitializeWritableStream(this);
            const type = underlyingSink.type;
            if (type !== undefined) {
                throw new RangeError('Invalid type is specified');
            }
            const sizeAlgorithm = ExtractSizeAlgorithm(strategy);
            const highWaterMark = ExtractHighWaterMark(strategy, 1);
            SetUpWritableStreamDefaultControllerFromUnderlyingSink(this, underlyingSink, highWaterMark, sizeAlgorithm);
        }
        /**
         * Returns whether or not the writable stream is locked to a writer.
         */
        get locked() {
            if (!IsWritableStream(this)) {
                throw streamBrandCheckException$2('locked');
            }
            return IsWritableStreamLocked(this);
        }
        /**
         * Aborts the stream, signaling that the producer can no longer successfully write to the stream and it is to be
         * immediately moved to an errored state, with any queued-up writes discarded. This will also execute any abort
         * mechanism of the underlying sink.
         *
         * The returned promise will fulfill if the stream shuts down successfully, or reject if the underlying sink signaled
         * that there was an error doing so. Additionally, it will reject with a `TypeError` (without attempting to cancel
         * the stream) if the stream is currently locked.
         */
        abort(reason = undefined) {
            if (!IsWritableStream(this)) {
                return promiseRejectedWith(streamBrandCheckException$2('abort'));
            }
            if (IsWritableStreamLocked(this)) {
                return promiseRejectedWith(new TypeError('Cannot abort a stream that already has a writer'));
            }
            return WritableStreamAbort(this, reason);
        }
        /**
         * Closes the stream. The underlying sink will finish processing any previously-written chunks, before invoking its
         * close behavior. During this time any further attempts to write will fail (without erroring the stream).
         *
         * The method returns a promise that will fulfill if all remaining chunks are successfully written and the stream
         * successfully closes, or rejects if an error is encountered during this process. Additionally, it will reject with
         * a `TypeError` (without attempting to cancel the stream) if the stream is currently locked.
         */
        close() {
            if (!IsWritableStream(this)) {
                return promiseRejectedWith(streamBrandCheckException$2('close'));
            }
            if (IsWritableStreamLocked(this)) {
                return promiseRejectedWith(new TypeError('Cannot close a stream that already has a writer'));
            }
            if (WritableStreamCloseQueuedOrInFlight(this)) {
                return promiseRejectedWith(new TypeError('Cannot close an already-closing stream'));
            }
            return WritableStreamClose(this);
        }
        /**
         * Creates a {@link WritableStreamDefaultWriter | writer} and locks the stream to the new writer. While the stream
         * is locked, no other writer can be acquired until this one is released.
         *
         * This functionality is especially useful for creating abstractions that desire the ability to write to a stream
         * without interruption or interleaving. By getting a writer for the stream, you can ensure nobody else can write at
         * the same time, which would cause the resulting written data to be unpredictable and probably useless.
         */
        getWriter() {
            if (!IsWritableStream(this)) {
                throw streamBrandCheckException$2('getWriter');
            }
            return AcquireWritableStreamDefaultWriter(this);
        }
    }
    Object.defineProperties(WritableStream.prototype, {
        abort: { enumerable: true },
        close: { enumerable: true },
        getWriter: { enumerable: true },
        locked: { enumerable: true }
    });
    setFunctionName(WritableStream.prototype.abort, 'abort');
    setFunctionName(WritableStream.prototype.close, 'close');
    setFunctionName(WritableStream.prototype.getWriter, 'getWriter');
    if (typeof Symbol.toStringTag === 'symbol') {
        Object.defineProperty(WritableStream.prototype, Symbol.toStringTag, {
            value: 'WritableStream',
            configurable: true
        });
    }
    // Abstract operations for the WritableStream.
    function AcquireWritableStreamDefaultWriter(stream) {
        return new WritableStreamDefaultWriter(stream);
    }
    // Throws if and only if startAlgorithm throws.
    function CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark = 1, sizeAlgorithm = () => 1) {
        const stream = Object.create(WritableStream.prototype);
        InitializeWritableStream(stream);
        const controller = Object.create(WritableStreamDefaultController.prototype);
        SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);
        return stream;
    }
    function InitializeWritableStream(stream) {
        stream._state = 'writable';
        // The error that will be reported by new method calls once the state becomes errored. Only set when [[state]] is
        // 'erroring' or 'errored'. May be set to an undefined value.
        stream._storedError = undefined;
        stream._writer = undefined;
        // Initialize to undefined first because the constructor of the controller checks this
        // variable to validate the caller.
        stream._writableStreamController = undefined;
        // This queue is placed here instead of the writer class in order to allow for passing a writer to the next data
        // producer without waiting for the queued writes to finish.
        stream._writeRequests = new SimpleQueue();
        // Write requests are removed from _writeRequests when write() is called on the underlying sink. This prevents
        // them from being erroneously rejected on error. If a write() call is in-flight, the request is stored here.
        stream._inFlightWriteRequest = undefined;
        // The promise that was returned from writer.close(). Stored here because it may be fulfilled after the writer
        // has been detached.
        stream._closeRequest = undefined;
        // Close request is removed from _closeRequest when close() is called on the underlying sink. This prevents it
        // from being erroneously rejected on error. If a close() call is in-flight, the request is stored here.
        stream._inFlightCloseRequest = undefined;
        // The promise that was returned from writer.abort(). This may also be fulfilled after the writer has detached.
        stream._pendingAbortRequest = undefined;
        // The backpressure signal set by the controller.
        stream._backpressure = false;
    }
    function IsWritableStream(x) {
        if (!typeIsObject(x)) {
            return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, '_writableStreamController')) {
            return false;
        }
        return x instanceof WritableStream;
    }
    function IsWritableStreamLocked(stream) {
        if (stream._writer === undefined) {
            return false;
        }
        return true;
    }
    function WritableStreamAbort(stream, reason) {
        var _a;
        if (stream._state === 'closed' || stream._state === 'errored') {
            return promiseResolvedWith(undefined);
        }
        stream._writableStreamController._abortReason = reason;
        (_a = stream._writableStreamController._abortController) === null || _a === void 0 ? void 0 : _a.abort(reason);
        // TypeScript narrows the type of `stream._state` down to 'writable' | 'erroring',
        // but it doesn't know that signaling abort runs author code that might have changed the state.
        // Widen the type again by casting to WritableStreamState.
        const state = stream._state;
        if (state === 'closed' || state === 'errored') {
            return promiseResolvedWith(undefined);
        }
        if (stream._pendingAbortRequest !== undefined) {
            return stream._pendingAbortRequest._promise;
        }
        let wasAlreadyErroring = false;
        if (state === 'erroring') {
            wasAlreadyErroring = true;
            // reason will not be used, so don't keep a reference to it.
            reason = undefined;
        }
        const promise = newPromise((resolve, reject) => {
            stream._pendingAbortRequest = {
                _promise: undefined,
                _resolve: resolve,
                _reject: reject,
                _reason: reason,
                _wasAlreadyErroring: wasAlreadyErroring
            };
        });
        stream._pendingAbortRequest._promise = promise;
        if (!wasAlreadyErroring) {
            WritableStreamStartErroring(stream, reason);
        }
        return promise;
    }
    function WritableStreamClose(stream) {
        const state = stream._state;
        if (state === 'closed' || state === 'errored') {
            return promiseRejectedWith(new TypeError(`The stream (in ${state} state) is not in the writable state and cannot be closed`));
        }
        const promise = newPromise((resolve, reject) => {
            const closeRequest = {
                _resolve: resolve,
                _reject: reject
            };
            stream._closeRequest = closeRequest;
        });
        const writer = stream._writer;
        if (writer !== undefined && stream._backpressure && state === 'writable') {
            defaultWriterReadyPromiseResolve(writer);
        }
        WritableStreamDefaultControllerClose(stream._writableStreamController);
        return promise;
    }
    // WritableStream API exposed for controllers.
    function WritableStreamAddWriteRequest(stream) {
        const promise = newPromise((resolve, reject) => {
            const writeRequest = {
                _resolve: resolve,
                _reject: reject
            };
            stream._writeRequests.push(writeRequest);
        });
        return promise;
    }
    function WritableStreamDealWithRejection(stream, error) {
        const state = stream._state;
        if (state === 'writable') {
            WritableStreamStartErroring(stream, error);
            return;
        }
        WritableStreamFinishErroring(stream);
    }
    function WritableStreamStartErroring(stream, reason) {
        const controller = stream._writableStreamController;
        stream._state = 'erroring';
        stream._storedError = reason;
        const writer = stream._writer;
        if (writer !== undefined) {
            WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, reason);
        }
        if (!WritableStreamHasOperationMarkedInFlight(stream) && controller._started) {
            WritableStreamFinishErroring(stream);
        }
    }
    function WritableStreamFinishErroring(stream) {
        stream._state = 'errored';
        stream._writableStreamController[ErrorSteps]();
        const storedError = stream._storedError;
        stream._writeRequests.forEach(writeRequest => {
            writeRequest._reject(storedError);
        });
        stream._writeRequests = new SimpleQueue();
        if (stream._pendingAbortRequest === undefined) {
            WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
            return;
        }
        const abortRequest = stream._pendingAbortRequest;
        stream._pendingAbortRequest = undefined;
        if (abortRequest._wasAlreadyErroring) {
            abortRequest._reject(storedError);
            WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
            return;
        }
        const promise = stream._writableStreamController[AbortSteps](abortRequest._reason);
        uponPromise(promise, () => {
            abortRequest._resolve();
            WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
            return null;
        }, (reason) => {
            abortRequest._reject(reason);
            WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
            return null;
        });
    }
    function WritableStreamFinishInFlightWrite(stream) {
        stream._inFlightWriteRequest._resolve(undefined);
        stream._inFlightWriteRequest = undefined;
    }
    function WritableStreamFinishInFlightWriteWithError(stream, error) {
        stream._inFlightWriteRequest._reject(error);
        stream._inFlightWriteRequest = undefined;
        WritableStreamDealWithRejection(stream, error);
    }
    function WritableStreamFinishInFlightClose(stream) {
        stream._inFlightCloseRequest._resolve(undefined);
        stream._inFlightCloseRequest = undefined;
        const state = stream._state;
        if (state === 'erroring') {
            // The error was too late to do anything, so it is ignored.
            stream._storedError = undefined;
            if (stream._pendingAbortRequest !== undefined) {
                stream._pendingAbortRequest._resolve();
                stream._pendingAbortRequest = undefined;
            }
        }
        stream._state = 'closed';
        const writer = stream._writer;
        if (writer !== undefined) {
            defaultWriterClosedPromiseResolve(writer);
        }
    }
    function WritableStreamFinishInFlightCloseWithError(stream, error) {
        stream._inFlightCloseRequest._reject(error);
        stream._inFlightCloseRequest = undefined;
        // Never execute sink abort() after sink close().
        if (stream._pendingAbortRequest !== undefined) {
            stream._pendingAbortRequest._reject(error);
            stream._pendingAbortRequest = undefined;
        }
        WritableStreamDealWithRejection(stream, error);
    }
    // TODO(ricea): Fix alphabetical order.
    function WritableStreamCloseQueuedOrInFlight(stream) {
        if (stream._closeRequest === undefined && stream._inFlightCloseRequest === undefined) {
            return false;
        }
        return true;
    }
    function WritableStreamHasOperationMarkedInFlight(stream) {
        if (stream._inFlightWriteRequest === undefined && stream._inFlightCloseRequest === undefined) {
            return false;
        }
        return true;
    }
    function WritableStreamMarkCloseRequestInFlight(stream) {
        stream._inFlightCloseRequest = stream._closeRequest;
        stream._closeRequest = undefined;
    }
    function WritableStreamMarkFirstWriteRequestInFlight(stream) {
        stream._inFlightWriteRequest = stream._writeRequests.shift();
    }
    function WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream) {
        if (stream._closeRequest !== undefined) {
            stream._closeRequest._reject(stream._storedError);
            stream._closeRequest = undefined;
        }
        const writer = stream._writer;
        if (writer !== undefined) {
            defaultWriterClosedPromiseReject(writer, stream._storedError);
        }
    }
    function WritableStreamUpdateBackpressure(stream, backpressure) {
        const writer = stream._writer;
        if (writer !== undefined && backpressure !== stream._backpressure) {
            if (backpressure) {
                defaultWriterReadyPromiseReset(writer);
            }
            else {
                defaultWriterReadyPromiseResolve(writer);
            }
        }
        stream._backpressure = backpressure;
    }
    /**
     * A default writer vended by a {@link WritableStream}.
     *
     * @public
     */
    class WritableStreamDefaultWriter {
        constructor(stream) {
            assertRequiredArgument(stream, 1, 'WritableStreamDefaultWriter');
            assertWritableStream(stream, 'First parameter');
            if (IsWritableStreamLocked(stream)) {
                throw new TypeError('This stream has already been locked for exclusive writing by another writer');
            }
            this._ownerWritableStream = stream;
            stream._writer = this;
            const state = stream._state;
            if (state === 'writable') {
                if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._backpressure) {
                    defaultWriterReadyPromiseInitialize(this);
                }
                else {
                    defaultWriterReadyPromiseInitializeAsResolved(this);
                }
                defaultWriterClosedPromiseInitialize(this);
            }
            else if (state === 'erroring') {
                defaultWriterReadyPromiseInitializeAsRejected(this, stream._storedError);
                defaultWriterClosedPromiseInitialize(this);
            }
            else if (state === 'closed') {
                defaultWriterReadyPromiseInitializeAsResolved(this);
                defaultWriterClosedPromiseInitializeAsResolved(this);
            }
            else {
                const storedError = stream._storedError;
                defaultWriterReadyPromiseInitializeAsRejected(this, storedError);
                defaultWriterClosedPromiseInitializeAsRejected(this, storedError);
            }
        }
        /**
         * Returns a promise that will be fulfilled when the stream becomes closed, or rejected if the stream ever errors or
         * the writer’s lock is released before the stream finishes closing.
         */
        get closed() {
            if (!IsWritableStreamDefaultWriter(this)) {
                return promiseRejectedWith(defaultWriterBrandCheckException('closed'));
            }
            return this._closedPromise;
        }
        /**
         * Returns the desired size to fill the stream’s internal queue. It can be negative, if the queue is over-full.
         * A producer can use this information to determine the right amount of data to write.
         *
         * It will be `null` if the stream cannot be successfully written to (due to either being errored, or having an abort
         * queued up). It will return zero if the stream is closed. And the getter will throw an exception if invoked when
         * the writer’s lock is released.
         */
        get desiredSize() {
            if (!IsWritableStreamDefaultWriter(this)) {
                throw defaultWriterBrandCheckException('desiredSize');
            }
            if (this._ownerWritableStream === undefined) {
                throw defaultWriterLockException('desiredSize');
            }
            return WritableStreamDefaultWriterGetDesiredSize(this);
        }
        /**
         * Returns a promise that will be fulfilled when the desired size to fill the stream’s internal queue transitions
         * from non-positive to positive, signaling that it is no longer applying backpressure. Once the desired size dips
         * back to zero or below, the getter will return a new promise that stays pending until the next transition.
         *
         * If the stream becomes errored or aborted, or the writer’s lock is released, the returned promise will become
         * rejected.
         */
        get ready() {
            if (!IsWritableStreamDefaultWriter(this)) {
                return promiseRejectedWith(defaultWriterBrandCheckException('ready'));
            }
            return this._readyPromise;
        }
        /**
         * If the reader is active, behaves the same as {@link WritableStream.abort | stream.abort(reason)}.
         */
        abort(reason = undefined) {
            if (!IsWritableStreamDefaultWriter(this)) {
                return promiseRejectedWith(defaultWriterBrandCheckException('abort'));
            }
            if (this._ownerWritableStream === undefined) {
                return promiseRejectedWith(defaultWriterLockException('abort'));
            }
            return WritableStreamDefaultWriterAbort(this, reason);
        }
        /**
         * If the reader is active, behaves the same as {@link WritableStream.close | stream.close()}.
         */
        close() {
            if (!IsWritableStreamDefaultWriter(this)) {
                return promiseRejectedWith(defaultWriterBrandCheckException('close'));
            }
            const stream = this._ownerWritableStream;
            if (stream === undefined) {
                return promiseRejectedWith(defaultWriterLockException('close'));
            }
            if (WritableStreamCloseQueuedOrInFlight(stream)) {
                return promiseRejectedWith(new TypeError('Cannot close an already-closing stream'));
            }
            return WritableStreamDefaultWriterClose(this);
        }
        /**
         * Releases the writer’s lock on the corresponding stream. After the lock is released, the writer is no longer active.
         * If the associated stream is errored when the lock is released, the writer will appear errored in the same way from
         * now on; otherwise, the writer will appear closed.
         *
         * Note that the lock can still be released even if some ongoing writes have not yet finished (i.e. even if the
         * promises returned from previous calls to {@link WritableStreamDefaultWriter.write | write()} have not yet settled).
         * It’s not necessary to hold the lock on the writer for the duration of the write; the lock instead simply prevents
         * other producers from writing in an interleaved manner.
         */
        releaseLock() {
            if (!IsWritableStreamDefaultWriter(this)) {
                throw defaultWriterBrandCheckException('releaseLock');
            }
            const stream = this._ownerWritableStream;
            if (stream === undefined) {
                return;
            }
            WritableStreamDefaultWriterRelease(this);
        }
        write(chunk = undefined) {
            if (!IsWritableStreamDefaultWriter(this)) {
                return promiseRejectedWith(defaultWriterBrandCheckException('write'));
            }
            if (this._ownerWritableStream === undefined) {
                return promiseRejectedWith(defaultWriterLockException('write to'));
            }
            return WritableStreamDefaultWriterWrite(this, chunk);
        }
    }
    Object.defineProperties(WritableStreamDefaultWriter.prototype, {
        abort: { enumerable: true },
        close: { enumerable: true },
        releaseLock: { enumerable: true },
        write: { enumerable: true },
        closed: { enumerable: true },
        desiredSize: { enumerable: true },
        ready: { enumerable: true }
    });
    setFunctionName(WritableStreamDefaultWriter.prototype.abort, 'abort');
    setFunctionName(WritableStreamDefaultWriter.prototype.close, 'close');
    setFunctionName(WritableStreamDefaultWriter.prototype.releaseLock, 'releaseLock');
    setFunctionName(WritableStreamDefaultWriter.prototype.write, 'write');
    if (typeof Symbol.toStringTag === 'symbol') {
        Object.defineProperty(WritableStreamDefaultWriter.prototype, Symbol.toStringTag, {
            value: 'WritableStreamDefaultWriter',
            configurable: true
        });
    }
    // Abstract operations for the WritableStreamDefaultWriter.
    function IsWritableStreamDefaultWriter(x) {
        if (!typeIsObject(x)) {
            return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, '_ownerWritableStream')) {
            return false;
        }
        return x instanceof WritableStreamDefaultWriter;
    }
    // A client of WritableStreamDefaultWriter may use these functions directly to bypass state check.
    function WritableStreamDefaultWriterAbort(writer, reason) {
        const stream = writer._ownerWritableStream;
        return WritableStreamAbort(stream, reason);
    }
    function WritableStreamDefaultWriterClose(writer) {
        const stream = writer._ownerWritableStream;
        return WritableStreamClose(stream);
    }
    function WritableStreamDefaultWriterCloseWithErrorPropagation(writer) {
        const stream = writer._ownerWritableStream;
        const state = stream._state;
        if (WritableStreamCloseQueuedOrInFlight(stream) || state === 'closed') {
            return promiseResolvedWith(undefined);
        }
        if (state === 'errored') {
            return promiseRejectedWith(stream._storedError);
        }
        return WritableStreamDefaultWriterClose(writer);
    }
    function WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, error) {
        if (writer._closedPromiseState === 'pending') {
            defaultWriterClosedPromiseReject(writer, error);
        }
        else {
            defaultWriterClosedPromiseResetToRejected(writer, error);
        }
    }
    function WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, error) {
        if (writer._readyPromiseState === 'pending') {
            defaultWriterReadyPromiseReject(writer, error);
        }
        else {
            defaultWriterReadyPromiseResetToRejected(writer, error);
        }
    }
    function WritableStreamDefaultWriterGetDesiredSize(writer) {
        const stream = writer._ownerWritableStream;
        const state = stream._state;
        if (state === 'errored' || state === 'erroring') {
            return null;
        }
        if (state === 'closed') {
            return 0;
        }
        return WritableStreamDefaultControllerGetDesiredSize(stream._writableStreamController);
    }
    function WritableStreamDefaultWriterRelease(writer) {
        const stream = writer._ownerWritableStream;
        const releasedError = new TypeError(`Writer was released and can no longer be used to monitor the stream's closedness`);
        WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, releasedError);
        // The state transitions to "errored" before the sink abort() method runs, but the writer.closed promise is not
        // rejected until afterwards. This means that simply testing state will not work.
        WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, releasedError);
        stream._writer = undefined;
        writer._ownerWritableStream = undefined;
    }
    function WritableStreamDefaultWriterWrite(writer, chunk) {
        const stream = writer._ownerWritableStream;
        const controller = stream._writableStreamController;
        const chunkSize = WritableStreamDefaultControllerGetChunkSize(controller, chunk);
        if (stream !== writer._ownerWritableStream) {
            return promiseRejectedWith(defaultWriterLockException('write to'));
        }
        const state = stream._state;
        if (state === 'errored') {
            return promiseRejectedWith(stream._storedError);
        }
        if (WritableStreamCloseQueuedOrInFlight(stream) || state === 'closed') {
            return promiseRejectedWith(new TypeError('The stream is closing or closed and cannot be written to'));
        }
        if (state === 'erroring') {
            return promiseRejectedWith(stream._storedError);
        }
        const promise = WritableStreamAddWriteRequest(stream);
        WritableStreamDefaultControllerWrite(controller, chunk, chunkSize);
        return promise;
    }
    const closeSentinel = {};
    /**
     * Allows control of a {@link WritableStream | writable stream}'s state and internal queue.
     *
     * @public
     */
    class WritableStreamDefaultController {
        constructor() {
            throw new TypeError('Illegal constructor');
        }
        /**
         * The reason which was passed to `WritableStream.abort(reason)` when the stream was aborted.
         *
         * @deprecated
         *  This property has been removed from the specification, see https://github.com/whatwg/streams/pull/1177.
         *  Use {@link WritableStreamDefaultController.signal}'s `reason` instead.
         */
        get abortReason() {
            if (!IsWritableStreamDefaultController(this)) {
                throw defaultControllerBrandCheckException$2('abortReason');
            }
            return this._abortReason;
        }
        /**
         * An `AbortSignal` that can be used to abort the pending write or close operation when the stream is aborted.
         */
        get signal() {
            if (!IsWritableStreamDefaultController(this)) {
                throw defaultControllerBrandCheckException$2('signal');
            }
            if (this._abortController === undefined) {
                // Older browsers or older Node versions may not support `AbortController` or `AbortSignal`.
                // We don't want to bundle and ship an `AbortController` polyfill together with our polyfill,
                // so instead we only implement support for `signal` if we find a global `AbortController` constructor.
                throw new TypeError('WritableStreamDefaultController.prototype.signal is not supported');
            }
            return this._abortController.signal;
        }
        /**
         * Closes the controlled writable stream, making all future interactions with it fail with the given error `e`.
         *
         * This method is rarely used, since usually it suffices to return a rejected promise from one of the underlying
         * sink's methods. However, it can be useful for suddenly shutting down a stream in response to an event outside the
         * normal lifecycle of interactions with the underlying sink.
         */
        error(e = undefined) {
            if (!IsWritableStreamDefaultController(this)) {
                throw defaultControllerBrandCheckException$2('error');
            }
            const state = this._controlledWritableStream._state;
            if (state !== 'writable') {
                // The stream is closed, errored or will be soon. The sink can't do anything useful if it gets an error here, so
                // just treat it as a no-op.
                return;
            }
            WritableStreamDefaultControllerError(this, e);
        }
        /** @internal */
        [AbortSteps](reason) {
            const result = this._abortAlgorithm(reason);
            WritableStreamDefaultControllerClearAlgorithms(this);
            return result;
        }
        /** @internal */
        [ErrorSteps]() {
            ResetQueue(this);
        }
    }
    Object.defineProperties(WritableStreamDefaultController.prototype, {
        abortReason: { enumerable: true },
        signal: { enumerable: true },
        error: { enumerable: true }
    });
    if (typeof Symbol.toStringTag === 'symbol') {
        Object.defineProperty(WritableStreamDefaultController.prototype, Symbol.toStringTag, {
            value: 'WritableStreamDefaultController',
            configurable: true
        });
    }
    // Abstract operations implementing interface required by the WritableStream.
    function IsWritableStreamDefaultController(x) {
        if (!typeIsObject(x)) {
            return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, '_controlledWritableStream')) {
            return false;
        }
        return x instanceof WritableStreamDefaultController;
    }
    function SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm) {
        controller._controlledWritableStream = stream;
        stream._writableStreamController = controller;
        // Need to set the slots so that the assert doesn't fire. In the spec the slots already exist implicitly.
        controller._queue = undefined;
        controller._queueTotalSize = undefined;
        ResetQueue(controller);
        controller._abortReason = undefined;
        controller._abortController = createAbortController();
        controller._started = false;
        controller._strategySizeAlgorithm = sizeAlgorithm;
        controller._strategyHWM = highWaterMark;
        controller._writeAlgorithm = writeAlgorithm;
        controller._closeAlgorithm = closeAlgorithm;
        controller._abortAlgorithm = abortAlgorithm;
        const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
        WritableStreamUpdateBackpressure(stream, backpressure);
        const startResult = startAlgorithm();
        const startPromise = promiseResolvedWith(startResult);
        uponPromise(startPromise, () => {
            controller._started = true;
            WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
            return null;
        }, r => {
            controller._started = true;
            WritableStreamDealWithRejection(stream, r);
            return null;
        });
    }
    function SetUpWritableStreamDefaultControllerFromUnderlyingSink(stream, underlyingSink, highWaterMark, sizeAlgorithm) {
        const controller = Object.create(WritableStreamDefaultController.prototype);
        let startAlgorithm;
        let writeAlgorithm;
        let closeAlgorithm;
        let abortAlgorithm;
        if (underlyingSink.start !== undefined) {
            startAlgorithm = () => underlyingSink.start(controller);
        }
        else {
            startAlgorithm = () => undefined;
        }
        if (underlyingSink.write !== undefined) {
            writeAlgorithm = chunk => underlyingSink.write(chunk, controller);
        }
        else {
            writeAlgorithm = () => promiseResolvedWith(undefined);
        }
        if (underlyingSink.close !== undefined) {
            closeAlgorithm = () => underlyingSink.close();
        }
        else {
            closeAlgorithm = () => promiseResolvedWith(undefined);
        }
        if (underlyingSink.abort !== undefined) {
            abortAlgorithm = reason => underlyingSink.abort(reason);
        }
        else {
            abortAlgorithm = () => promiseResolvedWith(undefined);
        }
        SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);
    }
    // ClearAlgorithms may be called twice. Erroring the same stream in multiple ways will often result in redundant calls.
    function WritableStreamDefaultControllerClearAlgorithms(controller) {
        controller._writeAlgorithm = undefined;
        controller._closeAlgorithm = undefined;
        controller._abortAlgorithm = undefined;
        controller._strategySizeAlgorithm = undefined;
    }
    function WritableStreamDefaultControllerClose(controller) {
        EnqueueValueWithSize(controller, closeSentinel, 0);
        WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
    }
    function WritableStreamDefaultControllerGetChunkSize(controller, chunk) {
        try {
            return controller._strategySizeAlgorithm(chunk);
        }
        catch (chunkSizeE) {
            WritableStreamDefaultControllerErrorIfNeeded(controller, chunkSizeE);
            return 1;
        }
    }
    function WritableStreamDefaultControllerGetDesiredSize(controller) {
        return controller._strategyHWM - controller._queueTotalSize;
    }
    function WritableStreamDefaultControllerWrite(controller, chunk, chunkSize) {
        try {
            EnqueueValueWithSize(controller, chunk, chunkSize);
        }
        catch (enqueueE) {
            WritableStreamDefaultControllerErrorIfNeeded(controller, enqueueE);
            return;
        }
        const stream = controller._controlledWritableStream;
        if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._state === 'writable') {
            const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
            WritableStreamUpdateBackpressure(stream, backpressure);
        }
        WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
    }
    // Abstract operations for the WritableStreamDefaultController.
    function WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller) {
        const stream = controller._controlledWritableStream;
        if (!controller._started) {
            return;
        }
        if (stream._inFlightWriteRequest !== undefined) {
            return;
        }
        const state = stream._state;
        if (state === 'erroring') {
            WritableStreamFinishErroring(stream);
            return;
        }
        if (controller._queue.length === 0) {
            return;
        }
        const value = PeekQueueValue(controller);
        if (value === closeSentinel) {
            WritableStreamDefaultControllerProcessClose(controller);
        }
        else {
            WritableStreamDefaultControllerProcessWrite(controller, value);
        }
    }
    function WritableStreamDefaultControllerErrorIfNeeded(controller, error) {
        if (controller._controlledWritableStream._state === 'writable') {
            WritableStreamDefaultControllerError(controller, error);
        }
    }
    function WritableStreamDefaultControllerProcessClose(controller) {
        const stream = controller._controlledWritableStream;
        WritableStreamMarkCloseRequestInFlight(stream);
        DequeueValue(controller);
        const sinkClosePromise = controller._closeAlgorithm();
        WritableStreamDefaultControllerClearAlgorithms(controller);
        uponPromise(sinkClosePromise, () => {
            WritableStreamFinishInFlightClose(stream);
            return null;
        }, reason => {
            WritableStreamFinishInFlightCloseWithError(stream, reason);
            return null;
        });
    }
    function WritableStreamDefaultControllerProcessWrite(controller, chunk) {
        const stream = controller._controlledWritableStream;
        WritableStreamMarkFirstWriteRequestInFlight(stream);
        const sinkWritePromise = controller._writeAlgorithm(chunk);
        uponPromise(sinkWritePromise, () => {
            WritableStreamFinishInFlightWrite(stream);
            const state = stream._state;
            DequeueValue(controller);
            if (!WritableStreamCloseQueuedOrInFlight(stream) && state === 'writable') {
                const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
                WritableStreamUpdateBackpressure(stream, backpressure);
            }
            WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
            return null;
        }, reason => {
            if (stream._state === 'writable') {
                WritableStreamDefaultControllerClearAlgorithms(controller);
            }
            WritableStreamFinishInFlightWriteWithError(stream, reason);
            return null;
        });
    }
    function WritableStreamDefaultControllerGetBackpressure(controller) {
        const desiredSize = WritableStreamDefaultControllerGetDesiredSize(controller);
        return desiredSize <= 0;
    }
    // A client of WritableStreamDefaultController may use these functions directly to bypass state check.
    function WritableStreamDefaultControllerError(controller, error) {
        const stream = controller._controlledWritableStream;
        WritableStreamDefaultControllerClearAlgorithms(controller);
        WritableStreamStartErroring(stream, error);
    }
    // Helper functions for the WritableStream.
    function streamBrandCheckException$2(name) {
        return new TypeError(`WritableStream.prototype.${name} can only be used on a WritableStream`);
    }
    // Helper functions for the WritableStreamDefaultController.
    function defaultControllerBrandCheckException$2(name) {
        return new TypeError(`WritableStreamDefaultController.prototype.${name} can only be used on a WritableStreamDefaultController`);
    }
    // Helper functions for the WritableStreamDefaultWriter.
    function defaultWriterBrandCheckException(name) {
        return new TypeError(`WritableStreamDefaultWriter.prototype.${name} can only be used on a WritableStreamDefaultWriter`);
    }
    function defaultWriterLockException(name) {
        return new TypeError('Cannot ' + name + ' a stream using a released writer');
    }
    function defaultWriterClosedPromiseInitialize(writer) {
        writer._closedPromise = newPromise((resolve, reject) => {
            writer._closedPromise_resolve = resolve;
            writer._closedPromise_reject = reject;
            writer._closedPromiseState = 'pending';
        });
    }
    function defaultWriterClosedPromiseInitializeAsRejected(writer, reason) {
        defaultWriterClosedPromiseInitialize(writer);
        defaultWriterClosedPromiseReject(writer, reason);
    }
    function defaultWriterClosedPromiseInitializeAsResolved(writer) {
        defaultWriterClosedPromiseInitialize(writer);
        defaultWriterClosedPromiseResolve(writer);
    }
    function defaultWriterClosedPromiseReject(writer, reason) {
        if (writer._closedPromise_reject === undefined) {
            return;
        }
        setPromiseIsHandledToTrue(writer._closedPromise);
        writer._closedPromise_reject(reason);
        writer._closedPromise_resolve = undefined;
        writer._closedPromise_reject = undefined;
        writer._closedPromiseState = 'rejected';
    }
    function defaultWriterClosedPromiseResetToRejected(writer, reason) {
        defaultWriterClosedPromiseInitializeAsRejected(writer, reason);
    }
    function defaultWriterClosedPromiseResolve(writer) {
        if (writer._closedPromise_resolve === undefined) {
            return;
        }
        writer._closedPromise_resolve(undefined);
        writer._closedPromise_resolve = undefined;
        writer._closedPromise_reject = undefined;
        writer._closedPromiseState = 'resolved';
    }
    function defaultWriterReadyPromiseInitialize(writer) {
        writer._readyPromise = newPromise((resolve, reject) => {
            writer._readyPromise_resolve = resolve;
            writer._readyPromise_reject = reject;
        });
        writer._readyPromiseState = 'pending';
    }
    function defaultWriterReadyPromiseInitializeAsRejected(writer, reason) {
        defaultWriterReadyPromiseInitialize(writer);
        defaultWriterReadyPromiseReject(writer, reason);
    }
    function defaultWriterReadyPromiseInitializeAsResolved(writer) {
        defaultWriterReadyPromiseInitialize(writer);
        defaultWriterReadyPromiseResolve(writer);
    }
    function defaultWriterReadyPromiseReject(writer, reason) {
        if (writer._readyPromise_reject === undefined) {
            return;
        }
        setPromiseIsHandledToTrue(writer._readyPromise);
        writer._readyPromise_reject(reason);
        writer._readyPromise_resolve = undefined;
        writer._readyPromise_reject = undefined;
        writer._readyPromiseState = 'rejected';
    }
    function defaultWriterReadyPromiseReset(writer) {
        defaultWriterReadyPromiseInitialize(writer);
    }
    function defaultWriterReadyPromiseResetToRejected(writer, reason) {
        defaultWriterReadyPromiseInitializeAsRejected(writer, reason);
    }
    function defaultWriterReadyPromiseResolve(writer) {
        if (writer._readyPromise_resolve === undefined) {
            return;
        }
        writer._readyPromise_resolve(undefined);
        writer._readyPromise_resolve = undefined;
        writer._readyPromise_reject = undefined;
        writer._readyPromiseState = 'fulfilled';
    }

    /// <reference lib="dom" />
    function getGlobals() {
        if (typeof globalThis !== 'undefined') {
            return globalThis;
        }
        else if (typeof self !== 'undefined') {
            return self;
        }
        else if (typeof global !== 'undefined') {
            return global;
        }
        return undefined;
    }
    const globals = getGlobals();

    /// <reference types="node" />
    function isDOMExceptionConstructor(ctor) {
        if (!(typeof ctor === 'function' || typeof ctor === 'object')) {
            return false;
        }
        if (ctor.name !== 'DOMException') {
            return false;
        }
        try {
            new ctor();
            return true;
        }
        catch (_a) {
            return false;
        }
    }
    /**
     * Support:
     * - Web browsers
     * - Node 18 and higher (https://github.com/nodejs/node/commit/e4b1fb5e6422c1ff151234bb9de792d45dd88d87)
     */
    function getFromGlobal() {
        const ctor = globals === null || globals === void 0 ? void 0 : globals.DOMException;
        return isDOMExceptionConstructor(ctor) ? ctor : undefined;
    }
    /**
     * Support:
     * - All platforms
     */
    function createPolyfill() {
        // eslint-disable-next-line @typescript-eslint/no-shadow
        const ctor = function DOMException(message, name) {
            this.message = message || '';
            this.name = name || 'Error';
            if (Error.captureStackTrace) {
                Error.captureStackTrace(this, this.constructor);
            }
        };
        setFunctionName(ctor, 'DOMException');
        ctor.prototype = Object.create(Error.prototype);
        Object.defineProperty(ctor.prototype, 'constructor', { value: ctor, writable: true, configurable: true });
        return ctor;
    }
    // eslint-disable-next-line @typescript-eslint/no-redeclare
    const DOMException = getFromGlobal() || createPolyfill();

    function ReadableStreamPipeTo(source, dest, preventClose, preventAbort, preventCancel, signal) {
        const reader = AcquireReadableStreamDefaultReader(source);
        const writer = AcquireWritableStreamDefaultWriter(dest);
        source._disturbed = true;
        let shuttingDown = false;
        // This is used to keep track of the spec's requirement that we wait for ongoing writes during shutdown.
        let currentWrite = promiseResolvedWith(undefined);
        return newPromise((resolve, reject) => {
            let abortAlgorithm;
            if (signal !== undefined) {
                abortAlgorithm = () => {
                    const error = signal.reason !== undefined ? signal.reason : new DOMException('Aborted', 'AbortError');
                    const actions = [];
                    if (!preventAbort) {
                        actions.push(() => {
                            if (dest._state === 'writable') {
                                return WritableStreamAbort(dest, error);
                            }
                            return promiseResolvedWith(undefined);
                        });
                    }
                    if (!preventCancel) {
                        actions.push(() => {
                            if (source._state === 'readable') {
                                return ReadableStreamCancel(source, error);
                            }
                            return promiseResolvedWith(undefined);
                        });
                    }
                    shutdownWithAction(() => Promise.all(actions.map(action => action())), true, error);
                };
                if (signal.aborted) {
                    abortAlgorithm();
                    return;
                }
                signal.addEventListener('abort', abortAlgorithm);
            }
            // Using reader and writer, read all chunks from this and write them to dest
            // - Backpressure must be enforced
            // - Shutdown must stop all activity
            function pipeLoop() {
                return newPromise((resolveLoop, rejectLoop) => {
                    function next(done) {
                        if (done) {
                            resolveLoop();
                        }
                        else {
                            // Use `PerformPromiseThen` instead of `uponPromise` to avoid
                            // adding unnecessary `.catch(rethrowAssertionErrorRejection)` handlers
                            PerformPromiseThen(pipeStep(), next, rejectLoop);
                        }
                    }
                    next(false);
                });
            }
            function pipeStep() {
                if (shuttingDown) {
                    return promiseResolvedWith(true);
                }
                return PerformPromiseThen(writer._readyPromise, () => {
                    return newPromise((resolveRead, rejectRead) => {
                        ReadableStreamDefaultReaderRead(reader, {
                            _chunkSteps: chunk => {
                                currentWrite = PerformPromiseThen(WritableStreamDefaultWriterWrite(writer, chunk), undefined, noop);
                                resolveRead(false);
                            },
                            _closeSteps: () => resolveRead(true),
                            _errorSteps: rejectRead
                        });
                    });
                });
            }
            // Errors must be propagated forward
            isOrBecomesErrored(source, reader._closedPromise, storedError => {
                if (!preventAbort) {
                    shutdownWithAction(() => WritableStreamAbort(dest, storedError), true, storedError);
                }
                else {
                    shutdown(true, storedError);
                }
                return null;
            });
            // Errors must be propagated backward
            isOrBecomesErrored(dest, writer._closedPromise, storedError => {
                if (!preventCancel) {
                    shutdownWithAction(() => ReadableStreamCancel(source, storedError), true, storedError);
                }
                else {
                    shutdown(true, storedError);
                }
                return null;
            });
            // Closing must be propagated forward
            isOrBecomesClosed(source, reader._closedPromise, () => {
                if (!preventClose) {
                    shutdownWithAction(() => WritableStreamDefaultWriterCloseWithErrorPropagation(writer));
                }
                else {
                    shutdown();
                }
                return null;
            });
            // Closing must be propagated backward
            if (WritableStreamCloseQueuedOrInFlight(dest) || dest._state === 'closed') {
                const destClosed = new TypeError('the destination writable stream closed before all data could be piped to it');
                if (!preventCancel) {
                    shutdownWithAction(() => ReadableStreamCancel(source, destClosed), true, destClosed);
                }
                else {
                    shutdown(true, destClosed);
                }
            }
            setPromiseIsHandledToTrue(pipeLoop());
            function waitForWritesToFinish() {
                // Another write may have started while we were waiting on this currentWrite, so we have to be sure to wait
                // for that too.
                const oldCurrentWrite = currentWrite;
                return PerformPromiseThen(currentWrite, () => oldCurrentWrite !== currentWrite ? waitForWritesToFinish() : undefined);
            }
            function isOrBecomesErrored(stream, promise, action) {
                if (stream._state === 'errored') {
                    action(stream._storedError);
                }
                else {
                    uponRejection(promise, action);
                }
            }
            function isOrBecomesClosed(stream, promise, action) {
                if (stream._state === 'closed') {
                    action();
                }
                else {
                    uponFulfillment(promise, action);
                }
            }
            function shutdownWithAction(action, originalIsError, originalError) {
                if (shuttingDown) {
                    return;
                }
                shuttingDown = true;
                if (dest._state === 'writable' && !WritableStreamCloseQueuedOrInFlight(dest)) {
                    uponFulfillment(waitForWritesToFinish(), doTheRest);
                }
                else {
                    doTheRest();
                }
                function doTheRest() {
                    uponPromise(action(), () => finalize(originalIsError, originalError), newError => finalize(true, newError));
                    return null;
                }
            }
            function shutdown(isError, error) {
                if (shuttingDown) {
                    return;
                }
                shuttingDown = true;
                if (dest._state === 'writable' && !WritableStreamCloseQueuedOrInFlight(dest)) {
                    uponFulfillment(waitForWritesToFinish(), () => finalize(isError, error));
                }
                else {
                    finalize(isError, error);
                }
            }
            function finalize(isError, error) {
                WritableStreamDefaultWriterRelease(writer);
                ReadableStreamReaderGenericRelease(reader);
                if (signal !== undefined) {
                    signal.removeEventListener('abort', abortAlgorithm);
                }
                if (isError) {
                    reject(error);
                }
                else {
                    resolve(undefined);
                }
                return null;
            }
        });
    }

    /**
     * Allows control of a {@link ReadableStream | readable stream}'s state and internal queue.
     *
     * @public
     */
    class ReadableStreamDefaultController {
        constructor() {
            throw new TypeError('Illegal constructor');
        }
        /**
         * Returns the desired size to fill the controlled stream's internal queue. It can be negative, if the queue is
         * over-full. An underlying source ought to use this information to determine when and how to apply backpressure.
         */
        get desiredSize() {
            if (!IsReadableStreamDefaultController(this)) {
                throw defaultControllerBrandCheckException$1('desiredSize');
            }
            return ReadableStreamDefaultControllerGetDesiredSize(this);
        }
        /**
         * Closes the controlled readable stream. Consumers will still be able to read any previously-enqueued chunks from
         * the stream, but once those are read, the stream will become closed.
         */
        close() {
            if (!IsReadableStreamDefaultController(this)) {
                throw defaultControllerBrandCheckException$1('close');
            }
            if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {
                throw new TypeError('The stream is not in a state that permits close');
            }
            ReadableStreamDefaultControllerClose(this);
        }
        enqueue(chunk = undefined) {
            if (!IsReadableStreamDefaultController(this)) {
                throw defaultControllerBrandCheckException$1('enqueue');
            }
            if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {
                throw new TypeError('The stream is not in a state that permits enqueue');
            }
            return ReadableStreamDefaultControllerEnqueue(this, chunk);
        }
        /**
         * Errors the controlled readable stream, making all future interactions with it fail with the given error `e`.
         */
        error(e = undefined) {
            if (!IsReadableStreamDefaultController(this)) {
                throw defaultControllerBrandCheckException$1('error');
            }
            ReadableStreamDefaultControllerError(this, e);
        }
        /** @internal */
        [CancelSteps](reason) {
            ResetQueue(this);
            const result = this._cancelAlgorithm(reason);
            ReadableStreamDefaultControllerClearAlgorithms(this);
            return result;
        }
        /** @internal */
        [PullSteps](readRequest) {
            const stream = this._controlledReadableStream;
            if (this._queue.length > 0) {
                const chunk = DequeueValue(this);
                if (this._closeRequested && this._queue.length === 0) {
                    ReadableStreamDefaultControllerClearAlgorithms(this);
                    ReadableStreamClose(stream);
                }
                else {
                    ReadableStreamDefaultControllerCallPullIfNeeded(this);
                }
                readRequest._chunkSteps(chunk);
            }
            else {
                ReadableStreamAddReadRequest(stream, readRequest);
                ReadableStreamDefaultControllerCallPullIfNeeded(this);
            }
        }
        /** @internal */
        [ReleaseSteps]() {
            // Do nothing.
        }
    }
    Object.defineProperties(ReadableStreamDefaultController.prototype, {
        close: { enumerable: true },
        enqueue: { enumerable: true },
        error: { enumerable: true },
        desiredSize: { enumerable: true }
    });
    setFunctionName(ReadableStreamDefaultController.prototype.close, 'close');
    setFunctionName(ReadableStreamDefaultController.prototype.enqueue, 'enqueue');
    setFunctionName(ReadableStreamDefaultController.prototype.error, 'error');
    if (typeof Symbol.toStringTag === 'symbol') {
        Object.defineProperty(ReadableStreamDefaultController.prototype, Symbol.toStringTag, {
            value: 'ReadableStreamDefaultController',
            configurable: true
        });
    }
    // Abstract operations for the ReadableStreamDefaultController.
    function IsReadableStreamDefaultController(x) {
        if (!typeIsObject(x)) {
            return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, '_controlledReadableStream')) {
            return false;
        }
        return x instanceof ReadableStreamDefaultController;
    }
    function ReadableStreamDefaultControllerCallPullIfNeeded(controller) {
        const shouldPull = ReadableStreamDefaultControllerShouldCallPull(controller);
        if (!shouldPull) {
            return;
        }
        if (controller._pulling) {
            controller._pullAgain = true;
            return;
        }
        controller._pulling = true;
        const pullPromise = controller._pullAlgorithm();
        uponPromise(pullPromise, () => {
            controller._pulling = false;
            if (controller._pullAgain) {
                controller._pullAgain = false;
                ReadableStreamDefaultControllerCallPullIfNeeded(controller);
            }
            return null;
        }, e => {
            ReadableStreamDefaultControllerError(controller, e);
            return null;
        });
    }
    function ReadableStreamDefaultControllerShouldCallPull(controller) {
        const stream = controller._controlledReadableStream;
        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
            return false;
        }
        if (!controller._started) {
            return false;
        }
        if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
            return true;
        }
        const desiredSize = ReadableStreamDefaultControllerGetDesiredSize(controller);
        if (desiredSize > 0) {
            return true;
        }
        return false;
    }
    function ReadableStreamDefaultControllerClearAlgorithms(controller) {
        controller._pullAlgorithm = undefined;
        controller._cancelAlgorithm = undefined;
        controller._strategySizeAlgorithm = undefined;
    }
    // A client of ReadableStreamDefaultController may use these functions directly to bypass state check.
    function ReadableStreamDefaultControllerClose(controller) {
        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
            return;
        }
        const stream = controller._controlledReadableStream;
        controller._closeRequested = true;
        if (controller._queue.length === 0) {
            ReadableStreamDefaultControllerClearAlgorithms(controller);
            ReadableStreamClose(stream);
        }
    }
    function ReadableStreamDefaultControllerEnqueue(controller, chunk) {
        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
            return;
        }
        const stream = controller._controlledReadableStream;
        if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
            ReadableStreamFulfillReadRequest(stream, chunk, false);
        }
        else {
            let chunkSize;
            try {
                chunkSize = controller._strategySizeAlgorithm(chunk);
            }
            catch (chunkSizeE) {
                ReadableStreamDefaultControllerError(controller, chunkSizeE);
                throw chunkSizeE;
            }
            try {
                EnqueueValueWithSize(controller, chunk, chunkSize);
            }
            catch (enqueueE) {
                ReadableStreamDefaultControllerError(controller, enqueueE);
                throw enqueueE;
            }
        }
        ReadableStreamDefaultControllerCallPullIfNeeded(controller);
    }
    function ReadableStreamDefaultControllerError(controller, e) {
        const stream = controller._controlledReadableStream;
        if (stream._state !== 'readable') {
            return;
        }
        ResetQueue(controller);
        ReadableStreamDefaultControllerClearAlgorithms(controller);
        ReadableStreamError(stream, e);
    }
    function ReadableStreamDefaultControllerGetDesiredSize(controller) {
        const state = controller._controlledReadableStream._state;
        if (state === 'errored') {
            return null;
        }
        if (state === 'closed') {
            return 0;
        }
        return controller._strategyHWM - controller._queueTotalSize;
    }
    // This is used in the implementation of TransformStream.
    function ReadableStreamDefaultControllerHasBackpressure(controller) {
        if (ReadableStreamDefaultControllerShouldCallPull(controller)) {
            return false;
        }
        return true;
    }
    function ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) {
        const state = controller._controlledReadableStream._state;
        if (!controller._closeRequested && state === 'readable') {
            return true;
        }
        return false;
    }
    function SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm) {
        controller._controlledReadableStream = stream;
        controller._queue = undefined;
        controller._queueTotalSize = undefined;
        ResetQueue(controller);
        controller._started = false;
        controller._closeRequested = false;
        controller._pullAgain = false;
        controller._pulling = false;
        controller._strategySizeAlgorithm = sizeAlgorithm;
        controller._strategyHWM = highWaterMark;
        controller._pullAlgorithm = pullAlgorithm;
        controller._cancelAlgorithm = cancelAlgorithm;
        stream._readableStreamController = controller;
        const startResult = startAlgorithm();
        uponPromise(promiseResolvedWith(startResult), () => {
            controller._started = true;
            ReadableStreamDefaultControllerCallPullIfNeeded(controller);
            return null;
        }, r => {
            ReadableStreamDefaultControllerError(controller, r);
            return null;
        });
    }
    function SetUpReadableStreamDefaultControllerFromUnderlyingSource(stream, underlyingSource, highWaterMark, sizeAlgorithm) {
        const controller = Object.create(ReadableStreamDefaultController.prototype);
        let startAlgorithm;
        let pullAlgorithm;
        let cancelAlgorithm;
        if (underlyingSource.start !== undefined) {
            startAlgorithm = () => underlyingSource.start(controller);
        }
        else {
            startAlgorithm = () => undefined;
        }
        if (underlyingSource.pull !== undefined) {
            pullAlgorithm = () => underlyingSource.pull(controller);
        }
        else {
            pullAlgorithm = () => promiseResolvedWith(undefined);
        }
        if (underlyingSource.cancel !== undefined) {
            cancelAlgorithm = reason => underlyingSource.cancel(reason);
        }
        else {
            cancelAlgorithm = () => promiseResolvedWith(undefined);
        }
        SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);
    }
    // Helper functions for the ReadableStreamDefaultController.
    function defaultControllerBrandCheckException$1(name) {
        return new TypeError(`ReadableStreamDefaultController.prototype.${name} can only be used on a ReadableStreamDefaultController`);
    }

    function ReadableStreamTee(stream, cloneForBranch2) {
        if (IsReadableByteStreamController(stream._readableStreamController)) {
            return ReadableByteStreamTee(stream);
        }
        return ReadableStreamDefaultTee(stream);
    }
    function ReadableStreamDefaultTee(stream, cloneForBranch2) {
        const reader = AcquireReadableStreamDefaultReader(stream);
        let reading = false;
        let readAgain = false;
        let canceled1 = false;
        let canceled2 = false;
        let reason1;
        let reason2;
        let branch1;
        let branch2;
        let resolveCancelPromise;
        const cancelPromise = newPromise(resolve => {
            resolveCancelPromise = resolve;
        });
        function pullAlgorithm() {
            if (reading) {
                readAgain = true;
                return promiseResolvedWith(undefined);
            }
            reading = true;
            const readRequest = {
                _chunkSteps: chunk => {
                    // This needs to be delayed a microtask because it takes at least a microtask to detect errors (using
                    // reader._closedPromise below), and we want errors in stream to error both branches immediately. We cannot let
                    // successful synchronously-available reads get ahead of asynchronously-available errors.
                    _queueMicrotask(() => {
                        readAgain = false;
                        const chunk1 = chunk;
                        const chunk2 = chunk;
                        // There is no way to access the cloning code right now in the reference implementation.
                        // If we add one then we'll need an implementation for serializable objects.
                        // if (!canceled2 && cloneForBranch2) {
                        //   chunk2 = StructuredDeserialize(StructuredSerialize(chunk2));
                        // }
                        if (!canceled1) {
                            ReadableStreamDefaultControllerEnqueue(branch1._readableStreamController, chunk1);
                        }
                        if (!canceled2) {
                            ReadableStreamDefaultControllerEnqueue(branch2._readableStreamController, chunk2);
                        }
                        reading = false;
                        if (readAgain) {
                            pullAlgorithm();
                        }
                    });
                },
                _closeSteps: () => {
                    reading = false;
                    if (!canceled1) {
                        ReadableStreamDefaultControllerClose(branch1._readableStreamController);
                    }
                    if (!canceled2) {
                        ReadableStreamDefaultControllerClose(branch2._readableStreamController);
                    }
                    if (!canceled1 || !canceled2) {
                        resolveCancelPromise(undefined);
                    }
                },
                _errorSteps: () => {
                    reading = false;
                }
            };
            ReadableStreamDefaultReaderRead(reader, readRequest);
            return promiseResolvedWith(undefined);
        }
        function cancel1Algorithm(reason) {
            canceled1 = true;
            reason1 = reason;
            if (canceled2) {
                const compositeReason = CreateArrayFromList([reason1, reason2]);
                const cancelResult = ReadableStreamCancel(stream, compositeReason);
                resolveCancelPromise(cancelResult);
            }
            return cancelPromise;
        }
        function cancel2Algorithm(reason) {
            canceled2 = true;
            reason2 = reason;
            if (canceled1) {
                const compositeReason = CreateArrayFromList([reason1, reason2]);
                const cancelResult = ReadableStreamCancel(stream, compositeReason);
                resolveCancelPromise(cancelResult);
            }
            return cancelPromise;
        }
        function startAlgorithm() {
            // do nothing
        }
        branch1 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel1Algorithm);
        branch2 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel2Algorithm);
        uponRejection(reader._closedPromise, (r) => {
            ReadableStreamDefaultControllerError(branch1._readableStreamController, r);
            ReadableStreamDefaultControllerError(branch2._readableStreamController, r);
            if (!canceled1 || !canceled2) {
                resolveCancelPromise(undefined);
            }
            return null;
        });
        return [branch1, branch2];
    }
    function ReadableByteStreamTee(stream) {
        let reader = AcquireReadableStreamDefaultReader(stream);
        let reading = false;
        let readAgainForBranch1 = false;
        let readAgainForBranch2 = false;
        let canceled1 = false;
        let canceled2 = false;
        let reason1;
        let reason2;
        let branch1;
        let branch2;
        let resolveCancelPromise;
        const cancelPromise = newPromise(resolve => {
            resolveCancelPromise = resolve;
        });
        function forwardReaderError(thisReader) {
            uponRejection(thisReader._closedPromise, r => {
                if (thisReader !== reader) {
                    return null;
                }
                ReadableByteStreamControllerError(branch1._readableStreamController, r);
                ReadableByteStreamControllerError(branch2._readableStreamController, r);
                if (!canceled1 || !canceled2) {
                    resolveCancelPromise(undefined);
                }
                return null;
            });
        }
        function pullWithDefaultReader() {
            if (IsReadableStreamBYOBReader(reader)) {
                ReadableStreamReaderGenericRelease(reader);
                reader = AcquireReadableStreamDefaultReader(stream);
                forwardReaderError(reader);
            }
            const readRequest = {
                _chunkSteps: chunk => {
                    // This needs to be delayed a microtask because it takes at least a microtask to detect errors (using
                    // reader._closedPromise below), and we want errors in stream to error both branches immediately. We cannot let
                    // successful synchronously-available reads get ahead of asynchronously-available errors.
                    _queueMicrotask(() => {
                        readAgainForBranch1 = false;
                        readAgainForBranch2 = false;
                        const chunk1 = chunk;
                        let chunk2 = chunk;
                        if (!canceled1 && !canceled2) {
                            try {
                                chunk2 = CloneAsUint8Array(chunk);
                            }
                            catch (cloneE) {
                                ReadableByteStreamControllerError(branch1._readableStreamController, cloneE);
                                ReadableByteStreamControllerError(branch2._readableStreamController, cloneE);
                                resolveCancelPromise(ReadableStreamCancel(stream, cloneE));
                                return;
                            }
                        }
                        if (!canceled1) {
                            ReadableByteStreamControllerEnqueue(branch1._readableStreamController, chunk1);
                        }
                        if (!canceled2) {
                            ReadableByteStreamControllerEnqueue(branch2._readableStreamController, chunk2);
                        }
                        reading = false;
                        if (readAgainForBranch1) {
                            pull1Algorithm();
                        }
                        else if (readAgainForBranch2) {
                            pull2Algorithm();
                        }
                    });
                },
                _closeSteps: () => {
                    reading = false;
                    if (!canceled1) {
                        ReadableByteStreamControllerClose(branch1._readableStreamController);
                    }
                    if (!canceled2) {
                        ReadableByteStreamControllerClose(branch2._readableStreamController);
                    }
                    if (branch1._readableStreamController._pendingPullIntos.length > 0) {
                        ReadableByteStreamControllerRespond(branch1._readableStreamController, 0);
                    }
                    if (branch2._readableStreamController._pendingPullIntos.length > 0) {
                        ReadableByteStreamControllerRespond(branch2._readableStreamController, 0);
                    }
                    if (!canceled1 || !canceled2) {
                        resolveCancelPromise(undefined);
                    }
                },
                _errorSteps: () => {
                    reading = false;
                }
            };
            ReadableStreamDefaultReaderRead(reader, readRequest);
        }
        function pullWithBYOBReader(view, forBranch2) {
            if (IsReadableStreamDefaultReader(reader)) {
                ReadableStreamReaderGenericRelease(reader);
                reader = AcquireReadableStreamBYOBReader(stream);
                forwardReaderError(reader);
            }
            const byobBranch = forBranch2 ? branch2 : branch1;
            const otherBranch = forBranch2 ? branch1 : branch2;
            const readIntoRequest = {
                _chunkSteps: chunk => {
                    // This needs to be delayed a microtask because it takes at least a microtask to detect errors (using
                    // reader._closedPromise below), and we want errors in stream to error both branches immediately. We cannot let
                    // successful synchronously-available reads get ahead of asynchronously-available errors.
                    _queueMicrotask(() => {
                        readAgainForBranch1 = false;
                        readAgainForBranch2 = false;
                        const byobCanceled = forBranch2 ? canceled2 : canceled1;
                        const otherCanceled = forBranch2 ? canceled1 : canceled2;
                        if (!otherCanceled) {
                            let clonedChunk;
                            try {
                                clonedChunk = CloneAsUint8Array(chunk);
                            }
                            catch (cloneE) {
                                ReadableByteStreamControllerError(byobBranch._readableStreamController, cloneE);
                                ReadableByteStreamControllerError(otherBranch._readableStreamController, cloneE);
                                resolveCancelPromise(ReadableStreamCancel(stream, cloneE));
                                return;
                            }
                            if (!byobCanceled) {
                                ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
                            }
                            ReadableByteStreamControllerEnqueue(otherBranch._readableStreamController, clonedChunk);
                        }
                        else if (!byobCanceled) {
                            ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
                        }
                        reading = false;
                        if (readAgainForBranch1) {
                            pull1Algorithm();
                        }
                        else if (readAgainForBranch2) {
                            pull2Algorithm();
                        }
                    });
                },
                _closeSteps: chunk => {
                    reading = false;
                    const byobCanceled = forBranch2 ? canceled2 : canceled1;
                    const otherCanceled = forBranch2 ? canceled1 : canceled2;
                    if (!byobCanceled) {
                        ReadableByteStreamControllerClose(byobBranch._readableStreamController);
                    }
                    if (!otherCanceled) {
                        ReadableByteStreamControllerClose(otherBranch._readableStreamController);
                    }
                    if (chunk !== undefined) {
                        if (!byobCanceled) {
                            ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
                        }
                        if (!otherCanceled && otherBranch._readableStreamController._pendingPullIntos.length > 0) {
                            ReadableByteStreamControllerRespond(otherBranch._readableStreamController, 0);
                        }
                    }
                    if (!byobCanceled || !otherCanceled) {
                        resolveCancelPromise(undefined);
                    }
                },
                _errorSteps: () => {
                    reading = false;
                }
            };
            ReadableStreamBYOBReaderRead(reader, view, 1, readIntoRequest);
        }
        function pull1Algorithm() {
            if (reading) {
                readAgainForBranch1 = true;
                return promiseResolvedWith(undefined);
            }
            reading = true;
            const byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch1._readableStreamController);
            if (byobRequest === null) {
                pullWithDefaultReader();
            }
            else {
                pullWithBYOBReader(byobRequest._view, false);
            }
            return promiseResolvedWith(undefined);
        }
        function pull2Algorithm() {
            if (reading) {
                readAgainForBranch2 = true;
                return promiseResolvedWith(undefined);
            }
            reading = true;
            const byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch2._readableStreamController);
            if (byobRequest === null) {
                pullWithDefaultReader();
            }
            else {
                pullWithBYOBReader(byobRequest._view, true);
            }
            return promiseResolvedWith(undefined);
        }
        function cancel1Algorithm(reason) {
            canceled1 = true;
            reason1 = reason;
            if (canceled2) {
                const compositeReason = CreateArrayFromList([reason1, reason2]);
                const cancelResult = ReadableStreamCancel(stream, compositeReason);
                resolveCancelPromise(cancelResult);
            }
            return cancelPromise;
        }
        function cancel2Algorithm(reason) {
            canceled2 = true;
            reason2 = reason;
            if (canceled1) {
                const compositeReason = CreateArrayFromList([reason1, reason2]);
                const cancelResult = ReadableStreamCancel(stream, compositeReason);
                resolveCancelPromise(cancelResult);
            }
            return cancelPromise;
        }
        function startAlgorithm() {
            return;
        }
        branch1 = CreateReadableByteStream(startAlgorithm, pull1Algorithm, cancel1Algorithm);
        branch2 = CreateReadableByteStream(startAlgorithm, pull2Algorithm, cancel2Algorithm);
        forwardReaderError(reader);
        return [branch1, branch2];
    }

    function isReadableStreamLike(stream) {
        return typeIsObject(stream) && typeof stream.getReader !== 'undefined';
    }

    function ReadableStreamFrom(source) {
        if (isReadableStreamLike(source)) {
            return ReadableStreamFromDefaultReader(source.getReader());
        }
        return ReadableStreamFromIterable(source);
    }
    function ReadableStreamFromIterable(asyncIterable) {
        let stream;
        const iteratorRecord = GetIterator(asyncIterable, 'async');
        const startAlgorithm = noop;
        function pullAlgorithm() {
            let nextResult;
            try {
                nextResult = IteratorNext(iteratorRecord);
            }
            catch (e) {
                return promiseRejectedWith(e);
            }
            const nextPromise = promiseResolvedWith(nextResult);
            return transformPromiseWith(nextPromise, iterResult => {
                if (!typeIsObject(iterResult)) {
                    throw new TypeError('The promise returned by the iterator.next() method must fulfill with an object');
                }
                const done = IteratorComplete(iterResult);
                if (done) {
                    ReadableStreamDefaultControllerClose(stream._readableStreamController);
                }
                else {
                    const value = IteratorValue(iterResult);
                    ReadableStreamDefaultControllerEnqueue(stream._readableStreamController, value);
                }
            });
        }
        function cancelAlgorithm(reason) {
            const iterator = iteratorRecord.iterator;
            let returnMethod;
            try {
                returnMethod = GetMethod(iterator, 'return');
            }
            catch (e) {
                return promiseRejectedWith(e);
            }
            if (returnMethod === undefined) {
                return promiseResolvedWith(undefined);
            }
            let returnResult;
            try {
                returnResult = reflectCall(returnMethod, iterator, [reason]);
            }
            catch (e) {
                return promiseRejectedWith(e);
            }
            const returnPromise = promiseResolvedWith(returnResult);
            return transformPromiseWith(returnPromise, iterResult => {
                if (!typeIsObject(iterResult)) {
                    throw new TypeError('The promise returned by the iterator.return() method must fulfill with an object');
                }
                return undefined;
            });
        }
        stream = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, 0);
        return stream;
    }
    function ReadableStreamFromDefaultReader(reader) {
        let stream;
        const startAlgorithm = noop;
        function pullAlgorithm() {
            let readPromise;
            try {
                readPromise = reader.read();
            }
            catch (e) {
                return promiseRejectedWith(e);
            }
            return transformPromiseWith(readPromise, readResult => {
                if (!typeIsObject(readResult)) {
                    throw new TypeError('The promise returned by the reader.read() method must fulfill with an object');
                }
                if (readResult.done) {
                    ReadableStreamDefaultControllerClose(stream._readableStreamController);
                }
                else {
                    const value = readResult.value;
                    ReadableStreamDefaultControllerEnqueue(stream._readableStreamController, value);
                }
            });
        }
        function cancelAlgorithm(reason) {
            try {
                return promiseResolvedWith(reader.cancel(reason));
            }
            catch (e) {
                return promiseRejectedWith(e);
            }
        }
        stream = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, 0);
        return stream;
    }

    function convertUnderlyingDefaultOrByteSource(source, context) {
        assertDictionary(source, context);
        const original = source;
        const autoAllocateChunkSize = original === null || original === void 0 ? void 0 : original.autoAllocateChunkSize;
        const cancel = original === null || original === void 0 ? void 0 : original.cancel;
        const pull = original === null || original === void 0 ? void 0 : original.pull;
        const start = original === null || original === void 0 ? void 0 : original.start;
        const type = original === null || original === void 0 ? void 0 : original.type;
        return {
            autoAllocateChunkSize: autoAllocateChunkSize === undefined ?
                undefined :
                convertUnsignedLongLongWithEnforceRange(autoAllocateChunkSize, `${context} has member 'autoAllocateChunkSize' that`),
            cancel: cancel === undefined ?
                undefined :
                convertUnderlyingSourceCancelCallback(cancel, original, `${context} has member 'cancel' that`),
            pull: pull === undefined ?
                undefined :
                convertUnderlyingSourcePullCallback(pull, original, `${context} has member 'pull' that`),
            start: start === undefined ?
                undefined :
                convertUnderlyingSourceStartCallback(start, original, `${context} has member 'start' that`),
            type: type === undefined ? undefined : convertReadableStreamType(type, `${context} has member 'type' that`)
        };
    }
    function convertUnderlyingSourceCancelCallback(fn, original, context) {
        assertFunction(fn, context);
        return (reason) => promiseCall(fn, original, [reason]);
    }
    function convertUnderlyingSourcePullCallback(fn, original, context) {
        assertFunction(fn, context);
        return (controller) => promiseCall(fn, original, [controller]);
    }
    function convertUnderlyingSourceStartCallback(fn, original, context) {
        assertFunction(fn, context);
        return (controller) => reflectCall(fn, original, [controller]);
    }
    function convertReadableStreamType(type, context) {
        type = `${type}`;
        if (type !== 'bytes') {
            throw new TypeError(`${context} '${type}' is not a valid enumeration value for ReadableStreamType`);
        }
        return type;
    }

    function convertIteratorOptions(options, context) {
        assertDictionary(options, context);
        const preventCancel = options === null || options === void 0 ? void 0 : options.preventCancel;
        return { preventCancel: Boolean(preventCancel) };
    }

    function convertPipeOptions(options, context) {
        assertDictionary(options, context);
        const preventAbort = options === null || options === void 0 ? void 0 : options.preventAbort;
        const preventCancel = options === null || options === void 0 ? void 0 : options.preventCancel;
        const preventClose = options === null || options === void 0 ? void 0 : options.preventClose;
        const signal = options === null || options === void 0 ? void 0 : options.signal;
        if (signal !== undefined) {
            assertAbortSignal(signal, `${context} has member 'signal' that`);
        }
        return {
            preventAbort: Boolean(preventAbort),
            preventCancel: Boolean(preventCancel),
            preventClose: Boolean(preventClose),
            signal
        };
    }
    function assertAbortSignal(signal, context) {
        if (!isAbortSignal(signal)) {
            throw new TypeError(`${context} is not an AbortSignal.`);
        }
    }

    function convertReadableWritablePair(pair, context) {
        assertDictionary(pair, context);
        const readable = pair === null || pair === void 0 ? void 0 : pair.readable;
        assertRequiredField(readable, 'readable', 'ReadableWritablePair');
        assertReadableStream(readable, `${context} has member 'readable' that`);
        const writable = pair === null || pair === void 0 ? void 0 : pair.writable;
        assertRequiredField(writable, 'writable', 'ReadableWritablePair');
        assertWritableStream(writable, `${context} has member 'writable' that`);
        return { readable, writable };
    }

    /**
     * A readable stream represents a source of data, from which you can read.
     *
     * @public
     */
    class ReadableStream {
        constructor(rawUnderlyingSource = {}, rawStrategy = {}) {
            if (rawUnderlyingSource === undefined) {
                rawUnderlyingSource = null;
            }
            else {
                assertObject(rawUnderlyingSource, 'First parameter');
            }
            const strategy = convertQueuingStrategy(rawStrategy, 'Second parameter');
            const underlyingSource = convertUnderlyingDefaultOrByteSource(rawUnderlyingSource, 'First parameter');
            InitializeReadableStream(this);
            if (underlyingSource.type === 'bytes') {
                if (strategy.size !== undefined) {
                    throw new RangeError('The strategy for a byte stream cannot have a size function');
                }
                const highWaterMark = ExtractHighWaterMark(strategy, 0);
                SetUpReadableByteStreamControllerFromUnderlyingSource(this, underlyingSource, highWaterMark);
            }
            else {
                const sizeAlgorithm = ExtractSizeAlgorithm(strategy);
                const highWaterMark = ExtractHighWaterMark(strategy, 1);
                SetUpReadableStreamDefaultControllerFromUnderlyingSource(this, underlyingSource, highWaterMark, sizeAlgorithm);
            }
        }
        /**
         * Whether or not the readable stream is locked to a {@link ReadableStreamDefaultReader | reader}.
         */
        get locked() {
            if (!IsReadableStream(this)) {
                throw streamBrandCheckException$1('locked');
            }
            return IsReadableStreamLocked(this);
        }
        /**
         * Cancels the stream, signaling a loss of interest in the stream by a consumer.
         *
         * The supplied `reason` argument will be given to the underlying source's {@link UnderlyingSource.cancel | cancel()}
         * method, which might or might not use it.
         */
        cancel(reason = undefined) {
            if (!IsReadableStream(this)) {
                return promiseRejectedWith(streamBrandCheckException$1('cancel'));
            }
            if (IsReadableStreamLocked(this)) {
                return promiseRejectedWith(new TypeError('Cannot cancel a stream that already has a reader'));
            }
            return ReadableStreamCancel(this, reason);
        }
        getReader(rawOptions = undefined) {
            if (!IsReadableStream(this)) {
                throw streamBrandCheckException$1('getReader');
            }
            const options = convertReaderOptions(rawOptions, 'First parameter');
            if (options.mode === undefined) {
                return AcquireReadableStreamDefaultReader(this);
            }
            return AcquireReadableStreamBYOBReader(this);
        }
        pipeThrough(rawTransform, rawOptions = {}) {
            if (!IsReadableStream(this)) {
                throw streamBrandCheckException$1('pipeThrough');
            }
            assertRequiredArgument(rawTransform, 1, 'pipeThrough');
            const transform = convertReadableWritablePair(rawTransform, 'First parameter');
            const options = convertPipeOptions(rawOptions, 'Second parameter');
            if (IsReadableStreamLocked(this)) {
                throw new TypeError('ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream');
            }
            if (IsWritableStreamLocked(transform.writable)) {
                throw new TypeError('ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream');
            }
            const promise = ReadableStreamPipeTo(this, transform.writable, options.preventClose, options.preventAbort, options.preventCancel, options.signal);
            setPromiseIsHandledToTrue(promise);
            return transform.readable;
        }
        pipeTo(destination, rawOptions = {}) {
            if (!IsReadableStream(this)) {
                return promiseRejectedWith(streamBrandCheckException$1('pipeTo'));
            }
            if (destination === undefined) {
                return promiseRejectedWith(`Parameter 1 is required in 'pipeTo'.`);
            }
            if (!IsWritableStream(destination)) {
                return promiseRejectedWith(new TypeError(`ReadableStream.prototype.pipeTo's first argument must be a WritableStream`));
            }
            let options;
            try {
                options = convertPipeOptions(rawOptions, 'Second parameter');
            }
            catch (e) {
                return promiseRejectedWith(e);
            }
            if (IsReadableStreamLocked(this)) {
                return promiseRejectedWith(new TypeError('ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream'));
            }
            if (IsWritableStreamLocked(destination)) {
                return promiseRejectedWith(new TypeError('ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream'));
            }
            return ReadableStreamPipeTo(this, destination, options.preventClose, options.preventAbort, options.preventCancel, options.signal);
        }
        /**
         * Tees this readable stream, returning a two-element array containing the two resulting branches as
         * new {@link ReadableStream} instances.
         *
         * Teeing a stream will lock it, preventing any other consumer from acquiring a reader.
         * To cancel the stream, cancel both of the resulting branches; a composite cancellation reason will then be
         * propagated to the stream's underlying source.
         *
         * Note that the chunks seen in each branch will be the same object. If the chunks are not immutable,
         * this could allow interference between the two branches.
         */
        tee() {
            if (!IsReadableStream(this)) {
                throw streamBrandCheckException$1('tee');
            }
            const branches = ReadableStreamTee(this);
            return CreateArrayFromList(branches);
        }
        values(rawOptions = undefined) {
            if (!IsReadableStream(this)) {
                throw streamBrandCheckException$1('values');
            }
            const options = convertIteratorOptions(rawOptions, 'First parameter');
            return AcquireReadableStreamAsyncIterator(this, options.preventCancel);
        }
        [SymbolAsyncIterator](options) {
            // Stub implementation, overridden below
            return this.values(options);
        }
        /**
         * Creates a new ReadableStream wrapping the provided iterable or async iterable.
         *
         * This can be used to adapt various kinds of objects into a readable stream,
         * such as an array, an async generator, or a Node.js readable stream.
         */
        static from(asyncIterable) {
            return ReadableStreamFrom(asyncIterable);
        }
    }
    Object.defineProperties(ReadableStream, {
        from: { enumerable: true }
    });
    Object.defineProperties(ReadableStream.prototype, {
        cancel: { enumerable: true },
        getReader: { enumerable: true },
        pipeThrough: { enumerable: true },
        pipeTo: { enumerable: true },
        tee: { enumerable: true },
        values: { enumerable: true },
        locked: { enumerable: true }
    });
    setFunctionName(ReadableStream.from, 'from');
    setFunctionName(ReadableStream.prototype.cancel, 'cancel');
    setFunctionName(ReadableStream.prototype.getReader, 'getReader');
    setFunctionName(ReadableStream.prototype.pipeThrough, 'pipeThrough');
    setFunctionName(ReadableStream.prototype.pipeTo, 'pipeTo');
    setFunctionName(ReadableStream.prototype.tee, 'tee');
    setFunctionName(ReadableStream.prototype.values, 'values');
    if (typeof Symbol.toStringTag === 'symbol') {
        Object.defineProperty(ReadableStream.prototype, Symbol.toStringTag, {
            value: 'ReadableStream',
            configurable: true
        });
    }
    Object.defineProperty(ReadableStream.prototype, SymbolAsyncIterator, {
        value: ReadableStream.prototype.values,
        writable: true,
        configurable: true
    });
    // Abstract operations for the ReadableStream.
    // Throws if and only if startAlgorithm throws.
    function CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark = 1, sizeAlgorithm = () => 1) {
        const stream = Object.create(ReadableStream.prototype);
        InitializeReadableStream(stream);
        const controller = Object.create(ReadableStreamDefaultController.prototype);
        SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);
        return stream;
    }
    // Throws if and only if startAlgorithm throws.
    function CreateReadableByteStream(startAlgorithm, pullAlgorithm, cancelAlgorithm) {
        const stream = Object.create(ReadableStream.prototype);
        InitializeReadableStream(stream);
        const controller = Object.create(ReadableByteStreamController.prototype);
        SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, 0, undefined);
        return stream;
    }
    function InitializeReadableStream(stream) {
        stream._state = 'readable';
        stream._reader = undefined;
        stream._storedError = undefined;
        stream._disturbed = false;
    }
    function IsReadableStream(x) {
        if (!typeIsObject(x)) {
            return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, '_readableStreamController')) {
            return false;
        }
        return x instanceof ReadableStream;
    }
    function IsReadableStreamLocked(stream) {
        if (stream._reader === undefined) {
            return false;
        }
        return true;
    }
    // ReadableStream API exposed for controllers.
    function ReadableStreamCancel(stream, reason) {
        stream._disturbed = true;
        if (stream._state === 'closed') {
            return promiseResolvedWith(undefined);
        }
        if (stream._state === 'errored') {
            return promiseRejectedWith(stream._storedError);
        }
        ReadableStreamClose(stream);
        const reader = stream._reader;
        if (reader !== undefined && IsReadableStreamBYOBReader(reader)) {
            const readIntoRequests = reader._readIntoRequests;
            reader._readIntoRequests = new SimpleQueue();
            readIntoRequests.forEach(readIntoRequest => {
                readIntoRequest._closeSteps(undefined);
            });
        }
        const sourceCancelPromise = stream._readableStreamController[CancelSteps](reason);
        return transformPromiseWith(sourceCancelPromise, noop);
    }
    function ReadableStreamClose(stream) {
        stream._state = 'closed';
        const reader = stream._reader;
        if (reader === undefined) {
            return;
        }
        defaultReaderClosedPromiseResolve(reader);
        if (IsReadableStreamDefaultReader(reader)) {
            const readRequests = reader._readRequests;
            reader._readRequests = new SimpleQueue();
            readRequests.forEach(readRequest => {
                readRequest._closeSteps();
            });
        }
    }
    function ReadableStreamError(stream, e) {
        stream._state = 'errored';
        stream._storedError = e;
        const reader = stream._reader;
        if (reader === undefined) {
            return;
        }
        defaultReaderClosedPromiseReject(reader, e);
        if (IsReadableStreamDefaultReader(reader)) {
            ReadableStreamDefaultReaderErrorReadRequests(reader, e);
        }
        else {
            ReadableStreamBYOBReaderErrorReadIntoRequests(reader, e);
        }
    }
    // Helper functions for the ReadableStream.
    function streamBrandCheckException$1(name) {
        return new TypeError(`ReadableStream.prototype.${name} can only be used on a ReadableStream`);
    }

    function convertQueuingStrategyInit(init, context) {
        assertDictionary(init, context);
        const highWaterMark = init === null || init === void 0 ? void 0 : init.highWaterMark;
        assertRequiredField(highWaterMark, 'highWaterMark', 'QueuingStrategyInit');
        return {
            highWaterMark: convertUnrestrictedDouble(highWaterMark)
        };
    }

    // The size function must not have a prototype property nor be a constructor
    const byteLengthSizeFunction = (chunk) => {
        return chunk.byteLength;
    };
    setFunctionName(byteLengthSizeFunction, 'size');
    /**
     * A queuing strategy that counts the number of bytes in each chunk.
     *
     * @public
     */
    class ByteLengthQueuingStrategy {
        constructor(options) {
            assertRequiredArgument(options, 1, 'ByteLengthQueuingStrategy');
            options = convertQueuingStrategyInit(options, 'First parameter');
            this._byteLengthQueuingStrategyHighWaterMark = options.highWaterMark;
        }
        /**
         * Returns the high water mark provided to the constructor.
         */
        get highWaterMark() {
            if (!IsByteLengthQueuingStrategy(this)) {
                throw byteLengthBrandCheckException('highWaterMark');
            }
            return this._byteLengthQueuingStrategyHighWaterMark;
        }
        /**
         * Measures the size of `chunk` by returning the value of its `byteLength` property.
         */
        get size() {
            if (!IsByteLengthQueuingStrategy(this)) {
                throw byteLengthBrandCheckException('size');
            }
            return byteLengthSizeFunction;
        }
    }
    Object.defineProperties(ByteLengthQueuingStrategy.prototype, {
        highWaterMark: { enumerable: true },
        size: { enumerable: true }
    });
    if (typeof Symbol.toStringTag === 'symbol') {
        Object.defineProperty(ByteLengthQueuingStrategy.prototype, Symbol.toStringTag, {
            value: 'ByteLengthQueuingStrategy',
            configurable: true
        });
    }
    // Helper functions for the ByteLengthQueuingStrategy.
    function byteLengthBrandCheckException(name) {
        return new TypeError(`ByteLengthQueuingStrategy.prototype.${name} can only be used on a ByteLengthQueuingStrategy`);
    }
    function IsByteLengthQueuingStrategy(x) {
        if (!typeIsObject(x)) {
            return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, '_byteLengthQueuingStrategyHighWaterMark')) {
            return false;
        }
        return x instanceof ByteLengthQueuingStrategy;
    }

    // The size function must not have a prototype property nor be a constructor
    const countSizeFunction = () => {
        return 1;
    };
    setFunctionName(countSizeFunction, 'size');
    /**
     * A queuing strategy that counts the number of chunks.
     *
     * @public
     */
    class CountQueuingStrategy {
        constructor(options) {
            assertRequiredArgument(options, 1, 'CountQueuingStrategy');
            options = convertQueuingStrategyInit(options, 'First parameter');
            this._countQueuingStrategyHighWaterMark = options.highWaterMark;
        }
        /**
         * Returns the high water mark provided to the constructor.
         */
        get highWaterMark() {
            if (!IsCountQueuingStrategy(this)) {
                throw countBrandCheckException('highWaterMark');
            }
            return this._countQueuingStrategyHighWaterMark;
        }
        /**
         * Measures the size of `chunk` by always returning 1.
         * This ensures that the total queue size is a count of the number of chunks in the queue.
         */
        get size() {
            if (!IsCountQueuingStrategy(this)) {
                throw countBrandCheckException('size');
            }
            return countSizeFunction;
        }
    }
    Object.defineProperties(CountQueuingStrategy.prototype, {
        highWaterMark: { enumerable: true },
        size: { enumerable: true }
    });
    if (typeof Symbol.toStringTag === 'symbol') {
        Object.defineProperty(CountQueuingStrategy.prototype, Symbol.toStringTag, {
            value: 'CountQueuingStrategy',
            configurable: true
        });
    }
    // Helper functions for the CountQueuingStrategy.
    function countBrandCheckException(name) {
        return new TypeError(`CountQueuingStrategy.prototype.${name} can only be used on a CountQueuingStrategy`);
    }
    function IsCountQueuingStrategy(x) {
        if (!typeIsObject(x)) {
            return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, '_countQueuingStrategyHighWaterMark')) {
            return false;
        }
        return x instanceof CountQueuingStrategy;
    }

    function convertTransformer(original, context) {
        assertDictionary(original, context);
        const cancel = original === null || original === void 0 ? void 0 : original.cancel;
        const flush = original === null || original === void 0 ? void 0 : original.flush;
        const readableType = original === null || original === void 0 ? void 0 : original.readableType;
        const start = original === null || original === void 0 ? void 0 : original.start;
        const transform = original === null || original === void 0 ? void 0 : original.transform;
        const writableType = original === null || original === void 0 ? void 0 : original.writableType;
        return {
            cancel: cancel === undefined ?
                undefined :
                convertTransformerCancelCallback(cancel, original, `${context} has member 'cancel' that`),
            flush: flush === undefined ?
                undefined :
                convertTransformerFlushCallback(flush, original, `${context} has member 'flush' that`),
            readableType,
            start: start === undefined ?
                undefined :
                convertTransformerStartCallback(start, original, `${context} has member 'start' that`),
            transform: transform === undefined ?
                undefined :
                convertTransformerTransformCallback(transform, original, `${context} has member 'transform' that`),
            writableType
        };
    }
    function convertTransformerFlushCallback(fn, original, context) {
        assertFunction(fn, context);
        return (controller) => promiseCall(fn, original, [controller]);
    }
    function convertTransformerStartCallback(fn, original, context) {
        assertFunction(fn, context);
        return (controller) => reflectCall(fn, original, [controller]);
    }
    function convertTransformerTransformCallback(fn, original, context) {
        assertFunction(fn, context);
        return (chunk, controller) => promiseCall(fn, original, [chunk, controller]);
    }
    function convertTransformerCancelCallback(fn, original, context) {
        assertFunction(fn, context);
        return (reason) => promiseCall(fn, original, [reason]);
    }

    // Class TransformStream
    /**
     * A transform stream consists of a pair of streams: a {@link WritableStream | writable stream},
     * known as its writable side, and a {@link ReadableStream | readable stream}, known as its readable side.
     * In a manner specific to the transform stream in question, writes to the writable side result in new data being
     * made available for reading from the readable side.
     *
     * @public
     */
    class TransformStream {
        constructor(rawTransformer = {}, rawWritableStrategy = {}, rawReadableStrategy = {}) {
            if (rawTransformer === undefined) {
                rawTransformer = null;
            }
            const writableStrategy = convertQueuingStrategy(rawWritableStrategy, 'Second parameter');
            const readableStrategy = convertQueuingStrategy(rawReadableStrategy, 'Third parameter');
            const transformer = convertTransformer(rawTransformer, 'First parameter');
            if (transformer.readableType !== undefined) {
                throw new RangeError('Invalid readableType specified');
            }
            if (transformer.writableType !== undefined) {
                throw new RangeError('Invalid writableType specified');
            }
            const readableHighWaterMark = ExtractHighWaterMark(readableStrategy, 0);
            const readableSizeAlgorithm = ExtractSizeAlgorithm(readableStrategy);
            const writableHighWaterMark = ExtractHighWaterMark(writableStrategy, 1);
            const writableSizeAlgorithm = ExtractSizeAlgorithm(writableStrategy);
            let startPromise_resolve;
            const startPromise = newPromise(resolve => {
                startPromise_resolve = resolve;
            });
            InitializeTransformStream(this, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm);
            SetUpTransformStreamDefaultControllerFromTransformer(this, transformer);
            if (transformer.start !== undefined) {
                startPromise_resolve(transformer.start(this._transformStreamController));
            }
            else {
                startPromise_resolve(undefined);
            }
        }
        /**
         * The readable side of the transform stream.
         */
        get readable() {
            if (!IsTransformStream(this)) {
                throw streamBrandCheckException('readable');
            }
            return this._readable;
        }
        /**
         * The writable side of the transform stream.
         */
        get writable() {
            if (!IsTransformStream(this)) {
                throw streamBrandCheckException('writable');
            }
            return this._writable;
        }
    }
    Object.defineProperties(TransformStream.prototype, {
        readable: { enumerable: true },
        writable: { enumerable: true }
    });
    if (typeof Symbol.toStringTag === 'symbol') {
        Object.defineProperty(TransformStream.prototype, Symbol.toStringTag, {
            value: 'TransformStream',
            configurable: true
        });
    }
    function InitializeTransformStream(stream, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm) {
        function startAlgorithm() {
            return startPromise;
        }
        function writeAlgorithm(chunk) {
            return TransformStreamDefaultSinkWriteAlgorithm(stream, chunk);
        }
        function abortAlgorithm(reason) {
            return TransformStreamDefaultSinkAbortAlgorithm(stream, reason);
        }
        function closeAlgorithm() {
            return TransformStreamDefaultSinkCloseAlgorithm(stream);
        }
        stream._writable = CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, writableHighWaterMark, writableSizeAlgorithm);
        function pullAlgorithm() {
            return TransformStreamDefaultSourcePullAlgorithm(stream);
        }
        function cancelAlgorithm(reason) {
            return TransformStreamDefaultSourceCancelAlgorithm(stream, reason);
        }
        stream._readable = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, readableHighWaterMark, readableSizeAlgorithm);
        // The [[backpressure]] slot is set to undefined so that it can be initialised by TransformStreamSetBackpressure.
        stream._backpressure = undefined;
        stream._backpressureChangePromise = undefined;
        stream._backpressureChangePromise_resolve = undefined;
        TransformStreamSetBackpressure(stream, true);
        stream._transformStreamController = undefined;
    }
    function IsTransformStream(x) {
        if (!typeIsObject(x)) {
            return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, '_transformStreamController')) {
            return false;
        }
        return x instanceof TransformStream;
    }
    // This is a no-op if both sides are already errored.
    function TransformStreamError(stream, e) {
        ReadableStreamDefaultControllerError(stream._readable._readableStreamController, e);
        TransformStreamErrorWritableAndUnblockWrite(stream, e);
    }
    function TransformStreamErrorWritableAndUnblockWrite(stream, e) {
        TransformStreamDefaultControllerClearAlgorithms(stream._transformStreamController);
        WritableStreamDefaultControllerErrorIfNeeded(stream._writable._writableStreamController, e);
        TransformStreamUnblockWrite(stream);
    }
    function TransformStreamUnblockWrite(stream) {
        if (stream._backpressure) {
            // Pretend that pull() was called to permit any pending write() calls to complete. TransformStreamSetBackpressure()
            // cannot be called from enqueue() or pull() once the ReadableStream is errored, so this will will be the final time
            // _backpressure is set.
            TransformStreamSetBackpressure(stream, false);
        }
    }
    function TransformStreamSetBackpressure(stream, backpressure) {
        // Passes also when called during construction.
        if (stream._backpressureChangePromise !== undefined) {
            stream._backpressureChangePromise_resolve();
        }
        stream._backpressureChangePromise = newPromise(resolve => {
            stream._backpressureChangePromise_resolve = resolve;
        });
        stream._backpressure = backpressure;
    }
    // Class TransformStreamDefaultController
    /**
     * Allows control of the {@link ReadableStream} and {@link WritableStream} of the associated {@link TransformStream}.
     *
     * @public
     */
    class TransformStreamDefaultController {
        constructor() {
            throw new TypeError('Illegal constructor');
        }
        /**
         * Returns the desired size to fill the readable side’s internal queue. It can be negative, if the queue is over-full.
         */
        get desiredSize() {
            if (!IsTransformStreamDefaultController(this)) {
                throw defaultControllerBrandCheckException('desiredSize');
            }
            const readableController = this._controlledTransformStream._readable._readableStreamController;
            return ReadableStreamDefaultControllerGetDesiredSize(readableController);
        }
        enqueue(chunk = undefined) {
            if (!IsTransformStreamDefaultController(this)) {
                throw defaultControllerBrandCheckException('enqueue');
            }
            TransformStreamDefaultControllerEnqueue(this, chunk);
        }
        /**
         * Errors both the readable side and the writable side of the controlled transform stream, making all future
         * interactions with it fail with the given error `e`. Any chunks queued for transformation will be discarded.
         */
        error(reason = undefined) {
            if (!IsTransformStreamDefaultController(this)) {
                throw defaultControllerBrandCheckException('error');
            }
            TransformStreamDefaultControllerError(this, reason);
        }
        /**
         * Closes the readable side and errors the writable side of the controlled transform stream. This is useful when the
         * transformer only needs to consume a portion of the chunks written to the writable side.
         */
        terminate() {
            if (!IsTransformStreamDefaultController(this)) {
                throw defaultControllerBrandCheckException('terminate');
            }
            TransformStreamDefaultControllerTerminate(this);
        }
    }
    Object.defineProperties(TransformStreamDefaultController.prototype, {
        enqueue: { enumerable: true },
        error: { enumerable: true },
        terminate: { enumerable: true },
        desiredSize: { enumerable: true }
    });
    setFunctionName(TransformStreamDefaultController.prototype.enqueue, 'enqueue');
    setFunctionName(TransformStreamDefaultController.prototype.error, 'error');
    setFunctionName(TransformStreamDefaultController.prototype.terminate, 'terminate');
    if (typeof Symbol.toStringTag === 'symbol') {
        Object.defineProperty(TransformStreamDefaultController.prototype, Symbol.toStringTag, {
            value: 'TransformStreamDefaultController',
            configurable: true
        });
    }
    // Transform Stream Default Controller Abstract Operations
    function IsTransformStreamDefaultController(x) {
        if (!typeIsObject(x)) {
            return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, '_controlledTransformStream')) {
            return false;
        }
        return x instanceof TransformStreamDefaultController;
    }
    function SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm, cancelAlgorithm) {
        controller._controlledTransformStream = stream;
        stream._transformStreamController = controller;
        controller._transformAlgorithm = transformAlgorithm;
        controller._flushAlgorithm = flushAlgorithm;
        controller._cancelAlgorithm = cancelAlgorithm;
        controller._finishPromise = undefined;
        controller._finishPromise_resolve = undefined;
        controller._finishPromise_reject = undefined;
    }
    function SetUpTransformStreamDefaultControllerFromTransformer(stream, transformer) {
        const controller = Object.create(TransformStreamDefaultController.prototype);
        let transformAlgorithm;
        let flushAlgorithm;
        let cancelAlgorithm;
        if (transformer.transform !== undefined) {
            transformAlgorithm = chunk => transformer.transform(chunk, controller);
        }
        else {
            transformAlgorithm = chunk => {
                try {
                    TransformStreamDefaultControllerEnqueue(controller, chunk);
                    return promiseResolvedWith(undefined);
                }
                catch (transformResultE) {
                    return promiseRejectedWith(transformResultE);
                }
            };
        }
        if (transformer.flush !== undefined) {
            flushAlgorithm = () => transformer.flush(controller);
        }
        else {
            flushAlgorithm = () => promiseResolvedWith(undefined);
        }
        if (transformer.cancel !== undefined) {
            cancelAlgorithm = reason => transformer.cancel(reason);
        }
        else {
            cancelAlgorithm = () => promiseResolvedWith(undefined);
        }
        SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm, cancelAlgorithm);
    }
    function TransformStreamDefaultControllerClearAlgorithms(controller) {
        controller._transformAlgorithm = undefined;
        controller._flushAlgorithm = undefined;
        controller._cancelAlgorithm = undefined;
    }
    function TransformStreamDefaultControllerEnqueue(controller, chunk) {
        const stream = controller._controlledTransformStream;
        const readableController = stream._readable._readableStreamController;
        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController)) {
            throw new TypeError('Readable side is not in a state that permits enqueue');
        }
        // We throttle transform invocations based on the backpressure of the ReadableStream, but we still
        // accept TransformStreamDefaultControllerEnqueue() calls.
        try {
            ReadableStreamDefaultControllerEnqueue(readableController, chunk);
        }
        catch (e) {
            // This happens when readableStrategy.size() throws.
            TransformStreamErrorWritableAndUnblockWrite(stream, e);
            throw stream._readable._storedError;
        }
        const backpressure = ReadableStreamDefaultControllerHasBackpressure(readableController);
        if (backpressure !== stream._backpressure) {
            TransformStreamSetBackpressure(stream, true);
        }
    }
    function TransformStreamDefaultControllerError(controller, e) {
        TransformStreamError(controller._controlledTransformStream, e);
    }
    function TransformStreamDefaultControllerPerformTransform(controller, chunk) {
        const transformPromise = controller._transformAlgorithm(chunk);
        return transformPromiseWith(transformPromise, undefined, r => {
            TransformStreamError(controller._controlledTransformStream, r);
            throw r;
        });
    }
    function TransformStreamDefaultControllerTerminate(controller) {
        const stream = controller._controlledTransformStream;
        const readableController = stream._readable._readableStreamController;
        ReadableStreamDefaultControllerClose(readableController);
        const error = new TypeError('TransformStream terminated');
        TransformStreamErrorWritableAndUnblockWrite(stream, error);
    }
    // TransformStreamDefaultSink Algorithms
    function TransformStreamDefaultSinkWriteAlgorithm(stream, chunk) {
        const controller = stream._transformStreamController;
        if (stream._backpressure) {
            const backpressureChangePromise = stream._backpressureChangePromise;
            return transformPromiseWith(backpressureChangePromise, () => {
                const writable = stream._writable;
                const state = writable._state;
                if (state === 'erroring') {
                    throw writable._storedError;
                }
                return TransformStreamDefaultControllerPerformTransform(controller, chunk);
            });
        }
        return TransformStreamDefaultControllerPerformTransform(controller, chunk);
    }
    function TransformStreamDefaultSinkAbortAlgorithm(stream, reason) {
        const controller = stream._transformStreamController;
        if (controller._finishPromise !== undefined) {
            return controller._finishPromise;
        }
        // stream._readable cannot change after construction, so caching it across a call to user code is safe.
        const readable = stream._readable;
        // Assign the _finishPromise now so that if _cancelAlgorithm calls readable.cancel() internally,
        // we don't run the _cancelAlgorithm again.
        controller._finishPromise = newPromise((resolve, reject) => {
            controller._finishPromise_resolve = resolve;
            controller._finishPromise_reject = reject;
        });
        const cancelPromise = controller._cancelAlgorithm(reason);
        TransformStreamDefaultControllerClearAlgorithms(controller);
        uponPromise(cancelPromise, () => {
            if (readable._state === 'errored') {
                defaultControllerFinishPromiseReject(controller, readable._storedError);
            }
            else {
                ReadableStreamDefaultControllerError(readable._readableStreamController, reason);
                defaultControllerFinishPromiseResolve(controller);
            }
            return null;
        }, r => {
            ReadableStreamDefaultControllerError(readable._readableStreamController, r);
            defaultControllerFinishPromiseReject(controller, r);
            return null;
        });
        return controller._finishPromise;
    }
    function TransformStreamDefaultSinkCloseAlgorithm(stream) {
        const controller = stream._transformStreamController;
        if (controller._finishPromise !== undefined) {
            return controller._finishPromise;
        }
        // stream._readable cannot change after construction, so caching it across a call to user code is safe.
        const readable = stream._readable;
        // Assign the _finishPromise now so that if _flushAlgorithm calls readable.cancel() internally,
        // we don't also run the _cancelAlgorithm.
        controller._finishPromise = newPromise((resolve, reject) => {
            controller._finishPromise_resolve = resolve;
            controller._finishPromise_reject = reject;
        });
        const flushPromise = controller._flushAlgorithm();
        TransformStreamDefaultControllerClearAlgorithms(controller);
        uponPromise(flushPromise, () => {
            if (readable._state === 'errored') {
                defaultControllerFinishPromiseReject(controller, readable._storedError);
            }
            else {
                ReadableStreamDefaultControllerClose(readable._readableStreamController);
                defaultControllerFinishPromiseResolve(controller);
            }
            return null;
        }, r => {
            ReadableStreamDefaultControllerError(readable._readableStreamController, r);
            defaultControllerFinishPromiseReject(controller, r);
            return null;
        });
        return controller._finishPromise;
    }
    // TransformStreamDefaultSource Algorithms
    function TransformStreamDefaultSourcePullAlgorithm(stream) {
        // Invariant. Enforced by the promises returned by start() and pull().
        TransformStreamSetBackpressure(stream, false);
        // Prevent the next pull() call until there is backpressure.
        return stream._backpressureChangePromise;
    }
    function TransformStreamDefaultSourceCancelAlgorithm(stream, reason) {
        const controller = stream._transformStreamController;
        if (controller._finishPromise !== undefined) {
            return controller._finishPromise;
        }
        // stream._writable cannot change after construction, so caching it across a call to user code is safe.
        const writable = stream._writable;
        // Assign the _finishPromise now so that if _flushAlgorithm calls writable.abort() or
        // writable.cancel() internally, we don't run the _cancelAlgorithm again, or also run the
        // _flushAlgorithm.
        controller._finishPromise = newPromise((resolve, reject) => {
            controller._finishPromise_resolve = resolve;
            controller._finishPromise_reject = reject;
        });
        const cancelPromise = controller._cancelAlgorithm(reason);
        TransformStreamDefaultControllerClearAlgorithms(controller);
        uponPromise(cancelPromise, () => {
            if (writable._state === 'errored') {
                defaultControllerFinishPromiseReject(controller, writable._storedError);
            }
            else {
                WritableStreamDefaultControllerErrorIfNeeded(writable._writableStreamController, reason);
                TransformStreamUnblockWrite(stream);
                defaultControllerFinishPromiseResolve(controller);
            }
            return null;
        }, r => {
            WritableStreamDefaultControllerErrorIfNeeded(writable._writableStreamController, r);
            TransformStreamUnblockWrite(stream);
            defaultControllerFinishPromiseReject(controller, r);
            return null;
        });
        return controller._finishPromise;
    }
    // Helper functions for the TransformStreamDefaultController.
    function defaultControllerBrandCheckException(name) {
        return new TypeError(`TransformStreamDefaultController.prototype.${name} can only be used on a TransformStreamDefaultController`);
    }
    function defaultControllerFinishPromiseResolve(controller) {
        if (controller._finishPromise_resolve === undefined) {
            return;
        }
        controller._finishPromise_resolve();
        controller._finishPromise_resolve = undefined;
        controller._finishPromise_reject = undefined;
    }
    function defaultControllerFinishPromiseReject(controller, reason) {
        if (controller._finishPromise_reject === undefined) {
            return;
        }
        setPromiseIsHandledToTrue(controller._finishPromise);
        controller._finishPromise_reject(reason);
        controller._finishPromise_resolve = undefined;
        controller._finishPromise_reject = undefined;
    }
    // Helper functions for the TransformStream.
    function streamBrandCheckException(name) {
        return new TypeError(`TransformStream.prototype.${name} can only be used on a TransformStream`);
    }

    exports.ByteLengthQueuingStrategy = ByteLengthQueuingStrategy;
    exports.CountQueuingStrategy = CountQueuingStrategy;
    exports.ReadableByteStreamController = ReadableByteStreamController;
    exports.ReadableStream = ReadableStream;
    exports.ReadableStreamBYOBReader = ReadableStreamBYOBReader;
    exports.ReadableStreamBYOBRequest = ReadableStreamBYOBRequest;
    exports.ReadableStreamDefaultController = ReadableStreamDefaultController;
    exports.ReadableStreamDefaultReader = ReadableStreamDefaultReader;
    exports.TransformStream = TransformStream;
    exports.TransformStreamDefaultController = TransformStreamDefaultController;
    exports.WritableStream = WritableStream;
    exports.WritableStreamDefaultController = WritableStreamDefaultController;
    exports.WritableStreamDefaultWriter = WritableStreamDefaultWriter;

}));
//# sourceMappingURL=ponyfill.es2018.js.map


/***/ }),

/***/ 8076:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
var interfaces_1 = __nccwpck_require__(5212);
var util_1 = __nccwpck_require__(7061);
var util_2 = __nccwpck_require__(628);
var _1 = __nccwpck_require__(8434);
var dom_1 = __nccwpck_require__(1954);
/** @inheritdoc */
function builder(p1, p2) {
    var options = formatBuilderOptions(isXMLBuilderCreateOptions(p1) ? p1 : interfaces_1.DefaultBuilderOptions);
    var nodes = util_2.Guard.isNode(p1) || util_1.isArray(p1) ? p1 : p2;
    if (nodes === undefined) {
        throw new Error("Invalid arguments.");
    }
    if (util_1.isArray(nodes)) {
        var builders = [];
        for (var i = 0; i < nodes.length; i++) {
            var builder_1 = new _1.XMLBuilderImpl(nodes[i]);
            builder_1.set(options);
            builders.push(builder_1);
        }
        return builders;
    }
    else {
        var builder_2 = new _1.XMLBuilderImpl(nodes);
        builder_2.set(options);
        return builder_2;
    }
}
exports.builder = builder;
/** @inheritdoc */
function create(p1, p2) {
    var options = formatBuilderOptions(p1 === undefined || isXMLBuilderCreateOptions(p1) ?
        p1 : interfaces_1.DefaultBuilderOptions);
    var contents = isXMLBuilderCreateOptions(p1) ? p2 : p1;
    var doc = dom_1.createDocument();
    setOptions(doc, options);
    var builder = new _1.XMLBuilderImpl(doc);
    if (contents !== undefined) {
        // parse contents
        builder.ele(contents);
    }
    return builder;
}
exports.create = create;
/** @inheritdoc */
function fragment(p1, p2) {
    var options = formatBuilderOptions(p1 === undefined || isXMLBuilderCreateOptions(p1) ?
        p1 : interfaces_1.DefaultBuilderOptions);
    var contents = isXMLBuilderCreateOptions(p1) ? p2 : p1;
    var doc = dom_1.createDocument();
    setOptions(doc, options, true);
    var builder = new _1.XMLBuilderImpl(doc.createDocumentFragment());
    if (contents !== undefined) {
        // parse contents
        builder.ele(contents);
    }
    return builder;
}
exports.fragment = fragment;
/** @inheritdoc */
function convert(p1, p2, p3) {
    var builderOptions;
    var contents;
    var convertOptions;
    if (isXMLBuilderCreateOptions(p1) && p2 !== undefined) {
        builderOptions = p1;
        contents = p2;
        convertOptions = p3;
    }
    else {
        builderOptions = interfaces_1.DefaultBuilderOptions;
        contents = p1;
        convertOptions = p2 || undefined;
    }
    return create(builderOptions, contents).end(convertOptions);
}
exports.convert = convert;
function isXMLBuilderCreateOptions(obj) {
    if (!util_1.isPlainObject(obj))
        return false;
    for (var key in obj) {
        /* istanbul ignore else */
        if (obj.hasOwnProperty(key)) {
            if (!interfaces_1.XMLBuilderOptionKeys.has(key))
                return false;
        }
    }
    return true;
}
function formatBuilderOptions(createOptions) {
    if (createOptions === void 0) { createOptions = {}; }
    var options = util_1.applyDefaults(createOptions, interfaces_1.DefaultBuilderOptions);
    if (options.convert.att.length === 0 ||
        options.convert.ins.length === 0 ||
        options.convert.text.length === 0 ||
        options.convert.cdata.length === 0 ||
        options.convert.comment.length === 0) {
        throw new Error("JS object converter strings cannot be zero length.");
    }
    return options;
}
function setOptions(doc, options, isFragment) {
    var docWithSettings = doc;
    docWithSettings._xmlBuilderOptions = options;
    docWithSettings._isFragment = isFragment;
}
//# sourceMappingURL=BuilderFunctions.js.map

/***/ }),

/***/ 821:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
var _1 = __nccwpck_require__(8434);
/**
 * Creates an XML builder which serializes the document in chunks.
 *
 * @param options - callback builder options
 *
 * @returns callback builder
 */
function createCB(options) {
    return new _1.XMLBuilderCBImpl(options);
}
exports.createCB = createCB;
/**
 * Creates an XML builder which serializes the fragment in chunks.
 *
 * @param options - callback builder options
 *
 * @returns callback builder
 */
function fragmentCB(options) {
    return new _1.XMLBuilderCBImpl(options, true);
}
exports.fragmentCB = fragmentCB;
//# sourceMappingURL=BuilderFunctionsCB.js.map

/***/ }),

/***/ 8191:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var interfaces_1 = __nccwpck_require__(5212);
var util_1 = __nccwpck_require__(7061);
var BuilderFunctions_1 = __nccwpck_require__(8076);
var algorithm_1 = __nccwpck_require__(6573);
var infra_1 = __nccwpck_require__(4737);
var NamespacePrefixMap_1 = __nccwpck_require__(8377);
var LocalNameSet_1 = __nccwpck_require__(7830);
var util_2 = __nccwpck_require__(628);
var XMLCBWriter_1 = __nccwpck_require__(9982);
var JSONCBWriter_1 = __nccwpck_require__(4685);
var YAMLCBWriter_1 = __nccwpck_require__(3864);
var events_1 = __nccwpck_require__(4434);
/**
 * Represents a readable XML document stream.
 */
var XMLBuilderCBImpl = /** @class */ (function (_super) {
    __extends(XMLBuilderCBImpl, _super);
    /**
     * Initializes a new instance of `XMLStream`.
     *
     * @param options - stream writer options
     * @param fragment - whether to create fragment stream or a document stream
     *
     * @returns XML stream
     */
    function XMLBuilderCBImpl(options, fragment) {
        if (fragment === void 0) { fragment = false; }
        var _this = _super.call(this) || this;
        _this._hasDeclaration = false;
        _this._docTypeName = "";
        _this._hasDocumentElement = false;
        _this._currentElementSerialized = false;
        _this._openTags = [];
        _this._ended = false;
        _this._fragment = fragment;
        // provide default options
        _this._options = util_1.applyDefaults(options || {}, interfaces_1.DefaultXMLBuilderCBOptions);
        _this._builderOptions = {
            defaultNamespace: _this._options.defaultNamespace,
            namespaceAlias: _this._options.namespaceAlias
        };
        if (_this._options.format === "json") {
            _this._writer = new JSONCBWriter_1.JSONCBWriter(_this._options);
        }
        else if (_this._options.format === "yaml") {
            _this._writer = new YAMLCBWriter_1.YAMLCBWriter(_this._options);
        }
        else {
            _this._writer = new XMLCBWriter_1.XMLCBWriter(_this._options);
        }
        // automatically create listeners for callbacks passed via options
        if (_this._options.data !== undefined) {
            _this.on("data", _this._options.data);
        }
        if (_this._options.end !== undefined) {
            _this.on("end", _this._options.end);
        }
        if (_this._options.error !== undefined) {
            _this.on("error", _this._options.error);
        }
        _this._prefixMap = new NamespacePrefixMap_1.NamespacePrefixMap();
        _this._prefixMap.set("xml", infra_1.namespace.XML);
        _this._prefixIndex = { value: 1 };
        _this._push(_this._writer.frontMatter());
        return _this;
    }
    /** @inheritdoc */
    XMLBuilderCBImpl.prototype.ele = function (p1, p2, p3) {
        var e_1, _a;
        // parse if JS object or XML or JSON string
        if (util_1.isObject(p1) || (util_1.isString(p1) && (/^\s*</.test(p1) || /^\s*[\{\[]/.test(p1) || /^(\s*|(#.*)|(%.*))*---/.test(p1)))) {
            var frag = BuilderFunctions_1.fragment().set(this._options);
            try {
                frag.ele(p1);
            }
            catch (err) {
                this.emit("error", err);
                return this;
            }
            try {
                for (var _b = __values(frag.node.childNodes), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var node = _c.value;
                    this._fromNode(node);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return this;
        }
        this._serializeOpenTag(true);
        if (!this._fragment && this._hasDocumentElement && this._writer.level === 0) {
            this.emit("error", new Error("Document cannot have multiple document element nodes."));
            return this;
        }
        try {
            this._currentElement = BuilderFunctions_1.fragment(this._builderOptions).ele(p1, p2, p3);
        }
        catch (err) {
            this.emit("error", err);
            return this;
        }
        if (!this._fragment && !this._hasDocumentElement && this._docTypeName !== ""
            && this._currentElement.node._qualifiedName !== this._docTypeName) {
            this.emit("error", new Error("Document element name does not match DocType declaration name."));
            return this;
        }
        this._currentElementSerialized = false;
        if (!this._fragment) {
            this._hasDocumentElement = true;
        }
        return this;
    };
    /** @inheritdoc */
    XMLBuilderCBImpl.prototype.att = function (p1, p2, p3) {
        if (this._currentElement === undefined) {
            this.emit("error", new Error("Cannot insert an attribute node as child of a document node."));
            return this;
        }
        try {
            this._currentElement.att(p1, p2, p3);
        }
        catch (err) {
            this.emit("error", err);
            return this;
        }
        return this;
    };
    /** @inheritdoc */
    XMLBuilderCBImpl.prototype.com = function (content) {
        this._serializeOpenTag(true);
        var node;
        try {
            node = BuilderFunctions_1.fragment(this._builderOptions).com(content).first().node;
        }
        catch (err) {
            /* istanbul ignore next */
            this.emit("error", err);
            /* istanbul ignore next */
            return this;
        }
        if (this._options.wellFormed && (!algorithm_1.xml_isLegalChar(node.data) ||
            node.data.indexOf("--") !== -1 || node.data.endsWith("-"))) {
            this.emit("error", new Error("Comment data contains invalid characters (well-formed required)."));
            return this;
        }
        this._push(this._writer.comment(node.data));
        return this;
    };
    /** @inheritdoc */
    XMLBuilderCBImpl.prototype.txt = function (content) {
        if (!this._fragment && this._currentElement === undefined) {
            this.emit("error", new Error("Cannot insert a text node as child of a document node."));
            return this;
        }
        this._serializeOpenTag(true);
        var node;
        try {
            node = BuilderFunctions_1.fragment(this._builderOptions).txt(content).first().node;
        }
        catch (err) {
            /* istanbul ignore next */
            this.emit("error", err);
            /* istanbul ignore next */
            return this;
        }
        if (this._options.wellFormed && !algorithm_1.xml_isLegalChar(node.data)) {
            this.emit("error", new Error("Text data contains invalid characters (well-formed required)."));
            return this;
        }
        var markup = node.data.replace(/(?!&(lt|gt|amp|apos|quot);)&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;');
        this._push(this._writer.text(markup));
        return this;
    };
    /** @inheritdoc */
    XMLBuilderCBImpl.prototype.ins = function (target, content) {
        if (content === void 0) { content = ''; }
        this._serializeOpenTag(true);
        var node;
        try {
            node = BuilderFunctions_1.fragment(this._builderOptions).ins(target, content).first().node;
        }
        catch (err) {
            /* istanbul ignore next */
            this.emit("error", err);
            /* istanbul ignore next */
            return this;
        }
        if (this._options.wellFormed && (node.target.indexOf(":") !== -1 || (/^xml$/i).test(node.target))) {
            this.emit("error", new Error("Processing instruction target contains invalid characters (well-formed required)."));
            return this;
        }
        if (this._options.wellFormed && !algorithm_1.xml_isLegalChar(node.data)) {
            this.emit("error", Error("Processing instruction data contains invalid characters (well-formed required)."));
            return this;
        }
        this._push(this._writer.instruction(node.target, node.data));
        return this;
    };
    /** @inheritdoc */
    XMLBuilderCBImpl.prototype.dat = function (content) {
        this._serializeOpenTag(true);
        var node;
        try {
            node = BuilderFunctions_1.fragment(this._builderOptions).dat(content).first().node;
        }
        catch (err) {
            this.emit("error", err);
            return this;
        }
        this._push(this._writer.cdata(node.data));
        return this;
    };
    /** @inheritdoc */
    XMLBuilderCBImpl.prototype.dec = function (options) {
        if (options === void 0) { options = { version: "1.0" }; }
        if (this._fragment) {
            this.emit("error", Error("Cannot insert an XML declaration into a document fragment."));
            return this;
        }
        if (this._hasDeclaration) {
            this.emit("error", Error("XML declaration is already inserted."));
            return this;
        }
        this._push(this._writer.declaration(options.version || "1.0", options.encoding, options.standalone));
        this._hasDeclaration = true;
        return this;
    };
    /** @inheritdoc */
    XMLBuilderCBImpl.prototype.dtd = function (options) {
        if (this._fragment) {
            this.emit("error", Error("Cannot insert a DocType declaration into a document fragment."));
            return this;
        }
        if (this._docTypeName !== "") {
            this.emit("error", new Error("DocType declaration is already inserted."));
            return this;
        }
        if (this._hasDocumentElement) {
            this.emit("error", new Error("Cannot insert DocType declaration after document element."));
            return this;
        }
        var node;
        try {
            node = BuilderFunctions_1.create().dtd(options).first().node;
        }
        catch (err) {
            this.emit("error", err);
            return this;
        }
        if (this._options.wellFormed && !algorithm_1.xml_isPubidChar(node.publicId)) {
            this.emit("error", new Error("DocType public identifier does not match PubidChar construct (well-formed required)."));
            return this;
        }
        if (this._options.wellFormed &&
            (!algorithm_1.xml_isLegalChar(node.systemId) ||
                (node.systemId.indexOf('"') !== -1 && node.systemId.indexOf("'") !== -1))) {
            this.emit("error", new Error("DocType system identifier contains invalid characters (well-formed required)."));
            return this;
        }
        this._docTypeName = options.name;
        this._push(this._writer.docType(options.name, node.publicId, node.systemId));
        return this;
    };
    /** @inheritdoc */
    XMLBuilderCBImpl.prototype.import = function (node) {
        var e_2, _a;
        var frag = BuilderFunctions_1.fragment().set(this._options);
        try {
            frag.import(node);
        }
        catch (err) {
            this.emit("error", err);
            return this;
        }
        try {
            for (var _b = __values(frag.node.childNodes), _c = _b.next(); !_c.done; _c = _b.next()) {
                var node_1 = _c.value;
                this._fromNode(node_1);
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_2) throw e_2.error; }
        }
        return this;
    };
    /** @inheritdoc */
    XMLBuilderCBImpl.prototype.up = function () {
        this._serializeOpenTag(false);
        this._serializeCloseTag();
        return this;
    };
    /** @inheritdoc */
    XMLBuilderCBImpl.prototype.end = function () {
        this._serializeOpenTag(false);
        while (this._openTags.length > 0) {
            this._serializeCloseTag();
        }
        this._push(null);
        return this;
    };
    /**
     * Serializes the opening tag of an element node.
     *
     * @param hasChildren - whether the element node has child nodes
     */
    XMLBuilderCBImpl.prototype._serializeOpenTag = function (hasChildren) {
        if (this._currentElementSerialized)
            return;
        if (this._currentElement === undefined)
            return;
        var node = this._currentElement.node;
        if (this._options.wellFormed && (node.localName.indexOf(":") !== -1 ||
            !algorithm_1.xml_isName(node.localName))) {
            this.emit("error", new Error("Node local name contains invalid characters (well-formed required)."));
            return;
        }
        var qualifiedName = "";
        var ignoreNamespaceDefinitionAttribute = false;
        var map = this._prefixMap.copy();
        var localPrefixesMap = {};
        var localDefaultNamespace = this._recordNamespaceInformation(node, map, localPrefixesMap);
        var inheritedNS = this._openTags.length === 0 ? null : this._openTags[this._openTags.length - 1][1];
        var ns = node.namespaceURI;
        if (ns === null)
            ns = inheritedNS;
        if (inheritedNS === ns) {
            if (localDefaultNamespace !== null) {
                ignoreNamespaceDefinitionAttribute = true;
            }
            if (ns === infra_1.namespace.XML) {
                qualifiedName = "xml:" + node.localName;
            }
            else {
                qualifiedName = node.localName;
            }
            this._writer.beginElement(qualifiedName);
            this._push(this._writer.openTagBegin(qualifiedName));
        }
        else {
            var prefix = node.prefix;
            var candidatePrefix = null;
            if (prefix !== null || ns !== localDefaultNamespace) {
                candidatePrefix = map.get(prefix, ns);
            }
            if (prefix === "xmlns") {
                if (this._options.wellFormed) {
                    this.emit("error", new Error("An element cannot have the 'xmlns' prefix (well-formed required)."));
                    return;
                }
                candidatePrefix = prefix;
            }
            if (candidatePrefix !== null) {
                qualifiedName = candidatePrefix + ':' + node.localName;
                if (localDefaultNamespace !== null && localDefaultNamespace !== infra_1.namespace.XML) {
                    inheritedNS = localDefaultNamespace || null;
                }
                this._writer.beginElement(qualifiedName);
                this._push(this._writer.openTagBegin(qualifiedName));
            }
            else if (prefix !== null) {
                if (prefix in localPrefixesMap) {
                    prefix = this._generatePrefix(ns, map, this._prefixIndex);
                }
                map.set(prefix, ns);
                qualifiedName += prefix + ':' + node.localName;
                this._writer.beginElement(qualifiedName);
                this._push(this._writer.openTagBegin(qualifiedName));
                this._push(this._writer.attribute("xmlns:" + prefix, this._serializeAttributeValue(ns, this._options.wellFormed)));
                if (localDefaultNamespace !== null) {
                    inheritedNS = localDefaultNamespace || null;
                }
            }
            else if (localDefaultNamespace === null ||
                (localDefaultNamespace !== null && localDefaultNamespace !== ns)) {
                ignoreNamespaceDefinitionAttribute = true;
                qualifiedName += node.localName;
                inheritedNS = ns;
                this._writer.beginElement(qualifiedName);
                this._push(this._writer.openTagBegin(qualifiedName));
                this._push(this._writer.attribute("xmlns", this._serializeAttributeValue(ns, this._options.wellFormed)));
            }
            else {
                qualifiedName += node.localName;
                inheritedNS = ns;
                this._writer.beginElement(qualifiedName);
                this._push(this._writer.openTagBegin(qualifiedName));
            }
        }
        this._serializeAttributes(node, map, this._prefixIndex, localPrefixesMap, ignoreNamespaceDefinitionAttribute, this._options.wellFormed);
        var isHTML = (ns === infra_1.namespace.HTML);
        if (isHTML && !hasChildren &&
            XMLBuilderCBImpl._VoidElementNames.has(node.localName)) {
            this._push(this._writer.openTagEnd(qualifiedName, true, true));
            this._writer.endElement(qualifiedName);
        }
        else if (!isHTML && !hasChildren) {
            this._push(this._writer.openTagEnd(qualifiedName, true, false));
            this._writer.endElement(qualifiedName);
        }
        else {
            this._push(this._writer.openTagEnd(qualifiedName, false, false));
        }
        this._currentElementSerialized = true;
        /**
         * Save qualified name, original inherited ns, original prefix map, and
         * hasChildren flag.
         */
        this._openTags.push([qualifiedName, inheritedNS, this._prefixMap, hasChildren]);
        /**
         * New values of inherited namespace and prefix map will be used while
         * serializing child nodes. They will be returned to their original values
         * when this node is closed using the _openTags array item we saved above.
         */
        if (this._isPrefixMapModified(this._prefixMap, map)) {
            this._prefixMap = map;
        }
        /**
         * Calls following this will either serialize child nodes or close this tag.
         */
        this._writer.level++;
    };
    /**
     * Serializes the closing tag of an element node.
     */
    XMLBuilderCBImpl.prototype._serializeCloseTag = function () {
        this._writer.level--;
        var lastEle = this._openTags.pop();
        /* istanbul ignore next */
        if (lastEle === undefined) {
            this.emit("error", new Error("Last element is undefined."));
            return;
        }
        var _a = __read(lastEle, 4), qualifiedName = _a[0], ns = _a[1], map = _a[2], hasChildren = _a[3];
        /**
         * Restore original values of inherited namespace and prefix map.
         */
        this._prefixMap = map;
        if (!hasChildren)
            return;
        this._push(this._writer.closeTag(qualifiedName));
        this._writer.endElement(qualifiedName);
    };
    /**
     * Pushes data to internal buffer.
     *
     * @param data - data
     */
    XMLBuilderCBImpl.prototype._push = function (data) {
        if (data === null) {
            this._ended = true;
            this.emit("end");
        }
        else if (this._ended) {
            this.emit("error", new Error("Cannot push to ended stream."));
        }
        else if (data.length !== 0) {
            this._writer.hasData = true;
            this.emit("data", data, this._writer.level);
        }
    };
    /**
     * Reads and serializes an XML tree.
     *
     * @param node - root node
     */
    XMLBuilderCBImpl.prototype._fromNode = function (node) {
        var e_3, _a, e_4, _b;
        if (util_2.Guard.isElementNode(node)) {
            var name = node.prefix ? node.prefix + ":" + node.localName : node.localName;
            if (node.namespaceURI !== null) {
                this.ele(node.namespaceURI, name);
            }
            else {
                this.ele(name);
            }
            try {
                for (var _c = __values(node.attributes), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var attr = _d.value;
                    var name_1 = attr.prefix ? attr.prefix + ":" + attr.localName : attr.localName;
                    if (attr.namespaceURI !== null) {
                        this.att(attr.namespaceURI, name_1, attr.value);
                    }
                    else {
                        this.att(name_1, attr.value);
                    }
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                }
                finally { if (e_3) throw e_3.error; }
            }
            try {
                for (var _e = __values(node.childNodes), _f = _e.next(); !_f.done; _f = _e.next()) {
                    var child = _f.value;
                    this._fromNode(child);
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                }
                finally { if (e_4) throw e_4.error; }
            }
            this.up();
        }
        else if (util_2.Guard.isExclusiveTextNode(node) && node.data) {
            this.txt(node.data);
        }
        else if (util_2.Guard.isCommentNode(node)) {
            this.com(node.data);
        }
        else if (util_2.Guard.isCDATASectionNode(node)) {
            this.dat(node.data);
        }
        else if (util_2.Guard.isProcessingInstructionNode(node)) {
            this.ins(node.target, node.data);
        }
    };
    /**
     * Produces an XML serialization of the attributes of an element node.
     *
     * @param node - node to serialize
     * @param map - namespace prefix map
     * @param prefixIndex - generated namespace prefix index
     * @param localPrefixesMap - local prefixes map
     * @param ignoreNamespaceDefinitionAttribute - whether to ignore namespace
     * attributes
     * @param requireWellFormed - whether to check conformance
     */
    XMLBuilderCBImpl.prototype._serializeAttributes = function (node, map, prefixIndex, localPrefixesMap, ignoreNamespaceDefinitionAttribute, requireWellFormed) {
        var e_5, _a;
        var localNameSet = requireWellFormed ? new LocalNameSet_1.LocalNameSet() : undefined;
        try {
            for (var _b = __values(node.attributes), _c = _b.next(); !_c.done; _c = _b.next()) {
                var attr = _c.value;
                // Optimize common case
                if (!requireWellFormed && !ignoreNamespaceDefinitionAttribute && attr.namespaceURI === null) {
                    this._push(this._writer.attribute(attr.localName, this._serializeAttributeValue(attr.value, this._options.wellFormed)));
                    continue;
                }
                if (requireWellFormed && localNameSet && localNameSet.has(attr.namespaceURI, attr.localName)) {
                    this.emit("error", new Error("Element contains duplicate attributes (well-formed required)."));
                    return;
                }
                if (requireWellFormed && localNameSet)
                    localNameSet.set(attr.namespaceURI, attr.localName);
                var attributeNamespace = attr.namespaceURI;
                var candidatePrefix = null;
                if (attributeNamespace !== null) {
                    candidatePrefix = map.get(attr.prefix, attributeNamespace);
                    if (attributeNamespace === infra_1.namespace.XMLNS) {
                        if (attr.value === infra_1.namespace.XML ||
                            (attr.prefix === null && ignoreNamespaceDefinitionAttribute) ||
                            (attr.prefix !== null && (!(attr.localName in localPrefixesMap) ||
                                localPrefixesMap[attr.localName] !== attr.value) &&
                                map.has(attr.localName, attr.value)))
                            continue;
                        if (requireWellFormed && attr.value === infra_1.namespace.XMLNS) {
                            this.emit("error", new Error("XMLNS namespace is reserved (well-formed required)."));
                            return;
                        }
                        if (requireWellFormed && attr.value === '') {
                            this.emit("error", new Error("Namespace prefix declarations cannot be used to undeclare a namespace (well-formed required)."));
                            return;
                        }
                        if (attr.prefix === 'xmlns')
                            candidatePrefix = 'xmlns';
                        /**
                         * _Note:_ The (candidatePrefix === null) check is not in the spec.
                         * We deviate from the spec here. Otherwise a prefix is generated for
                         * all attributes with namespaces.
                         */
                    }
                    else if (candidatePrefix === null) {
                        if (attr.prefix !== null &&
                            (!map.hasPrefix(attr.prefix) ||
                                map.has(attr.prefix, attributeNamespace))) {
                            /**
                             * Check if we can use the attribute's own prefix.
                             * We deviate from the spec here.
                             * TODO: This is not an efficient way of searching for prefixes.
                             * Follow developments to the spec.
                             */
                            candidatePrefix = attr.prefix;
                        }
                        else {
                            candidatePrefix = this._generatePrefix(attributeNamespace, map, prefixIndex);
                        }
                        this._push(this._writer.attribute("xmlns:" + candidatePrefix, this._serializeAttributeValue(attributeNamespace, this._options.wellFormed)));
                    }
                }
                if (requireWellFormed && (attr.localName.indexOf(":") !== -1 ||
                    !algorithm_1.xml_isName(attr.localName) ||
                    (attr.localName === "xmlns" && attributeNamespace === null))) {
                    this.emit("error", new Error("Attribute local name contains invalid characters (well-formed required)."));
                    return;
                }
                this._push(this._writer.attribute((candidatePrefix !== null ? candidatePrefix + ":" : "") + attr.localName, this._serializeAttributeValue(attr.value, this._options.wellFormed)));
            }
        }
        catch (e_5_1) { e_5 = { error: e_5_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_5) throw e_5.error; }
        }
    };
    /**
     * Produces an XML serialization of an attribute value.
     *
     * @param value - attribute value
     * @param requireWellFormed - whether to check conformance
     */
    XMLBuilderCBImpl.prototype._serializeAttributeValue = function (value, requireWellFormed) {
        if (requireWellFormed && value !== null && !algorithm_1.xml_isLegalChar(value)) {
            this.emit("error", new Error("Invalid characters in attribute value."));
            return "";
        }
        if (value === null)
            return "";
        return value.replace(/(?!&(lt|gt|amp|apos|quot);)&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;');
    };
    /**
     * Records namespace information for the given element and returns the
     * default namespace attribute value.
     *
     * @param node - element node to process
     * @param map - namespace prefix map
     * @param localPrefixesMap - local prefixes map
     */
    XMLBuilderCBImpl.prototype._recordNamespaceInformation = function (node, map, localPrefixesMap) {
        var e_6, _a;
        var defaultNamespaceAttrValue = null;
        try {
            for (var _b = __values(node.attributes), _c = _b.next(); !_c.done; _c = _b.next()) {
                var attr = _c.value;
                var attributeNamespace = attr.namespaceURI;
                var attributePrefix = attr.prefix;
                if (attributeNamespace === infra_1.namespace.XMLNS) {
                    if (attributePrefix === null) {
                        defaultNamespaceAttrValue = attr.value;
                        continue;
                    }
                    else {
                        var prefixDefinition = attr.localName;
                        var namespaceDefinition = attr.value;
                        if (namespaceDefinition === infra_1.namespace.XML) {
                            continue;
                        }
                        if (namespaceDefinition === '') {
                            namespaceDefinition = null;
                        }
                        if (map.has(prefixDefinition, namespaceDefinition)) {
                            continue;
                        }
                        map.set(prefixDefinition, namespaceDefinition);
                        localPrefixesMap[prefixDefinition] = namespaceDefinition || '';
                    }
                }
            }
        }
        catch (e_6_1) { e_6 = { error: e_6_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_6) throw e_6.error; }
        }
        return defaultNamespaceAttrValue;
    };
    /**
     * Generates a new prefix for the given namespace.
     *
     * @param newNamespace - a namespace to generate prefix for
     * @param prefixMap - namespace prefix map
     * @param prefixIndex - generated namespace prefix index
     */
    XMLBuilderCBImpl.prototype._generatePrefix = function (newNamespace, prefixMap, prefixIndex) {
        var generatedPrefix = "ns" + prefixIndex.value;
        prefixIndex.value++;
        prefixMap.set(generatedPrefix, newNamespace);
        return generatedPrefix;
    };
    /**
     * Determines if the namespace prefix map was modified from its original.
     *
     * @param originalMap - original namespace prefix map
     * @param newMap - new namespace prefix map
     */
    XMLBuilderCBImpl.prototype._isPrefixMapModified = function (originalMap, newMap) {
        var items1 = originalMap._items;
        var items2 = newMap._items;
        var nullItems1 = originalMap._nullItems;
        var nullItems2 = newMap._nullItems;
        for (var key in items2) {
            var arr1 = items1[key];
            if (arr1 === undefined)
                return true;
            var arr2 = items2[key];
            if (arr1.length !== arr2.length)
                return true;
            for (var i = 0; i < arr1.length; i++) {
                if (arr1[i] !== arr2[i])
                    return true;
            }
        }
        if (nullItems1.length !== nullItems2.length)
            return true;
        for (var i = 0; i < nullItems1.length; i++) {
            if (nullItems1[i] !== nullItems2[i])
                return true;
        }
        return false;
    };
    XMLBuilderCBImpl._VoidElementNames = new Set(['area', 'base', 'basefont',
        'bgsound', 'br', 'col', 'embed', 'frame', 'hr', 'img', 'input', 'keygen',
        'link', 'menuitem', 'meta', 'param', 'source', 'track', 'wbr']);
    return XMLBuilderCBImpl;
}(events_1.EventEmitter));
exports.XMLBuilderCBImpl = XMLBuilderCBImpl;
//# sourceMappingURL=XMLBuilderCBImpl.js.map

/***/ }),

/***/ 4042:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {


var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var interfaces_1 = __nccwpck_require__(5212);
var util_1 = __nccwpck_require__(7061);
var writers_1 = __nccwpck_require__(8017);
var interfaces_2 = __nccwpck_require__(9454);
var util_2 = __nccwpck_require__(628);
var algorithm_1 = __nccwpck_require__(6573);
var dom_1 = __nccwpck_require__(1954);
var infra_1 = __nccwpck_require__(4737);
var readers_1 = __nccwpck_require__(1521);
/**
 * Represents a wrapper that extends XML nodes to implement easy to use and
 * chainable document builder methods.
 */
var XMLBuilderImpl = /** @class */ (function () {
    /**
     * Initializes a new instance of `XMLBuilderNodeImpl`.
     *
     * @param domNode - the DOM node to wrap
     */
    function XMLBuilderImpl(domNode) {
        this._domNode = domNode;
    }
    Object.defineProperty(XMLBuilderImpl.prototype, "node", {
        /** @inheritdoc */
        get: function () { return this._domNode; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(XMLBuilderImpl.prototype, "options", {
        /** @inheritdoc */
        get: function () { return this._options; },
        enumerable: true,
        configurable: true
    });
    /** @inheritdoc */
    XMLBuilderImpl.prototype.set = function (options) {
        this._options = util_1.applyDefaults(util_1.applyDefaults(this._options, options, true), // apply user settings
        interfaces_1.DefaultBuilderOptions); // provide defaults
        return this;
    };
    /** @inheritdoc */
    XMLBuilderImpl.prototype.ele = function (p1, p2, p3) {
        var _a, _b, _c;
        var namespace;
        var name;
        var attributes;
        if (util_1.isObject(p1)) {
            // ele(obj: ExpandObject)
            return new readers_1.ObjectReader(this._options).parse(this, p1);
        }
        else if (p1 !== null && /^\s*</.test(p1)) {
            // parse XML document string
            return new readers_1.XMLReader(this._options).parse(this, p1);
        }
        else if (p1 !== null && /^\s*[\{\[]/.test(p1)) {
            // parse JSON string
            return new readers_1.JSONReader(this._options).parse(this, p1);
        }
        else if (p1 !== null && /^(\s*|(#.*)|(%.*))*---/.test(p1)) {
            // parse YAML string
            return new readers_1.YAMLReader(this._options).parse(this, p1);
        }
        if ((p1 === null || util_1.isString(p1)) && util_1.isString(p2)) {
            // ele(namespace: string, name: string, attributes?: AttributesObject)
            _a = __read([p1, p2, p3], 3), namespace = _a[0], name = _a[1], attributes = _a[2];
        }
        else if (p1 !== null) {
            // ele(name: string, attributes?: AttributesObject)
            _b = __read([undefined, p1, util_1.isObject(p2) ? p2 : undefined], 3), namespace = _b[0], name = _b[1], attributes = _b[2];
        }
        else {
            throw new Error("Element name cannot be null. " + this._debugInfo());
        }
        if (attributes) {
            attributes = util_1.getValue(attributes);
        }
        _c = __read(this._extractNamespace(dom_1.sanitizeInput(namespace, this._options.invalidCharReplacement), dom_1.sanitizeInput(name, this._options.invalidCharReplacement), true), 2), namespace = _c[0], name = _c[1];
        // inherit namespace from parent
        if (namespace === undefined) {
            var _d = __read(algorithm_1.namespace_extractQName(name), 1), prefix = _d[0];
            namespace = this.node.lookupNamespaceURI(prefix);
        }
        // create a child element node
        var childNode = (namespace !== undefined && namespace !== null ?
            this._doc.createElementNS(namespace, name) :
            this._doc.createElement(name));
        this.node.appendChild(childNode);
        var builder = new XMLBuilderImpl(childNode);
        // update doctype node if the new node is the document element node
        var oldDocType = this._doc.doctype;
        if (childNode === this._doc.documentElement && oldDocType !== null) {
            var docType = this._doc.implementation.createDocumentType(this._doc.documentElement.tagName, oldDocType.publicId, oldDocType.systemId);
            this._doc.replaceChild(docType, oldDocType);
        }
        // create attributes
        if (attributes && !util_1.isEmpty(attributes)) {
            builder.att(attributes);
        }
        return builder;
    };
    /** @inheritdoc */
    XMLBuilderImpl.prototype.remove = function () {
        var parent = this.up();
        parent.node.removeChild(this.node);
        return parent;
    };
    /** @inheritdoc */
    XMLBuilderImpl.prototype.att = function (p1, p2, p3) {
        var _a, _b, _c;
        var _this = this;
        if (util_1.isMap(p1) || util_1.isObject(p1)) {
            // att(obj: AttributesObject)
            // expand if object
            util_1.forEachObject(p1, function (attName, attValue) { return _this.att(attName, attValue); }, this);
            return this;
        }
        // get primitive values
        if (p1 !== undefined && p1 !== null)
            p1 = util_1.getValue(p1 + "");
        if (p2 !== undefined && p2 !== null)
            p2 = util_1.getValue(p2 + "");
        if (p3 !== undefined && p3 !== null)
            p3 = util_1.getValue(p3 + "");
        var namespace;
        var name;
        var value;
        if ((p1 === null || util_1.isString(p1)) && util_1.isString(p2) && (p3 === null || util_1.isString(p3))) {
            // att(namespace: string, name: string, value: string)
            _a = __read([p1, p2, p3], 3), namespace = _a[0], name = _a[1], value = _a[2];
        }
        else if (util_1.isString(p1) && (p2 == null || util_1.isString(p2))) {
            // ele(name: string, value: string)
            _b = __read([undefined, p1, p2], 3), namespace = _b[0], name = _b[1], value = _b[2];
        }
        else {
            throw new Error("Attribute name and value not specified. " + this._debugInfo());
        }
        if (this._options.keepNullAttributes && (value == null)) {
            // keep null attributes
            value = "";
        }
        else if (value == null) {
            // skip null|undefined attributes
            return this;
        }
        if (!util_2.Guard.isElementNode(this.node)) {
            throw new Error("An attribute can only be assigned to an element node.");
        }
        var ele = this.node;
        _c = __read(this._extractNamespace(namespace, name, false), 2), namespace = _c[0], name = _c[1];
        name = dom_1.sanitizeInput(name, this._options.invalidCharReplacement);
        namespace = dom_1.sanitizeInput(namespace, this._options.invalidCharReplacement);
        value = dom_1.sanitizeInput(value, this._options.invalidCharReplacement);
        var _d = __read(algorithm_1.namespace_extractQName(name), 2), prefix = _d[0], localName = _d[1];
        var _e = __read(algorithm_1.namespace_extractQName(ele.prefix ? ele.prefix + ':' + ele.localName : ele.localName), 1), elePrefix = _e[0];
        // check if this is a namespace declaration attribute
        // assign a new element namespace if it wasn't previously assigned
        var eleNamespace = null;
        if (prefix === "xmlns") {
            namespace = infra_1.namespace.XMLNS;
            if (ele.namespaceURI === null && elePrefix === localName) {
                eleNamespace = value;
            }
        }
        else if (prefix === null && localName === "xmlns" && elePrefix === null) {
            namespace = infra_1.namespace.XMLNS;
            eleNamespace = value;
        }
        // re-create the element node if its namespace changed
        // we can't simply change the namespaceURI since its read-only
        if (eleNamespace !== null) {
            this._updateNamespace(eleNamespace);
            ele = this.node;
        }
        if (namespace !== undefined) {
            ele.setAttributeNS(namespace, name, value);
        }
        else {
            ele.setAttribute(name, value);
        }
        return this;
    };
    /** @inheritdoc */
    XMLBuilderImpl.prototype.removeAtt = function (p1, p2) {
        var _this = this;
        if (!util_2.Guard.isElementNode(this.node)) {
            throw new Error("An attribute can only be removed from an element node.");
        }
        // get primitive values
        p1 = util_1.getValue(p1);
        if (p2 !== undefined) {
            p2 = util_1.getValue(p2);
        }
        var namespace;
        var name;
        if (p1 !== null && p2 === undefined) {
            name = p1;
        }
        else if ((p1 === null || util_1.isString(p1)) && p2 !== undefined) {
            namespace = p1;
            name = p2;
        }
        else {
            throw new Error("Attribute namespace must be a string. " + this._debugInfo());
        }
        if (util_1.isArray(name) || util_1.isSet(name)) {
            // removeAtt(names: string[])
            // removeAtt(namespace: string, names: string[])
            util_1.forEachArray(name, function (attName) {
                return namespace === undefined ? _this.removeAtt(attName) : _this.removeAtt(namespace, attName);
            }, this);
        }
        else if (namespace !== undefined) {
            // removeAtt(namespace: string, name: string)
            name = dom_1.sanitizeInput(name, this._options.invalidCharReplacement);
            namespace = dom_1.sanitizeInput(namespace, this._options.invalidCharReplacement);
            this.node.removeAttributeNS(namespace, name);
        }
        else {
            // removeAtt(name: string)
            name = dom_1.sanitizeInput(name, this._options.invalidCharReplacement);
            this.node.removeAttribute(name);
        }
        return this;
    };
    /** @inheritdoc */
    XMLBuilderImpl.prototype.txt = function (content) {
        if (content === null || content === undefined) {
            if (this._options.keepNullNodes) {
                // keep null nodes
                content = "";
            }
            else {
                // skip null|undefined nodes
                return this;
            }
        }
        var child = this._doc.createTextNode(dom_1.sanitizeInput(content, this._options.invalidCharReplacement));
        this.node.appendChild(child);
        return this;
    };
    /** @inheritdoc */
    XMLBuilderImpl.prototype.com = function (content) {
        if (content === null || content === undefined) {
            if (this._options.keepNullNodes) {
                // keep null nodes
                content = "";
            }
            else {
                // skip null|undefined nodes
                return this;
            }
        }
        var child = this._doc.createComment(dom_1.sanitizeInput(content, this._options.invalidCharReplacement));
        this.node.appendChild(child);
        return this;
    };
    /** @inheritdoc */
    XMLBuilderImpl.prototype.dat = function (content) {
        if (content === null || content === undefined) {
            if (this._options.keepNullNodes) {
                // keep null nodes
                content = "";
            }
            else {
                // skip null|undefined nodes
                return this;
            }
        }
        var child = this._doc.createCDATASection(dom_1.sanitizeInput(content, this._options.invalidCharReplacement));
        this.node.appendChild(child);
        return this;
    };
    /** @inheritdoc */
    XMLBuilderImpl.prototype.ins = function (target, content) {
        var _this = this;
        if (content === void 0) { content = ''; }
        if (content === null || content === undefined) {
            if (this._options.keepNullNodes) {
                // keep null nodes
                content = "";
            }
            else {
                // skip null|undefined nodes
                return this;
            }
        }
        if (util_1.isArray(target) || util_1.isSet(target)) {
            util_1.forEachArray(target, function (item) {
                item += "";
                var insIndex = item.indexOf(' ');
                var insTarget = (insIndex === -1 ? item : item.substr(0, insIndex));
                var insValue = (insIndex === -1 ? '' : item.substr(insIndex + 1));
                _this.ins(insTarget, insValue);
            }, this);
        }
        else if (util_1.isMap(target) || util_1.isObject(target)) {
            util_1.forEachObject(target, function (insTarget, insValue) { return _this.ins(insTarget, insValue); }, this);
        }
        else {
            var child = this._doc.createProcessingInstruction(dom_1.sanitizeInput(target, this._options.invalidCharReplacement), dom_1.sanitizeInput(content, this._options.invalidCharReplacement));
            this.node.appendChild(child);
        }
        return this;
    };
    /** @inheritdoc */
    XMLBuilderImpl.prototype.dec = function (options) {
        this._options.version = options.version || "1.0";
        this._options.encoding = options.encoding;
        this._options.standalone = options.standalone;
        return this;
    };
    /** @inheritdoc */
    XMLBuilderImpl.prototype.dtd = function (options) {
        var name = dom_1.sanitizeInput((options && options.name) || (this._doc.documentElement ? this._doc.documentElement.tagName : "ROOT"), this._options.invalidCharReplacement);
        var pubID = dom_1.sanitizeInput((options && options.pubID) || "", this._options.invalidCharReplacement);
        var sysID = dom_1.sanitizeInput((options && options.sysID) || "", this._options.invalidCharReplacement);
        // name must match document element
        if (this._doc.documentElement !== null && name !== this._doc.documentElement.tagName) {
            throw new Error("DocType name does not match document element name.");
        }
        // create doctype node
        var docType = this._doc.implementation.createDocumentType(name, pubID, sysID);
        if (this._doc.doctype !== null) {
            // replace existing doctype
            this._doc.replaceChild(docType, this._doc.doctype);
        }
        else {
            // insert before document element node or append to end
            this._doc.insertBefore(docType, this._doc.documentElement);
        }
        return this;
    };
    /** @inheritdoc */
    XMLBuilderImpl.prototype.import = function (node) {
        var e_1, _a;
        var hostNode = this._domNode;
        var hostDoc = this._doc;
        var importedNode = node.node;
        if (util_2.Guard.isDocumentNode(importedNode)) {
            // import document node
            var elementNode = importedNode.documentElement;
            if (elementNode === null) {
                throw new Error("Imported document has no document element node. " + this._debugInfo());
            }
            var clone = hostDoc.importNode(elementNode, true);
            hostNode.appendChild(clone);
            var _b = __read(algorithm_1.namespace_extractQName(clone.prefix ? clone.prefix + ':' + clone.localName : clone.localName), 1), prefix = _b[0];
            var namespace = hostNode.lookupNamespaceURI(prefix);
            new XMLBuilderImpl(clone)._updateNamespace(namespace);
        }
        else if (util_2.Guard.isDocumentFragmentNode(importedNode)) {
            try {
                // import child nodes
                for (var _c = __values(importedNode.childNodes), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var childNode = _d.value;
                    var clone = hostDoc.importNode(childNode, true);
                    hostNode.appendChild(clone);
                    if (util_2.Guard.isElementNode(clone)) {
                        var _e = __read(algorithm_1.namespace_extractQName(clone.prefix ? clone.prefix + ':' + clone.localName : clone.localName), 1), prefix = _e[0];
                        var namespace = hostNode.lookupNamespaceURI(prefix);
                        new XMLBuilderImpl(clone)._updateNamespace(namespace);
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                }
                finally { if (e_1) throw e_1.error; }
            }
        }
        else {
            // import node
            var clone = hostDoc.importNode(importedNode, true);
            hostNode.appendChild(clone);
            if (util_2.Guard.isElementNode(clone)) {
                var _f = __read(algorithm_1.namespace_extractQName(clone.prefix ? clone.prefix + ':' + clone.localName : clone.localName), 1), prefix = _f[0];
                var namespace = hostNode.lookupNamespaceURI(prefix);
                new XMLBuilderImpl(clone)._updateNamespace(namespace);
            }
        }
        return this;
    };
    /** @inheritdoc */
    XMLBuilderImpl.prototype.doc = function () {
        if (this._doc._isFragment) {
            var node = this.node;
            while (node && node.nodeType !== interfaces_2.NodeType.DocumentFragment) {
                node = node.parentNode;
            }
            /* istanbul ignore next */
            if (node === null) {
                throw new Error("Node has no parent node while searching for document fragment ancestor. " + this._debugInfo());
            }
            return new XMLBuilderImpl(node);
        }
        else {
            return new XMLBuilderImpl(this._doc);
        }
    };
    /** @inheritdoc */
    XMLBuilderImpl.prototype.root = function () {
        var ele = this._doc.documentElement;
        if (!ele) {
            throw new Error("Document root element is null. " + this._debugInfo());
        }
        return new XMLBuilderImpl(ele);
    };
    /** @inheritdoc */
    XMLBuilderImpl.prototype.up = function () {
        var parent = this._domNode.parentNode;
        if (!parent) {
            throw new Error("Parent node is null. " + this._debugInfo());
        }
        return new XMLBuilderImpl(parent);
    };
    /** @inheritdoc */
    XMLBuilderImpl.prototype.prev = function () {
        var node = this._domNode.previousSibling;
        if (!node) {
            throw new Error("Previous sibling node is null. " + this._debugInfo());
        }
        return new XMLBuilderImpl(node);
    };
    /** @inheritdoc */
    XMLBuilderImpl.prototype.next = function () {
        var node = this._domNode.nextSibling;
        if (!node) {
            throw new Error("Next sibling node is null. " + this._debugInfo());
        }
        return new XMLBuilderImpl(node);
    };
    /** @inheritdoc */
    XMLBuilderImpl.prototype.first = function () {
        var node = this._domNode.firstChild;
        if (!node) {
            throw new Error("First child node is null. " + this._debugInfo());
        }
        return new XMLBuilderImpl(node);
    };
    /** @inheritdoc */
    XMLBuilderImpl.prototype.last = function () {
        var node = this._domNode.lastChild;
        if (!node) {
            throw new Error("Last child node is null. " + this._debugInfo());
        }
        return new XMLBuilderImpl(node);
    };
    /** @inheritdoc */
    XMLBuilderImpl.prototype.each = function (callback, self, recursive, thisArg) {
        if (self === void 0) { self = false; }
        if (recursive === void 0) { recursive = false; }
        var result = this._getFirstDescendantNode(this._domNode, self, recursive);
        while (result[0]) {
            var nextResult = this._getNextDescendantNode(this._domNode, result[0], recursive, result[1], result[2]);
            callback.call(thisArg, new XMLBuilderImpl(result[0]), result[1], result[2]);
            result = nextResult;
        }
        return this;
    };
    /** @inheritdoc */
    XMLBuilderImpl.prototype.map = function (callback, self, recursive, thisArg) {
        if (self === void 0) { self = false; }
        if (recursive === void 0) { recursive = false; }
        var result = [];
        this.each(function (node, index, level) {
            return result.push(callback.call(thisArg, node, index, level));
        }, self, recursive);
        return result;
    };
    /** @inheritdoc */
    XMLBuilderImpl.prototype.reduce = function (callback, initialValue, self, recursive, thisArg) {
        if (self === void 0) { self = false; }
        if (recursive === void 0) { recursive = false; }
        var value = initialValue;
        this.each(function (node, index, level) {
            return value = callback.call(thisArg, value, node, index, level);
        }, self, recursive);
        return value;
    };
    /** @inheritdoc */
    XMLBuilderImpl.prototype.find = function (predicate, self, recursive, thisArg) {
        if (self === void 0) { self = false; }
        if (recursive === void 0) { recursive = false; }
        var result = this._getFirstDescendantNode(this._domNode, self, recursive);
        while (result[0]) {
            var builder = new XMLBuilderImpl(result[0]);
            if (predicate.call(thisArg, builder, result[1], result[2])) {
                return builder;
            }
            result = this._getNextDescendantNode(this._domNode, result[0], recursive, result[1], result[2]);
        }
        return undefined;
    };
    /** @inheritdoc */
    XMLBuilderImpl.prototype.filter = function (predicate, self, recursive, thisArg) {
        if (self === void 0) { self = false; }
        if (recursive === void 0) { recursive = false; }
        var result = [];
        this.each(function (node, index, level) {
            if (predicate.call(thisArg, node, index, level)) {
                result.push(node);
            }
        }, self, recursive);
        return result;
    };
    /** @inheritdoc */
    XMLBuilderImpl.prototype.every = function (predicate, self, recursive, thisArg) {
        if (self === void 0) { self = false; }
        if (recursive === void 0) { recursive = false; }
        var result = this._getFirstDescendantNode(this._domNode, self, recursive);
        while (result[0]) {
            var builder = new XMLBuilderImpl(result[0]);
            if (!predicate.call(thisArg, builder, result[1], result[2])) {
                return false;
            }
            result = this._getNextDescendantNode(this._domNode, result[0], recursive, result[1], result[2]);
        }
        return true;
    };
    /** @inheritdoc */
    XMLBuilderImpl.prototype.some = function (predicate, self, recursive, thisArg) {
        if (self === void 0) { self = false; }
        if (recursive === void 0) { recursive = false; }
        var result = this._getFirstDescendantNode(this._domNode, self, recursive);
        while (result[0]) {
            var builder = new XMLBuilderImpl(result[0]);
            if (predicate.call(thisArg, builder, result[1], result[2])) {
                return true;
            }
            result = this._getNextDescendantNode(this._domNode, result[0], recursive, result[1], result[2]);
        }
        return false;
    };
    /** @inheritdoc */
    XMLBuilderImpl.prototype.toArray = function (self, recursive) {
        if (self === void 0) { self = false; }
        if (recursive === void 0) { recursive = false; }
        var result = [];
        this.each(function (node) { return result.push(node); }, self, recursive);
        return result;
    };
    /** @inheritdoc */
    XMLBuilderImpl.prototype.toString = function (writerOptions) {
        writerOptions = writerOptions || {};
        if (writerOptions.format === undefined) {
            writerOptions.format = "xml";
        }
        return this._serialize(writerOptions);
    };
    /** @inheritdoc */
    XMLBuilderImpl.prototype.toObject = function (writerOptions) {
        writerOptions = writerOptions || {};
        if (writerOptions.format === undefined) {
            writerOptions.format = "object";
        }
        return this._serialize(writerOptions);
    };
    /** @inheritdoc */
    XMLBuilderImpl.prototype.end = function (writerOptions) {
        writerOptions = writerOptions || {};
        if (writerOptions.format === undefined) {
            writerOptions.format = "xml";
        }
        return this.doc()._serialize(writerOptions);
    };
    /**
     * Gets the next descendant of the given node of the tree rooted at `root`
     * in depth-first pre-order. Returns a three-tuple with
     * [descendant, descendant_index, descendant_level].
     *
     * @param root - root node of the tree
     * @param self - whether to visit the current node along with child nodes
     * @param recursive - whether to visit all descendant nodes in tree-order or
     * only the immediate child nodes
     */
    XMLBuilderImpl.prototype._getFirstDescendantNode = function (root, self, recursive) {
        if (self)
            return [this._domNode, 0, 0];
        else if (recursive)
            return this._getNextDescendantNode(root, root, recursive, 0, 0);
        else
            return [this._domNode.firstChild, 0, 1];
    };
    /**
     * Gets the next descendant of the given node of the tree rooted at `root`
     * in depth-first pre-order. Returns a three-tuple with
     * [descendant, descendant_index, descendant_level].
     *
     * @param root - root node of the tree
     * @param node - current node
     * @param recursive - whether to visit all descendant nodes in tree-order or
     * only the immediate child nodes
     * @param index - child node index
     * @param level - current depth of the XML tree
     */
    XMLBuilderImpl.prototype._getNextDescendantNode = function (root, node, recursive, index, level) {
        if (recursive) {
            // traverse child nodes
            if (node.firstChild)
                return [node.firstChild, 0, level + 1];
            if (node === root)
                return [null, -1, -1];
            // traverse siblings
            if (node.nextSibling)
                return [node.nextSibling, index + 1, level];
            // traverse parent's next sibling
            var parent = node.parentNode;
            while (parent && parent !== root) {
                if (parent.nextSibling)
                    return [parent.nextSibling, algorithm_1.tree_index(parent.nextSibling), level - 1];
                parent = parent.parentNode;
                level--;
            }
        }
        else {
            if (root === node)
                return [node.firstChild, 0, level + 1];
            else
                return [node.nextSibling, index + 1, level];
        }
        return [null, -1, -1];
    };
    /**
     * Converts the node into its string or object representation.
     *
     * @param options - serialization options
     */
    XMLBuilderImpl.prototype._serialize = function (writerOptions) {
        if (writerOptions.format === "xml") {
            var writer = new writers_1.XMLWriter(this._options, writerOptions);
            return writer.serialize(this.node);
        }
        else if (writerOptions.format === "map") {
            var writer = new writers_1.MapWriter(this._options, writerOptions);
            return writer.serialize(this.node);
        }
        else if (writerOptions.format === "object") {
            var writer = new writers_1.ObjectWriter(this._options, writerOptions);
            return writer.serialize(this.node);
        }
        else if (writerOptions.format === "json") {
            var writer = new writers_1.JSONWriter(this._options, writerOptions);
            return writer.serialize(this.node);
        }
        else if (writerOptions.format === "yaml") {
            var writer = new writers_1.YAMLWriter(this._options, writerOptions);
            return writer.serialize(this.node);
        }
        else {
            throw new Error("Invalid writer format: " + writerOptions.format + ". " + this._debugInfo());
        }
    };
    /**
     * Extracts a namespace and name from the given string.
     *
     * @param namespace - namespace
     * @param name - a string containing both a name and namespace separated by an
     * `'@'` character
     * @param ele - `true` if this is an element namespace; otherwise `false`
     */
    XMLBuilderImpl.prototype._extractNamespace = function (namespace, name, ele) {
        // extract from name
        var atIndex = name.indexOf("@");
        if (atIndex > 0) {
            if (namespace === undefined)
                namespace = name.slice(atIndex + 1);
            name = name.slice(0, atIndex);
        }
        if (namespace === undefined) {
            // look-up default namespace
            namespace = (ele ? this._options.defaultNamespace.ele : this._options.defaultNamespace.att);
        }
        else if (namespace !== null && namespace[0] === "@") {
            // look-up namespace aliases
            var alias = namespace.slice(1);
            namespace = this._options.namespaceAlias[alias];
            if (namespace === undefined) {
                throw new Error("Namespace alias `" + alias + "` is not defined. " + this._debugInfo());
            }
        }
        return [namespace, name];
    };
    /**
     * Updates the element's namespace.
     *
     * @param ns - new namespace
     */
    XMLBuilderImpl.prototype._updateNamespace = function (ns) {
        var e_2, _a, e_3, _b;
        var ele = this._domNode;
        if (util_2.Guard.isElementNode(ele) && ns !== null && ele.namespaceURI !== ns) {
            var _c = __read(algorithm_1.namespace_extractQName(ele.prefix ? ele.prefix + ':' + ele.localName : ele.localName), 2), elePrefix = _c[0], eleLocalName = _c[1];
            // re-create the element node if its namespace changed
            // we can't simply change the namespaceURI since its read-only
            var newEle = algorithm_1.create_element(this._doc, eleLocalName, ns, elePrefix);
            try {
                for (var _d = __values(ele.attributes), _e = _d.next(); !_e.done; _e = _d.next()) {
                    var attr = _e.value;
                    var attrQName = attr.prefix ? attr.prefix + ':' + attr.localName : attr.localName;
                    var _f = __read(algorithm_1.namespace_extractQName(attrQName), 1), attrPrefix = _f[0];
                    var newAttrNS = attr.namespaceURI;
                    if (newAttrNS === null && attrPrefix !== null) {
                        newAttrNS = ele.lookupNamespaceURI(attrPrefix);
                    }
                    if (newAttrNS === null) {
                        newEle.setAttribute(attrQName, attr.value);
                    }
                    else {
                        newEle.setAttributeNS(newAttrNS, attrQName, attr.value);
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_e && !_e.done && (_a = _d.return)) _a.call(_d);
                }
                finally { if (e_2) throw e_2.error; }
            }
            // replace the new node in parent node
            var parent = ele.parentNode;
            /* istanbul ignore next */
            if (parent === null) {
                throw new Error("Parent node is null." + this._debugInfo());
            }
            parent.replaceChild(newEle, ele);
            this._domNode = newEle;
            try {
                // check child nodes
                for (var _g = __values(ele.childNodes), _h = _g.next(); !_h.done; _h = _g.next()) {
                    var childNode = _h.value;
                    var newChildNode = childNode.cloneNode(true);
                    newEle.appendChild(newChildNode);
                    if (util_2.Guard.isElementNode(newChildNode)) {
                        var _j = __read(algorithm_1.namespace_extractQName(newChildNode.prefix ? newChildNode.prefix + ':' + newChildNode.localName : newChildNode.localName), 1), newChildNodePrefix = _j[0];
                        var newChildNodeNS = newEle.lookupNamespaceURI(newChildNodePrefix);
                        new XMLBuilderImpl(newChildNode)._updateNamespace(newChildNodeNS);
                    }
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_h && !_h.done && (_b = _g.return)) _b.call(_g);
                }
                finally { if (e_3) throw e_3.error; }
            }
        }
    };
    Object.defineProperty(XMLBuilderImpl.prototype, "_doc", {
        /**
         * Returns the document owning this node.
         */
        get: function () {
            var node = this.node;
            if (util_2.Guard.isDocumentNode(node)) {
                return node;
            }
            else {
                var docNode = node.ownerDocument;
                /* istanbul ignore next */
                if (!docNode)
                    throw new Error("Owner document is null. " + this._debugInfo());
                return docNode;
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns debug information for this node.
     *
     * @param name - node name
     */
    XMLBuilderImpl.prototype._debugInfo = function (name) {
        var node = this.node;
        var parentNode = node.parentNode;
        name = name || node.nodeName;
        var parentName = parentNode ? parentNode.nodeName : '';
        if (!parentName) {
            return "node: <" + name + ">";
        }
        else {
            return "node: <" + name + ">, parent: <" + parentName + ">";
        }
    };
    Object.defineProperty(XMLBuilderImpl.prototype, "_options", {
        /**
         * Gets or sets builder options.
         */
        get: function () {
            var doc = this._doc;
            /* istanbul ignore next */
            if (doc._xmlBuilderOptions === undefined) {
                throw new Error("Builder options is not set.");
            }
            return doc._xmlBuilderOptions;
        },
        set: function (value) {
            var doc = this._doc;
            doc._xmlBuilderOptions = value;
        },
        enumerable: true,
        configurable: true
    });
    return XMLBuilderImpl;
}());
exports.XMLBuilderImpl = XMLBuilderImpl;
//# sourceMappingURL=XMLBuilderImpl.js.map

/***/ }),

/***/ 1954:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
var dom_1 = __nccwpck_require__(6371);
var dom_2 = __nccwpck_require__(4204);
var util_1 = __nccwpck_require__(7061);
dom_2.dom.setFeatures(false);
/**
 * Creates an XML document without any child nodes.
 */
function createDocument() {
    var impl = new dom_1.DOMImplementation();
    var doc = impl.createDocument(null, 'root', null);
    /* istanbul ignore else */
    if (doc.documentElement) {
        doc.removeChild(doc.documentElement);
    }
    return doc;
}
exports.createDocument = createDocument;
/**
 * Sanitizes input strings with user supplied replacement characters.
 *
 * @param str - input string
 * @param replacement - replacement character or function
 */
function sanitizeInput(str, replacement) {
    if (str == null) {
        return str;
    }
    else if (replacement === undefined) {
        return str + "";
    }
    else {
        var result = "";
        str = str + "";
        for (var i = 0; i < str.length; i++) {
            var n = str.charCodeAt(i);
            // #x9 | #xA | #xD | [#x20-#xD7FF] | [#xE000-#xFFFD] | [#x10000-#x10FFFF]
            if (n === 0x9 || n === 0xA || n === 0xD ||
                (n >= 0x20 && n <= 0xD7FF) ||
                (n >= 0xE000 && n <= 0xFFFD)) {
                // valid character - not surrogate pair
                result += str.charAt(i);
            }
            else if (n >= 0xD800 && n <= 0xDBFF && i < str.length - 1) {
                var n2 = str.charCodeAt(i + 1);
                if (n2 >= 0xDC00 && n2 <= 0xDFFF) {
                    // valid surrogate pair
                    n = (n - 0xD800) * 0x400 + n2 - 0xDC00 + 0x10000;
                    result += String.fromCodePoint(n);
                    i++;
                }
                else {
                    // invalid lone surrogate
                    result += util_1.isString(replacement) ? replacement : replacement(str.charAt(i), i, str);
                }
            }
            else {
                // invalid character
                result += util_1.isString(replacement) ? replacement : replacement(str.charAt(i), i, str);
            }
        }
        return result;
    }
}
exports.sanitizeInput = sanitizeInput;
//# sourceMappingURL=dom.js.map

/***/ }),

/***/ 8434:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
var XMLBuilderImpl_1 = __nccwpck_require__(4042);
exports.XMLBuilderImpl = XMLBuilderImpl_1.XMLBuilderImpl;
var XMLBuilderCBImpl_1 = __nccwpck_require__(8191);
exports.XMLBuilderCBImpl = XMLBuilderCBImpl_1.XMLBuilderCBImpl;
var BuilderFunctions_1 = __nccwpck_require__(8076);
exports.builder = BuilderFunctions_1.builder;
exports.create = BuilderFunctions_1.create;
exports.fragment = BuilderFunctions_1.fragment;
exports.convert = BuilderFunctions_1.convert;
var BuilderFunctionsCB_1 = __nccwpck_require__(821);
exports.createCB = BuilderFunctionsCB_1.createCB;
exports.fragmentCB = BuilderFunctionsCB_1.fragmentCB;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 23:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.nonEntityAmpersandRegex = /&(?![A-Za-z]+;|#\d+;)/g;
//# sourceMappingURL=constants.js.map

/***/ }),

/***/ 2998:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
var builder_1 = __nccwpck_require__(8434);
exports.builder = builder_1.builder;
exports.create = builder_1.create;
exports.fragment = builder_1.fragment;
exports.convert = builder_1.convert;
exports.createCB = builder_1.createCB;
exports.fragmentCB = builder_1.fragmentCB;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 5212:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * Defines default values for builder options.
 */
exports.DefaultBuilderOptions = {
    version: "1.0",
    encoding: undefined,
    standalone: undefined,
    keepNullNodes: false,
    keepNullAttributes: false,
    ignoreConverters: false,
    skipWhitespaceOnlyText: true,
    convert: {
        att: "@",
        ins: "?",
        text: "#",
        cdata: "$",
        comment: "!"
    },
    defaultNamespace: {
        ele: undefined,
        att: undefined
    },
    namespaceAlias: {
        html: "http://www.w3.org/1999/xhtml",
        xml: "http://www.w3.org/XML/1998/namespace",
        xmlns: "http://www.w3.org/2000/xmlns/",
        mathml: "http://www.w3.org/1998/Math/MathML",
        svg: "http://www.w3.org/2000/svg",
        xlink: "http://www.w3.org/1999/xlink"
    },
    invalidCharReplacement: undefined,
    parser: undefined
};
/**
 * Contains keys of `XMLBuilderOptions`.
 */
exports.XMLBuilderOptionKeys = new Set(Object.keys(exports.DefaultBuilderOptions));
/**
 * Defines default values for builder options.
 */
exports.DefaultXMLBuilderCBOptions = {
    format: "xml",
    wellFormed: false,
    prettyPrint: false,
    indent: "  ",
    newline: "\n",
    offset: 0,
    width: 0,
    allowEmptyTags: false,
    spaceBeforeSlash: false,
    keepNullNodes: false,
    keepNullAttributes: false,
    ignoreConverters: false,
    convert: {
        att: "@",
        ins: "?",
        text: "#",
        cdata: "$",
        comment: "!"
    },
    defaultNamespace: {
        ele: undefined,
        att: undefined
    },
    namespaceAlias: {
        html: "http://www.w3.org/1999/xhtml",
        xml: "http://www.w3.org/XML/1998/namespace",
        xmlns: "http://www.w3.org/2000/xmlns/",
        mathml: "http://www.w3.org/1998/Math/MathML",
        svg: "http://www.w3.org/2000/svg",
        xlink: "http://www.w3.org/1999/xlink"
    }
};
//# sourceMappingURL=interfaces.js.map

/***/ }),

/***/ 271:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
var dom_1 = __nccwpck_require__(1954);
/**
 * Parses XML nodes.
 */
var BaseReader = /** @class */ (function () {
    /**
     * Initializes a new instance of `BaseReader`.
     *
     * @param builderOptions - XML builder options
     */
    function BaseReader(builderOptions) {
        this._builderOptions = builderOptions;
        if (builderOptions.parser) {
            Object.assign(this, builderOptions.parser);
        }
    }
    BaseReader.prototype._docType = function (parent, name, publicId, systemId) {
        return parent.dtd({ name: name, pubID: publicId, sysID: systemId });
    };
    BaseReader.prototype._comment = function (parent, data) {
        return parent.com(data);
    };
    BaseReader.prototype._text = function (parent, data) {
        return parent.txt(data);
    };
    BaseReader.prototype._instruction = function (parent, target, data) {
        return parent.ins(target, data);
    };
    BaseReader.prototype._cdata = function (parent, data) {
        return parent.dat(data);
    };
    BaseReader.prototype._element = function (parent, namespace, name) {
        return (namespace === undefined ? parent.ele(name) : parent.ele(namespace, name));
    };
    BaseReader.prototype._attribute = function (parent, namespace, name, value) {
        return (namespace === undefined ? parent.att(name, value) : parent.att(namespace, name, value));
    };
    BaseReader.prototype._sanitize = function (str) {
        return dom_1.sanitizeInput(str, this._builderOptions.invalidCharReplacement);
    };
    /**
     * Decodes serialized text.
     *
     * @param text - text value to serialize
     */
    BaseReader.prototype._decodeText = function (text) {
        if (text == null)
            return text;
        return text.replace(/&(quot|amp|apos|lt|gt);/g, function (_match, tag) {
            return BaseReader._entityTable[tag];
        }).replace(/&#(?:x([a-fA-F0-9]+)|([0-9]+));/g, function (_match, hexStr, numStr) {
            return String.fromCodePoint(parseInt(hexStr || numStr, hexStr ? 16 : 10));
        });
    };
    /**
     * Decodes serialized attribute value.
     *
     * @param text - attribute value to serialize
     */
    BaseReader.prototype._decodeAttributeValue = function (text) {
        return this._decodeText(text);
    };
    /**
     * Main parser function which parses the given object and returns an XMLBuilder.
     *
     * @param node - node to recieve parsed content
     * @param obj - object to parse
     */
    BaseReader.prototype.parse = function (node, obj) {
        return this._parse(node, obj);
    };
    /**
     * Creates a DocType node.
     * The node will be skipped if the function returns `undefined`.
     *
     * @param name - node name
     * @param publicId - public identifier
     * @param systemId - system identifier
     */
    BaseReader.prototype.docType = function (parent, name, publicId, systemId) {
        return this._docType(parent, name, publicId, systemId);
    };
    /**
     * Creates a comment node.
     * The node will be skipped if the function returns `undefined`.
     *
     * @param parent - parent node
     * @param data - node data
     */
    BaseReader.prototype.comment = function (parent, data) {
        return this._comment(parent, data);
    };
    /**
     * Creates a text node.
     * The node will be skipped if the function returns `undefined`.
     *
     * @param parent - parent node
     * @param data - node data
     */
    BaseReader.prototype.text = function (parent, data) {
        return this._text(parent, data);
    };
    /**
     * Creates a processing instruction node.
     * The node will be skipped if the function returns `undefined`.
     *
     * @param parent - parent node
     * @param target - instruction target
     * @param data - node data
     */
    BaseReader.prototype.instruction = function (parent, target, data) {
        return this._instruction(parent, target, data);
    };
    /**
     * Creates a CData section node.
     * The node will be skipped if the function returns `undefined`.
     *
     * @param parent - parent node
     * @param data - node data
     */
    BaseReader.prototype.cdata = function (parent, data) {
        return this._cdata(parent, data);
    };
    /**
     * Creates an element node.
     * The node will be skipped if the function returns `undefined`.
     *
     * @param parent - parent node
     * @param namespace - node namespace
     * @param name - node name
     */
    BaseReader.prototype.element = function (parent, namespace, name) {
        return this._element(parent, namespace, name);
    };
    /**
     * Creates an attribute or namespace declaration.
     * The node will be skipped if the function returns `undefined`.
     *
     * @param parent - parent node
     * @param namespace - node namespace
     * @param name - node name
     * @param value - node value
     */
    BaseReader.prototype.attribute = function (parent, namespace, name, value) {
        return this._attribute(parent, namespace, name, value);
    };
    /**
     * Sanitizes input strings.
     *
     * @param str - input string
     */
    BaseReader.prototype.sanitize = function (str) {
        return this._sanitize(str);
    };
    BaseReader._entityTable = {
        "lt": "<",
        "gt": ">",
        "amp": "&",
        "quot": '"',
        "apos": "'",
    };
    return BaseReader;
}());
exports.BaseReader = BaseReader;
//# sourceMappingURL=BaseReader.js.map

/***/ }),

/***/ 7132:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
var ObjectReader_1 = __nccwpck_require__(3301);
var BaseReader_1 = __nccwpck_require__(271);
/**
 * Parses XML nodes from a JSON string.
 */
var JSONReader = /** @class */ (function (_super) {
    __extends(JSONReader, _super);
    function JSONReader() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Parses the given document representation.
     *
     * @param node - node receive parsed XML nodes
     * @param str - JSON string to parse
     */
    JSONReader.prototype._parse = function (node, str) {
        return new ObjectReader_1.ObjectReader(this._builderOptions).parse(node, JSON.parse(str));
    };
    return JSONReader;
}(BaseReader_1.BaseReader));
exports.JSONReader = JSONReader;
//# sourceMappingURL=JSONReader.js.map

/***/ }),

/***/ 3301:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
var util_1 = __nccwpck_require__(7061);
var BaseReader_1 = __nccwpck_require__(271);
/**
 * Parses XML nodes from objects and arrays.
 * ES6 maps and sets are also supoorted.
 */
var ObjectReader = /** @class */ (function (_super) {
    __extends(ObjectReader, _super);
    function ObjectReader() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Parses the given document representation.
     *
     * @param node - node receive parsed XML nodes
     * @param obj - object to parse
     */
    ObjectReader.prototype._parse = function (node, obj) {
        var _this = this;
        var options = this._builderOptions;
        var lastChild = null;
        if (util_1.isFunction(obj)) {
            // evaluate if function
            lastChild = this.parse(node, obj.apply(this));
        }
        else if (util_1.isArray(obj) || util_1.isSet(obj)) {
            util_1.forEachArray(obj, function (item) { return lastChild = _this.parse(node, item); }, this);
        }
        else if (util_1.isMap(obj) || util_1.isObject(obj)) {
            // expand if object
            util_1.forEachObject(obj, function (key, val) {
                if (util_1.isFunction(val)) {
                    // evaluate if function
                    val = val.apply(_this);
                }
                if (!options.ignoreConverters && key.indexOf(options.convert.att) === 0) {
                    // assign attributes
                    if (key === options.convert.att) {
                        if (util_1.isArray(val) || util_1.isSet(val)) {
                            throw new Error("Invalid attribute: " + val.toString() + ". " + node._debugInfo());
                        }
                        else /* if (isMap(val) || isObject(val)) */ {
                            util_1.forEachObject(val, function (attrKey, attrVal) {
                                lastChild = _this.attribute(node, undefined, _this.sanitize(attrKey), _this._decodeAttributeValue(_this.sanitize(attrVal))) || lastChild;
                            });
                        }
                    }
                    else {
                        lastChild = _this.attribute(node, undefined, _this.sanitize(key.substr(options.convert.att.length)), _this._decodeAttributeValue(_this.sanitize(val))) || lastChild;
                    }
                }
                else if (!options.ignoreConverters && key.indexOf(options.convert.text) === 0) {
                    // text node
                    if (util_1.isMap(val) || util_1.isObject(val)) {
                        // if the key is #text expand child nodes under this node to support mixed content
                        lastChild = _this.parse(node, val);
                    }
                    else {
                        lastChild = _this.text(node, _this._decodeText(_this.sanitize(val))) || lastChild;
                    }
                }
                else if (!options.ignoreConverters && key.indexOf(options.convert.cdata) === 0) {
                    // cdata node
                    if (util_1.isArray(val) || util_1.isSet(val)) {
                        util_1.forEachArray(val, function (item) { return lastChild = _this.cdata(node, _this.sanitize(item)) || lastChild; }, _this);
                    }
                    else {
                        lastChild = _this.cdata(node, _this.sanitize(val)) || lastChild;
                    }
                }
                else if (!options.ignoreConverters && key.indexOf(options.convert.comment) === 0) {
                    // comment node
                    if (util_1.isArray(val) || util_1.isSet(val)) {
                        util_1.forEachArray(val, function (item) { return lastChild = _this.comment(node, _this.sanitize(item)) || lastChild; }, _this);
                    }
                    else {
                        lastChild = _this.comment(node, _this.sanitize(val)) || lastChild;
                    }
                }
                else if (!options.ignoreConverters && key.indexOf(options.convert.ins) === 0) {
                    // processing instruction
                    if (util_1.isString(val)) {
                        var insIndex = val.indexOf(' ');
                        var insTarget = (insIndex === -1 ? val : val.substr(0, insIndex));
                        var insValue = (insIndex === -1 ? '' : val.substr(insIndex + 1));
                        lastChild = _this.instruction(node, _this.sanitize(insTarget), _this.sanitize(insValue)) || lastChild;
                    }
                    else if (util_1.isArray(val) || util_1.isSet(val)) {
                        util_1.forEachArray(val, function (item) {
                            var insIndex = item.indexOf(' ');
                            var insTarget = (insIndex === -1 ? item : item.substr(0, insIndex));
                            var insValue = (insIndex === -1 ? '' : item.substr(insIndex + 1));
                            lastChild = _this.instruction(node, _this.sanitize(insTarget), _this.sanitize(insValue)) || lastChild;
                        }, _this);
                    }
                    else /* if (isMap(target) || isObject(target)) */ {
                        util_1.forEachObject(val, function (insTarget, insValue) { return lastChild = _this.instruction(node, _this.sanitize(insTarget), _this.sanitize(insValue)) || lastChild; }, _this);
                    }
                }
                else if ((util_1.isArray(val) || util_1.isSet(val)) && util_1.isEmpty(val)) {
                    // skip empty arrays
                }
                else if ((util_1.isMap(val) || util_1.isObject(val)) && util_1.isEmpty(val)) {
                    // empty objects produce one node
                    lastChild = _this.element(node, undefined, _this.sanitize(key)) || lastChild;
                }
                else if (!options.keepNullNodes && (val == null)) {
                    // skip null and undefined nodes
                }
                else if (util_1.isArray(val) || util_1.isSet(val)) {
                    // expand list by creating child nodes
                    util_1.forEachArray(val, function (item) {
                        var childNode = {};
                        childNode[key] = item;
                        lastChild = _this.parse(node, childNode);
                    }, _this);
                }
                else if (util_1.isMap(val) || util_1.isObject(val)) {
                    // create a parent node
                    var parent = _this.element(node, undefined, _this.sanitize(key));
                    if (parent) {
                        lastChild = parent;
                        // expand child nodes under parent
                        _this.parse(parent, val);
                    }
                }
                else if (val != null && val !== '') {
                    // leaf element node with a single text node
                    var parent = _this.element(node, undefined, _this.sanitize(key));
                    if (parent) {
                        lastChild = parent;
                        _this.text(parent, _this._decodeText(_this.sanitize(val)));
                    }
                }
                else {
                    // leaf element node
                    lastChild = _this.element(node, undefined, _this.sanitize(key)) || lastChild;
                }
            }, this);
        }
        else if (!options.keepNullNodes && (obj == null)) {
            // skip null and undefined nodes
        }
        else {
            // text node
            lastChild = this.text(node, this._decodeText(this.sanitize(obj))) || lastChild;
        }
        return lastChild || node;
    };
    return ObjectReader;
}(BaseReader_1.BaseReader));
exports.ObjectReader = ObjectReader;
//# sourceMappingURL=ObjectReader.js.map

/***/ }),

/***/ 5871:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var XMLStringLexer_1 = __nccwpck_require__(3529);
var interfaces_1 = __nccwpck_require__(4727);
var interfaces_2 = __nccwpck_require__(9454);
var infra_1 = __nccwpck_require__(4737);
var algorithm_1 = __nccwpck_require__(6573);
var BaseReader_1 = __nccwpck_require__(271);
/**
 * Parses XML nodes from an XML document string.
 */
var XMLReader = /** @class */ (function (_super) {
    __extends(XMLReader, _super);
    function XMLReader() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Parses the given document representation.
     *
     * @param node - node receive parsed XML nodes
     * @param str - XML document string to parse
     */
    XMLReader.prototype._parse = function (node, str) {
        var e_1, _a, e_2, _b;
        var lexer = new XMLStringLexer_1.XMLStringLexer(str, { skipWhitespaceOnlyText: this._builderOptions.skipWhitespaceOnlyText });
        var lastChild = node;
        var context = node;
        var token = lexer.nextToken();
        while (token.type !== interfaces_1.TokenType.EOF) {
            switch (token.type) {
                case interfaces_1.TokenType.Declaration:
                    var declaration = token;
                    var version = this.sanitize(declaration.version);
                    if (version !== "1.0") {
                        throw new Error("Invalid xml version: " + version);
                    }
                    var builderOptions = {
                        version: version
                    };
                    if (declaration.encoding) {
                        builderOptions.encoding = this.sanitize(declaration.encoding);
                    }
                    if (declaration.standalone) {
                        builderOptions.standalone = (this.sanitize(declaration.standalone) === "yes");
                    }
                    context.set(builderOptions);
                    break;
                case interfaces_1.TokenType.DocType:
                    var doctype = token;
                    context = this.docType(context, this.sanitize(doctype.name), this.sanitize(doctype.pubId), this.sanitize(doctype.sysId)) || context;
                    break;
                case interfaces_1.TokenType.CDATA:
                    var cdata = token;
                    context = this.cdata(context, this.sanitize(cdata.data)) || context;
                    break;
                case interfaces_1.TokenType.Comment:
                    var comment = token;
                    context = this.comment(context, this.sanitize(comment.data)) || context;
                    break;
                case interfaces_1.TokenType.PI:
                    var pi = token;
                    context = this.instruction(context, this.sanitize(pi.target), this.sanitize(pi.data)) || context;
                    break;
                case interfaces_1.TokenType.Text:
                    if (context.node.nodeType === interfaces_2.NodeType.Document)
                        break;
                    var text = token;
                    context = this.text(context, this._decodeText(this.sanitize(text.data))) || context;
                    break;
                case interfaces_1.TokenType.Element:
                    var element = token;
                    var elementName = this.sanitize(element.name);
                    // inherit namespace from parent
                    var _c = __read(algorithm_1.namespace_extractQName(elementName), 1), prefix = _c[0];
                    var namespace = context.node.lookupNamespaceURI(prefix);
                    // override namespace if there is a namespace declaration
                    // attribute
                    // also lookup namespace declaration attributes
                    var nsDeclarations = {};
                    try {
                        for (var _d = (e_1 = void 0, __values(element.attributes)), _e = _d.next(); !_e.done; _e = _d.next()) {
                            var _f = __read(_e.value, 2), attName = _f[0], attValue = _f[1];
                            attName = this.sanitize(attName);
                            attValue = this.sanitize(attValue);
                            if (attName === "xmlns") {
                                namespace = attValue;
                            }
                            else {
                                var _g = __read(algorithm_1.namespace_extractQName(attName), 2), attPrefix = _g[0], attLocalName = _g[1];
                                if (attPrefix === "xmlns") {
                                    if (attLocalName === prefix) {
                                        namespace = attValue;
                                    }
                                    nsDeclarations[attLocalName] = attValue;
                                }
                            }
                        }
                    }
                    catch (e_1_1) { e_1 = { error: e_1_1 }; }
                    finally {
                        try {
                            if (_e && !_e.done && (_a = _d.return)) _a.call(_d);
                        }
                        finally { if (e_1) throw e_1.error; }
                    }
                    // create the DOM element node
                    var elementNode = (namespace !== null ?
                        this.element(context, namespace, elementName) :
                        this.element(context, undefined, elementName));
                    if (elementNode === undefined)
                        break;
                    if (context.node === node.node)
                        lastChild = elementNode;
                    try {
                        // assign attributes
                        for (var _h = (e_2 = void 0, __values(element.attributes)), _j = _h.next(); !_j.done; _j = _h.next()) {
                            var _k = __read(_j.value, 2), attName = _k[0], attValue = _k[1];
                            attName = this.sanitize(attName);
                            attValue = this.sanitize(attValue);
                            var _l = __read(algorithm_1.namespace_extractQName(attName), 2), attPrefix = _l[0], attLocalName = _l[1];
                            var attNamespace = null;
                            if (attPrefix === "xmlns" || (attPrefix === null && attLocalName === "xmlns")) {
                                // namespace declaration attribute
                                attNamespace = infra_1.namespace.XMLNS;
                            }
                            else {
                                attNamespace = elementNode.node.lookupNamespaceURI(attPrefix);
                                if (attNamespace !== null && elementNode.node.isDefaultNamespace(attNamespace)) {
                                    attNamespace = null;
                                }
                                else if (attNamespace === null && attPrefix !== null) {
                                    attNamespace = nsDeclarations[attPrefix] || null;
                                }
                            }
                            if (attNamespace !== null)
                                this.attribute(elementNode, attNamespace, attName, this._decodeAttributeValue(attValue));
                            else
                                this.attribute(elementNode, undefined, attName, this._decodeAttributeValue(attValue));
                        }
                    }
                    catch (e_2_1) { e_2 = { error: e_2_1 }; }
                    finally {
                        try {
                            if (_j && !_j.done && (_b = _h.return)) _b.call(_h);
                        }
                        finally { if (e_2) throw e_2.error; }
                    }
                    if (!element.selfClosing) {
                        context = elementNode;
                    }
                    break;
                case interfaces_1.TokenType.ClosingTag:
                    /* istanbul ignore else */
                    if (context.node.parentNode) {
                        context = context.up();
                    }
                    break;
            }
            token = lexer.nextToken();
        }
        return lastChild;
    };
    return XMLReader;
}(BaseReader_1.BaseReader));
exports.XMLReader = XMLReader;
//# sourceMappingURL=XMLReader.js.map

/***/ }),

/***/ 1013:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
var ObjectReader_1 = __nccwpck_require__(3301);
var BaseReader_1 = __nccwpck_require__(271);
var js_yaml_1 = __nccwpck_require__(4281);
/**
 * Parses XML nodes from a YAML string.
 */
var YAMLReader = /** @class */ (function (_super) {
    __extends(YAMLReader, _super);
    function YAMLReader() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Parses the given document representation.
     *
     * @param node - node receive parsed XML nodes
     * @param str - YAML string to parse
     */
    YAMLReader.prototype._parse = function (node, str) {
        var result = js_yaml_1.safeLoad(str);
        /* istanbul ignore next */
        if (result === undefined) {
            throw new Error("Unable to parse YAML document.");
        }
        return new ObjectReader_1.ObjectReader(this._builderOptions).parse(node, result);
    };
    return YAMLReader;
}(BaseReader_1.BaseReader));
exports.YAMLReader = YAMLReader;
//# sourceMappingURL=YAMLReader.js.map

/***/ }),

/***/ 1521:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
var XMLReader_1 = __nccwpck_require__(5871);
exports.XMLReader = XMLReader_1.XMLReader;
var ObjectReader_1 = __nccwpck_require__(3301);
exports.ObjectReader = ObjectReader_1.ObjectReader;
var JSONReader_1 = __nccwpck_require__(7132);
exports.JSONReader = JSONReader_1.JSONReader;
var YAMLReader_1 = __nccwpck_require__(1013);
exports.YAMLReader = YAMLReader_1.YAMLReader;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 126:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * Pre-serializes XML nodes.
 */
var BaseCBWriter = /** @class */ (function () {
    /**
     * Initializes a new instance of `BaseCBWriter`.
     *
     * @param builderOptions - XML builder options
     */
    function BaseCBWriter(builderOptions) {
        /**
         * Gets the current depth of the XML tree.
         */
        this.level = 0;
        this._builderOptions = builderOptions;
        this._writerOptions = builderOptions;
    }
    return BaseCBWriter;
}());
exports.BaseCBWriter = BaseCBWriter;
//# sourceMappingURL=BaseCBWriter.js.map

/***/ }),

/***/ 9903:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {


var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var interfaces_1 = __nccwpck_require__(9454);
var LocalNameSet_1 = __nccwpck_require__(7830);
var NamespacePrefixMap_1 = __nccwpck_require__(8377);
var infra_1 = __nccwpck_require__(4737);
var algorithm_1 = __nccwpck_require__(6573);
var constants_1 = __nccwpck_require__(23);
/**
 * Pre-serializes XML nodes.
 */
var BaseWriter = /** @class */ (function () {
    /**
     * Initializes a new instance of `BaseWriter`.
     *
     * @param builderOptions - XML builder options
     */
    function BaseWriter(builderOptions) {
        /**
         * Gets the current depth of the XML tree.
         */
        this.level = 0;
        this._builderOptions = builderOptions;
    }
    /**
     * Used by derived classes to serialize the XML declaration.
     *
     * @param version - a version number string
     * @param encoding - encoding declaration
     * @param standalone - standalone document declaration
     */
    BaseWriter.prototype.declaration = function (version, encoding, standalone) { };
    /**
     * Used by derived classes to serialize a DocType node.
     *
     * @param name - node name
     * @param publicId - public identifier
     * @param systemId - system identifier
     */
    BaseWriter.prototype.docType = function (name, publicId, systemId) { };
    /**
     * Used by derived classes to serialize a comment node.
     *
     * @param data - node data
     */
    BaseWriter.prototype.comment = function (data) { };
    /**
     * Used by derived classes to serialize a text node.
     *
     * @param data - node data
     */
    BaseWriter.prototype.text = function (data) { };
    /**
     * Used by derived classes to serialize a processing instruction node.
     *
     * @param target - instruction target
     * @param data - node data
     */
    BaseWriter.prototype.instruction = function (target, data) { };
    /**
     * Used by derived classes to serialize a CData section node.
     *
     * @param data - node data
     */
    BaseWriter.prototype.cdata = function (data) { };
    /**
     * Used by derived classes to serialize the beginning of the opening tag of an
     * element node.
     *
     * @param name - node name
     */
    BaseWriter.prototype.openTagBegin = function (name) { };
    /**
     * Used by derived classes to serialize the ending of the opening tag of an
     * element node.
     *
     * @param name - node name
     * @param selfClosing - whether the element node is self closing
     * @param voidElement - whether the element node is a HTML void element
     */
    BaseWriter.prototype.openTagEnd = function (name, selfClosing, voidElement) { };
    /**
     * Used by derived classes to serialize the closing tag of an element node.
     *
     * @param name - node name
     */
    BaseWriter.prototype.closeTag = function (name) { };
    /**
     * Used by derived classes to serialize attributes or namespace declarations.
     *
     * @param attributes - attribute array
     */
    BaseWriter.prototype.attributes = function (attributes) {
        var e_1, _a;
        try {
            for (var attributes_1 = __values(attributes), attributes_1_1 = attributes_1.next(); !attributes_1_1.done; attributes_1_1 = attributes_1.next()) {
                var attr = attributes_1_1.value;
                this.attribute(attr[1] === null ? attr[2] : attr[1] + ':' + attr[2], attr[3]);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (attributes_1_1 && !attributes_1_1.done && (_a = attributes_1.return)) _a.call(attributes_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
    };
    /**
     * Used by derived classes to serialize an attribute or namespace declaration.
     *
     * @param name - node name
     * @param value - node value
     */
    BaseWriter.prototype.attribute = function (name, value) { };
    /**
     * Used by derived classes to perform any pre-processing steps before starting
     * serializing an element node.
     *
     * @param name - node name
     */
    BaseWriter.prototype.beginElement = function (name) { };
    /**
     * Used by derived classes to perform any post-processing steps after
     * completing serializing an element node.
     *
     * @param name - node name
     */
    BaseWriter.prototype.endElement = function (name) { };
    /**
     * Produces an XML serialization of the given node. The pre-serializer inserts
     * namespace declarations where necessary and produces qualified names for
     * nodes and attributes.
     *
     * @param node - node to serialize
     * @param requireWellFormed - whether to check conformance
     */
    BaseWriter.prototype.serializeNode = function (node, requireWellFormed) {
        var hasNamespaces = (node._nodeDocument !== undefined && node._nodeDocument._hasNamespaces);
        this.level = 0;
        this.currentNode = node;
        if (hasNamespaces) {
            /** From: https://w3c.github.io/DOM-Parsing/#xml-serialization
             *
             * 1. Let namespace be a context namespace with value null.
             * The context namespace tracks the XML serialization algorithm's current
             * default namespace. The context namespace is changed when either an Element
             * Node has a default namespace declaration, or the algorithm generates a
             * default namespace declaration for the Element Node to match its own
             * namespace. The algorithm assumes no namespace (null) to start.
             * 2. Let prefix map be a new namespace prefix map.
             * 3. Add the XML namespace with prefix value "xml" to prefix map.
             * 4. Let prefix index be a generated namespace prefix index with value 1.
             * The generated namespace prefix index is used to generate a new unique
             * prefix value when no suitable existing namespace prefix is available to
             * serialize a node's namespaceURI (or the namespaceURI of one of node's
             * attributes). See the generate a prefix algorithm.
             */
            var namespace = null;
            var prefixMap = new NamespacePrefixMap_1.NamespacePrefixMap();
            prefixMap.set("xml", infra_1.namespace.XML);
            var prefixIndex = { value: 1 };
            /**
             * 5. Return the result of running the XML serialization algorithm on node
             * passing the context namespace namespace, namespace prefix map prefix map,
             * generated namespace prefix index reference to prefix index, and the
             * flag require well-formed. If an exception occurs during the execution
             * of the algorithm, then catch that exception and throw an
             * "InvalidStateError" DOMException.
             */
            this._serializeNodeNS(node, namespace, prefixMap, prefixIndex, requireWellFormed);
        }
        else {
            this._serializeNode(node, requireWellFormed);
        }
    };
    /**
     * Produces an XML serialization of a node.
     *
     * @param node - node to serialize
     * @param namespace - context namespace
     * @param prefixMap - namespace prefix map
     * @param prefixIndex - generated namespace prefix index
     * @param requireWellFormed - whether to check conformance
     */
    BaseWriter.prototype._serializeNodeNS = function (node, namespace, prefixMap, prefixIndex, requireWellFormed) {
        this.currentNode = node;
        switch (node.nodeType) {
            case interfaces_1.NodeType.Element:
                this._serializeElementNS(node, namespace, prefixMap, prefixIndex, requireWellFormed);
                break;
            case interfaces_1.NodeType.Document:
                this._serializeDocumentNS(node, namespace, prefixMap, prefixIndex, requireWellFormed);
                break;
            case interfaces_1.NodeType.Comment:
                this._serializeComment(node, requireWellFormed);
                break;
            case interfaces_1.NodeType.Text:
                this._serializeText(node, requireWellFormed);
                break;
            case interfaces_1.NodeType.DocumentFragment:
                this._serializeDocumentFragmentNS(node, namespace, prefixMap, prefixIndex, requireWellFormed);
                break;
            case interfaces_1.NodeType.DocumentType:
                this._serializeDocumentType(node, requireWellFormed);
                break;
            case interfaces_1.NodeType.ProcessingInstruction:
                this._serializeProcessingInstruction(node, requireWellFormed);
                break;
            case interfaces_1.NodeType.CData:
                this._serializeCData(node, requireWellFormed);
                break;
            default:
                throw new Error("Unknown node type: " + node.nodeType);
        }
    };
    /**
     * Produces an XML serialization of a node.
     *
     * @param node - node to serialize
     * @param requireWellFormed - whether to check conformance
     */
    BaseWriter.prototype._serializeNode = function (node, requireWellFormed) {
        this.currentNode = node;
        switch (node.nodeType) {
            case interfaces_1.NodeType.Element:
                this._serializeElement(node, requireWellFormed);
                break;
            case interfaces_1.NodeType.Document:
                this._serializeDocument(node, requireWellFormed);
                break;
            case interfaces_1.NodeType.Comment:
                this._serializeComment(node, requireWellFormed);
                break;
            case interfaces_1.NodeType.Text:
                this._serializeText(node, requireWellFormed);
                break;
            case interfaces_1.NodeType.DocumentFragment:
                this._serializeDocumentFragment(node, requireWellFormed);
                break;
            case interfaces_1.NodeType.DocumentType:
                this._serializeDocumentType(node, requireWellFormed);
                break;
            case interfaces_1.NodeType.ProcessingInstruction:
                this._serializeProcessingInstruction(node, requireWellFormed);
                break;
            case interfaces_1.NodeType.CData:
                this._serializeCData(node, requireWellFormed);
                break;
            default:
                throw new Error("Unknown node type: " + node.nodeType);
        }
    };
    /**
     * Produces an XML serialization of an element node.
     *
     * @param node - node to serialize
     * @param namespace - context namespace
     * @param prefixMap - namespace prefix map
     * @param prefixIndex - generated namespace prefix index
     * @param requireWellFormed - whether to check conformance
     */
    BaseWriter.prototype._serializeElementNS = function (node, namespace, prefixMap, prefixIndex, requireWellFormed) {
        var e_2, _a;
        var attributes = [];
        /**
         * From: https://w3c.github.io/DOM-Parsing/#xml-serializing-an-element-node
         *
         * 1. If the require well-formed flag is set (its value is true), and this
         * node's localName attribute contains the character ":" (U+003A COLON) or
         * does not match the XML Name production, then throw an exception; the
         * serialization of this node would not be a well-formed element.
         */
        if (requireWellFormed && (node.localName.indexOf(":") !== -1 ||
            !algorithm_1.xml_isName(node.localName))) {
            throw new Error("Node local name contains invalid characters (well-formed required).");
        }
        /**
         * 2. Let markup be the string "<" (U+003C LESS-THAN SIGN).
         * 3. Let qualified name be an empty string.
         * 4. Let skip end tag be a boolean flag with value false.
         * 5. Let ignore namespace definition attribute be a boolean flag with value
         * false.
         * 6. Given prefix map, copy a namespace prefix map and let map be the
         * result.
         * 7. Let local prefixes map be an empty map. The map has unique Node prefix
         * strings as its keys, with corresponding namespaceURI Node values as the
         * map's key values (in this map, the null namespace is represented by the
         * empty string).
         *
         * _Note:_ This map is local to each element. It is used to ensure there
         * are no conflicting prefixes should a new namespace prefix attribute need
         * to be generated. It is also used to enable skipping of duplicate prefix
         * definitions when writing an element's attributes: the map allows the
         * algorithm to distinguish between a prefix in the namespace prefix map
         * that might be locally-defined (to the current Element) and one that is
         * not.
         * 8. Let local default namespace be the result of recording the namespace
         * information for node given map and local prefixes map.
         *
         * _Note:_ The above step will update map with any found namespace prefix
         * definitions, add the found prefix definitions to the local prefixes map
         * and return a local default namespace value defined by a default namespace
         * attribute if one exists. Otherwise it returns null.
         * 9. Let inherited ns be a copy of namespace.
         * 10. Let ns be the value of node's namespaceURI attribute.
         */
        var qualifiedName = '';
        var skipEndTag = false;
        var ignoreNamespaceDefinitionAttribute = false;
        var map = prefixMap.copy();
        var localPrefixesMap = {};
        var localDefaultNamespace = this._recordNamespaceInformation(node, map, localPrefixesMap);
        var inheritedNS = namespace;
        var ns = node.namespaceURI;
        /** 11. If inherited ns is equal to ns, then: */
        if (inheritedNS === ns) {
            /**
             * 11.1. If local default namespace is not null, then set ignore
             * namespace definition attribute to true.
             */
            if (localDefaultNamespace !== null) {
                ignoreNamespaceDefinitionAttribute = true;
            }
            /**
             * 11.2. If ns is the XML namespace, then append to qualified name the
             * concatenation of the string "xml:" and the value of node's localName.
             * 11.3. Otherwise, append to qualified name the value of node's
             * localName. The node's prefix if it exists, is dropped.
             */
            if (ns === infra_1.namespace.XML) {
                qualifiedName = 'xml:' + node.localName;
            }
            else {
                qualifiedName = node.localName;
            }
            /** 11.4. Append the value of qualified name to markup. */
            this.beginElement(qualifiedName);
            this.openTagBegin(qualifiedName);
        }
        else {
            /**
             * 12. Otherwise, inherited ns is not equal to ns (the node's own
             * namespace is different from the context namespace of its parent).
             * Run these sub-steps:
             *
             * 12.1. Let prefix be the value of node's prefix attribute.
             * 12.2. Let candidate prefix be the result of retrieving a preferred
             * prefix string prefix from map given namespace ns. The above may return
             * null if no namespace key ns exists in map.
             */
            var prefix = node.prefix;
            /**
             * We don't need to run "retrieving a preferred prefix string" algorithm if
             * the element has no prefix and its namespace matches to the default
             * namespace.
             * See: https://github.com/web-platform-tests/wpt/pull/16703
             */
            var candidatePrefix = null;
            if (prefix !== null || ns !== localDefaultNamespace) {
                candidatePrefix = map.get(prefix, ns);
            }
            /**
             * 12.3. If the value of prefix matches "xmlns", then run the following
             * steps:
             */
            if (prefix === "xmlns") {
                /**
                 * 12.3.1. If the require well-formed flag is set, then throw an error.
                 * An Element with prefix "xmlns" will not legally round-trip in a
                 * conforming XML parser.
                 */
                if (requireWellFormed) {
                    throw new Error("An element cannot have the 'xmlns' prefix (well-formed required).");
                }
                /**
                 * 12.3.2. Let candidate prefix be the value of prefix.
                 */
                candidatePrefix = prefix;
            }
            /**
             * 12.4.Found a suitable namespace prefix: if candidate prefix is not
             * null (a namespace prefix is defined which maps to ns), then:
             */
            if (candidatePrefix !== null) {
                /**
                 * The following may serialize a different prefix than the Element's
                 * existing prefix if it already had one. However, the retrieving a
                 * preferred prefix string algorithm already tried to match the
                 * existing prefix if possible.
                 *
                 * 12.4.1. Append to qualified name the concatenation of candidate
                 * prefix, ":" (U+003A COLON), and node's localName. There exists on
                 * this node or the node's ancestry a namespace prefix definition that
                 * defines the node's namespace.
                 * 12.4.2. If the local default namespace is not null (there exists a
                 * locally-defined default namespace declaration attribute) and its
                 * value is not the XML namespace, then let inherited ns get the value
                 * of local default namespace unless the local default namespace is the
                 * empty string in which case let it get null (the context namespace
                 * is changed to the declared default, rather than this node's own
                 * namespace).
                 *
                 * _Note:_ Any default namespace definitions or namespace prefixes that
                 * define the XML namespace are omitted when serializing this node's
                 * attributes.
                 */
                qualifiedName = candidatePrefix + ':' + node.localName;
                if (localDefaultNamespace !== null && localDefaultNamespace !== infra_1.namespace.XML) {
                    inheritedNS = localDefaultNamespace || null;
                }
                /**
                 * 12.4.3. Append the value of qualified name to markup.
                 */
                this.beginElement(qualifiedName);
                this.openTagBegin(qualifiedName);
                /** 12.5. Otherwise, if prefix is not null, then: */
            }
            else if (prefix !== null) {
                /**
                 * _Note:_ By this step, there is no namespace or prefix mapping
                 * declaration in this node (or any parent node visited by this
                 * algorithm) that defines prefix otherwise the step labelled Found
                 * a suitable namespace prefix would have been followed. The sub-steps
                 * that follow will create a new namespace prefix declaration for prefix
                 * and ensure that prefix does not conflict with an existing namespace
                 * prefix declaration of the same localName in node's attribute list.
                 *
                 * 12.5.1. If the local prefixes map contains a key matching prefix,
                 * then let prefix be the result of generating a prefix providing as
                 * input map, ns, and prefix index.
                 */
                if (prefix in localPrefixesMap) {
                    prefix = this._generatePrefix(ns, map, prefixIndex);
                }
                /**
                 * 12.5.2. Add prefix to map given namespace ns.
                 * 12.5.3. Append to qualified name the concatenation of prefix, ":"
                 * (U+003A COLON), and node's localName.
                 * 12.5.4. Append the value of qualified name to markup.
                 */
                map.set(prefix, ns);
                qualifiedName += prefix + ':' + node.localName;
                this.beginElement(qualifiedName);
                this.openTagBegin(qualifiedName);
                /**
                 * 12.5.5. Append the following to markup, in the order listed:
                 *
                 * _Note:_ The following serializes a namespace prefix declaration for
                 * prefix which was just added to the map.
                 *
                 * 12.5.5.1. " " (U+0020 SPACE);
                 * 12.5.5.2. The string "xmlns:";
                 * 12.5.5.3. The value of prefix;
                 * 12.5.5.4. "="" (U+003D EQUALS SIGN, U+0022 QUOTATION MARK);
                 * 12.5.5.5. The result of serializing an attribute value given ns and
                 * the require well-formed flag as input;
                 * 12.5.5.6. """ (U+0022 QUOTATION MARK).
                 */
                attributes.push([null, 'xmlns', prefix,
                    this._serializeAttributeValue(ns, requireWellFormed)]);
                /**
                 * 12.5.5.7. If local default namespace is not null (there exists a
                 * locally-defined default namespace declaration attribute), then
                 * let inherited ns get the value of local default namespace unless the
                 * local default namespace is the empty string in which case let it get
                 * null.
                 */
                if (localDefaultNamespace !== null) {
                    inheritedNS = localDefaultNamespace || null;
                }
                /**
                 * 12.6. Otherwise, if local default namespace is null, or local
                 * default namespace is not null and its value is not equal to ns, then:
                 */
            }
            else if (localDefaultNamespace === null ||
                (localDefaultNamespace !== null && localDefaultNamespace !== ns)) {
                /**
                 * _Note:_ At this point, the namespace for this node still needs to be
                 * serialized, but there's no prefix (or candidate prefix) available; the
                 * following uses the default namespace declaration to define the
                 * namespace--optionally replacing an existing default declaration
                 * if present.
                 *
                 * 12.6.1. Set the ignore namespace definition attribute flag to true.
                 * 12.6.2. Append to qualified name the value of node's localName.
                 * 12.6.3. Let the value of inherited ns be ns.
                 *
                 * _Note:_ The new default namespace will be used in the serialization
                 * to define this node's namespace and act as the context namespace for
                 * its children.
                 */
                ignoreNamespaceDefinitionAttribute = true;
                qualifiedName += node.localName;
                inheritedNS = ns;
                /**
                 * 12.6.4. Append the value of qualified name to markup.
                 */
                this.beginElement(qualifiedName);
                this.openTagBegin(qualifiedName);
                /**
                 * 12.6.5. Append the following to markup, in the order listed:
                 *
                 * _Note:_ The following serializes the new (or replacement) default
                 * namespace definition.
                 *
                 * 12.6.5.1. " " (U+0020 SPACE);
                 * 12.6.5.2. The string "xmlns";
                 * 12.6.5.3. "="" (U+003D EQUALS SIGN, U+0022 QUOTATION MARK);
                 * 12.6.5.4. The result of serializing an attribute value given ns
                 * and the require well-formed flag as input;
                 * 12.6.5.5. """ (U+0022 QUOTATION MARK).
                 */
                attributes.push([null, null, 'xmlns',
                    this._serializeAttributeValue(ns, requireWellFormed)]);
                /**
                 * 12.7. Otherwise, the node has a local default namespace that matches
                 * ns. Append to qualified name the value of node's localName, let the
                 * value of inherited ns be ns, and append the value of qualified name
                 * to markup.
                 */
            }
            else {
                qualifiedName += node.localName;
                inheritedNS = ns;
                this.beginElement(qualifiedName);
                this.openTagBegin(qualifiedName);
            }
        }
        /**
         * 13. Append to markup the result of the XML serialization of node's
         * attributes given map, prefix index, local prefixes map, ignore namespace
         * definition attribute flag, and require well-formed flag.
         */
        attributes.push.apply(attributes, __spread(this._serializeAttributesNS(node, map, prefixIndex, localPrefixesMap, ignoreNamespaceDefinitionAttribute, requireWellFormed)));
        this.attributes(attributes);
        /**
         * 14. If ns is the HTML namespace, and the node's list of children is
         * empty, and the node's localName matches any one of the following void
         * elements: "area", "base", "basefont", "bgsound", "br", "col", "embed",
         * "frame", "hr", "img", "input", "keygen", "link", "menuitem", "meta",
         * "param", "source", "track", "wbr"; then append the following to markup,
         * in the order listed:
         * 14.1. " " (U+0020 SPACE);
         * 14.2. "/" (U+002F SOLIDUS).
         * and set the skip end tag flag to true.
         * 15. If ns is not the HTML namespace, and the node's list of children is
         * empty, then append "/" (U+002F SOLIDUS) to markup and set the skip end
         * tag flag to true.
         * 16. Append ">" (U+003E GREATER-THAN SIGN) to markup.
         */
        var isHTML = (ns === infra_1.namespace.HTML);
        if (isHTML && node.childNodes.length === 0 &&
            BaseWriter._VoidElementNames.has(node.localName)) {
            this.openTagEnd(qualifiedName, true, true);
            this.endElement(qualifiedName);
            skipEndTag = true;
        }
        else if (!isHTML && node.childNodes.length === 0) {
            this.openTagEnd(qualifiedName, true, false);
            this.endElement(qualifiedName);
            skipEndTag = true;
        }
        else {
            this.openTagEnd(qualifiedName, false, false);
        }
        /**
         * 17. If the value of skip end tag is true, then return the value of markup
         * and skip the remaining steps. The node is a leaf-node.
         */
        if (skipEndTag)
            return;
        /**
         * 18. If ns is the HTML namespace, and the node's localName matches the
         * string "template", then this is a template element. Append to markup the
         * result of XML serializing a DocumentFragment node given the template
         * element's template contents (a DocumentFragment), providing inherited
         * ns, map, prefix index, and the require well-formed flag.
         *
         * _Note:_ This allows template content to round-trip, given the rules for
         * parsing XHTML documents.
         *
         * 19. Otherwise, append to markup the result of running the XML
         * serialization algorithm on each of node's children, in tree order,
         * providing inherited ns, map, prefix index, and the require well-formed
         * flag.
         */
        if (isHTML && node.localName === "template") {
            // TODO: serialize template contents
        }
        else {
            try {
                for (var _b = __values(node.childNodes), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var childNode = _c.value;
                    this.level++;
                    this._serializeNodeNS(childNode, inheritedNS, map, prefixIndex, requireWellFormed);
                    this.level--;
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_2) throw e_2.error; }
            }
        }
        /**
         * 20. Append the following to markup, in the order listed:
         * 20.1. "</" (U+003C LESS-THAN SIGN, U+002F SOLIDUS);
         * 20.2. The value of qualified name;
         * 20.3. ">" (U+003E GREATER-THAN SIGN).
         * 21. Return the value of markup.
         */
        this.closeTag(qualifiedName);
        this.endElement(qualifiedName);
    };
    /**
     * Produces an XML serialization of an element node.
     *
     * @param node - node to serialize
     * @param requireWellFormed - whether to check conformance
     */
    BaseWriter.prototype._serializeElement = function (node, requireWellFormed) {
        var e_3, _a;
        /**
         * From: https://w3c.github.io/DOM-Parsing/#xml-serializing-an-element-node
         *
         * 1. If the require well-formed flag is set (its value is true), and this
         * node's localName attribute contains the character ":" (U+003A COLON) or
         * does not match the XML Name production, then throw an exception; the
         * serialization of this node would not be a well-formed element.
         */
        if (requireWellFormed && (node.localName.indexOf(":") !== -1 ||
            !algorithm_1.xml_isName(node.localName))) {
            throw new Error("Node local name contains invalid characters (well-formed required).");
        }
        /**
         * 2. Let markup be the string "<" (U+003C LESS-THAN SIGN).
         * 3. Let qualified name be an empty string.
         * 4. Let skip end tag be a boolean flag with value false.
         * 5. Let ignore namespace definition attribute be a boolean flag with value
         * false.
         * 6. Given prefix map, copy a namespace prefix map and let map be the
         * result.
         * 7. Let local prefixes map be an empty map. The map has unique Node prefix
         * strings as its keys, with corresponding namespaceURI Node values as the
         * map's key values (in this map, the null namespace is represented by the
         * empty string).
         *
         * _Note:_ This map is local to each element. It is used to ensure there
         * are no conflicting prefixes should a new namespace prefix attribute need
         * to be generated. It is also used to enable skipping of duplicate prefix
         * definitions when writing an element's attributes: the map allows the
         * algorithm to distinguish between a prefix in the namespace prefix map
         * that might be locally-defined (to the current Element) and one that is
         * not.
         * 8. Let local default namespace be the result of recording the namespace
         * information for node given map and local prefixes map.
         *
         * _Note:_ The above step will update map with any found namespace prefix
         * definitions, add the found prefix definitions to the local prefixes map
         * and return a local default namespace value defined by a default namespace
         * attribute if one exists. Otherwise it returns null.
         * 9. Let inherited ns be a copy of namespace.
         * 10. Let ns be the value of node's namespaceURI attribute.
         */
        var skipEndTag = false;
        /** 11. If inherited ns is equal to ns, then: */
        /**
         * 11.1. If local default namespace is not null, then set ignore
         * namespace definition attribute to true.
         */
        /**
         * 11.2. If ns is the XML namespace, then append to qualified name the
         * concatenation of the string "xml:" and the value of node's localName.
         * 11.3. Otherwise, append to qualified name the value of node's
         * localName. The node's prefix if it exists, is dropped.
         */
        var qualifiedName = node.localName;
        /** 11.4. Append the value of qualified name to markup. */
        this.beginElement(qualifiedName);
        this.openTagBegin(qualifiedName);
        /**
         * 13. Append to markup the result of the XML serialization of node's
         * attributes given map, prefix index, local prefixes map, ignore namespace
         * definition attribute flag, and require well-formed flag.
         */
        var attributes = this._serializeAttributes(node, requireWellFormed);
        this.attributes(attributes);
        /**
         * 14. If ns is the HTML namespace, and the node's list of children is
         * empty, and the node's localName matches any one of the following void
         * elements: "area", "base", "basefont", "bgsound", "br", "col", "embed",
         * "frame", "hr", "img", "input", "keygen", "link", "menuitem", "meta",
         * "param", "source", "track", "wbr"; then append the following to markup,
         * in the order listed:
         * 14.1. " " (U+0020 SPACE);
         * 14.2. "/" (U+002F SOLIDUS).
         * and set the skip end tag flag to true.
         * 15. If ns is not the HTML namespace, and the node's list of children is
         * empty, then append "/" (U+002F SOLIDUS) to markup and set the skip end
         * tag flag to true.
         * 16. Append ">" (U+003E GREATER-THAN SIGN) to markup.
         */
        if (!node.hasChildNodes()) {
            this.openTagEnd(qualifiedName, true, false);
            this.endElement(qualifiedName);
            skipEndTag = true;
        }
        else {
            this.openTagEnd(qualifiedName, false, false);
        }
        /**
         * 17. If the value of skip end tag is true, then return the value of markup
         * and skip the remaining steps. The node is a leaf-node.
         */
        if (skipEndTag)
            return;
        try {
            /**
             * 18. If ns is the HTML namespace, and the node's localName matches the
             * string "template", then this is a template element. Append to markup the
             * result of XML serializing a DocumentFragment node given the template
             * element's template contents (a DocumentFragment), providing inherited
             * ns, map, prefix index, and the require well-formed flag.
             *
             * _Note:_ This allows template content to round-trip, given the rules for
             * parsing XHTML documents.
             *
             * 19. Otherwise, append to markup the result of running the XML
             * serialization algorithm on each of node's children, in tree order,
             * providing inherited ns, map, prefix index, and the require well-formed
             * flag.
             */
            for (var _b = __values(node._children), _c = _b.next(); !_c.done; _c = _b.next()) {
                var childNode = _c.value;
                this.level++;
                this._serializeNode(childNode, requireWellFormed);
                this.level--;
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_3) throw e_3.error; }
        }
        /**
         * 20. Append the following to markup, in the order listed:
         * 20.1. "</" (U+003C LESS-THAN SIGN, U+002F SOLIDUS);
         * 20.2. The value of qualified name;
         * 20.3. ">" (U+003E GREATER-THAN SIGN).
         * 21. Return the value of markup.
         */
        this.closeTag(qualifiedName);
        this.endElement(qualifiedName);
    };
    /**
     * Produces an XML serialization of a document node.
     *
     * @param node - node to serialize
     * @param namespace - context namespace
     * @param prefixMap - namespace prefix map
     * @param prefixIndex - generated namespace prefix index
     * @param requireWellFormed - whether to check conformance
     */
    BaseWriter.prototype._serializeDocumentNS = function (node, namespace, prefixMap, prefixIndex, requireWellFormed) {
        var e_4, _a;
        /**
         * If the require well-formed flag is set (its value is true), and this node
         * has no documentElement (the documentElement attribute's value is null),
         * then throw an exception; the serialization of this node would not be a
         * well-formed document.
         */
        if (requireWellFormed && node.documentElement === null) {
            throw new Error("Missing document element (well-formed required).");
        }
        try {
            /**
             * Otherwise, run the following steps:
             * 1. Let serialized document be an empty string.
             * 2. For each child child of node, in tree order, run the XML
             * serialization algorithm on the child passing along the provided
             * arguments, and append the result to serialized document.
             *
             * _Note:_ This will serialize any number of ProcessingInstruction and
             * Comment nodes both before and after the Document's documentElement node,
             * including at most one DocumentType node. (Text nodes are not allowed as
             * children of the Document.)
             *
             * 3. Return the value of serialized document.
            */
            for (var _b = __values(node.childNodes), _c = _b.next(); !_c.done; _c = _b.next()) {
                var childNode = _c.value;
                this._serializeNodeNS(childNode, namespace, prefixMap, prefixIndex, requireWellFormed);
            }
        }
        catch (e_4_1) { e_4 = { error: e_4_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_4) throw e_4.error; }
        }
    };
    /**
     * Produces an XML serialization of a document node.
     *
     * @param node - node to serialize
     * @param requireWellFormed - whether to check conformance
     */
    BaseWriter.prototype._serializeDocument = function (node, requireWellFormed) {
        var e_5, _a;
        /**
         * If the require well-formed flag is set (its value is true), and this node
         * has no documentElement (the documentElement attribute's value is null),
         * then throw an exception; the serialization of this node would not be a
         * well-formed document.
         */
        if (requireWellFormed && node.documentElement === null) {
            throw new Error("Missing document element (well-formed required).");
        }
        try {
            /**
             * Otherwise, run the following steps:
             * 1. Let serialized document be an empty string.
             * 2. For each child child of node, in tree order, run the XML
             * serialization algorithm on the child passing along the provided
             * arguments, and append the result to serialized document.
             *
             * _Note:_ This will serialize any number of ProcessingInstruction and
             * Comment nodes both before and after the Document's documentElement node,
             * including at most one DocumentType node. (Text nodes are not allowed as
             * children of the Document.)
             *
             * 3. Return the value of serialized document.
            */
            for (var _b = __values(node._children), _c = _b.next(); !_c.done; _c = _b.next()) {
                var childNode = _c.value;
                this._serializeNode(childNode, requireWellFormed);
            }
        }
        catch (e_5_1) { e_5 = { error: e_5_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_5) throw e_5.error; }
        }
    };
    /**
     * Produces an XML serialization of a comment node.
     *
     * @param node - node to serialize
     * @param requireWellFormed - whether to check conformance
     */
    BaseWriter.prototype._serializeComment = function (node, requireWellFormed) {
        /**
         * If the require well-formed flag is set (its value is true), and node's
         * data contains characters that are not matched by the XML Char production
         * or contains "--" (two adjacent U+002D HYPHEN-MINUS characters) or that
         * ends with a "-" (U+002D HYPHEN-MINUS) character, then throw an exception;
         * the serialization of this node's data would not be well-formed.
         */
        if (requireWellFormed && (!algorithm_1.xml_isLegalChar(node.data) ||
            node.data.indexOf("--") !== -1 || node.data.endsWith("-"))) {
            throw new Error("Comment data contains invalid characters (well-formed required).");
        }
        /**
         * Otherwise, return the concatenation of "<!--", node's data, and "-->".
         */
        this.comment(node.data);
    };
    /**
     * Produces an XML serialization of a text node.
     *
     * @param node - node to serialize
     * @param requireWellFormed - whether to check conformance
     * @param level - current depth of the XML tree
     */
    BaseWriter.prototype._serializeText = function (node, requireWellFormed) {
        /**
         * 1. If the require well-formed flag is set (its value is true), and
         * node's data contains characters that are not matched by the XML Char
         * production, then throw an exception; the serialization of this node's
         * data would not be well-formed.
         */
        if (requireWellFormed && !algorithm_1.xml_isLegalChar(node.data)) {
            throw new Error("Text data contains invalid characters (well-formed required).");
        }
        /**
         * 2. Let markup be the value of node's data.
         * 3. Replace any occurrences of "&" in markup by "&amp;".
         * 4. Replace any occurrences of "<" in markup by "&lt;".
         * 5. Replace any occurrences of ">" in markup by "&gt;".
         * 6. Return the value of markup.
         */
        var markup = node.data.replace(constants_1.nonEntityAmpersandRegex, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;');
        this.text(markup);
    };
    /**
     * Produces an XML serialization of a document fragment node.
     *
     * @param node - node to serialize
     * @param namespace - context namespace
     * @param prefixMap - namespace prefix map
     * @param prefixIndex - generated namespace prefix index
     * @param requireWellFormed - whether to check conformance
     */
    BaseWriter.prototype._serializeDocumentFragmentNS = function (node, namespace, prefixMap, prefixIndex, requireWellFormed) {
        var e_6, _a;
        try {
            /**
             * 1. Let markup the empty string.
             * 2. For each child child of node, in tree order, run the XML serialization
             * algorithm on the child given namespace, prefix map, a reference to prefix
             * index, and flag require well-formed. Concatenate the result to markup.
             * 3. Return the value of markup.
             */
            for (var _b = __values(node.childNodes), _c = _b.next(); !_c.done; _c = _b.next()) {
                var childNode = _c.value;
                this._serializeNodeNS(childNode, namespace, prefixMap, prefixIndex, requireWellFormed);
            }
        }
        catch (e_6_1) { e_6 = { error: e_6_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_6) throw e_6.error; }
        }
    };
    /**
     * Produces an XML serialization of a document fragment node.
     *
     * @param node - node to serialize
     * @param requireWellFormed - whether to check conformance
     */
    BaseWriter.prototype._serializeDocumentFragment = function (node, requireWellFormed) {
        var e_7, _a;
        try {
            /**
             * 1. Let markup the empty string.
             * 2. For each child child of node, in tree order, run the XML serialization
             * algorithm on the child given namespace, prefix map, a reference to prefix
             * index, and flag require well-formed. Concatenate the result to markup.
             * 3. Return the value of markup.
             */
            for (var _b = __values(node._children), _c = _b.next(); !_c.done; _c = _b.next()) {
                var childNode = _c.value;
                this._serializeNode(childNode, requireWellFormed);
            }
        }
        catch (e_7_1) { e_7 = { error: e_7_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_7) throw e_7.error; }
        }
    };
    /**
     * Produces an XML serialization of a document type node.
     *
     * @param node - node to serialize
     * @param requireWellFormed - whether to check conformance
     */
    BaseWriter.prototype._serializeDocumentType = function (node, requireWellFormed) {
        /**
         * 1. If the require well-formed flag is true and the node's publicId
         * attribute contains characters that are not matched by the XML PubidChar
         *  production, then throw an exception; the serialization of this node
         * would not be a well-formed document type declaration.
         */
        if (requireWellFormed && !algorithm_1.xml_isPubidChar(node.publicId)) {
            throw new Error("DocType public identifier does not match PubidChar construct (well-formed required).");
        }
        /**
         * 2. If the require well-formed flag is true and the node's systemId
         * attribute contains characters that are not matched by the XML Char
         * production or that contains both a """ (U+0022 QUOTATION MARK) and a
         * "'" (U+0027 APOSTROPHE), then throw an exception; the serialization
         * of this node would not be a well-formed document type declaration.
         */
        if (requireWellFormed &&
            (!algorithm_1.xml_isLegalChar(node.systemId) ||
                (node.systemId.indexOf('"') !== -1 && node.systemId.indexOf("'") !== -1))) {
            throw new Error("DocType system identifier contains invalid characters (well-formed required).");
        }
        /**
         * 3. Let markup be an empty string.
         * 4. Append the string "<!DOCTYPE" to markup.
         * 5. Append " " (U+0020 SPACE) to markup.
         * 6. Append the value of the node's name attribute to markup. For a node
         * belonging to an HTML document, the value will be all lowercase.
         * 7. If the node's publicId is not the empty string then append the
         * following, in the order listed, to markup:
         * 7.1. " " (U+0020 SPACE);
         * 7.2. The string "PUBLIC";
         * 7.3. " " (U+0020 SPACE);
         * 7.4. """ (U+0022 QUOTATION MARK);
         * 7.5. The value of the node's publicId attribute;
         * 7.6. """ (U+0022 QUOTATION MARK).
         * 8. If the node's systemId is not the empty string and the node's publicId
         * is set to the empty string, then append the following, in the order
         * listed, to markup:
         * 8.1. " " (U+0020 SPACE);
         * 8.2. The string "SYSTEM".
         * 9. If the node's systemId is not the empty string then append the
         * following, in the order listed, to markup:
         * 9.2. " " (U+0020 SPACE);
         * 9.3. """ (U+0022 QUOTATION MARK);
         * 9.3. The value of the node's systemId attribute;
         * 9.4. """ (U+0022 QUOTATION MARK).
         * 10. Append ">" (U+003E GREATER-THAN SIGN) to markup.
         * 11. Return the value of markup.
         */
        this.docType(node.name, node.publicId, node.systemId);
    };
    /**
     * Produces an XML serialization of a processing instruction node.
     *
     * @param node - node to serialize
     * @param requireWellFormed - whether to check conformance
     */
    BaseWriter.prototype._serializeProcessingInstruction = function (node, requireWellFormed) {
        /**
         * 1. If the require well-formed flag is set (its value is true), and node's
         * target contains a ":" (U+003A COLON) character or is an ASCII
         * case-insensitive match for the string "xml", then throw an exception;
         * the serialization of this node's target would not be well-formed.
         */
        if (requireWellFormed && (node.target.indexOf(":") !== -1 || (/^xml$/i).test(node.target))) {
            throw new Error("Processing instruction target contains invalid characters (well-formed required).");
        }
        /**
         * 2. If the require well-formed flag is set (its value is true), and node's
         * data contains characters that are not matched by the XML Char production
         * or contains the string "?>" (U+003F QUESTION MARK,
         * U+003E GREATER-THAN SIGN), then throw an exception; the serialization of
         * this node's data would not be well-formed.
         */
        if (requireWellFormed && (!algorithm_1.xml_isLegalChar(node.data) ||
            node.data.indexOf("?>") !== -1)) {
            throw new Error("Processing instruction data contains invalid characters (well-formed required).");
        }
        /**
         * 3. Let markup be the concatenation of the following, in the order listed:
         * 3.1. "<?" (U+003C LESS-THAN SIGN, U+003F QUESTION MARK);
         * 3.2. The value of node's target;
         * 3.3. " " (U+0020 SPACE);
         * 3.4. The value of node's data;
         * 3.5. "?>" (U+003F QUESTION MARK, U+003E GREATER-THAN SIGN).
         * 4. Return the value of markup.
         */
        this.instruction(node.target, node.data);
    };
    /**
     * Produces an XML serialization of a CDATA node.
     *
     * @param node - node to serialize
     * @param requireWellFormed - whether to check conformance
     */
    BaseWriter.prototype._serializeCData = function (node, requireWellFormed) {
        if (requireWellFormed && (node.data.indexOf("]]>") !== -1)) {
            throw new Error("CDATA contains invalid characters (well-formed required).");
        }
        this.cdata(node.data);
    };
    /**
    * Produces an XML serialization of the attributes of an element node.
    *
     * @param node - node to serialize
     * @param map - namespace prefix map
     * @param prefixIndex - generated namespace prefix index
     * @param localPrefixesMap - local prefixes map
     * @param ignoreNamespaceDefinitionAttribute - whether to ignore namespace
     * attributes
     * @param requireWellFormed - whether to check conformance
    */
    BaseWriter.prototype._serializeAttributesNS = function (node, map, prefixIndex, localPrefixesMap, ignoreNamespaceDefinitionAttribute, requireWellFormed) {
        var e_8, _a;
        /**
         * 1. Let result be the empty string.
         * 2. Let localname set be a new empty namespace localname set. This
         * localname set will contain tuples of unique attribute namespaceURI and
         * localName pairs, and is populated as each attr is processed. This set is
         * used to [optionally] enforce the well-formed constraint that an element
         * cannot have two attributes with the same namespaceURI and localName.
         * This can occur when two otherwise identical attributes on the same
         * element differ only by their prefix values.
         */
        var result = [];
        var localNameSet = requireWellFormed ? new LocalNameSet_1.LocalNameSet() : undefined;
        try {
            /**
             * 3. Loop: For each attribute attr in element's attributes, in the order
             * they are specified in the element's attribute list:
             */
            for (var _b = __values(node.attributes), _c = _b.next(); !_c.done; _c = _b.next()) {
                var attr = _c.value;
                // Optimize common case
                if (!requireWellFormed && !ignoreNamespaceDefinitionAttribute && attr.namespaceURI === null) {
                    result.push([null, null, attr.localName,
                        this._serializeAttributeValue(attr.value, requireWellFormed)]);
                    continue;
                }
                /**
                 * 3.1. If the require well-formed flag is set (its value is true), and the
                 * localname set contains a tuple whose values match those of a new tuple
                 * consisting of attr's namespaceURI attribute and localName attribute,
                 * then throw an exception; the serialization of this attr would fail to
                 * produce a well-formed element serialization.
                 */
                if (requireWellFormed && localNameSet && localNameSet.has(attr.namespaceURI, attr.localName)) {
                    throw new Error("Element contains duplicate attributes (well-formed required).");
                }
                /**
                 * 3.2. Create a new tuple consisting of attr's namespaceURI attribute and
                 * localName attribute, and add it to the localname set.
                 * 3.3. Let attribute namespace be the value of attr's namespaceURI value.
                 * 3.4. Let candidate prefix be null.
                 */
                if (requireWellFormed && localNameSet)
                    localNameSet.set(attr.namespaceURI, attr.localName);
                var attributeNamespace = attr.namespaceURI;
                var candidatePrefix = null;
                /** 3.5. If attribute namespace is not null, then run these sub-steps: */
                if (attributeNamespace !== null) {
                    /**
                     * 3.5.1. Let candidate prefix be the result of retrieving a preferred
                     * prefix string from map given namespace attribute namespace with
                     * preferred prefix being attr's prefix value.
                     */
                    candidatePrefix = map.get(attr.prefix, attributeNamespace);
                    /**
                     * 3.5.2. If the value of attribute namespace is the XMLNS namespace,
                     * then run these steps:
                     */
                    if (attributeNamespace === infra_1.namespace.XMLNS) {
                        /**
                         * 3.5.2.1. If any of the following are true, then stop running these
                         * steps and goto Loop to visit the next attribute:
                         * - the attr's value is the XML namespace;
                         * _Note:_ The XML namespace cannot be redeclared and survive
                         * round-tripping (unless it defines the prefix "xml"). To avoid this
                         * problem, this algorithm always prefixes elements in the XML
                         * namespace with "xml" and drops any related definitions as seen
                         * in the above condition.
                         * - the attr's prefix is null and the ignore namespace definition
                         * attribute flag is true (the Element's default namespace attribute
                         * should be skipped);
                         * - the attr's prefix is not null and either
                         *   * the attr's localName is not a key contained in the local
                         *     prefixes map, or
                         *   * the attr's localName is present in the local prefixes map but
                         *     the value of the key does not match attr's value
                         * and furthermore that the attr's localName (as the prefix to find)
                         * is found in the namespace prefix map given the namespace consisting
                         * of the attr's value (the current namespace prefix definition was
                         * exactly defined previously--on an ancestor element not the current
                         * element whose attributes are being processed).
                         */
                        if (attr.value === infra_1.namespace.XML ||
                            (attr.prefix === null && ignoreNamespaceDefinitionAttribute) ||
                            (attr.prefix !== null && (!(attr.localName in localPrefixesMap) ||
                                localPrefixesMap[attr.localName] !== attr.value) &&
                                map.has(attr.localName, attr.value)))
                            continue;
                        /**
                         * 3.5.2.2. If the require well-formed flag is set (its value is true),
                         * and the value of attr's value attribute matches the XMLNS
                         * namespace, then throw an exception; the serialization of this
                         * attribute would produce invalid XML because the XMLNS namespace
                         * is reserved and cannot be applied as an element's namespace via
                         * XML parsing.
                         *
                         * _Note:_ DOM APIs do allow creation of elements in the XMLNS
                         * namespace but with strict qualifications.
                         */
                        if (requireWellFormed && attr.value === infra_1.namespace.XMLNS) {
                            throw new Error("XMLNS namespace is reserved (well-formed required).");
                        }
                        /**
                         * 3.5.2.3. If the require well-formed flag is set (its value is true),
                         * and the value of attr's value attribute is the empty string, then
                         * throw an exception; namespace prefix declarations cannot be used
                         * to undeclare a namespace (use a default namespace declaration
                         * instead).
                         */
                        if (requireWellFormed && attr.value === '') {
                            throw new Error("Namespace prefix declarations cannot be used to undeclare a namespace (well-formed required).");
                        }
                        /**
                         * 3.5.2.4. the attr's prefix matches the string "xmlns", then let
                         * candidate prefix be the string "xmlns".
                         */
                        if (attr.prefix === 'xmlns')
                            candidatePrefix = 'xmlns';
                        /**
                         * 3.5.3. Otherwise, the attribute namespace is not the XMLNS namespace.
                         * Run these steps:
                         *
                         * _Note:_ The (candidatePrefix === null) check is not in the spec.
                         * We deviate from the spec here. Otherwise a prefix is generated for
                         * all attributes with namespaces.
                         */
                    }
                    else if (candidatePrefix === null) {
                        if (attr.prefix !== null &&
                            (!map.hasPrefix(attr.prefix) ||
                                map.has(attr.prefix, attributeNamespace))) {
                            /**
                             * Check if we can use the attribute's own prefix.
                             * We deviate from the spec here.
                             * TODO: This is not an efficient way of searching for prefixes.
                             * Follow developments to the spec.
                             */
                            candidatePrefix = attr.prefix;
                        }
                        else {
                            /**
                             * 3.5.3.1. Let candidate prefix be the result of generating a prefix
                             * providing map, attribute namespace, and prefix index as input.
                             */
                            candidatePrefix = this._generatePrefix(attributeNamespace, map, prefixIndex);
                        }
                        /**
                         * 3.5.3.2. Append the following to result, in the order listed:
                         * 3.5.3.2.1. " " (U+0020 SPACE);
                         * 3.5.3.2.2. The string "xmlns:";
                         * 3.5.3.2.3. The value of candidate prefix;
                         * 3.5.3.2.4. "="" (U+003D EQUALS SIGN, U+0022 QUOTATION MARK);
                         * 3.5.3.2.5. The result of serializing an attribute value given
                         * attribute namespace and the require well-formed flag as input;
                         * 3.5.3.2.6. """ (U+0022 QUOTATION MARK).
                        */
                        result.push([null, "xmlns", candidatePrefix,
                            this._serializeAttributeValue(attributeNamespace, requireWellFormed)]);
                    }
                }
                /**
                 * 3.6. Append a " " (U+0020 SPACE) to result.
                 * 3.7. If candidate prefix is not null, then append to result the
                 * concatenation of candidate prefix with ":" (U+003A COLON).
                 */
                var attrName = '';
                if (candidatePrefix !== null) {
                    attrName = candidatePrefix;
                }
                /**
                 * 3.8. If the require well-formed flag is set (its value is true), and
                 * this attr's localName attribute contains the character
                 * ":" (U+003A COLON) or does not match the XML Name production or
                 * equals "xmlns" and attribute namespace is null, then throw an
                 * exception; the serialization of this attr would not be a
                 * well-formed attribute.
                 */
                if (requireWellFormed && (attr.localName.indexOf(":") !== -1 ||
                    !algorithm_1.xml_isName(attr.localName) ||
                    (attr.localName === "xmlns" && attributeNamespace === null))) {
                    throw new Error("Attribute local name contains invalid characters (well-formed required).");
                }
                /**
                 * 3.9. Append the following strings to result, in the order listed:
                 * 3.9.1. The value of attr's localName;
                 * 3.9.2. "="" (U+003D EQUALS SIGN, U+0022 QUOTATION MARK);
                 * 3.9.3. The result of serializing an attribute value given attr's value
                 * attribute and the require well-formed flag as input;
                 * 3.9.4. """ (U+0022 QUOTATION MARK).
                 */
                result.push([attributeNamespace, candidatePrefix, attr.localName,
                    this._serializeAttributeValue(attr.value, requireWellFormed)]);
            }
        }
        catch (e_8_1) { e_8 = { error: e_8_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_8) throw e_8.error; }
        }
        /**
         * 4. Return the value of result.
         */
        return result;
    };
    /**
    * Produces an XML serialization of the attributes of an element node.
    *
     * @param node - node to serialize
     * @param requireWellFormed - whether to check conformance
    */
    BaseWriter.prototype._serializeAttributes = function (node, requireWellFormed) {
        var e_9, _a;
        /**
         * 1. Let result be the empty string.
         * 2. Let localname set be a new empty namespace localname set. This
         * localname set will contain tuples of unique attribute namespaceURI and
         * localName pairs, and is populated as each attr is processed. This set is
         * used to [optionally] enforce the well-formed constraint that an element
         * cannot have two attributes with the same namespaceURI and localName.
         * This can occur when two otherwise identical attributes on the same
         * element differ only by their prefix values.
         */
        var result = [];
        var localNameSet = requireWellFormed ? {} : undefined;
        try {
            /**
             * 3. Loop: For each attribute attr in element's attributes, in the order
             * they are specified in the element's attribute list:
             */
            for (var _b = __values(node.attributes), _c = _b.next(); !_c.done; _c = _b.next()) {
                var attr = _c.value;
                // Optimize common case
                if (!requireWellFormed) {
                    result.push([null, null, attr.localName,
                        this._serializeAttributeValue(attr.value, requireWellFormed)]);
                    continue;
                }
                /**
                 * 3.1. If the require well-formed flag is set (its value is true), and the
                 * localname set contains a tuple whose values match those of a new tuple
                 * consisting of attr's namespaceURI attribute and localName attribute,
                 * then throw an exception; the serialization of this attr would fail to
                 * produce a well-formed element serialization.
                 */
                if (requireWellFormed && localNameSet && (attr.localName in localNameSet)) {
                    throw new Error("Element contains duplicate attributes (well-formed required).");
                }
                /**
                 * 3.2. Create a new tuple consisting of attr's namespaceURI attribute and
                 * localName attribute, and add it to the localname set.
                 * 3.3. Let attribute namespace be the value of attr's namespaceURI value.
                 * 3.4. Let candidate prefix be null.
                 */
                /* istanbul ignore else */
                if (requireWellFormed && localNameSet)
                    localNameSet[attr.localName] = true;
                /** 3.5. If attribute namespace is not null, then run these sub-steps: */
                /**
                 * 3.6. Append a " " (U+0020 SPACE) to result.
                 * 3.7. If candidate prefix is not null, then append to result the
                 * concatenation of candidate prefix with ":" (U+003A COLON).
                 */
                /**
                 * 3.8. If the require well-formed flag is set (its value is true), and
                 * this attr's localName attribute contains the character
                 * ":" (U+003A COLON) or does not match the XML Name production or
                 * equals "xmlns" and attribute namespace is null, then throw an
                 * exception; the serialization of this attr would not be a
                 * well-formed attribute.
                 */
                if (requireWellFormed && (attr.localName.indexOf(":") !== -1 ||
                    !algorithm_1.xml_isName(attr.localName))) {
                    throw new Error("Attribute local name contains invalid characters (well-formed required).");
                }
                /**
                 * 3.9. Append the following strings to result, in the order listed:
                 * 3.9.1. The value of attr's localName;
                 * 3.9.2. "="" (U+003D EQUALS SIGN, U+0022 QUOTATION MARK);
                 * 3.9.3. The result of serializing an attribute value given attr's value
                 * attribute and the require well-formed flag as input;
                 * 3.9.4. """ (U+0022 QUOTATION MARK).
                 */
                result.push([null, null, attr.localName,
                    this._serializeAttributeValue(attr.value, requireWellFormed)]);
            }
        }
        catch (e_9_1) { e_9 = { error: e_9_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_9) throw e_9.error; }
        }
        /**
         * 4. Return the value of result.
         */
        return result;
    };
    /**
    * Records namespace information for the given element and returns the
    * default namespace attribute value.
    *
    * @param node - element node to process
    * @param map - namespace prefix map
    * @param localPrefixesMap - local prefixes map
    */
    BaseWriter.prototype._recordNamespaceInformation = function (node, map, localPrefixesMap) {
        var e_10, _a;
        /**
         * 1. Let default namespace attr value be null.
         */
        var defaultNamespaceAttrValue = null;
        try {
            /**
             * 2. Main: For each attribute attr in element's attributes, in the order
             * they are specified in the element's attribute list:
             */
            for (var _b = __values(node.attributes), _c = _b.next(); !_c.done; _c = _b.next()) {
                var attr = _c.value;
                /**
                 * _Note:_ The following conditional steps find namespace prefixes. Only
                 * attributes in the XMLNS namespace are considered (e.g., attributes made
                 * to look like namespace declarations via
                 * setAttribute("xmlns:pretend-prefix", "pretend-namespace") are not
                 * included).
                 */
                /** 2.1. Let attribute namespace be the value of attr's namespaceURI value. */
                var attributeNamespace = attr.namespaceURI;
                /** 2.2. Let attribute prefix be the value of attr's prefix. */
                var attributePrefix = attr.prefix;
                /** 2.3. If the attribute namespace is the XMLNS namespace, then: */
                if (attributeNamespace === infra_1.namespace.XMLNS) {
                    /**
                     * 2.3.1. If attribute prefix is null, then attr is a default namespace
                     * declaration. Set the default namespace attr value to attr's value and
                     * stop running these steps, returning to Main to visit the next
                     * attribute.
                     */
                    if (attributePrefix === null) {
                        defaultNamespaceAttrValue = attr.value;
                        continue;
                        /**
                         * 2.3.2. Otherwise, the attribute prefix is not null and attr is a
                         * namespace prefix definition. Run the following steps:
                         */
                    }
                    else {
                        /** 2.3.2.1. Let prefix definition be the value of attr's localName. */
                        var prefixDefinition = attr.localName;
                        /** 2.3.2.2. Let namespace definition be the value of attr's value. */
                        var namespaceDefinition = attr.value;
                        /**
                         * 2.3.2.3. If namespace definition is the XML namespace, then stop
                         * running these steps, and return to Main to visit the next
                         * attribute.
                         *
                         * _Note:_ XML namespace definitions in prefixes are completely
                         * ignored (in order to avoid unnecessary work when there might be
                         * prefix conflicts). XML namespaced elements are always handled
                         * uniformly by prefixing (and overriding if necessary) the element's
                         * localname with the reserved "xml" prefix.
                         */
                        if (namespaceDefinition === infra_1.namespace.XML) {
                            continue;
                        }
                        /**
                         * 2.3.2.4. If namespace definition is the empty string (the
                         * declarative form of having no namespace), then let namespace
                         * definition be null instead.
                         */
                        if (namespaceDefinition === '') {
                            namespaceDefinition = null;
                        }
                        /**
                         * 2.3.2.5. If prefix definition is found in map given the namespace
                         * namespace definition, then stop running these steps, and return to
                         * Main to visit the next attribute.
                         *
                         * _Note:_ This step avoids adding duplicate prefix definitions for
                         * the same namespace in the map. This has the side-effect of avoiding
                         * later serialization of duplicate namespace prefix declarations in
                         * any descendant nodes.
                         */
                        if (map.has(prefixDefinition, namespaceDefinition)) {
                            continue;
                        }
                        /**
                         * 2.3.2.6. Add the prefix prefix definition to map given namespace
                         * namespace definition.
                         */
                        map.set(prefixDefinition, namespaceDefinition);
                        /**
                         * 2.3.2.7. Add the value of prefix definition as a new key to the
                         * local prefixes map, with the namespace definition as the key's
                         * value replacing the value of null with the empty string if
                         * applicable.
                         */
                        localPrefixesMap[prefixDefinition] = namespaceDefinition || '';
                    }
                }
            }
        }
        catch (e_10_1) { e_10 = { error: e_10_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_10) throw e_10.error; }
        }
        /**
         * 3. Return the value of default namespace attr value.
         *
         * _Note:_ The empty string is a legitimate return value and is not
         * converted to null.
         */
        return defaultNamespaceAttrValue;
    };
    /**
    * Generates a new prefix for the given namespace.
    *
    * @param newNamespace - a namespace to generate prefix for
    * @param prefixMap - namespace prefix map
    * @param prefixIndex - generated namespace prefix index
    */
    BaseWriter.prototype._generatePrefix = function (newNamespace, prefixMap, prefixIndex) {
        /**
         * 1. Let generated prefix be the concatenation of the string "ns" and the
         * current numerical value of prefix index.
         * 2. Let the value of prefix index be incremented by one.
         * 3. Add to map the generated prefix given the new namespace namespace.
         * 4. Return the value of generated prefix.
         */
        var generatedPrefix = "ns" + prefixIndex.value.toString();
        prefixIndex.value++;
        prefixMap.set(generatedPrefix, newNamespace);
        return generatedPrefix;
    };
    /**
     * Produces an XML serialization of an attribute value.
     *
     * @param value - attribute value
     * @param requireWellFormed - whether to check conformance
     */
    BaseWriter.prototype._serializeAttributeValue = function (value, requireWellFormed) {
        /**
         * From: https://w3c.github.io/DOM-Parsing/#dfn-serializing-an-attribute-value
         *
         * 1. If the require well-formed flag is set (its value is true), and
         * attribute value contains characters that are not matched by the XML Char
         * production, then throw an exception; the serialization of this attribute
         * value would fail to produce a well-formed element serialization.
         */
        if (requireWellFormed && value !== null && !algorithm_1.xml_isLegalChar(value)) {
            throw new Error("Invalid characters in attribute value.");
        }
        /**
         * 2. If attribute value is null, then return the empty string.
         */
        if (value === null)
            return "";
        /**
         * 3. Otherwise, attribute value is a string. Return the value of attribute
         * value, first replacing any occurrences of the following:
         * - "&" with "&amp;"
         * - """ with "&quot;"
         * - "<" with "&lt;"
         * - ">" with "&gt;"
         * NOTE
         * This matches behavior present in browsers, and goes above and beyond the
         * grammar requirement in the XML specification's AttValue production by
         * also replacing ">" characters.
         */
        return value.replace(constants_1.nonEntityAmpersandRegex, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;');
    };
    BaseWriter._VoidElementNames = new Set(['area', 'base', 'basefont',
        'bgsound', 'br', 'col', 'embed', 'frame', 'hr', 'img', 'input', 'keygen',
        'link', 'menuitem', 'meta', 'param', 'source', 'track', 'wbr']);
    return BaseWriter;
}());
exports.BaseWriter = BaseWriter;
//# sourceMappingURL=BaseWriter.js.map

/***/ }),

/***/ 4685:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
var BaseCBWriter_1 = __nccwpck_require__(126);
/**
 * Serializes XML nodes.
 */
var JSONCBWriter = /** @class */ (function (_super) {
    __extends(JSONCBWriter, _super);
    /**
     * Initializes a new instance of `JSONCBWriter`.
     *
     * @param builderOptions - XML builder options
     */
    function JSONCBWriter(builderOptions) {
        var _this = _super.call(this, builderOptions) || this;
        _this._hasChildren = [];
        _this._additionalLevel = 0;
        return _this;
    }
    /** @inheritdoc */
    JSONCBWriter.prototype.frontMatter = function () {
        return "";
    };
    /** @inheritdoc */
    JSONCBWriter.prototype.declaration = function (version, encoding, standalone) {
        return "";
    };
    /** @inheritdoc */
    JSONCBWriter.prototype.docType = function (name, publicId, systemId) {
        return "";
    };
    /** @inheritdoc */
    JSONCBWriter.prototype.comment = function (data) {
        // { "!": "hello" }
        return this._comma() + this._beginLine() + "{" + this._sep() +
            this._key(this._builderOptions.convert.comment) + this._sep() +
            this._val(data) + this._sep() + "}";
    };
    /** @inheritdoc */
    JSONCBWriter.prototype.text = function (data) {
        // { "#": "hello" }
        return this._comma() + this._beginLine() + "{" + this._sep() +
            this._key(this._builderOptions.convert.text) + this._sep() +
            this._val(data) + this._sep() + "}";
    };
    /** @inheritdoc */
    JSONCBWriter.prototype.instruction = function (target, data) {
        // { "?": "target hello" }
        return this._comma() + this._beginLine() + "{" + this._sep() +
            this._key(this._builderOptions.convert.ins) + this._sep() +
            this._val(data ? target + " " + data : target) + this._sep() + "}";
    };
    /** @inheritdoc */
    JSONCBWriter.prototype.cdata = function (data) {
        // { "$": "hello" }
        return this._comma() + this._beginLine() + "{" + this._sep() +
            this._key(this._builderOptions.convert.cdata) + this._sep() +
            this._val(data) + this._sep() + "}";
    };
    /** @inheritdoc */
    JSONCBWriter.prototype.attribute = function (name, value) {
        // { "@name": "val" }
        return this._comma() + this._beginLine(1) + "{" + this._sep() +
            this._key(this._builderOptions.convert.att + name) + this._sep() +
            this._val(value) + this._sep() + "}";
    };
    /** @inheritdoc */
    JSONCBWriter.prototype.openTagBegin = function (name) {
        // { "node": { "#": [
        var str = this._comma() + this._beginLine() + "{" + this._sep() + this._key(name) + this._sep() + "{";
        this._additionalLevel++;
        this.hasData = true;
        str += this._beginLine() + this._key(this._builderOptions.convert.text) + this._sep() + "[";
        this._hasChildren.push(false);
        return str;
    };
    /** @inheritdoc */
    JSONCBWriter.prototype.openTagEnd = function (name, selfClosing, voidElement) {
        if (selfClosing) {
            var str = this._sep() + "]";
            this._additionalLevel--;
            str += this._beginLine() + "}" + this._sep() + "}";
            return str;
        }
        else {
            return "";
        }
    };
    /** @inheritdoc */
    JSONCBWriter.prototype.closeTag = function (name) {
        // ] } }
        var str = this._beginLine() + "]";
        this._additionalLevel--;
        str += this._beginLine() + "}" + this._sep() + "}";
        return str;
    };
    /** @inheritdoc */
    JSONCBWriter.prototype.beginElement = function (name) { };
    /** @inheritdoc */
    JSONCBWriter.prototype.endElement = function (name) { this._hasChildren.pop(); };
    /**
     * Produces characters to be prepended to a line of string in pretty-print
     * mode.
     */
    JSONCBWriter.prototype._beginLine = function (additionalOffset) {
        if (additionalOffset === void 0) { additionalOffset = 0; }
        if (this._writerOptions.prettyPrint) {
            return (this.hasData ? this._writerOptions.newline : "") +
                this._indent(this._writerOptions.offset + this.level + additionalOffset);
        }
        else {
            return "";
        }
    };
    /**
     * Produces an indentation string.
     *
     * @param level - depth of the tree
     */
    JSONCBWriter.prototype._indent = function (level) {
        if (level + this._additionalLevel <= 0) {
            return "";
        }
        else {
            return this._writerOptions.indent.repeat(level + this._additionalLevel);
        }
    };
    /**
     * Produces a comma before a child node if it has previous siblings.
     */
    JSONCBWriter.prototype._comma = function () {
        var str = (this._hasChildren[this._hasChildren.length - 1] ? "," : "");
        if (this._hasChildren.length > 0) {
            this._hasChildren[this._hasChildren.length - 1] = true;
        }
        return str;
    };
    /**
     * Produces a separator string.
     */
    JSONCBWriter.prototype._sep = function () {
        return (this._writerOptions.prettyPrint ? " " : "");
    };
    /**
     * Produces a JSON key string delimited with double quotes.
     */
    JSONCBWriter.prototype._key = function (key) {
        return "\"" + key + "\":";
    };
    /**
     * Produces a JSON value string delimited with double quotes.
     */
    JSONCBWriter.prototype._val = function (val) {
        return JSON.stringify(val);
    };
    return JSONCBWriter;
}(BaseCBWriter_1.BaseCBWriter));
exports.JSONCBWriter = JSONCBWriter;
//# sourceMappingURL=JSONCBWriter.js.map

/***/ }),

/***/ 9096:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var ObjectWriter_1 = __nccwpck_require__(9265);
var util_1 = __nccwpck_require__(7061);
var BaseWriter_1 = __nccwpck_require__(9903);
/**
 * Serializes XML nodes into a JSON string.
 */
var JSONWriter = /** @class */ (function (_super) {
    __extends(JSONWriter, _super);
    /**
     * Initializes a new instance of `JSONWriter`.
     *
     * @param builderOptions - XML builder options
     * @param writerOptions - serialization options
     */
    function JSONWriter(builderOptions, writerOptions) {
        var _this = _super.call(this, builderOptions) || this;
        // provide default options
        _this._writerOptions = util_1.applyDefaults(writerOptions, {
            wellFormed: false,
            prettyPrint: false,
            indent: '  ',
            newline: '\n',
            offset: 0,
            group: false,
            verbose: false
        });
        return _this;
    }
    /**
     * Produces an XML serialization of the given node.
     *
     * @param node - node to serialize
     * @param writerOptions - serialization options
     */
    JSONWriter.prototype.serialize = function (node) {
        // convert to object
        var objectWriterOptions = util_1.applyDefaults(this._writerOptions, {
            format: "object",
            wellFormed: false
        });
        var objectWriter = new ObjectWriter_1.ObjectWriter(this._builderOptions, objectWriterOptions);
        var val = objectWriter.serialize(node);
        // recursively convert object into JSON string
        return this._beginLine(this._writerOptions, 0) + this._convertObject(val, this._writerOptions);
    };
    /**
     * Produces an XML serialization of the given object.
     *
     * @param obj - object to serialize
     * @param options - serialization options
     * @param level - depth of the XML tree
     */
    JSONWriter.prototype._convertObject = function (obj, options, level) {
        var e_1, _a;
        var _this = this;
        if (level === void 0) { level = 0; }
        var markup = '';
        var isLeaf = this._isLeafNode(obj);
        if (util_1.isArray(obj)) {
            markup += '[';
            var len = obj.length;
            var i = 0;
            try {
                for (var obj_1 = __values(obj), obj_1_1 = obj_1.next(); !obj_1_1.done; obj_1_1 = obj_1.next()) {
                    var val = obj_1_1.value;
                    markup += this._endLine(options, level + 1) +
                        this._beginLine(options, level + 1) +
                        this._convertObject(val, options, level + 1);
                    if (i < len - 1) {
                        markup += ',';
                    }
                    i++;
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (obj_1_1 && !obj_1_1.done && (_a = obj_1.return)) _a.call(obj_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            markup += this._endLine(options, level) + this._beginLine(options, level);
            markup += ']';
        }
        else if (util_1.isObject(obj)) {
            markup += '{';
            var len_1 = util_1.objectLength(obj);
            var i_1 = 0;
            util_1.forEachObject(obj, function (key, val) {
                if (isLeaf && options.prettyPrint) {
                    markup += ' ';
                }
                else {
                    markup += _this._endLine(options, level + 1) + _this._beginLine(options, level + 1);
                }
                markup += _this._key(key);
                if (options.prettyPrint) {
                    markup += ' ';
                }
                markup += _this._convertObject(val, options, level + 1);
                if (i_1 < len_1 - 1) {
                    markup += ',';
                }
                i_1++;
            }, this);
            if (isLeaf && options.prettyPrint) {
                markup += ' ';
            }
            else {
                markup += this._endLine(options, level) + this._beginLine(options, level);
            }
            markup += '}';
        }
        else {
            markup += this._val(obj);
        }
        return markup;
    };
    /**
     * Produces characters to be prepended to a line of string in pretty-print
     * mode.
     *
     * @param options - serialization options
     * @param level - current depth of the XML tree
     */
    JSONWriter.prototype._beginLine = function (options, level) {
        if (!options.prettyPrint) {
            return '';
        }
        else {
            var indentLevel = options.offset + level + 1;
            if (indentLevel > 0) {
                return new Array(indentLevel).join(options.indent);
            }
        }
        return '';
    };
    /**
     * Produces characters to be appended to a line of string in pretty-print
     * mode.
     *
     * @param options - serialization options
     * @param level - current depth of the XML tree
     */
    JSONWriter.prototype._endLine = function (options, level) {
        if (!options.prettyPrint) {
            return '';
        }
        else {
            return options.newline;
        }
    };
    /**
     * Produces a JSON key string delimited with double quotes.
     */
    JSONWriter.prototype._key = function (key) {
        return "\"" + key + "\":";
    };
    /**
     * Produces a JSON value string delimited with double quotes.
     */
    JSONWriter.prototype._val = function (val) {
        return JSON.stringify(val);
    };
    /**
     * Determines if an object is a leaf node.
     *
     * @param obj
     */
    JSONWriter.prototype._isLeafNode = function (obj) {
        return this._descendantCount(obj) <= 1;
    };
    /**
     * Counts the number of descendants of the given object.
     *
     * @param obj
     * @param count
     */
    JSONWriter.prototype._descendantCount = function (obj, count) {
        var _this = this;
        if (count === void 0) { count = 0; }
        if (util_1.isArray(obj)) {
            util_1.forEachArray(obj, function (val) { return count += _this._descendantCount(val, count); }, this);
        }
        else if (util_1.isObject(obj)) {
            util_1.forEachObject(obj, function (key, val) { return count += _this._descendantCount(val, count); }, this);
        }
        else {
            count++;
        }
        return count;
    };
    return JSONWriter;
}(BaseWriter_1.BaseWriter));
exports.JSONWriter = JSONWriter;
//# sourceMappingURL=JSONWriter.js.map

/***/ }),

/***/ 7432:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
var util_1 = __nccwpck_require__(7061);
var ObjectWriter_1 = __nccwpck_require__(9265);
var BaseWriter_1 = __nccwpck_require__(9903);
/**
 * Serializes XML nodes into ES6 maps and arrays.
 */
var MapWriter = /** @class */ (function (_super) {
    __extends(MapWriter, _super);
    /**
     * Initializes a new instance of `MapWriter`.
     *
     * @param builderOptions - XML builder options
     * @param writerOptions - serialization options
     */
    function MapWriter(builderOptions, writerOptions) {
        var _this = _super.call(this, builderOptions) || this;
        // provide default options
        _this._writerOptions = util_1.applyDefaults(writerOptions, {
            format: "map",
            wellFormed: false,
            group: false,
            verbose: false
        });
        return _this;
    }
    /**
     * Produces an XML serialization of the given node.
     *
     * @param node - node to serialize
     */
    MapWriter.prototype.serialize = function (node) {
        // convert to object
        var objectWriterOptions = util_1.applyDefaults(this._writerOptions, {
            format: "object",
            wellFormed: false,
            verbose: false
        });
        var objectWriter = new ObjectWriter_1.ObjectWriter(this._builderOptions, objectWriterOptions);
        var val = objectWriter.serialize(node);
        // recursively convert object into Map
        return this._convertObject(val);
    };
    /**
     * Recursively converts a JS object into an ES5 map.
     *
     * @param obj - a JS object
     */
    MapWriter.prototype._convertObject = function (obj) {
        if (util_1.isArray(obj)) {
            for (var i = 0; i < obj.length; i++) {
                obj[i] = this._convertObject(obj[i]);
            }
            return obj;
        }
        else if (util_1.isObject(obj)) {
            var map = new Map();
            for (var key in obj) {
                map.set(key, this._convertObject(obj[key]));
            }
            return map;
        }
        else {
            return obj;
        }
    };
    return MapWriter;
}(BaseWriter_1.BaseWriter));
exports.MapWriter = MapWriter;
//# sourceMappingURL=MapWriter.js.map

/***/ }),

/***/ 9265:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var util_1 = __nccwpck_require__(7061);
var interfaces_1 = __nccwpck_require__(9454);
var BaseWriter_1 = __nccwpck_require__(9903);
/**
 * Serializes XML nodes into objects and arrays.
 */
var ObjectWriter = /** @class */ (function (_super) {
    __extends(ObjectWriter, _super);
    /**
     * Initializes a new instance of `ObjectWriter`.
     *
     * @param builderOptions - XML builder options
     * @param writerOptions - serialization options
     */
    function ObjectWriter(builderOptions, writerOptions) {
        var _this = _super.call(this, builderOptions) || this;
        _this._writerOptions = util_1.applyDefaults(writerOptions, {
            format: "object",
            wellFormed: false,
            group: false,
            verbose: false
        });
        return _this;
    }
    /**
     * Produces an XML serialization of the given node.
     *
     * @param node - node to serialize
     */
    ObjectWriter.prototype.serialize = function (node) {
        this._currentList = [];
        this._currentIndex = 0;
        this._listRegister = [this._currentList];
        /**
         * First pass, serialize nodes
         * This creates a list of nodes grouped under node types while preserving
         * insertion order. For example:
         * [
         *   root: [
         *     node: [
         *       { "@" : { "att1": "val1", "att2": "val2" }
         *       { "#": "node text" }
         *       { childNode: [] }
         *       { "#": "more text" }
         *     ],
         *     node: [
         *       { "@" : { "att": "val" }
         *       { "#": [ "text line1", "text line2" ] }
         *     ]
         *   ]
         * ]
         */
        this.serializeNode(node, this._writerOptions.wellFormed);
        /**
         * Second pass, process node lists. Above example becomes:
         * {
         *   root: {
         *     node: [
         *       {
         *         "@att1": "val1",
         *         "@att2": "val2",
         *         "#1": "node text",
         *         childNode: {},
         *         "#2": "more text"
         *       },
         *       {
         *         "@att": "val",
         *         "#": [ "text line1", "text line2" ]
         *       }
         *     ]
         *   }
         * }
         */
        return this._process(this._currentList, this._writerOptions);
    };
    ObjectWriter.prototype._process = function (items, options) {
        var _a, _b, _c, _d, _e, _f, _g;
        if (items.length === 0)
            return {};
        // determine if there are non-unique element names
        var namesSeen = {};
        var hasNonUniqueNames = false;
        var textCount = 0;
        var commentCount = 0;
        var instructionCount = 0;
        var cdataCount = 0;
        for (var i = 0; i < items.length; i++) {
            var item = items[i];
            var key = Object.keys(item)[0];
            switch (key) {
                case "@":
                    continue;
                case "#":
                    textCount++;
                    break;
                case "!":
                    commentCount++;
                    break;
                case "?":
                    instructionCount++;
                    break;
                case "$":
                    cdataCount++;
                    break;
                default:
                    if (namesSeen[key]) {
                        hasNonUniqueNames = true;
                    }
                    else {
                        namesSeen[key] = true;
                    }
                    break;
            }
        }
        var defAttrKey = this._getAttrKey();
        var defTextKey = this._getNodeKey(interfaces_1.NodeType.Text);
        var defCommentKey = this._getNodeKey(interfaces_1.NodeType.Comment);
        var defInstructionKey = this._getNodeKey(interfaces_1.NodeType.ProcessingInstruction);
        var defCdataKey = this._getNodeKey(interfaces_1.NodeType.CData);
        if (textCount === 1 && items.length === 1 && util_1.isString(items[0]["#"])) {
            // special case of an element node with a single text node
            return items[0]["#"];
        }
        else if (hasNonUniqueNames) {
            var obj = {};
            // process attributes first
            for (var i = 0; i < items.length; i++) {
                var item = items[i];
                var key = Object.keys(item)[0];
                if (key === "@") {
                    var attrs = item["@"];
                    var attrKeys = Object.keys(attrs);
                    if (attrKeys.length === 1) {
                        obj[defAttrKey + attrKeys[0]] = attrs[attrKeys[0]];
                    }
                    else {
                        obj[defAttrKey] = item["@"];
                    }
                }
            }
            // list contains element nodes with non-unique names
            // return an array with mixed content notation
            var result = [];
            for (var i = 0; i < items.length; i++) {
                var item = items[i];
                var key = Object.keys(item)[0];
                switch (key) {
                    case "@":
                        // attributes were processed above
                        break;
                    case "#":
                        result.push((_a = {}, _a[defTextKey] = item["#"], _a));
                        break;
                    case "!":
                        result.push((_b = {}, _b[defCommentKey] = item["!"], _b));
                        break;
                    case "?":
                        result.push((_c = {}, _c[defInstructionKey] = item["?"], _c));
                        break;
                    case "$":
                        result.push((_d = {}, _d[defCdataKey] = item["$"], _d));
                        break;
                    default:
                        // element node
                        var ele = item;
                        if (ele[key].length !== 0 && util_1.isArray(ele[key][0])) {
                            // group of element nodes
                            var eleGroup = [];
                            var listOfLists = ele[key];
                            for (var i_1 = 0; i_1 < listOfLists.length; i_1++) {
                                eleGroup.push(this._process(listOfLists[i_1], options));
                            }
                            result.push((_e = {}, _e[key] = eleGroup, _e));
                        }
                        else {
                            // single element node
                            if (options.verbose) {
                                result.push((_f = {}, _f[key] = [this._process(ele[key], options)], _f));
                            }
                            else {
                                result.push((_g = {}, _g[key] = this._process(ele[key], options), _g));
                            }
                        }
                        break;
                }
            }
            obj[defTextKey] = result;
            return obj;
        }
        else {
            // all element nodes have unique names
            // return an object while prefixing data node keys
            var textId = 1;
            var commentId = 1;
            var instructionId = 1;
            var cdataId = 1;
            var obj = {};
            for (var i = 0; i < items.length; i++) {
                var item = items[i];
                var key = Object.keys(item)[0];
                switch (key) {
                    case "@":
                        var attrs = item["@"];
                        var attrKeys = Object.keys(attrs);
                        if (!options.group || attrKeys.length === 1) {
                            for (var attrName in attrs) {
                                obj[defAttrKey + attrName] = attrs[attrName];
                            }
                        }
                        else {
                            obj[defAttrKey] = attrs;
                        }
                        break;
                    case "#":
                        textId = this._processSpecItem(item["#"], obj, options.group, defTextKey, textCount, textId);
                        break;
                    case "!":
                        commentId = this._processSpecItem(item["!"], obj, options.group, defCommentKey, commentCount, commentId);
                        break;
                    case "?":
                        instructionId = this._processSpecItem(item["?"], obj, options.group, defInstructionKey, instructionCount, instructionId);
                        break;
                    case "$":
                        cdataId = this._processSpecItem(item["$"], obj, options.group, defCdataKey, cdataCount, cdataId);
                        break;
                    default:
                        // element node
                        var ele = item;
                        if (ele[key].length !== 0 && util_1.isArray(ele[key][0])) {
                            // group of element nodes
                            var eleGroup = [];
                            var listOfLists = ele[key];
                            for (var i_2 = 0; i_2 < listOfLists.length; i_2++) {
                                eleGroup.push(this._process(listOfLists[i_2], options));
                            }
                            obj[key] = eleGroup;
                        }
                        else {
                            // single element node
                            if (options.verbose) {
                                obj[key] = [this._process(ele[key], options)];
                            }
                            else {
                                obj[key] = this._process(ele[key], options);
                            }
                        }
                        break;
                }
            }
            return obj;
        }
    };
    ObjectWriter.prototype._processSpecItem = function (item, obj, group, defKey, count, id) {
        var e_1, _a;
        if (!group && util_1.isArray(item) && count + item.length > 2) {
            try {
                for (var item_1 = __values(item), item_1_1 = item_1.next(); !item_1_1.done; item_1_1 = item_1.next()) {
                    var subItem = item_1_1.value;
                    var key = defKey + (id++).toString();
                    obj[key] = subItem;
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (item_1_1 && !item_1_1.done && (_a = item_1.return)) _a.call(item_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
        }
        else {
            var key = count > 1 ? defKey + (id++).toString() : defKey;
            obj[key] = item;
        }
        return id;
    };
    /** @inheritdoc */
    ObjectWriter.prototype.beginElement = function (name) {
        var _a, _b;
        var childItems = [];
        if (this._currentList.length === 0) {
            this._currentList.push((_a = {}, _a[name] = childItems, _a));
        }
        else {
            var lastItem = this._currentList[this._currentList.length - 1];
            if (this._isElementNode(lastItem, name)) {
                if (lastItem[name].length !== 0 && util_1.isArray(lastItem[name][0])) {
                    var listOfLists = lastItem[name];
                    listOfLists.push(childItems);
                }
                else {
                    lastItem[name] = [lastItem[name], childItems];
                }
            }
            else {
                this._currentList.push((_b = {}, _b[name] = childItems, _b));
            }
        }
        this._currentIndex++;
        if (this._listRegister.length > this._currentIndex) {
            this._listRegister[this._currentIndex] = childItems;
        }
        else {
            this._listRegister.push(childItems);
        }
        this._currentList = childItems;
    };
    /** @inheritdoc */
    ObjectWriter.prototype.endElement = function () {
        this._currentList = this._listRegister[--this._currentIndex];
    };
    /** @inheritdoc */
    ObjectWriter.prototype.attribute = function (name, value) {
        var _a, _b;
        if (this._currentList.length === 0) {
            this._currentList.push({ "@": (_a = {}, _a[name] = value, _a) });
        }
        else {
            var lastItem = this._currentList[this._currentList.length - 1];
            /* istanbul ignore else */
            if (this._isAttrNode(lastItem)) {
                lastItem["@"][name] = value;
            }
            else {
                this._currentList.push({ "@": (_b = {}, _b[name] = value, _b) });
            }
        }
    };
    /** @inheritdoc */
    ObjectWriter.prototype.comment = function (data) {
        if (this._currentList.length === 0) {
            this._currentList.push({ "!": data });
        }
        else {
            var lastItem = this._currentList[this._currentList.length - 1];
            if (this._isCommentNode(lastItem)) {
                if (util_1.isArray(lastItem["!"])) {
                    lastItem["!"].push(data);
                }
                else {
                    lastItem["!"] = [lastItem["!"], data];
                }
            }
            else {
                this._currentList.push({ "!": data });
            }
        }
    };
    /** @inheritdoc */
    ObjectWriter.prototype.text = function (data) {
        if (this._currentList.length === 0) {
            this._currentList.push({ "#": data });
        }
        else {
            var lastItem = this._currentList[this._currentList.length - 1];
            if (this._isTextNode(lastItem)) {
                if (util_1.isArray(lastItem["#"])) {
                    lastItem["#"].push(data);
                }
                else {
                    lastItem["#"] = [lastItem["#"], data];
                }
            }
            else {
                this._currentList.push({ "#": data });
            }
        }
    };
    /** @inheritdoc */
    ObjectWriter.prototype.instruction = function (target, data) {
        var value = (data === "" ? target : target + " " + data);
        if (this._currentList.length === 0) {
            this._currentList.push({ "?": value });
        }
        else {
            var lastItem = this._currentList[this._currentList.length - 1];
            if (this._isInstructionNode(lastItem)) {
                if (util_1.isArray(lastItem["?"])) {
                    lastItem["?"].push(value);
                }
                else {
                    lastItem["?"] = [lastItem["?"], value];
                }
            }
            else {
                this._currentList.push({ "?": value });
            }
        }
    };
    /** @inheritdoc */
    ObjectWriter.prototype.cdata = function (data) {
        if (this._currentList.length === 0) {
            this._currentList.push({ "$": data });
        }
        else {
            var lastItem = this._currentList[this._currentList.length - 1];
            if (this._isCDATANode(lastItem)) {
                if (util_1.isArray(lastItem["$"])) {
                    lastItem["$"].push(data);
                }
                else {
                    lastItem["$"] = [lastItem["$"], data];
                }
            }
            else {
                this._currentList.push({ "$": data });
            }
        }
    };
    ObjectWriter.prototype._isAttrNode = function (x) {
        return "@" in x;
    };
    ObjectWriter.prototype._isTextNode = function (x) {
        return "#" in x;
    };
    ObjectWriter.prototype._isCommentNode = function (x) {
        return "!" in x;
    };
    ObjectWriter.prototype._isInstructionNode = function (x) {
        return "?" in x;
    };
    ObjectWriter.prototype._isCDATANode = function (x) {
        return "$" in x;
    };
    ObjectWriter.prototype._isElementNode = function (x, name) {
        return name in x;
    };
    /**
     * Returns an object key for an attribute or namespace declaration.
     */
    ObjectWriter.prototype._getAttrKey = function () {
        return this._builderOptions.convert.att;
    };
    /**
     * Returns an object key for the given node type.
     *
     * @param nodeType - node type to get a key for
     */
    ObjectWriter.prototype._getNodeKey = function (nodeType) {
        switch (nodeType) {
            case interfaces_1.NodeType.Comment:
                return this._builderOptions.convert.comment;
            case interfaces_1.NodeType.Text:
                return this._builderOptions.convert.text;
            case interfaces_1.NodeType.ProcessingInstruction:
                return this._builderOptions.convert.ins;
            case interfaces_1.NodeType.CData:
                return this._builderOptions.convert.cdata;
            /* istanbul ignore next */
            default:
                throw new Error("Invalid node type.");
        }
    };
    return ObjectWriter;
}(BaseWriter_1.BaseWriter));
exports.ObjectWriter = ObjectWriter;
//# sourceMappingURL=ObjectWriter.js.map

/***/ }),

/***/ 9982:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
var BaseCBWriter_1 = __nccwpck_require__(126);
/**
 * Serializes XML nodes.
 */
var XMLCBWriter = /** @class */ (function (_super) {
    __extends(XMLCBWriter, _super);
    /**
     * Initializes a new instance of `XMLCBWriter`.
     *
     * @param builderOptions - XML builder options
     */
    function XMLCBWriter(builderOptions) {
        var _this = _super.call(this, builderOptions) || this;
        _this._lineLength = 0;
        return _this;
    }
    /** @inheritdoc */
    XMLCBWriter.prototype.frontMatter = function () {
        return "";
    };
    /** @inheritdoc */
    XMLCBWriter.prototype.declaration = function (version, encoding, standalone) {
        var markup = this._beginLine() + "<?xml";
        markup += " version=\"" + version + "\"";
        if (encoding !== undefined) {
            markup += " encoding=\"" + encoding + "\"";
        }
        if (standalone !== undefined) {
            markup += " standalone=\"" + (standalone ? "yes" : "no") + "\"";
        }
        markup += "?>";
        return markup;
    };
    /** @inheritdoc */
    XMLCBWriter.prototype.docType = function (name, publicId, systemId) {
        var markup = this._beginLine();
        if (publicId && systemId) {
            markup += "<!DOCTYPE " + name + " PUBLIC \"" + publicId + "\" \"" + systemId + "\">";
        }
        else if (publicId) {
            markup += "<!DOCTYPE " + name + " PUBLIC \"" + publicId + "\">";
        }
        else if (systemId) {
            markup += "<!DOCTYPE " + name + " SYSTEM \"" + systemId + "\">";
        }
        else {
            markup += "<!DOCTYPE " + name + ">";
        }
        return markup;
    };
    /** @inheritdoc */
    XMLCBWriter.prototype.comment = function (data) {
        return this._beginLine() + "<!--" + data + "-->";
    };
    /** @inheritdoc */
    XMLCBWriter.prototype.text = function (data) {
        return this._beginLine() + data;
    };
    /** @inheritdoc */
    XMLCBWriter.prototype.instruction = function (target, data) {
        if (data) {
            return this._beginLine() + "<?" + target + " " + data + "?>";
        }
        else {
            return this._beginLine() + "<?" + target + "?>";
        }
    };
    /** @inheritdoc */
    XMLCBWriter.prototype.cdata = function (data) {
        return this._beginLine() + "<![CDATA[" + data + "]]>";
    };
    /** @inheritdoc */
    XMLCBWriter.prototype.openTagBegin = function (name) {
        this._lineLength += 1 + name.length;
        return this._beginLine() + "<" + name;
    };
    /** @inheritdoc */
    XMLCBWriter.prototype.openTagEnd = function (name, selfClosing, voidElement) {
        if (voidElement) {
            return " />";
        }
        else if (selfClosing) {
            if (this._writerOptions.allowEmptyTags) {
                return "></" + name + ">";
            }
            else if (this._writerOptions.spaceBeforeSlash) {
                return " />";
            }
            else {
                return "/>";
            }
        }
        else {
            return ">";
        }
    };
    /** @inheritdoc */
    XMLCBWriter.prototype.closeTag = function (name) {
        return this._beginLine() + "</" + name + ">";
    };
    /** @inheritdoc */
    XMLCBWriter.prototype.attribute = function (name, value) {
        var str = name + "=\"" + value + "\"";
        if (this._writerOptions.prettyPrint && this._writerOptions.width > 0 &&
            this._lineLength + 1 + str.length > this._writerOptions.width) {
            str = this._beginLine() + this._indent(1) + str;
            this._lineLength = str.length;
            return str;
        }
        else {
            this._lineLength += 1 + str.length;
            return " " + str;
        }
    };
    /** @inheritdoc */
    XMLCBWriter.prototype.beginElement = function (name) { };
    /** @inheritdoc */
    XMLCBWriter.prototype.endElement = function (name) { };
    /**
     * Produces characters to be prepended to a line of string in pretty-print
     * mode.
     */
    XMLCBWriter.prototype._beginLine = function () {
        if (this._writerOptions.prettyPrint) {
            var str = (this.hasData ? this._writerOptions.newline : "") +
                this._indent(this._writerOptions.offset + this.level);
            this._lineLength = str.length;
            return str;
        }
        else {
            return "";
        }
    };
    /**
     * Produces an indentation string.
     *
     * @param level - depth of the tree
     */
    XMLCBWriter.prototype._indent = function (level) {
        if (level <= 0) {
            return "";
        }
        else {
            return this._writerOptions.indent.repeat(level);
        }
    };
    return XMLCBWriter;
}(BaseCBWriter_1.BaseCBWriter));
exports.XMLCBWriter = XMLCBWriter;
//# sourceMappingURL=XMLCBWriter.js.map

/***/ }),

/***/ 687:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
var util_1 = __nccwpck_require__(7061);
var interfaces_1 = __nccwpck_require__(9454);
var BaseWriter_1 = __nccwpck_require__(9903);
var util_2 = __nccwpck_require__(628);
/**
 * Serializes XML nodes into strings.
 */
var XMLWriter = /** @class */ (function (_super) {
    __extends(XMLWriter, _super);
    /**
     * Initializes a new instance of `XMLWriter`.
     *
     * @param builderOptions - XML builder options
     * @param writerOptions - serialization options
     */
    function XMLWriter(builderOptions, writerOptions) {
        var _this = _super.call(this, builderOptions) || this;
        _this._indentation = {};
        _this._lengthToLastNewline = 0;
        // provide default options
        _this._writerOptions = util_1.applyDefaults(writerOptions, {
            wellFormed: false,
            headless: false,
            prettyPrint: false,
            indent: "  ",
            newline: "\n",
            offset: 0,
            width: 0,
            allowEmptyTags: false,
            indentTextOnlyNodes: false,
            spaceBeforeSlash: false
        });
        return _this;
    }
    /**
     * Produces an XML serialization of the given node.
     *
     * @param node - node to serialize
     */
    XMLWriter.prototype.serialize = function (node) {
        this._refs = { suppressPretty: false, emptyNode: false, markup: "" };
        // Serialize XML declaration
        if (node.nodeType === interfaces_1.NodeType.Document && !this._writerOptions.headless) {
            this.declaration(this._builderOptions.version, this._builderOptions.encoding, this._builderOptions.standalone);
        }
        // recursively serialize node
        this.serializeNode(node, this._writerOptions.wellFormed);
        // remove trailing newline
        if (this._writerOptions.prettyPrint &&
            this._refs.markup.slice(-this._writerOptions.newline.length) === this._writerOptions.newline) {
            this._refs.markup = this._refs.markup.slice(0, -this._writerOptions.newline.length);
        }
        return this._refs.markup;
    };
    /** @inheritdoc */
    XMLWriter.prototype.declaration = function (version, encoding, standalone) {
        this._beginLine();
        this._refs.markup += "<?xml version=\"" + version + "\"";
        if (encoding !== undefined) {
            this._refs.markup += " encoding=\"" + encoding + "\"";
        }
        if (standalone !== undefined) {
            this._refs.markup += " standalone=\"" + (standalone ? "yes" : "no") + "\"";
        }
        this._refs.markup += "?>";
        this._endLine();
    };
    /** @inheritdoc */
    XMLWriter.prototype.docType = function (name, publicId, systemId) {
        this._beginLine();
        if (publicId && systemId) {
            this._refs.markup += "<!DOCTYPE " + name + " PUBLIC \"" + publicId + "\" \"" + systemId + "\">";
        }
        else if (publicId) {
            this._refs.markup += "<!DOCTYPE " + name + " PUBLIC \"" + publicId + "\">";
        }
        else if (systemId) {
            this._refs.markup += "<!DOCTYPE " + name + " SYSTEM \"" + systemId + "\">";
        }
        else {
            this._refs.markup += "<!DOCTYPE " + name + ">";
        }
        this._endLine();
    };
    /** @inheritdoc */
    XMLWriter.prototype.openTagBegin = function (name) {
        this._beginLine();
        this._refs.markup += "<" + name;
    };
    /** @inheritdoc */
    XMLWriter.prototype.openTagEnd = function (name, selfClosing, voidElement) {
        // do not indent text only elements or elements with empty text nodes
        this._refs.suppressPretty = false;
        this._refs.emptyNode = false;
        if (this._writerOptions.prettyPrint && !selfClosing && !voidElement) {
            var textOnlyNode = true;
            var emptyNode = true;
            var childNode = this.currentNode.firstChild;
            var cdataCount = 0;
            var textCount = 0;
            while (childNode) {
                if (util_2.Guard.isExclusiveTextNode(childNode)) {
                    textCount++;
                }
                else if (util_2.Guard.isCDATASectionNode(childNode)) {
                    cdataCount++;
                }
                else {
                    textOnlyNode = false;
                    emptyNode = false;
                    break;
                }
                if (childNode.data !== '') {
                    emptyNode = false;
                }
                childNode = childNode.nextSibling;
            }
            this._refs.suppressPretty = !this._writerOptions.indentTextOnlyNodes && textOnlyNode && ((cdataCount <= 1 && textCount === 0) || cdataCount === 0);
            this._refs.emptyNode = emptyNode;
        }
        if ((voidElement || selfClosing || this._refs.emptyNode) && this._writerOptions.allowEmptyTags) {
            this._refs.markup += "></" + name + ">";
        }
        else {
            this._refs.markup += voidElement ? " />" :
                (selfClosing || this._refs.emptyNode) ? (this._writerOptions.spaceBeforeSlash ? " />" : "/>") : ">";
        }
        this._endLine();
    };
    /** @inheritdoc */
    XMLWriter.prototype.closeTag = function (name) {
        if (!this._refs.emptyNode) {
            this._beginLine();
            this._refs.markup += "</" + name + ">";
        }
        this._refs.suppressPretty = false;
        this._refs.emptyNode = false;
        this._endLine();
    };
    /** @inheritdoc */
    XMLWriter.prototype.attribute = function (name, value) {
        var str = name + "=\"" + value + "\"";
        if (this._writerOptions.prettyPrint && this._writerOptions.width > 0 &&
            this._refs.markup.length - this._lengthToLastNewline + 1 + str.length > this._writerOptions.width) {
            this._endLine();
            this._beginLine();
            this._refs.markup += this._indent(1) + str;
        }
        else {
            this._refs.markup += " " + str;
        }
    };
    /** @inheritdoc */
    XMLWriter.prototype.text = function (data) {
        if (data !== '') {
            this._beginLine();
            this._refs.markup += data;
            this._endLine();
        }
    };
    /** @inheritdoc */
    XMLWriter.prototype.cdata = function (data) {
        if (data !== '') {
            this._beginLine();
            this._refs.markup += "<![CDATA[" + data + "]]>";
            this._endLine();
        }
    };
    /** @inheritdoc */
    XMLWriter.prototype.comment = function (data) {
        this._beginLine();
        this._refs.markup += "<!--" + data + "-->";
        this._endLine();
    };
    /** @inheritdoc */
    XMLWriter.prototype.instruction = function (target, data) {
        this._beginLine();
        this._refs.markup += "<?" + (data === "" ? target : target + " " + data) + "?>";
        this._endLine();
    };
    /**
     * Produces characters to be prepended to a line of string in pretty-print
     * mode.
     */
    XMLWriter.prototype._beginLine = function () {
        if (this._writerOptions.prettyPrint && !this._refs.suppressPretty) {
            this._refs.markup += this._indent(this._writerOptions.offset + this.level);
        }
    };
    /**
     * Produces characters to be appended to a line of string in pretty-print
     * mode.
     */
    XMLWriter.prototype._endLine = function () {
        if (this._writerOptions.prettyPrint && !this._refs.suppressPretty) {
            this._refs.markup += this._writerOptions.newline;
            this._lengthToLastNewline = this._refs.markup.length;
        }
    };
    /**
     * Produces an indentation string.
     *
     * @param level - depth of the tree
     */
    XMLWriter.prototype._indent = function (level) {
        if (level <= 0) {
            return "";
        }
        else if (this._indentation[level] !== undefined) {
            return this._indentation[level];
        }
        else {
            var str = this._writerOptions.indent.repeat(level);
            this._indentation[level] = str;
            return str;
        }
    };
    return XMLWriter;
}(BaseWriter_1.BaseWriter));
exports.XMLWriter = XMLWriter;
//# sourceMappingURL=XMLWriter.js.map

/***/ }),

/***/ 3864:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
var BaseCBWriter_1 = __nccwpck_require__(126);
/**
 * Serializes XML nodes.
 */
var YAMLCBWriter = /** @class */ (function (_super) {
    __extends(YAMLCBWriter, _super);
    /**
     * Initializes a new instance of `BaseCBWriter`.
     *
     * @param builderOptions - XML builder options
     */
    function YAMLCBWriter(builderOptions) {
        var _this = _super.call(this, builderOptions) || this;
        _this._rootWritten = false;
        _this._additionalLevel = 0;
        if (builderOptions.indent.length < 2) {
            throw new Error("YAML indententation string must be at least two characters long.");
        }
        if (builderOptions.offset < 0) {
            throw new Error("YAML offset should be zero or a positive number.");
        }
        return _this;
    }
    /** @inheritdoc */
    YAMLCBWriter.prototype.frontMatter = function () {
        return this._beginLine() + "---";
    };
    /** @inheritdoc */
    YAMLCBWriter.prototype.declaration = function (version, encoding, standalone) {
        return "";
    };
    /** @inheritdoc */
    YAMLCBWriter.prototype.docType = function (name, publicId, systemId) {
        return "";
    };
    /** @inheritdoc */
    YAMLCBWriter.prototype.comment = function (data) {
        // "!": "hello"
        return this._beginLine() +
            this._key(this._builderOptions.convert.comment) + " " +
            this._val(data);
    };
    /** @inheritdoc */
    YAMLCBWriter.prototype.text = function (data) {
        // "#": "hello"
        return this._beginLine() +
            this._key(this._builderOptions.convert.text) + " " +
            this._val(data);
    };
    /** @inheritdoc */
    YAMLCBWriter.prototype.instruction = function (target, data) {
        // "?": "target hello"
        return this._beginLine() +
            this._key(this._builderOptions.convert.ins) + " " +
            this._val(data ? target + " " + data : target);
    };
    /** @inheritdoc */
    YAMLCBWriter.prototype.cdata = function (data) {
        // "$": "hello"
        return this._beginLine() +
            this._key(this._builderOptions.convert.cdata) + " " +
            this._val(data);
    };
    /** @inheritdoc */
    YAMLCBWriter.prototype.attribute = function (name, value) {
        // "@name": "val"
        this._additionalLevel++;
        var str = this._beginLine() +
            this._key(this._builderOptions.convert.att + name) + " " +
            this._val(value);
        this._additionalLevel--;
        return str;
    };
    /** @inheritdoc */
    YAMLCBWriter.prototype.openTagBegin = function (name) {
        // "node":
        //   "#":
        //   -
        var str = this._beginLine() + this._key(name);
        if (!this._rootWritten) {
            this._rootWritten = true;
        }
        this.hasData = true;
        this._additionalLevel++;
        str += this._beginLine(true) + this._key(this._builderOptions.convert.text);
        return str;
    };
    /** @inheritdoc */
    YAMLCBWriter.prototype.openTagEnd = function (name, selfClosing, voidElement) {
        if (selfClosing) {
            return " " + this._val("");
        }
        return "";
    };
    /** @inheritdoc */
    YAMLCBWriter.prototype.closeTag = function (name) {
        this._additionalLevel--;
        return "";
    };
    /** @inheritdoc */
    YAMLCBWriter.prototype.beginElement = function (name) { };
    /** @inheritdoc */
    YAMLCBWriter.prototype.endElement = function (name) { };
    /**
     * Produces characters to be prepended to a line of string in pretty-print
     * mode.
     */
    YAMLCBWriter.prototype._beginLine = function (suppressArray) {
        if (suppressArray === void 0) { suppressArray = false; }
        return (this.hasData ? this._writerOptions.newline : "") +
            this._indent(this._writerOptions.offset + this.level, suppressArray);
    };
    /**
     * Produces an indentation string.
     *
     * @param level - depth of the tree
     * @param suppressArray - whether the suppress array marker
     */
    YAMLCBWriter.prototype._indent = function (level, suppressArray) {
        if (level + this._additionalLevel <= 0) {
            return "";
        }
        else {
            var chars = this._writerOptions.indent.repeat(level + this._additionalLevel);
            if (!suppressArray && this._rootWritten) {
                return chars.substr(0, chars.length - 2) + '-' + chars.substr(-1, 1);
            }
            return chars;
        }
    };
    /**
     * Produces a YAML key string delimited with double quotes.
     */
    YAMLCBWriter.prototype._key = function (key) {
        return "\"" + key + "\":";
    };
    /**
     * Produces a YAML value string delimited with double quotes.
     */
    YAMLCBWriter.prototype._val = function (val) {
        return JSON.stringify(val);
    };
    return YAMLCBWriter;
}(BaseCBWriter_1.BaseCBWriter));
exports.YAMLCBWriter = YAMLCBWriter;
//# sourceMappingURL=YAMLCBWriter.js.map

/***/ }),

/***/ 2625:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var ObjectWriter_1 = __nccwpck_require__(9265);
var util_1 = __nccwpck_require__(7061);
var BaseWriter_1 = __nccwpck_require__(9903);
/**
 * Serializes XML nodes into a YAML string.
 */
var YAMLWriter = /** @class */ (function (_super) {
    __extends(YAMLWriter, _super);
    /**
     * Initializes a new instance of `YAMLWriter`.
     *
     * @param builderOptions - XML builder options
     * @param writerOptions - serialization options
     */
    function YAMLWriter(builderOptions, writerOptions) {
        var _this = _super.call(this, builderOptions) || this;
        // provide default options
        _this._writerOptions = util_1.applyDefaults(writerOptions, {
            wellFormed: false,
            indent: '  ',
            newline: '\n',
            offset: 0,
            group: false,
            verbose: false
        });
        if (_this._writerOptions.indent.length < 2) {
            throw new Error("YAML indententation string must be at least two characters long.");
        }
        if (_this._writerOptions.offset < 0) {
            throw new Error("YAML offset should be zero or a positive number.");
        }
        return _this;
    }
    /**
     * Produces an XML serialization of the given node.
     *
     * @param node - node to serialize
     * @param writerOptions - serialization options
     */
    YAMLWriter.prototype.serialize = function (node) {
        // convert to object
        var objectWriterOptions = util_1.applyDefaults(this._writerOptions, {
            format: "object",
            wellFormed: false
        });
        var objectWriter = new ObjectWriter_1.ObjectWriter(this._builderOptions, objectWriterOptions);
        var val = objectWriter.serialize(node);
        var markup = this._beginLine(this._writerOptions, 0) + '---' + this._endLine(this._writerOptions) +
            this._convertObject(val, this._writerOptions, 0);
        // remove trailing newline
        /* istanbul ignore else */
        if (markup.slice(-this._writerOptions.newline.length) === this._writerOptions.newline) {
            markup = markup.slice(0, -this._writerOptions.newline.length);
        }
        return markup;
    };
    /**
     * Produces an XML serialization of the given object.
     *
     * @param obj - object to serialize
     * @param options - serialization options
     * @param level - depth of the XML tree
     * @param indentLeaf - indents leaf nodes
     */
    YAMLWriter.prototype._convertObject = function (obj, options, level, suppressIndent) {
        var e_1, _a;
        var _this = this;
        if (suppressIndent === void 0) { suppressIndent = false; }
        var markup = '';
        if (util_1.isArray(obj)) {
            try {
                for (var obj_1 = __values(obj), obj_1_1 = obj_1.next(); !obj_1_1.done; obj_1_1 = obj_1.next()) {
                    var val = obj_1_1.value;
                    markup += this._beginLine(options, level, true);
                    if (!util_1.isObject(val)) {
                        markup += this._val(val) + this._endLine(options);
                    }
                    else if (util_1.isEmpty(val)) {
                        markup += '""' + this._endLine(options);
                    }
                    else {
                        markup += this._convertObject(val, options, level, true);
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (obj_1_1 && !obj_1_1.done && (_a = obj_1.return)) _a.call(obj_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
        }
        else /* if (isObject(obj)) */ {
            util_1.forEachObject(obj, function (key, val) {
                if (suppressIndent) {
                    markup += _this._key(key);
                    suppressIndent = false;
                }
                else {
                    markup += _this._beginLine(options, level) + _this._key(key);
                }
                if (!util_1.isObject(val)) {
                    markup += ' ' + _this._val(val) + _this._endLine(options);
                }
                else if (util_1.isEmpty(val)) {
                    markup += ' ""' + _this._endLine(options);
                }
                else {
                    markup += _this._endLine(options) +
                        _this._convertObject(val, options, level + 1);
                }
            }, this);
        }
        return markup;
    };
    /**
     * Produces characters to be prepended to a line of string in pretty-print
     * mode.
     *
     * @param options - serialization options
     * @param level - current depth of the XML tree
     * @param isArray - whether this line is an array item
     */
    YAMLWriter.prototype._beginLine = function (options, level, isArray) {
        if (isArray === void 0) { isArray = false; }
        var indentLevel = options.offset + level + 1;
        var chars = new Array(indentLevel).join(options.indent);
        if (isArray) {
            return chars.substr(0, chars.length - 2) + '-' + chars.substr(-1, 1);
        }
        else {
            return chars;
        }
    };
    /**
     * Produces characters to be appended to a line of string in pretty-print
     * mode.
     *
     * @param options - serialization options
     */
    YAMLWriter.prototype._endLine = function (options) {
        return options.newline;
    };
    /**
     * Produces a YAML key string delimited with double quotes.
     */
    YAMLWriter.prototype._key = function (key) {
        return "\"" + key + "\":";
    };
    /**
     * Produces a YAML value string delimited with double quotes.
     */
    YAMLWriter.prototype._val = function (val) {
        return JSON.stringify(val);
    };
    return YAMLWriter;
}(BaseWriter_1.BaseWriter));
exports.YAMLWriter = YAMLWriter;
//# sourceMappingURL=YAMLWriter.js.map

/***/ }),

/***/ 8017:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
var MapWriter_1 = __nccwpck_require__(7432);
exports.MapWriter = MapWriter_1.MapWriter;
var XMLWriter_1 = __nccwpck_require__(687);
exports.XMLWriter = XMLWriter_1.XMLWriter;
var ObjectWriter_1 = __nccwpck_require__(9265);
exports.ObjectWriter = ObjectWriter_1.ObjectWriter;
var JSONWriter_1 = __nccwpck_require__(9096);
exports.JSONWriter = JSONWriter_1.JSONWriter;
var YAMLWriter_1 = __nccwpck_require__(2625);
exports.YAMLWriter = YAMLWriter_1.YAMLWriter;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 98:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {


var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
    return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var fs_1 = __importDefault(__nccwpck_require__(9896));
var xmlbuilder2_1 = __nccwpck_require__(2998);
var dotenv_1 = __importDefault(__nccwpck_require__(8889));
var form_data_1 = __importDefault(__nccwpck_require__(6454));
var node_fetch_1 = __importDefault(__nccwpck_require__(1485));
/**
 * Load environment variables from a .env file.
 */
dotenv_1.default.config();
/**
 * The Strava client ID.
 * This can be found in the Strava API settings.
 */
var STRAVA_CLIENT_ID = process.env.STRAVA_CLIENT_ID;
/**
 * The Strava client secret.
 * This can be found in the Strava API settings.
 */
var STRAVA_CLIENT_SECRET = process.env.STRAVA_CLIENT_SECRET;
/**
 * The Strava refresh token.
 * You can get this by following the Strava API documentation: https://developers.strava.com/docs/getting-started/
 */
var STRAVA_REFRESH_TOKEN = process.env.STRAVA_REFRESH_TOKEN;
/**
 * The Strava token endpoint.
 */
var STRAVA_TOKEN_ENDPOINT = "https://www.strava.com/api/v3/oauth/token";
/**
 * The Strava upload endpoint.
 * Docs: https://developers.strava.com/docs/reference/#api-Uploads-createUpload
 */
var STRAVA_UPLOAD_ENDPOINT = "https://www.strava.com/api/v3/uploads";
/**
 * Gets a new access token from Strava, allowing us to make an API request.
 */
var getAccessToken = function () { return __awaiter(void 0, void 0, void 0, function () {
    var response, error_1;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                _a.trys.push([0, 2, , 3]);
                return [4 /*yield*/, (0, node_fetch_1.default)(STRAVA_TOKEN_ENDPOINT, {
                        method: "POST",
                        headers: {
                            "Content-Type": "application/json",
                        },
                        body: JSON.stringify({
                            grant_type: "refresh_token",
                            refresh_token: STRAVA_REFRESH_TOKEN,
                            client_id: STRAVA_CLIENT_ID,
                            client_secret: STRAVA_CLIENT_SECRET,
                        }),
                    })];
            case 1:
                response = _a.sent();
                if (!response.ok) {
                    throw new Error("Error fetching access token: ".concat(response.statusText));
                }
                return [2 /*return*/, response.json()];
            case 2:
                error_1 = _a.sent();
                console.error("Failed to get access token: ".concat(error_1, " \u274C"));
                throw error_1;
            case 3: return [2 /*return*/];
        }
    });
}); };
/**
 * Uploads a TCX file to Strava.
 * The TCX file contains all of the information about the workout
 * including graph data, heart rates, and more.
 */
function uploadTcxFile(accessToken, filePath, data) {
    return __awaiter(this, void 0, void 0, function () {
        var file, formData, response, errorBody, error_2;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    _a.trys.push([0, 4, , 5]);
                    file = fs_1.default.createReadStream(filePath);
                    console.log(file);
                    formData = new form_data_1.default();
                    formData.append("file", file);
                    formData.append("name", data.name);
                    formData.append("description", data.description);
                    formData.append("data_type", data.data_type);
                    console.log("FormData headers:");
                    console.log(formData.getHeaders());
                    return [4 /*yield*/, (0, node_fetch_1.default)(STRAVA_UPLOAD_ENDPOINT, {
                            method: "POST",
                            headers: {
                                Authorization: "Bearer ".concat(accessToken),
                            },
                            body: formData,
                        })];
                case 1:
                    response = _a.sent();
                    if (!!response.ok) return [3 /*break*/, 3];
                    return [4 /*yield*/, response.text()];
                case 2:
                    errorBody = _a.sent();
                    throw new Error("Error uploading TCX file: ".concat(response.statusText, " - ").concat(errorBody));
                case 3: return [2 /*return*/, response.json()];
                case 4:
                    error_2 = _a.sent();
                    console.error("Failed to upload TCX file: ".concat(error_2, " \u274C"));
                    throw error_2;
                case 5: return [2 /*return*/];
            }
        });
    });
}
/**
 * Saves the TCX file to the file system.
 */
function saveTcxFile(tcxData, filePath) {
    try {
        fs_1.default.writeFileSync(filePath, tcxData);
    }
    catch (error) {
        console.error("Failed to save TCX file: ".concat(error, " \u274C"));
        throw error;
    }
}
/**
 * Fetches the JSON data from the undocumented Lionheart API.
 */
function fetchJsonData() {
    return __awaiter(this, void 0, void 0, function () {
        var CLASS_DATE, STUDIO_CODE, USER_ID, LIONHEART_SERIAL_NUMBER, CLASS_TIME, url, response, data, error_3;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    CLASS_DATE = process.env.F45_CLASS_DATE;
                    STUDIO_CODE = process.env.F45_STUDIO_CODE;
                    USER_ID = process.env.F45_USER_ID;
                    LIONHEART_SERIAL_NUMBER = process.env.F45_LIONHEART_SERIAL_NUMBER;
                    CLASS_TIME = process.env.F45_CLASS_TIME;
                    if (CLASS_TIME) {
                        CLASS_TIME = CLASS_TIME.replace(":", "");
                    }
                    _a.label = 1;
                case 1:
                    _a.trys.push([1, 4, , 5]);
                    url = "https://api.lionheart.f45.com/v3/sessions/".concat(CLASS_DATE, "_").concat(CLASS_TIME, ":studio:").concat(STUDIO_CODE, ":serial:").concat(LIONHEART_SERIAL_NUMBER, "?user_id=").concat(USER_ID);
                    return [4 /*yield*/, (0, node_fetch_1.default)(url)];
                case 2:
                    response = _a.sent();
                    if (!response.ok) {
                        throw new Error("Error fetching data from Lionheart API: ".concat(response.statusText));
                    }
                    return [4 /*yield*/, response.json()];
                case 3:
                    data = (_a.sent());
                    return [2 /*return*/, data];
                case 4:
                    error_3 = _a.sent();
                    console.error("Failed to fetch data from Lionheart API: ".concat(error_3, " \u274C"));
                    return [2 /*return*/, null];
                case 5: return [2 /*return*/];
            }
        });
    });
}
/**
 * Reformats the fetched data as a TCX file.
 */
function generateTcx(res) {
    try {
        var _a = res.data, summary = _a.summary, graph = _a.graph;
        var startTime_1 = new Date(res.data.classInfo.timestamp * 1000);
        var root_1 = (0, xmlbuilder2_1.create)({ version: "1.0" })
            .ele("TrainingCenterDatabase", {
            xmlns: "http://www.garmin.com/xmlschemas/TrainingCenterDatabase/v2",
        })
            .ele("Activities")
            .ele("Activity", { Sport: "Other" })
            .ele("Id")
            .txt(startTime_1.toISOString())
            .up()
            .ele("Lap", { StartTime: startTime_1.toISOString() })
            .ele("TotalTimeSeconds")
            .txt((res.data.classInfo.durationInMinutes * 60).toString())
            .up()
            .ele("DistanceMeters")
            .txt("0")
            .up()
            .ele("Calories")
            .txt(summary.estimatedCalories.toString())
            .up()
            .ele("AverageHeartRateBpm")
            .ele("Value")
            .txt(summary.heartrate.average.toString())
            .up()
            .up()
            .ele("MaximumHeartRateBpm")
            .ele("Value")
            .txt(summary.heartrate.max.toString())
            .up()
            .up()
            .ele("Intensity")
            .txt("Active")
            .up()
            .ele("TriggerMethod")
            .txt("Manual")
            .up()
            .ele("Track");
        graph.timeSeries.forEach(function (entry) {
            if (entry.type === "recordedBpm") {
                var timePoint = new Date(startTime_1.getTime() + entry.minute * 60000);
                if (entry.bpm) {
                    root_1
                        .ele("Trackpoint")
                        .ele("Time")
                        .txt(timePoint.toISOString())
                        .up()
                        .ele("HeartRateBpm")
                        .ele("Value")
                        .txt(entry.bpm.max.toString())
                        .up()
                        .up();
                }
            }
        });
        return root_1.end({ prettyPrint: true });
    }
    catch (error) {
        console.error("Error generating TCX file: ".concat(error, " \u274C"));
        throw error;
    }
}
/**
 * Main function that orchestrates the entire process.
 */
function main() {
    return __awaiter(this, void 0, void 0, function () {
        var tokenResponse, res, tcxData, workoutName, workoutDescription, uploadData, uploadResponse;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, getAccessToken()];
                case 1:
                    tokenResponse = _a.sent();
                    console.log("Access Token: ".concat(tokenResponse.access_token));
                    return [4 /*yield*/, fetchJsonData()];
                case 2:
                    res = _a.sent();
                    console.log(res);
                    if (!res) return [3 /*break*/, 4];
                    tcxData = generateTcx(res);
                    workoutName = res.data.workout.name;
                    workoutDescription = "".concat(res.data.summary.points, " Points \uD83C\uDFC6");
                    saveTcxFile(tcxData, "workout.tcx");
                    uploadData = {
                        name: "".concat(res.data.studio.name, " - ").concat(workoutName),
                        description: workoutDescription,
                        data_type: "tcx",
                    };
                    return [4 /*yield*/, uploadTcxFile(tokenResponse.access_token, "workout.tcx", uploadData)];
                case 3:
                    uploadResponse = _a.sent();
                    console.log("Upload Response: ".concat(JSON.stringify(uploadResponse)));
                    console.log("Workout uploaded to Strava! 🦁");
                    return [3 /*break*/, 5];
                case 4:
                    console.error("No data fetched from Lionheart API. Please verify the details you provided and try again... 😔");
                    _a.label = 5;
                case 5: return [2 /*return*/];
            }
        });
    });
}
main().catch;


/***/ }),

/***/ 181:
/***/ ((module) => {

module.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)("buffer");

/***/ }),

/***/ 6982:
/***/ ((module) => {

module.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)("crypto");

/***/ }),

/***/ 4434:
/***/ ((module) => {

module.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)("events");

/***/ }),

/***/ 9896:
/***/ ((module) => {

module.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)("fs");

/***/ }),

/***/ 8611:
/***/ ((module) => {

module.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)("http");

/***/ }),

/***/ 5692:
/***/ ((module) => {

module.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)("https");

/***/ }),

/***/ 1708:
/***/ ((module) => {

module.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)("node:process");

/***/ }),

/***/ 5449:
/***/ ((module) => {

module.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)("node:stream/web");

/***/ }),

/***/ 857:
/***/ ((module) => {

module.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)("os");

/***/ }),

/***/ 6928:
/***/ ((module) => {

module.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)("path");

/***/ }),

/***/ 2203:
/***/ ((module) => {

module.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)("stream");

/***/ }),

/***/ 7016:
/***/ ((module) => {

module.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)("url");

/***/ }),

/***/ 9023:
/***/ ((module) => {

module.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)("util");

/***/ }),

/***/ 8167:
/***/ ((module) => {

module.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)("worker_threads");

/***/ }),

/***/ 1204:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __nccwpck_require__) => {

/* c8 ignore start */
// 64 KiB (same size chrome slice theirs blob into Uint8array's)
const POOL_SIZE = 65536

if (!globalThis.ReadableStream) {
  // `node:stream/web` got introduced in v16.5.0 as experimental
  // and it's preferred over the polyfilled version. So we also
  // suppress the warning that gets emitted by NodeJS for using it.
  try {
    const process = __nccwpck_require__(1708)
    const { emitWarning } = process
    try {
      process.emitWarning = () => {}
      Object.assign(globalThis, __nccwpck_require__(5449))
      process.emitWarning = emitWarning
    } catch (error) {
      process.emitWarning = emitWarning
      throw error
    }
  } catch (error) {
    // fallback to polyfill implementation
    Object.assign(globalThis, __nccwpck_require__(3585))
  }
}

try {
  // Don't use node: prefix for this, require+node: is not supported until node v14.14
  // Only `import()` can use prefix in 12.20 and later
  const { Blob } = __nccwpck_require__(181)
  if (Blob && !Blob.prototype.stream) {
    Blob.prototype.stream = function name (params) {
      let position = 0
      const blob = this

      return new ReadableStream({
        type: 'bytes',
        async pull (ctrl) {
          const chunk = blob.slice(position, Math.min(blob.size, position + POOL_SIZE))
          const buffer = await chunk.arrayBuffer()
          position += buffer.byteLength
          ctrl.enqueue(new Uint8Array(buffer))

          if (position === blob.size) {
            ctrl.close()
          }
        }
      })
    }
  }
} catch (error) {}
/* c8 ignore end */


/***/ }),

/***/ 4645:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __nccwpck_require__) => {

/* harmony export */ __nccwpck_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* unused harmony export File */
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __nccwpck_require__(6327);


const _File = class File extends _index_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A {
  #lastModified = 0
  #name = ''

  /**
   * @param {*[]} fileBits
   * @param {string} fileName
   * @param {{lastModified?: number, type?: string}} options
   */// @ts-ignore
  constructor (fileBits, fileName, options = {}) {
    if (arguments.length < 2) {
      throw new TypeError(`Failed to construct 'File': 2 arguments required, but only ${arguments.length} present.`)
    }
    super(fileBits, options)

    if (options === null) options = {}

    // Simulate WebIDL type casting for NaN value in lastModified option.
    const lastModified = options.lastModified === undefined ? Date.now() : Number(options.lastModified)
    if (!Number.isNaN(lastModified)) {
      this.#lastModified = lastModified
    }

    this.#name = String(fileName)
  }

  get name () {
    return this.#name
  }

  get lastModified () {
    return this.#lastModified
  }

  get [Symbol.toStringTag] () {
    return 'File'
  }

  static [Symbol.hasInstance] (object) {
    return !!object && object instanceof _index_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A &&
      /^(File)$/.test(object[Symbol.toStringTag])
  }
}

/** @type {typeof globalThis.File} */// @ts-ignore
const File = _File
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (File);


/***/ }),

/***/ 9802:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __nccwpck_require__) => {


// EXPORTS
__nccwpck_require__.d(__webpack_exports__, {
  YQ: () => (/* reexport */ fetch_blob/* default */.A),
  ZH: () => (/* reexport */ file/* default */.A),
  k4: () => (/* binding */ blobFrom),
  F8: () => (/* binding */ blobFromSync),
  NX: () => (/* binding */ fileFrom),
  _M: () => (/* binding */ fileFromSync)
});

// UNUSED EXPORTS: default

;// CONCATENATED MODULE: external "node:fs"
const external_node_fs_namespaceObject = __WEBPACK_EXTERNAL_createRequire(import.meta.url)("node:fs");
;// CONCATENATED MODULE: external "node:path"
const external_node_path_namespaceObject = __WEBPACK_EXTERNAL_createRequire(import.meta.url)("node:path");
// EXTERNAL MODULE: ./node_modules/node-domexception/index.js
var node_domexception = __nccwpck_require__(7666);
// EXTERNAL MODULE: ./node_modules/fetch-blob/file.js
var file = __nccwpck_require__(4645);
// EXTERNAL MODULE: ./node_modules/fetch-blob/index.js
var fetch_blob = __nccwpck_require__(6327);
;// CONCATENATED MODULE: ./node_modules/fetch-blob/from.js







const { stat } = external_node_fs_namespaceObject.promises

/**
 * @param {string} path filepath on the disk
 * @param {string} [type] mimetype to use
 */
const blobFromSync = (path, type) => fromBlob((0,external_node_fs_namespaceObject.statSync)(path), path, type)

/**
 * @param {string} path filepath on the disk
 * @param {string} [type] mimetype to use
 * @returns {Promise<Blob>}
 */
const blobFrom = (path, type) => stat(path).then(stat => fromBlob(stat, path, type))

/**
 * @param {string} path filepath on the disk
 * @param {string} [type] mimetype to use
 * @returns {Promise<File>}
 */
const fileFrom = (path, type) => stat(path).then(stat => fromFile(stat, path, type))

/**
 * @param {string} path filepath on the disk
 * @param {string} [type] mimetype to use
 */
const fileFromSync = (path, type) => fromFile((0,external_node_fs_namespaceObject.statSync)(path), path, type)

// @ts-ignore
const fromBlob = (stat, path, type = '') => new fetch_blob/* default */.A([new BlobDataItem({
  path,
  size: stat.size,
  lastModified: stat.mtimeMs,
  start: 0
})], { type })

// @ts-ignore
const fromFile = (stat, path, type = '') => new file/* default */.A([new BlobDataItem({
  path,
  size: stat.size,
  lastModified: stat.mtimeMs,
  start: 0
})], (0,external_node_path_namespaceObject.basename)(path), { type, lastModified: stat.mtimeMs })

/**
 * This is a blob backed up by a file on the disk
 * with minium requirement. Its wrapped around a Blob as a blobPart
 * so you have no direct access to this.
 *
 * @private
 */
class BlobDataItem {
  #path
  #start

  constructor (options) {
    this.#path = options.path
    this.#start = options.start
    this.size = options.size
    this.lastModified = options.lastModified
  }

  /**
   * Slicing arguments is first validated and formatted
   * to not be out of range by Blob.prototype.slice
   */
  slice (start, end) {
    return new BlobDataItem({
      path: this.#path,
      lastModified: this.lastModified,
      size: end - start,
      start: this.#start + start
    })
  }

  async * stream () {
    const { mtimeMs } = await stat(this.#path)
    if (mtimeMs > this.lastModified) {
      throw new node_domexception('The requested file could not be read, typically due to permission problems that have occurred after a reference to a file was acquired.', 'NotReadableError')
    }
    yield * (0,external_node_fs_namespaceObject.createReadStream)(this.#path, {
      start: this.#start,
      end: this.#start + this.size - 1
    })
  }

  get [Symbol.toStringTag] () {
    return 'Blob'
  }
}

/* harmony default export */ const from = ((/* unused pure expression or super */ null && (blobFromSync)));



/***/ }),

/***/ 6327:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __nccwpck_require__) => {

/* harmony export */ __nccwpck_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* unused harmony export Blob */
/* harmony import */ var _streams_cjs__WEBPACK_IMPORTED_MODULE_0__ = __nccwpck_require__(1204);
/*! fetch-blob. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> */

// TODO (jimmywarting): in the feature use conditional loading with top level await (requires 14.x)
// Node has recently added whatwg stream into core



// 64 KiB (same size chrome slice theirs blob into Uint8array's)
const POOL_SIZE = 65536

/** @param {(Blob | Uint8Array)[]} parts */
async function * toIterator (parts, clone = true) {
  for (const part of parts) {
    if ('stream' in part) {
      yield * (/** @type {AsyncIterableIterator<Uint8Array>} */ (part.stream()))
    } else if (ArrayBuffer.isView(part)) {
      if (clone) {
        let position = part.byteOffset
        const end = part.byteOffset + part.byteLength
        while (position !== end) {
          const size = Math.min(end - position, POOL_SIZE)
          const chunk = part.buffer.slice(position, position + size)
          position += chunk.byteLength
          yield new Uint8Array(chunk)
        }
      } else {
        yield part
      }
    /* c8 ignore next 10 */
    } else {
      // For blobs that have arrayBuffer but no stream method (nodes buffer.Blob)
      let position = 0, b = (/** @type {Blob} */ (part))
      while (position !== b.size) {
        const chunk = b.slice(position, Math.min(b.size, position + POOL_SIZE))
        const buffer = await chunk.arrayBuffer()
        position += buffer.byteLength
        yield new Uint8Array(buffer)
      }
    }
  }
}

const _Blob = class Blob {
  /** @type {Array.<(Blob|Uint8Array)>} */
  #parts = []
  #type = ''
  #size = 0
  #endings = 'transparent'

  /**
   * The Blob() constructor returns a new Blob object. The content
   * of the blob consists of the concatenation of the values given
   * in the parameter array.
   *
   * @param {*} blobParts
   * @param {{ type?: string, endings?: string }} [options]
   */
  constructor (blobParts = [], options = {}) {
    if (typeof blobParts !== 'object' || blobParts === null) {
      throw new TypeError('Failed to construct \'Blob\': The provided value cannot be converted to a sequence.')
    }

    if (typeof blobParts[Symbol.iterator] !== 'function') {
      throw new TypeError('Failed to construct \'Blob\': The object must have a callable @@iterator property.')
    }

    if (typeof options !== 'object' && typeof options !== 'function') {
      throw new TypeError('Failed to construct \'Blob\': parameter 2 cannot convert to dictionary.')
    }

    if (options === null) options = {}

    const encoder = new TextEncoder()
    for (const element of blobParts) {
      let part
      if (ArrayBuffer.isView(element)) {
        part = new Uint8Array(element.buffer.slice(element.byteOffset, element.byteOffset + element.byteLength))
      } else if (element instanceof ArrayBuffer) {
        part = new Uint8Array(element.slice(0))
      } else if (element instanceof Blob) {
        part = element
      } else {
        part = encoder.encode(`${element}`)
      }

      this.#size += ArrayBuffer.isView(part) ? part.byteLength : part.size
      this.#parts.push(part)
    }

    this.#endings = `${options.endings === undefined ? 'transparent' : options.endings}`
    const type = options.type === undefined ? '' : String(options.type)
    this.#type = /^[\x20-\x7E]*$/.test(type) ? type : ''
  }

  /**
   * The Blob interface's size property returns the
   * size of the Blob in bytes.
   */
  get size () {
    return this.#size
  }

  /**
   * The type property of a Blob object returns the MIME type of the file.
   */
  get type () {
    return this.#type
  }

  /**
   * The text() method in the Blob interface returns a Promise
   * that resolves with a string containing the contents of
   * the blob, interpreted as UTF-8.
   *
   * @return {Promise<string>}
   */
  async text () {
    // More optimized than using this.arrayBuffer()
    // that requires twice as much ram
    const decoder = new TextDecoder()
    let str = ''
    for await (const part of toIterator(this.#parts, false)) {
      str += decoder.decode(part, { stream: true })
    }
    // Remaining
    str += decoder.decode()
    return str
  }

  /**
   * The arrayBuffer() method in the Blob interface returns a
   * Promise that resolves with the contents of the blob as
   * binary data contained in an ArrayBuffer.
   *
   * @return {Promise<ArrayBuffer>}
   */
  async arrayBuffer () {
    // Easier way... Just a unnecessary overhead
    // const view = new Uint8Array(this.size);
    // await this.stream().getReader({mode: 'byob'}).read(view);
    // return view.buffer;

    const data = new Uint8Array(this.size)
    let offset = 0
    for await (const chunk of toIterator(this.#parts, false)) {
      data.set(chunk, offset)
      offset += chunk.length
    }

    return data.buffer
  }

  stream () {
    const it = toIterator(this.#parts, true)

    return new globalThis.ReadableStream({
      // @ts-ignore
      type: 'bytes',
      async pull (ctrl) {
        const chunk = await it.next()
        chunk.done ? ctrl.close() : ctrl.enqueue(chunk.value)
      },

      async cancel () {
        await it.return()
      }
    })
  }

  /**
   * The Blob interface's slice() method creates and returns a
   * new Blob object which contains data from a subset of the
   * blob on which it's called.
   *
   * @param {number} [start]
   * @param {number} [end]
   * @param {string} [type]
   */
  slice (start = 0, end = this.size, type = '') {
    const { size } = this

    let relativeStart = start < 0 ? Math.max(size + start, 0) : Math.min(start, size)
    let relativeEnd = end < 0 ? Math.max(size + end, 0) : Math.min(end, size)

    const span = Math.max(relativeEnd - relativeStart, 0)
    const parts = this.#parts
    const blobParts = []
    let added = 0

    for (const part of parts) {
      // don't add the overflow to new blobParts
      if (added >= span) {
        break
      }

      const size = ArrayBuffer.isView(part) ? part.byteLength : part.size
      if (relativeStart && size <= relativeStart) {
        // Skip the beginning and change the relative
        // start & end position as we skip the unwanted parts
        relativeStart -= size
        relativeEnd -= size
      } else {
        let chunk
        if (ArrayBuffer.isView(part)) {
          chunk = part.subarray(relativeStart, Math.min(size, relativeEnd))
          added += chunk.byteLength
        } else {
          chunk = part.slice(relativeStart, Math.min(size, relativeEnd))
          added += chunk.size
        }
        relativeEnd -= size
        blobParts.push(chunk)
        relativeStart = 0 // All next sequential parts should start at 0
      }
    }

    const blob = new Blob([], { type: String(type).toLowerCase() })
    blob.#size = span
    blob.#parts = blobParts

    return blob
  }

  get [Symbol.toStringTag] () {
    return 'Blob'
  }

  static [Symbol.hasInstance] (object) {
    return (
      object &&
      typeof object === 'object' &&
      typeof object.constructor === 'function' &&
      (
        typeof object.stream === 'function' ||
        typeof object.arrayBuffer === 'function'
      ) &&
      /^(Blob|File)$/.test(object[Symbol.toStringTag])
    )
  }
}

Object.defineProperties(_Blob.prototype, {
  size: { enumerable: true },
  type: { enumerable: true },
  slice: { enumerable: true }
})

/** @type {typeof globalThis.Blob} */
const Blob = _Blob
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Blob);


/***/ }),

/***/ 3018:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __nccwpck_require__) => {

/* harmony export */ __nccwpck_require__.d(__webpack_exports__, {
/* harmony export */   $n: () => (/* binding */ formDataToBlob),
/* harmony export */   fS: () => (/* binding */ FormData)
/* harmony export */ });
/* unused harmony export File */
/* harmony import */ var fetch_blob__WEBPACK_IMPORTED_MODULE_0__ = __nccwpck_require__(6327);
/* harmony import */ var fetch_blob_file_js__WEBPACK_IMPORTED_MODULE_1__ = __nccwpck_require__(4645);
/*! formdata-polyfill. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> */




var {toStringTag:t,iterator:i,hasInstance:h}=Symbol,
r=Math.random,
m='append,set,get,getAll,delete,keys,values,entries,forEach,constructor'.split(','),
f=(a,b,c)=>(a+='',/^(Blob|File)$/.test(b && b[t])?[(c=c!==void 0?c+'':b[t]=='File'?b.name:'blob',a),b.name!==c||b[t]=='blob'?new fetch_blob_file_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A([b],c,b):b]:[a,b+'']),
e=(c,f)=>(f?c:c.replace(/\r?\n|\r/g,'\r\n')).replace(/\n/g,'%0A').replace(/\r/g,'%0D').replace(/"/g,'%22'),
x=(n, a, e)=>{if(a.length<e){throw new TypeError(`Failed to execute '${n}' on 'FormData': ${e} arguments required, but only ${a.length} present.`)}}

const File = (/* unused pure expression or super */ null && (F))

/** @type {typeof globalThis.FormData} */
const FormData = class FormData {
#d=[];
constructor(...a){if(a.length)throw new TypeError(`Failed to construct 'FormData': parameter 1 is not of type 'HTMLFormElement'.`)}
get [t]() {return 'FormData'}
[i](){return this.entries()}
static [h](o) {return o&&typeof o==='object'&&o[t]==='FormData'&&!m.some(m=>typeof o[m]!='function')}
append(...a){x('append',arguments,2);this.#d.push(f(...a))}
delete(a){x('delete',arguments,1);a+='';this.#d=this.#d.filter(([b])=>b!==a)}
get(a){x('get',arguments,1);a+='';for(var b=this.#d,l=b.length,c=0;c<l;c++)if(b[c][0]===a)return b[c][1];return null}
getAll(a,b){x('getAll',arguments,1);b=[];a+='';this.#d.forEach(c=>c[0]===a&&b.push(c[1]));return b}
has(a){x('has',arguments,1);a+='';return this.#d.some(b=>b[0]===a)}
forEach(a,b){x('forEach',arguments,1);for(var [c,d]of this)a.call(b,d,c,this)}
set(...a){x('set',arguments,2);var b=[],c=!0;a=f(...a);this.#d.forEach(d=>{d[0]===a[0]?c&&(c=!b.push(a)):b.push(d)});c&&b.push(a);this.#d=b}
*entries(){yield*this.#d}
*keys(){for(var[a]of this)yield a}
*values(){for(var[,a]of this)yield a}}

/** @param {FormData} F */
function formDataToBlob (F,B=fetch_blob__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A){
var b=`${r()}${r()}`.replace(/\./g, '').slice(-28).padStart(32, '-'),c=[],p=`--${b}\r\nContent-Disposition: form-data; name="`
F.forEach((v,n)=>typeof v=='string'
?c.push(p+e(n)+`"\r\n\r\n${v.replace(/\r(?!\n)|(?<!\r)\n/g, '\r\n')}\r\n`)
:c.push(p+e(n)+`"; filename="${e(v.name, 1)}"\r\nContent-Type: ${v.type||"application/octet-stream"}\r\n\r\n`, v, '\r\n'))
c.push(`--${b}--`)
return new B(c,{type:"multipart/form-data; boundary="+b})}


/***/ }),

/***/ 1485:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __nccwpck_require__) => {

// ESM COMPAT FLAG
__nccwpck_require__.r(__webpack_exports__);

// EXPORTS
__nccwpck_require__.d(__webpack_exports__, {
  AbortError: () => (/* reexport */ AbortError),
  Blob: () => (/* reexport */ from/* Blob */.YQ),
  FetchError: () => (/* reexport */ FetchError),
  File: () => (/* reexport */ from/* File */.ZH),
  FormData: () => (/* reexport */ esm_min/* FormData */.fS),
  Headers: () => (/* reexport */ Headers),
  Request: () => (/* reexport */ Request),
  Response: () => (/* reexport */ Response),
  blobFrom: () => (/* reexport */ from/* blobFrom */.k4),
  blobFromSync: () => (/* reexport */ from/* blobFromSync */.F8),
  "default": () => (/* binding */ fetch),
  fileFrom: () => (/* reexport */ from/* fileFrom */.NX),
  fileFromSync: () => (/* reexport */ from/* fileFromSync */._M),
  isRedirect: () => (/* reexport */ isRedirect)
});

;// CONCATENATED MODULE: external "node:http"
const external_node_http_namespaceObject = __WEBPACK_EXTERNAL_createRequire(import.meta.url)("node:http");
;// CONCATENATED MODULE: external "node:https"
const external_node_https_namespaceObject = __WEBPACK_EXTERNAL_createRequire(import.meta.url)("node:https");
;// CONCATENATED MODULE: external "node:zlib"
const external_node_zlib_namespaceObject = __WEBPACK_EXTERNAL_createRequire(import.meta.url)("node:zlib");
;// CONCATENATED MODULE: external "node:stream"
const external_node_stream_namespaceObject = __WEBPACK_EXTERNAL_createRequire(import.meta.url)("node:stream");
;// CONCATENATED MODULE: external "node:buffer"
const external_node_buffer_namespaceObject = __WEBPACK_EXTERNAL_createRequire(import.meta.url)("node:buffer");
;// CONCATENATED MODULE: ./node_modules/data-uri-to-buffer/dist/index.js
/**
 * Returns a `Buffer` instance from the given data URI `uri`.
 *
 * @param {String} uri Data URI to turn into a Buffer instance
 * @returns {Buffer} Buffer instance from Data URI
 * @api public
 */
function dataUriToBuffer(uri) {
    if (!/^data:/i.test(uri)) {
        throw new TypeError('`uri` does not appear to be a Data URI (must begin with "data:")');
    }
    // strip newlines
    uri = uri.replace(/\r?\n/g, '');
    // split the URI up into the "metadata" and the "data" portions
    const firstComma = uri.indexOf(',');
    if (firstComma === -1 || firstComma <= 4) {
        throw new TypeError('malformed data: URI');
    }
    // remove the "data:" scheme and parse the metadata
    const meta = uri.substring(5, firstComma).split(';');
    let charset = '';
    let base64 = false;
    const type = meta[0] || 'text/plain';
    let typeFull = type;
    for (let i = 1; i < meta.length; i++) {
        if (meta[i] === 'base64') {
            base64 = true;
        }
        else if (meta[i]) {
            typeFull += `;${meta[i]}`;
            if (meta[i].indexOf('charset=') === 0) {
                charset = meta[i].substring(8);
            }
        }
    }
    // defaults to US-ASCII only if type is not provided
    if (!meta[0] && !charset.length) {
        typeFull += ';charset=US-ASCII';
        charset = 'US-ASCII';
    }
    // get the encoded data portion and decode URI-encoded chars
    const encoding = base64 ? 'base64' : 'ascii';
    const data = unescape(uri.substring(firstComma + 1));
    const buffer = Buffer.from(data, encoding);
    // set `.type` and `.typeFull` properties to MIME type
    buffer.type = type;
    buffer.typeFull = typeFull;
    // set the `.charset` property
    buffer.charset = charset;
    return buffer;
}
/* harmony default export */ const dist = (dataUriToBuffer);
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: external "node:util"
const external_node_util_namespaceObject = __WEBPACK_EXTERNAL_createRequire(import.meta.url)("node:util");
// EXTERNAL MODULE: ./node_modules/fetch-blob/index.js
var fetch_blob = __nccwpck_require__(6327);
// EXTERNAL MODULE: ./node_modules/formdata-polyfill/esm.min.js
var esm_min = __nccwpck_require__(3018);
;// CONCATENATED MODULE: ./node_modules/node-fetch/src/errors/base.js
class FetchBaseError extends Error {
	constructor(message, type) {
		super(message);
		// Hide custom error implementation details from end-users
		Error.captureStackTrace(this, this.constructor);

		this.type = type;
	}

	get name() {
		return this.constructor.name;
	}

	get [Symbol.toStringTag]() {
		return this.constructor.name;
	}
}

;// CONCATENATED MODULE: ./node_modules/node-fetch/src/errors/fetch-error.js



/**
 * @typedef {{ address?: string, code: string, dest?: string, errno: number, info?: object, message: string, path?: string, port?: number, syscall: string}} SystemError
*/

/**
 * FetchError interface for operational errors
 */
class FetchError extends FetchBaseError {
	/**
	 * @param  {string} message -      Error message for human
	 * @param  {string} [type] -        Error type for machine
	 * @param  {SystemError} [systemError] - For Node.js system error
	 */
	constructor(message, type, systemError) {
		super(message, type);
		// When err.type is `system`, err.erroredSysCall contains system error and err.code contains system error code
		if (systemError) {
			// eslint-disable-next-line no-multi-assign
			this.code = this.errno = systemError.code;
			this.erroredSysCall = systemError.syscall;
		}
	}
}

;// CONCATENATED MODULE: ./node_modules/node-fetch/src/utils/is.js
/**
 * Is.js
 *
 * Object type checks.
 */

const NAME = Symbol.toStringTag;

/**
 * Check if `obj` is a URLSearchParams object
 * ref: https://github.com/node-fetch/node-fetch/issues/296#issuecomment-307598143
 * @param {*} object - Object to check for
 * @return {boolean}
 */
const isURLSearchParameters = object => {
	return (
		typeof object === 'object' &&
		typeof object.append === 'function' &&
		typeof object.delete === 'function' &&
		typeof object.get === 'function' &&
		typeof object.getAll === 'function' &&
		typeof object.has === 'function' &&
		typeof object.set === 'function' &&
		typeof object.sort === 'function' &&
		object[NAME] === 'URLSearchParams'
	);
};

/**
 * Check if `object` is a W3C `Blob` object (which `File` inherits from)
 * @param {*} object - Object to check for
 * @return {boolean}
 */
const isBlob = object => {
	return (
		object &&
		typeof object === 'object' &&
		typeof object.arrayBuffer === 'function' &&
		typeof object.type === 'string' &&
		typeof object.stream === 'function' &&
		typeof object.constructor === 'function' &&
		/^(Blob|File)$/.test(object[NAME])
	);
};

/**
 * Check if `obj` is an instance of AbortSignal.
 * @param {*} object - Object to check for
 * @return {boolean}
 */
const isAbortSignal = object => {
	return (
		typeof object === 'object' && (
			object[NAME] === 'AbortSignal' ||
			object[NAME] === 'EventTarget'
		)
	);
};

/**
 * isDomainOrSubdomain reports whether sub is a subdomain (or exact match) of
 * the parent domain.
 *
 * Both domains must already be in canonical form.
 * @param {string|URL} original
 * @param {string|URL} destination
 */
const isDomainOrSubdomain = (destination, original) => {
	const orig = new URL(original).hostname;
	const dest = new URL(destination).hostname;

	return orig === dest || orig.endsWith(`.${dest}`);
};

/**
 * isSameProtocol reports whether the two provided URLs use the same protocol.
 *
 * Both domains must already be in canonical form.
 * @param {string|URL} original
 * @param {string|URL} destination
 */
const isSameProtocol = (destination, original) => {
	const orig = new URL(original).protocol;
	const dest = new URL(destination).protocol;

	return orig === dest;
};

;// CONCATENATED MODULE: ./node_modules/node-fetch/src/body.js

/**
 * Body.js
 *
 * Body interface provides common methods for Request and Response
 */












const pipeline = (0,external_node_util_namespaceObject.promisify)(external_node_stream_namespaceObject.pipeline);
const INTERNALS = Symbol('Body internals');

/**
 * Body mixin
 *
 * Ref: https://fetch.spec.whatwg.org/#body
 *
 * @param   Stream  body  Readable stream
 * @param   Object  opts  Response options
 * @return  Void
 */
class Body {
	constructor(body, {
		size = 0
	} = {}) {
		let boundary = null;

		if (body === null) {
			// Body is undefined or null
			body = null;
		} else if (isURLSearchParameters(body)) {
			// Body is a URLSearchParams
			body = external_node_buffer_namespaceObject.Buffer.from(body.toString());
		} else if (isBlob(body)) {
			// Body is blob
		} else if (external_node_buffer_namespaceObject.Buffer.isBuffer(body)) {
			// Body is Buffer
		} else if (external_node_util_namespaceObject.types.isAnyArrayBuffer(body)) {
			// Body is ArrayBuffer
			body = external_node_buffer_namespaceObject.Buffer.from(body);
		} else if (ArrayBuffer.isView(body)) {
			// Body is ArrayBufferView
			body = external_node_buffer_namespaceObject.Buffer.from(body.buffer, body.byteOffset, body.byteLength);
		} else if (body instanceof external_node_stream_namespaceObject) {
			// Body is stream
		} else if (body instanceof esm_min/* FormData */.fS) {
			// Body is FormData
			body = (0,esm_min/* formDataToBlob */.$n)(body);
			boundary = body.type.split('=')[1];
		} else {
			// None of the above
			// coerce to string then buffer
			body = external_node_buffer_namespaceObject.Buffer.from(String(body));
		}

		let stream = body;

		if (external_node_buffer_namespaceObject.Buffer.isBuffer(body)) {
			stream = external_node_stream_namespaceObject.Readable.from(body);
		} else if (isBlob(body)) {
			stream = external_node_stream_namespaceObject.Readable.from(body.stream());
		}

		this[INTERNALS] = {
			body,
			stream,
			boundary,
			disturbed: false,
			error: null
		};
		this.size = size;

		if (body instanceof external_node_stream_namespaceObject) {
			body.on('error', error_ => {
				const error = error_ instanceof FetchBaseError ?
					error_ :
					new FetchError(`Invalid response body while trying to fetch ${this.url}: ${error_.message}`, 'system', error_);
				this[INTERNALS].error = error;
			});
		}
	}

	get body() {
		return this[INTERNALS].stream;
	}

	get bodyUsed() {
		return this[INTERNALS].disturbed;
	}

	/**
	 * Decode response as ArrayBuffer
	 *
	 * @return  Promise
	 */
	async arrayBuffer() {
		const {buffer, byteOffset, byteLength} = await consumeBody(this);
		return buffer.slice(byteOffset, byteOffset + byteLength);
	}

	async formData() {
		const ct = this.headers.get('content-type');

		if (ct.startsWith('application/x-www-form-urlencoded')) {
			const formData = new esm_min/* FormData */.fS();
			const parameters = new URLSearchParams(await this.text());

			for (const [name, value] of parameters) {
				formData.append(name, value);
			}

			return formData;
		}

		const {toFormData} = await __nccwpck_require__.e(/* import() */ 101).then(__nccwpck_require__.bind(__nccwpck_require__, 9101));
		return toFormData(this.body, ct);
	}

	/**
	 * Return raw response as Blob
	 *
	 * @return Promise
	 */
	async blob() {
		const ct = (this.headers && this.headers.get('content-type')) || (this[INTERNALS].body && this[INTERNALS].body.type) || '';
		const buf = await this.arrayBuffer();

		return new fetch_blob/* default */.A([buf], {
			type: ct
		});
	}

	/**
	 * Decode response as json
	 *
	 * @return  Promise
	 */
	async json() {
		const text = await this.text();
		return JSON.parse(text);
	}

	/**
	 * Decode response as text
	 *
	 * @return  Promise
	 */
	async text() {
		const buffer = await consumeBody(this);
		return new TextDecoder().decode(buffer);
	}

	/**
	 * Decode response as buffer (non-spec api)
	 *
	 * @return  Promise
	 */
	buffer() {
		return consumeBody(this);
	}
}

Body.prototype.buffer = (0,external_node_util_namespaceObject.deprecate)(Body.prototype.buffer, 'Please use \'response.arrayBuffer()\' instead of \'response.buffer()\'', 'node-fetch#buffer');

// In browsers, all properties are enumerable.
Object.defineProperties(Body.prototype, {
	body: {enumerable: true},
	bodyUsed: {enumerable: true},
	arrayBuffer: {enumerable: true},
	blob: {enumerable: true},
	json: {enumerable: true},
	text: {enumerable: true},
	data: {get: (0,external_node_util_namespaceObject.deprecate)(() => {},
		'data doesn\'t exist, use json(), text(), arrayBuffer(), or body instead',
		'https://github.com/node-fetch/node-fetch/issues/1000 (response)')}
});

/**
 * Consume and convert an entire Body to a Buffer.
 *
 * Ref: https://fetch.spec.whatwg.org/#concept-body-consume-body
 *
 * @return Promise
 */
async function consumeBody(data) {
	if (data[INTERNALS].disturbed) {
		throw new TypeError(`body used already for: ${data.url}`);
	}

	data[INTERNALS].disturbed = true;

	if (data[INTERNALS].error) {
		throw data[INTERNALS].error;
	}

	const {body} = data;

	// Body is null
	if (body === null) {
		return external_node_buffer_namespaceObject.Buffer.alloc(0);
	}

	/* c8 ignore next 3 */
	if (!(body instanceof external_node_stream_namespaceObject)) {
		return external_node_buffer_namespaceObject.Buffer.alloc(0);
	}

	// Body is stream
	// get ready to actually consume the body
	const accum = [];
	let accumBytes = 0;

	try {
		for await (const chunk of body) {
			if (data.size > 0 && accumBytes + chunk.length > data.size) {
				const error = new FetchError(`content size at ${data.url} over limit: ${data.size}`, 'max-size');
				body.destroy(error);
				throw error;
			}

			accumBytes += chunk.length;
			accum.push(chunk);
		}
	} catch (error) {
		const error_ = error instanceof FetchBaseError ? error : new FetchError(`Invalid response body while trying to fetch ${data.url}: ${error.message}`, 'system', error);
		throw error_;
	}

	if (body.readableEnded === true || body._readableState.ended === true) {
		try {
			if (accum.every(c => typeof c === 'string')) {
				return external_node_buffer_namespaceObject.Buffer.from(accum.join(''));
			}

			return external_node_buffer_namespaceObject.Buffer.concat(accum, accumBytes);
		} catch (error) {
			throw new FetchError(`Could not create Buffer from response body for ${data.url}: ${error.message}`, 'system', error);
		}
	} else {
		throw new FetchError(`Premature close of server response while trying to fetch ${data.url}`);
	}
}

/**
 * Clone body given Res/Req instance
 *
 * @param   Mixed   instance       Response or Request instance
 * @param   String  highWaterMark  highWaterMark for both PassThrough body streams
 * @return  Mixed
 */
const clone = (instance, highWaterMark) => {
	let p1;
	let p2;
	let {body} = instance[INTERNALS];

	// Don't allow cloning a used body
	if (instance.bodyUsed) {
		throw new Error('cannot clone body after it is used');
	}

	// Check that body is a stream and not form-data object
	// note: we can't clone the form-data object without having it as a dependency
	if ((body instanceof external_node_stream_namespaceObject) && (typeof body.getBoundary !== 'function')) {
		// Tee instance body
		p1 = new external_node_stream_namespaceObject.PassThrough({highWaterMark});
		p2 = new external_node_stream_namespaceObject.PassThrough({highWaterMark});
		body.pipe(p1);
		body.pipe(p2);
		// Set instance body to teed body and return the other teed body
		instance[INTERNALS].stream = p1;
		body = p2;
	}

	return body;
};

const getNonSpecFormDataBoundary = (0,external_node_util_namespaceObject.deprecate)(
	body => body.getBoundary(),
	'form-data doesn\'t follow the spec and requires special treatment. Use alternative package',
	'https://github.com/node-fetch/node-fetch/issues/1167'
);

/**
 * Performs the operation "extract a `Content-Type` value from |object|" as
 * specified in the specification:
 * https://fetch.spec.whatwg.org/#concept-bodyinit-extract
 *
 * This function assumes that instance.body is present.
 *
 * @param {any} body Any options.body input
 * @returns {string | null}
 */
const extractContentType = (body, request) => {
	// Body is null or undefined
	if (body === null) {
		return null;
	}

	// Body is string
	if (typeof body === 'string') {
		return 'text/plain;charset=UTF-8';
	}

	// Body is a URLSearchParams
	if (isURLSearchParameters(body)) {
		return 'application/x-www-form-urlencoded;charset=UTF-8';
	}

	// Body is blob
	if (isBlob(body)) {
		return body.type || null;
	}

	// Body is a Buffer (Buffer, ArrayBuffer or ArrayBufferView)
	if (external_node_buffer_namespaceObject.Buffer.isBuffer(body) || external_node_util_namespaceObject.types.isAnyArrayBuffer(body) || ArrayBuffer.isView(body)) {
		return null;
	}

	if (body instanceof esm_min/* FormData */.fS) {
		return `multipart/form-data; boundary=${request[INTERNALS].boundary}`;
	}

	// Detect form data input from form-data module
	if (body && typeof body.getBoundary === 'function') {
		return `multipart/form-data;boundary=${getNonSpecFormDataBoundary(body)}`;
	}

	// Body is stream - can't really do much about this
	if (body instanceof external_node_stream_namespaceObject) {
		return null;
	}

	// Body constructor defaults other things to string
	return 'text/plain;charset=UTF-8';
};

/**
 * The Fetch Standard treats this as if "total bytes" is a property on the body.
 * For us, we have to explicitly get it with a function.
 *
 * ref: https://fetch.spec.whatwg.org/#concept-body-total-bytes
 *
 * @param {any} obj.body Body object from the Body instance.
 * @returns {number | null}
 */
const getTotalBytes = request => {
	const {body} = request[INTERNALS];

	// Body is null or undefined
	if (body === null) {
		return 0;
	}

	// Body is Blob
	if (isBlob(body)) {
		return body.size;
	}

	// Body is Buffer
	if (external_node_buffer_namespaceObject.Buffer.isBuffer(body)) {
		return body.length;
	}

	// Detect form data input from form-data module
	if (body && typeof body.getLengthSync === 'function') {
		return body.hasKnownLength && body.hasKnownLength() ? body.getLengthSync() : null;
	}

	// Body is stream
	return null;
};

/**
 * Write a Body to a Node.js WritableStream (e.g. http.Request) object.
 *
 * @param {Stream.Writable} dest The stream to write to.
 * @param obj.body Body object from the Body instance.
 * @returns {Promise<void>}
 */
const writeToStream = async (dest, {body}) => {
	if (body === null) {
		// Body is null
		dest.end();
	} else {
		// Body is stream
		await pipeline(body, dest);
	}
};

;// CONCATENATED MODULE: ./node_modules/node-fetch/src/headers.js
/**
 * Headers.js
 *
 * Headers class offers convenient helpers
 */




/* c8 ignore next 9 */
const validateHeaderName = typeof external_node_http_namespaceObject.validateHeaderName === 'function' ?
	external_node_http_namespaceObject.validateHeaderName :
	name => {
		if (!/^[\^`\-\w!#$%&'*+.|~]+$/.test(name)) {
			const error = new TypeError(`Header name must be a valid HTTP token [${name}]`);
			Object.defineProperty(error, 'code', {value: 'ERR_INVALID_HTTP_TOKEN'});
			throw error;
		}
	};

/* c8 ignore next 9 */
const validateHeaderValue = typeof external_node_http_namespaceObject.validateHeaderValue === 'function' ?
	external_node_http_namespaceObject.validateHeaderValue :
	(name, value) => {
		if (/[^\t\u0020-\u007E\u0080-\u00FF]/.test(value)) {
			const error = new TypeError(`Invalid character in header content ["${name}"]`);
			Object.defineProperty(error, 'code', {value: 'ERR_INVALID_CHAR'});
			throw error;
		}
	};

/**
 * @typedef {Headers | Record<string, string> | Iterable<readonly [string, string]> | Iterable<Iterable<string>>} HeadersInit
 */

/**
 * This Fetch API interface allows you to perform various actions on HTTP request and response headers.
 * These actions include retrieving, setting, adding to, and removing.
 * A Headers object has an associated header list, which is initially empty and consists of zero or more name and value pairs.
 * You can add to this using methods like append() (see Examples.)
 * In all methods of this interface, header names are matched by case-insensitive byte sequence.
 *
 */
class Headers extends URLSearchParams {
	/**
	 * Headers class
	 *
	 * @constructor
	 * @param {HeadersInit} [init] - Response headers
	 */
	constructor(init) {
		// Validate and normalize init object in [name, value(s)][]
		/** @type {string[][]} */
		let result = [];
		if (init instanceof Headers) {
			const raw = init.raw();
			for (const [name, values] of Object.entries(raw)) {
				result.push(...values.map(value => [name, value]));
			}
		} else if (init == null) { // eslint-disable-line no-eq-null, eqeqeq
			// No op
		} else if (typeof init === 'object' && !external_node_util_namespaceObject.types.isBoxedPrimitive(init)) {
			const method = init[Symbol.iterator];
			// eslint-disable-next-line no-eq-null, eqeqeq
			if (method == null) {
				// Record<ByteString, ByteString>
				result.push(...Object.entries(init));
			} else {
				if (typeof method !== 'function') {
					throw new TypeError('Header pairs must be iterable');
				}

				// Sequence<sequence<ByteString>>
				// Note: per spec we have to first exhaust the lists then process them
				result = [...init]
					.map(pair => {
						if (
							typeof pair !== 'object' || external_node_util_namespaceObject.types.isBoxedPrimitive(pair)
						) {
							throw new TypeError('Each header pair must be an iterable object');
						}

						return [...pair];
					}).map(pair => {
						if (pair.length !== 2) {
							throw new TypeError('Each header pair must be a name/value tuple');
						}

						return [...pair];
					});
			}
		} else {
			throw new TypeError('Failed to construct \'Headers\': The provided value is not of type \'(sequence<sequence<ByteString>> or record<ByteString, ByteString>)');
		}

		// Validate and lowercase
		result =
			result.length > 0 ?
				result.map(([name, value]) => {
					validateHeaderName(name);
					validateHeaderValue(name, String(value));
					return [String(name).toLowerCase(), String(value)];
				}) :
				undefined;

		super(result);

		// Returning a Proxy that will lowercase key names, validate parameters and sort keys
		// eslint-disable-next-line no-constructor-return
		return new Proxy(this, {
			get(target, p, receiver) {
				switch (p) {
					case 'append':
					case 'set':
						return (name, value) => {
							validateHeaderName(name);
							validateHeaderValue(name, String(value));
							return URLSearchParams.prototype[p].call(
								target,
								String(name).toLowerCase(),
								String(value)
							);
						};

					case 'delete':
					case 'has':
					case 'getAll':
						return name => {
							validateHeaderName(name);
							return URLSearchParams.prototype[p].call(
								target,
								String(name).toLowerCase()
							);
						};

					case 'keys':
						return () => {
							target.sort();
							return new Set(URLSearchParams.prototype.keys.call(target)).keys();
						};

					default:
						return Reflect.get(target, p, receiver);
				}
			}
		});
		/* c8 ignore next */
	}

	get [Symbol.toStringTag]() {
		return this.constructor.name;
	}

	toString() {
		return Object.prototype.toString.call(this);
	}

	get(name) {
		const values = this.getAll(name);
		if (values.length === 0) {
			return null;
		}

		let value = values.join(', ');
		if (/^content-encoding$/i.test(name)) {
			value = value.toLowerCase();
		}

		return value;
	}

	forEach(callback, thisArg = undefined) {
		for (const name of this.keys()) {
			Reflect.apply(callback, thisArg, [this.get(name), name, this]);
		}
	}

	* values() {
		for (const name of this.keys()) {
			yield this.get(name);
		}
	}

	/**
	 * @type {() => IterableIterator<[string, string]>}
	 */
	* entries() {
		for (const name of this.keys()) {
			yield [name, this.get(name)];
		}
	}

	[Symbol.iterator]() {
		return this.entries();
	}

	/**
	 * Node-fetch non-spec method
	 * returning all headers and their values as array
	 * @returns {Record<string, string[]>}
	 */
	raw() {
		return [...this.keys()].reduce((result, key) => {
			result[key] = this.getAll(key);
			return result;
		}, {});
	}

	/**
	 * For better console.log(headers) and also to convert Headers into Node.js Request compatible format
	 */
	[Symbol.for('nodejs.util.inspect.custom')]() {
		return [...this.keys()].reduce((result, key) => {
			const values = this.getAll(key);
			// Http.request() only supports string as Host header.
			// This hack makes specifying custom Host header possible.
			if (key === 'host') {
				result[key] = values[0];
			} else {
				result[key] = values.length > 1 ? values : values[0];
			}

			return result;
		}, {});
	}
}

/**
 * Re-shaping object for Web IDL tests
 * Only need to do it for overridden methods
 */
Object.defineProperties(
	Headers.prototype,
	['get', 'entries', 'forEach', 'values'].reduce((result, property) => {
		result[property] = {enumerable: true};
		return result;
	}, {})
);

/**
 * Create a Headers object from an http.IncomingMessage.rawHeaders, ignoring those that do
 * not conform to HTTP grammar productions.
 * @param {import('http').IncomingMessage['rawHeaders']} headers
 */
function fromRawHeaders(headers = []) {
	return new Headers(
		headers
			// Split into pairs
			.reduce((result, value, index, array) => {
				if (index % 2 === 0) {
					result.push(array.slice(index, index + 2));
				}

				return result;
			}, [])
			.filter(([name, value]) => {
				try {
					validateHeaderName(name);
					validateHeaderValue(name, String(value));
					return true;
				} catch {
					return false;
				}
			})

	);
}

;// CONCATENATED MODULE: ./node_modules/node-fetch/src/utils/is-redirect.js
const redirectStatus = new Set([301, 302, 303, 307, 308]);

/**
 * Redirect code matching
 *
 * @param {number} code - Status code
 * @return {boolean}
 */
const isRedirect = code => {
	return redirectStatus.has(code);
};

;// CONCATENATED MODULE: ./node_modules/node-fetch/src/response.js
/**
 * Response.js
 *
 * Response class provides content decoding
 */





const response_INTERNALS = Symbol('Response internals');

/**
 * Response class
 *
 * Ref: https://fetch.spec.whatwg.org/#response-class
 *
 * @param   Stream  body  Readable stream
 * @param   Object  opts  Response options
 * @return  Void
 */
class Response extends Body {
	constructor(body = null, options = {}) {
		super(body, options);

		// eslint-disable-next-line no-eq-null, eqeqeq, no-negated-condition
		const status = options.status != null ? options.status : 200;

		const headers = new Headers(options.headers);

		if (body !== null && !headers.has('Content-Type')) {
			const contentType = extractContentType(body, this);
			if (contentType) {
				headers.append('Content-Type', contentType);
			}
		}

		this[response_INTERNALS] = {
			type: 'default',
			url: options.url,
			status,
			statusText: options.statusText || '',
			headers,
			counter: options.counter,
			highWaterMark: options.highWaterMark
		};
	}

	get type() {
		return this[response_INTERNALS].type;
	}

	get url() {
		return this[response_INTERNALS].url || '';
	}

	get status() {
		return this[response_INTERNALS].status;
	}

	/**
	 * Convenience property representing if the request ended normally
	 */
	get ok() {
		return this[response_INTERNALS].status >= 200 && this[response_INTERNALS].status < 300;
	}

	get redirected() {
		return this[response_INTERNALS].counter > 0;
	}

	get statusText() {
		return this[response_INTERNALS].statusText;
	}

	get headers() {
		return this[response_INTERNALS].headers;
	}

	get highWaterMark() {
		return this[response_INTERNALS].highWaterMark;
	}

	/**
	 * Clone this response
	 *
	 * @return  Response
	 */
	clone() {
		return new Response(clone(this, this.highWaterMark), {
			type: this.type,
			url: this.url,
			status: this.status,
			statusText: this.statusText,
			headers: this.headers,
			ok: this.ok,
			redirected: this.redirected,
			size: this.size,
			highWaterMark: this.highWaterMark
		});
	}

	/**
	 * @param {string} url    The URL that the new response is to originate from.
	 * @param {number} status An optional status code for the response (e.g., 302.)
	 * @returns {Response}    A Response object.
	 */
	static redirect(url, status = 302) {
		if (!isRedirect(status)) {
			throw new RangeError('Failed to execute "redirect" on "response": Invalid status code');
		}

		return new Response(null, {
			headers: {
				location: new URL(url).toString()
			},
			status
		});
	}

	static error() {
		const response = new Response(null, {status: 0, statusText: ''});
		response[response_INTERNALS].type = 'error';
		return response;
	}

	static json(data = undefined, init = {}) {
		const body = JSON.stringify(data);

		if (body === undefined) {
			throw new TypeError('data is not JSON serializable');
		}

		const headers = new Headers(init && init.headers);

		if (!headers.has('content-type')) {
			headers.set('content-type', 'application/json');
		}

		return new Response(body, {
			...init,
			headers
		});
	}

	get [Symbol.toStringTag]() {
		return 'Response';
	}
}

Object.defineProperties(Response.prototype, {
	type: {enumerable: true},
	url: {enumerable: true},
	status: {enumerable: true},
	ok: {enumerable: true},
	redirected: {enumerable: true},
	statusText: {enumerable: true},
	headers: {enumerable: true},
	clone: {enumerable: true}
});

;// CONCATENATED MODULE: external "node:url"
const external_node_url_namespaceObject = __WEBPACK_EXTERNAL_createRequire(import.meta.url)("node:url");
;// CONCATENATED MODULE: ./node_modules/node-fetch/src/utils/get-search.js
const getSearch = parsedURL => {
	if (parsedURL.search) {
		return parsedURL.search;
	}

	const lastOffset = parsedURL.href.length - 1;
	const hash = parsedURL.hash || (parsedURL.href[lastOffset] === '#' ? '#' : '');
	return parsedURL.href[lastOffset - hash.length] === '?' ? '?' : '';
};

;// CONCATENATED MODULE: external "node:net"
const external_node_net_namespaceObject = __WEBPACK_EXTERNAL_createRequire(import.meta.url)("node:net");
;// CONCATENATED MODULE: ./node_modules/node-fetch/src/utils/referrer.js


/**
 * @external URL
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/URL|URL}
 */

/**
 * @module utils/referrer
 * @private
 */

/**
 * @see {@link https://w3c.github.io/webappsec-referrer-policy/#strip-url|Referrer Policy §8.4. Strip url for use as a referrer}
 * @param {string} URL
 * @param {boolean} [originOnly=false]
 */
function stripURLForUseAsAReferrer(url, originOnly = false) {
	// 1. If url is null, return no referrer.
	if (url == null) { // eslint-disable-line no-eq-null, eqeqeq
		return 'no-referrer';
	}

	url = new URL(url);

	// 2. If url's scheme is a local scheme, then return no referrer.
	if (/^(about|blob|data):$/.test(url.protocol)) {
		return 'no-referrer';
	}

	// 3. Set url's username to the empty string.
	url.username = '';

	// 4. Set url's password to null.
	// Note: `null` appears to be a mistake as this actually results in the password being `"null"`.
	url.password = '';

	// 5. Set url's fragment to null.
	// Note: `null` appears to be a mistake as this actually results in the fragment being `"#null"`.
	url.hash = '';

	// 6. If the origin-only flag is true, then:
	if (originOnly) {
		// 6.1. Set url's path to null.
		// Note: `null` appears to be a mistake as this actually results in the path being `"/null"`.
		url.pathname = '';

		// 6.2. Set url's query to null.
		// Note: `null` appears to be a mistake as this actually results in the query being `"?null"`.
		url.search = '';
	}

	// 7. Return url.
	return url;
}

/**
 * @see {@link https://w3c.github.io/webappsec-referrer-policy/#enumdef-referrerpolicy|enum ReferrerPolicy}
 */
const ReferrerPolicy = new Set([
	'',
	'no-referrer',
	'no-referrer-when-downgrade',
	'same-origin',
	'origin',
	'strict-origin',
	'origin-when-cross-origin',
	'strict-origin-when-cross-origin',
	'unsafe-url'
]);

/**
 * @see {@link https://w3c.github.io/webappsec-referrer-policy/#default-referrer-policy|default referrer policy}
 */
const DEFAULT_REFERRER_POLICY = 'strict-origin-when-cross-origin';

/**
 * @see {@link https://w3c.github.io/webappsec-referrer-policy/#referrer-policies|Referrer Policy §3. Referrer Policies}
 * @param {string} referrerPolicy
 * @returns {string} referrerPolicy
 */
function validateReferrerPolicy(referrerPolicy) {
	if (!ReferrerPolicy.has(referrerPolicy)) {
		throw new TypeError(`Invalid referrerPolicy: ${referrerPolicy}`);
	}

	return referrerPolicy;
}

/**
 * @see {@link https://w3c.github.io/webappsec-secure-contexts/#is-origin-trustworthy|Referrer Policy §3.2. Is origin potentially trustworthy?}
 * @param {external:URL} url
 * @returns `true`: "Potentially Trustworthy", `false`: "Not Trustworthy"
 */
function isOriginPotentiallyTrustworthy(url) {
	// 1. If origin is an opaque origin, return "Not Trustworthy".
	// Not applicable

	// 2. Assert: origin is a tuple origin.
	// Not for implementations

	// 3. If origin's scheme is either "https" or "wss", return "Potentially Trustworthy".
	if (/^(http|ws)s:$/.test(url.protocol)) {
		return true;
	}

	// 4. If origin's host component matches one of the CIDR notations 127.0.0.0/8 or ::1/128 [RFC4632], return "Potentially Trustworthy".
	const hostIp = url.host.replace(/(^\[)|(]$)/g, '');
	const hostIPVersion = (0,external_node_net_namespaceObject.isIP)(hostIp);

	if (hostIPVersion === 4 && /^127\./.test(hostIp)) {
		return true;
	}

	if (hostIPVersion === 6 && /^(((0+:){7})|(::(0+:){0,6}))0*1$/.test(hostIp)) {
		return true;
	}

	// 5. If origin's host component is "localhost" or falls within ".localhost", and the user agent conforms to the name resolution rules in [let-localhost-be-localhost], return "Potentially Trustworthy".
	// We are returning FALSE here because we cannot ensure conformance to
	// let-localhost-be-loalhost (https://tools.ietf.org/html/draft-west-let-localhost-be-localhost)
	if (url.host === 'localhost' || url.host.endsWith('.localhost')) {
		return false;
	}

	// 6. If origin's scheme component is file, return "Potentially Trustworthy".
	if (url.protocol === 'file:') {
		return true;
	}

	// 7. If origin's scheme component is one which the user agent considers to be authenticated, return "Potentially Trustworthy".
	// Not supported

	// 8. If origin has been configured as a trustworthy origin, return "Potentially Trustworthy".
	// Not supported

	// 9. Return "Not Trustworthy".
	return false;
}

/**
 * @see {@link https://w3c.github.io/webappsec-secure-contexts/#is-url-trustworthy|Referrer Policy §3.3. Is url potentially trustworthy?}
 * @param {external:URL} url
 * @returns `true`: "Potentially Trustworthy", `false`: "Not Trustworthy"
 */
function isUrlPotentiallyTrustworthy(url) {
	// 1. If url is "about:blank" or "about:srcdoc", return "Potentially Trustworthy".
	if (/^about:(blank|srcdoc)$/.test(url)) {
		return true;
	}

	// 2. If url's scheme is "data", return "Potentially Trustworthy".
	if (url.protocol === 'data:') {
		return true;
	}

	// Note: The origin of blob: and filesystem: URLs is the origin of the context in which they were
	// created. Therefore, blobs created in a trustworthy origin will themselves be potentially
	// trustworthy.
	if (/^(blob|filesystem):$/.test(url.protocol)) {
		return true;
	}

	// 3. Return the result of executing §3.2 Is origin potentially trustworthy? on url's origin.
	return isOriginPotentiallyTrustworthy(url);
}

/**
 * Modifies the referrerURL to enforce any extra security policy considerations.
 * @see {@link https://w3c.github.io/webappsec-referrer-policy/#determine-requests-referrer|Referrer Policy §8.3. Determine request's Referrer}, step 7
 * @callback module:utils/referrer~referrerURLCallback
 * @param {external:URL} referrerURL
 * @returns {external:URL} modified referrerURL
 */

/**
 * Modifies the referrerOrigin to enforce any extra security policy considerations.
 * @see {@link https://w3c.github.io/webappsec-referrer-policy/#determine-requests-referrer|Referrer Policy §8.3. Determine request's Referrer}, step 7
 * @callback module:utils/referrer~referrerOriginCallback
 * @param {external:URL} referrerOrigin
 * @returns {external:URL} modified referrerOrigin
 */

/**
 * @see {@link https://w3c.github.io/webappsec-referrer-policy/#determine-requests-referrer|Referrer Policy §8.3. Determine request's Referrer}
 * @param {Request} request
 * @param {object} o
 * @param {module:utils/referrer~referrerURLCallback} o.referrerURLCallback
 * @param {module:utils/referrer~referrerOriginCallback} o.referrerOriginCallback
 * @returns {external:URL} Request's referrer
 */
function determineRequestsReferrer(request, {referrerURLCallback, referrerOriginCallback} = {}) {
	// There are 2 notes in the specification about invalid pre-conditions.  We return null, here, for
	// these cases:
	// > Note: If request's referrer is "no-referrer", Fetch will not call into this algorithm.
	// > Note: If request's referrer policy is the empty string, Fetch will not call into this
	// > algorithm.
	if (request.referrer === 'no-referrer' || request.referrerPolicy === '') {
		return null;
	}

	// 1. Let policy be request's associated referrer policy.
	const policy = request.referrerPolicy;

	// 2. Let environment be request's client.
	// not applicable to node.js

	// 3. Switch on request's referrer:
	if (request.referrer === 'about:client') {
		return 'no-referrer';
	}

	// "a URL": Let referrerSource be request's referrer.
	const referrerSource = request.referrer;

	// 4. Let request's referrerURL be the result of stripping referrerSource for use as a referrer.
	let referrerURL = stripURLForUseAsAReferrer(referrerSource);

	// 5. Let referrerOrigin be the result of stripping referrerSource for use as a referrer, with the
	//    origin-only flag set to true.
	let referrerOrigin = stripURLForUseAsAReferrer(referrerSource, true);

	// 6. If the result of serializing referrerURL is a string whose length is greater than 4096, set
	//    referrerURL to referrerOrigin.
	if (referrerURL.toString().length > 4096) {
		referrerURL = referrerOrigin;
	}

	// 7. The user agent MAY alter referrerURL or referrerOrigin at this point to enforce arbitrary
	//    policy considerations in the interests of minimizing data leakage. For example, the user
	//    agent could strip the URL down to an origin, modify its host, replace it with an empty
	//    string, etc.
	if (referrerURLCallback) {
		referrerURL = referrerURLCallback(referrerURL);
	}

	if (referrerOriginCallback) {
		referrerOrigin = referrerOriginCallback(referrerOrigin);
	}

	// 8.Execute the statements corresponding to the value of policy:
	const currentURL = new URL(request.url);

	switch (policy) {
		case 'no-referrer':
			return 'no-referrer';

		case 'origin':
			return referrerOrigin;

		case 'unsafe-url':
			return referrerURL;

		case 'strict-origin':
			// 1. If referrerURL is a potentially trustworthy URL and request's current URL is not a
			//    potentially trustworthy URL, then return no referrer.
			if (isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL)) {
				return 'no-referrer';
			}

			// 2. Return referrerOrigin.
			return referrerOrigin.toString();

		case 'strict-origin-when-cross-origin':
			// 1. If the origin of referrerURL and the origin of request's current URL are the same, then
			//    return referrerURL.
			if (referrerURL.origin === currentURL.origin) {
				return referrerURL;
			}

			// 2. If referrerURL is a potentially trustworthy URL and request's current URL is not a
			//    potentially trustworthy URL, then return no referrer.
			if (isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL)) {
				return 'no-referrer';
			}

			// 3. Return referrerOrigin.
			return referrerOrigin;

		case 'same-origin':
			// 1. If the origin of referrerURL and the origin of request's current URL are the same, then
			//    return referrerURL.
			if (referrerURL.origin === currentURL.origin) {
				return referrerURL;
			}

			// 2. Return no referrer.
			return 'no-referrer';

		case 'origin-when-cross-origin':
			// 1. If the origin of referrerURL and the origin of request's current URL are the same, then
			//    return referrerURL.
			if (referrerURL.origin === currentURL.origin) {
				return referrerURL;
			}

			// Return referrerOrigin.
			return referrerOrigin;

		case 'no-referrer-when-downgrade':
			// 1. If referrerURL is a potentially trustworthy URL and request's current URL is not a
			//    potentially trustworthy URL, then return no referrer.
			if (isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL)) {
				return 'no-referrer';
			}

			// 2. Return referrerURL.
			return referrerURL;

		default:
			throw new TypeError(`Invalid referrerPolicy: ${policy}`);
	}
}

/**
 * @see {@link https://w3c.github.io/webappsec-referrer-policy/#parse-referrer-policy-from-header|Referrer Policy §8.1. Parse a referrer policy from a Referrer-Policy header}
 * @param {Headers} headers Response headers
 * @returns {string} policy
 */
function parseReferrerPolicyFromHeader(headers) {
	// 1. Let policy-tokens be the result of extracting header list values given `Referrer-Policy`
	//    and response’s header list.
	const policyTokens = (headers.get('referrer-policy') || '').split(/[,\s]+/);

	// 2. Let policy be the empty string.
	let policy = '';

	// 3. For each token in policy-tokens, if token is a referrer policy and token is not the empty
	//    string, then set policy to token.
	// Note: This algorithm loops over multiple policy values to allow deployment of new policy
	// values with fallbacks for older user agents, as described in § 11.1 Unknown Policy Values.
	for (const token of policyTokens) {
		if (token && ReferrerPolicy.has(token)) {
			policy = token;
		}
	}

	// 4. Return policy.
	return policy;
}

;// CONCATENATED MODULE: ./node_modules/node-fetch/src/request.js
/**
 * Request.js
 *
 * Request class contains server only options
 *
 * All spec algorithm step numbers are based on https://fetch.spec.whatwg.org/commit-snapshots/ae716822cb3a61843226cd090eefc6589446c1d2/.
 */









const request_INTERNALS = Symbol('Request internals');

/**
 * Check if `obj` is an instance of Request.
 *
 * @param  {*} object
 * @return {boolean}
 */
const isRequest = object => {
	return (
		typeof object === 'object' &&
		typeof object[request_INTERNALS] === 'object'
	);
};

const doBadDataWarn = (0,external_node_util_namespaceObject.deprecate)(() => {},
	'.data is not a valid RequestInit property, use .body instead',
	'https://github.com/node-fetch/node-fetch/issues/1000 (request)');

/**
 * Request class
 *
 * Ref: https://fetch.spec.whatwg.org/#request-class
 *
 * @param   Mixed   input  Url or Request instance
 * @param   Object  init   Custom options
 * @return  Void
 */
class Request extends Body {
	constructor(input, init = {}) {
		let parsedURL;

		// Normalize input and force URL to be encoded as UTF-8 (https://github.com/node-fetch/node-fetch/issues/245)
		if (isRequest(input)) {
			parsedURL = new URL(input.url);
		} else {
			parsedURL = new URL(input);
			input = {};
		}

		if (parsedURL.username !== '' || parsedURL.password !== '') {
			throw new TypeError(`${parsedURL} is an url with embedded credentials.`);
		}

		let method = init.method || input.method || 'GET';
		if (/^(delete|get|head|options|post|put)$/i.test(method)) {
			method = method.toUpperCase();
		}

		if (!isRequest(init) && 'data' in init) {
			doBadDataWarn();
		}

		// eslint-disable-next-line no-eq-null, eqeqeq
		if ((init.body != null || (isRequest(input) && input.body !== null)) &&
			(method === 'GET' || method === 'HEAD')) {
			throw new TypeError('Request with GET/HEAD method cannot have body');
		}

		const inputBody = init.body ?
			init.body :
			(isRequest(input) && input.body !== null ?
				clone(input) :
				null);

		super(inputBody, {
			size: init.size || input.size || 0
		});

		const headers = new Headers(init.headers || input.headers || {});

		if (inputBody !== null && !headers.has('Content-Type')) {
			const contentType = extractContentType(inputBody, this);
			if (contentType) {
				headers.set('Content-Type', contentType);
			}
		}

		let signal = isRequest(input) ?
			input.signal :
			null;
		if ('signal' in init) {
			signal = init.signal;
		}

		// eslint-disable-next-line no-eq-null, eqeqeq
		if (signal != null && !isAbortSignal(signal)) {
			throw new TypeError('Expected signal to be an instanceof AbortSignal or EventTarget');
		}

		// §5.4, Request constructor steps, step 15.1
		// eslint-disable-next-line no-eq-null, eqeqeq
		let referrer = init.referrer == null ? input.referrer : init.referrer;
		if (referrer === '') {
			// §5.4, Request constructor steps, step 15.2
			referrer = 'no-referrer';
		} else if (referrer) {
			// §5.4, Request constructor steps, step 15.3.1, 15.3.2
			const parsedReferrer = new URL(referrer);
			// §5.4, Request constructor steps, step 15.3.3, 15.3.4
			referrer = /^about:(\/\/)?client$/.test(parsedReferrer) ? 'client' : parsedReferrer;
		} else {
			referrer = undefined;
		}

		this[request_INTERNALS] = {
			method,
			redirect: init.redirect || input.redirect || 'follow',
			headers,
			parsedURL,
			signal,
			referrer
		};

		// Node-fetch-only options
		this.follow = init.follow === undefined ? (input.follow === undefined ? 20 : input.follow) : init.follow;
		this.compress = init.compress === undefined ? (input.compress === undefined ? true : input.compress) : init.compress;
		this.counter = init.counter || input.counter || 0;
		this.agent = init.agent || input.agent;
		this.highWaterMark = init.highWaterMark || input.highWaterMark || 16384;
		this.insecureHTTPParser = init.insecureHTTPParser || input.insecureHTTPParser || false;

		// §5.4, Request constructor steps, step 16.
		// Default is empty string per https://fetch.spec.whatwg.org/#concept-request-referrer-policy
		this.referrerPolicy = init.referrerPolicy || input.referrerPolicy || '';
	}

	/** @returns {string} */
	get method() {
		return this[request_INTERNALS].method;
	}

	/** @returns {string} */
	get url() {
		return (0,external_node_url_namespaceObject.format)(this[request_INTERNALS].parsedURL);
	}

	/** @returns {Headers} */
	get headers() {
		return this[request_INTERNALS].headers;
	}

	get redirect() {
		return this[request_INTERNALS].redirect;
	}

	/** @returns {AbortSignal} */
	get signal() {
		return this[request_INTERNALS].signal;
	}

	// https://fetch.spec.whatwg.org/#dom-request-referrer
	get referrer() {
		if (this[request_INTERNALS].referrer === 'no-referrer') {
			return '';
		}

		if (this[request_INTERNALS].referrer === 'client') {
			return 'about:client';
		}

		if (this[request_INTERNALS].referrer) {
			return this[request_INTERNALS].referrer.toString();
		}

		return undefined;
	}

	get referrerPolicy() {
		return this[request_INTERNALS].referrerPolicy;
	}

	set referrerPolicy(referrerPolicy) {
		this[request_INTERNALS].referrerPolicy = validateReferrerPolicy(referrerPolicy);
	}

	/**
	 * Clone this request
	 *
	 * @return  Request
	 */
	clone() {
		return new Request(this);
	}

	get [Symbol.toStringTag]() {
		return 'Request';
	}
}

Object.defineProperties(Request.prototype, {
	method: {enumerable: true},
	url: {enumerable: true},
	headers: {enumerable: true},
	redirect: {enumerable: true},
	clone: {enumerable: true},
	signal: {enumerable: true},
	referrer: {enumerable: true},
	referrerPolicy: {enumerable: true}
});

/**
 * Convert a Request to Node.js http request options.
 *
 * @param {Request} request - A Request instance
 * @return The options object to be passed to http.request
 */
const getNodeRequestOptions = request => {
	const {parsedURL} = request[request_INTERNALS];
	const headers = new Headers(request[request_INTERNALS].headers);

	// Fetch step 1.3
	if (!headers.has('Accept')) {
		headers.set('Accept', '*/*');
	}

	// HTTP-network-or-cache fetch steps 2.4-2.7
	let contentLengthValue = null;
	if (request.body === null && /^(post|put)$/i.test(request.method)) {
		contentLengthValue = '0';
	}

	if (request.body !== null) {
		const totalBytes = getTotalBytes(request);
		// Set Content-Length if totalBytes is a number (that is not NaN)
		if (typeof totalBytes === 'number' && !Number.isNaN(totalBytes)) {
			contentLengthValue = String(totalBytes);
		}
	}

	if (contentLengthValue) {
		headers.set('Content-Length', contentLengthValue);
	}

	// 4.1. Main fetch, step 2.6
	// > If request's referrer policy is the empty string, then set request's referrer policy to the
	// > default referrer policy.
	if (request.referrerPolicy === '') {
		request.referrerPolicy = DEFAULT_REFERRER_POLICY;
	}

	// 4.1. Main fetch, step 2.7
	// > If request's referrer is not "no-referrer", set request's referrer to the result of invoking
	// > determine request's referrer.
	if (request.referrer && request.referrer !== 'no-referrer') {
		request[request_INTERNALS].referrer = determineRequestsReferrer(request);
	} else {
		request[request_INTERNALS].referrer = 'no-referrer';
	}

	// 4.5. HTTP-network-or-cache fetch, step 6.9
	// > If httpRequest's referrer is a URL, then append `Referer`/httpRequest's referrer, serialized
	// >  and isomorphic encoded, to httpRequest's header list.
	if (request[request_INTERNALS].referrer instanceof URL) {
		headers.set('Referer', request.referrer);
	}

	// HTTP-network-or-cache fetch step 2.11
	if (!headers.has('User-Agent')) {
		headers.set('User-Agent', 'node-fetch');
	}

	// HTTP-network-or-cache fetch step 2.15
	if (request.compress && !headers.has('Accept-Encoding')) {
		headers.set('Accept-Encoding', 'gzip, deflate, br');
	}

	let {agent} = request;
	if (typeof agent === 'function') {
		agent = agent(parsedURL);
	}

	// HTTP-network fetch step 4.2
	// chunked encoding is handled by Node.js

	const search = getSearch(parsedURL);

	// Pass the full URL directly to request(), but overwrite the following
	// options:
	const options = {
		// Overwrite search to retain trailing ? (issue #776)
		path: parsedURL.pathname + search,
		// The following options are not expressed in the URL
		method: request.method,
		headers: headers[Symbol.for('nodejs.util.inspect.custom')](),
		insecureHTTPParser: request.insecureHTTPParser,
		agent
	};

	return {
		/** @type {URL} */
		parsedURL,
		options
	};
};

;// CONCATENATED MODULE: ./node_modules/node-fetch/src/errors/abort-error.js


/**
 * AbortError interface for cancelled requests
 */
class AbortError extends FetchBaseError {
	constructor(message, type = 'aborted') {
		super(message, type);
	}
}

// EXTERNAL MODULE: ./node_modules/fetch-blob/from.js + 2 modules
var from = __nccwpck_require__(9802);
;// CONCATENATED MODULE: ./node_modules/node-fetch/src/index.js
/**
 * Index.js
 *
 * a request API compatible with window.fetch
 *
 * All spec algorithm step numbers are based on https://fetch.spec.whatwg.org/commit-snapshots/ae716822cb3a61843226cd090eefc6589446c1d2/.
 */
























const supportedSchemas = new Set(['data:', 'http:', 'https:']);

/**
 * Fetch function
 *
 * @param   {string | URL | import('./request').default} url - Absolute url or Request instance
 * @param   {*} [options_] - Fetch options
 * @return  {Promise<import('./response').default>}
 */
async function fetch(url, options_) {
	return new Promise((resolve, reject) => {
		// Build request object
		const request = new Request(url, options_);
		const {parsedURL, options} = getNodeRequestOptions(request);
		if (!supportedSchemas.has(parsedURL.protocol)) {
			throw new TypeError(`node-fetch cannot load ${url}. URL scheme "${parsedURL.protocol.replace(/:$/, '')}" is not supported.`);
		}

		if (parsedURL.protocol === 'data:') {
			const data = dist(request.url);
			const response = new Response(data, {headers: {'Content-Type': data.typeFull}});
			resolve(response);
			return;
		}

		// Wrap http.request into fetch
		const send = (parsedURL.protocol === 'https:' ? external_node_https_namespaceObject : external_node_http_namespaceObject).request;
		const {signal} = request;
		let response = null;

		const abort = () => {
			const error = new AbortError('The operation was aborted.');
			reject(error);
			if (request.body && request.body instanceof external_node_stream_namespaceObject.Readable) {
				request.body.destroy(error);
			}

			if (!response || !response.body) {
				return;
			}

			response.body.emit('error', error);
		};

		if (signal && signal.aborted) {
			abort();
			return;
		}

		const abortAndFinalize = () => {
			abort();
			finalize();
		};

		// Send request
		const request_ = send(parsedURL.toString(), options);

		if (signal) {
			signal.addEventListener('abort', abortAndFinalize);
		}

		const finalize = () => {
			request_.abort();
			if (signal) {
				signal.removeEventListener('abort', abortAndFinalize);
			}
		};

		request_.on('error', error => {
			reject(new FetchError(`request to ${request.url} failed, reason: ${error.message}`, 'system', error));
			finalize();
		});

		fixResponseChunkedTransferBadEnding(request_, error => {
			if (response && response.body) {
				response.body.destroy(error);
			}
		});

		/* c8 ignore next 18 */
		if (process.version < 'v14') {
			// Before Node.js 14, pipeline() does not fully support async iterators and does not always
			// properly handle when the socket close/end events are out of order.
			request_.on('socket', s => {
				let endedWithEventsCount;
				s.prependListener('end', () => {
					endedWithEventsCount = s._eventsCount;
				});
				s.prependListener('close', hadError => {
					// if end happened before close but the socket didn't emit an error, do it now
					if (response && endedWithEventsCount < s._eventsCount && !hadError) {
						const error = new Error('Premature close');
						error.code = 'ERR_STREAM_PREMATURE_CLOSE';
						response.body.emit('error', error);
					}
				});
			});
		}

		request_.on('response', response_ => {
			request_.setTimeout(0);
			const headers = fromRawHeaders(response_.rawHeaders);

			// HTTP fetch step 5
			if (isRedirect(response_.statusCode)) {
				// HTTP fetch step 5.2
				const location = headers.get('Location');

				// HTTP fetch step 5.3
				let locationURL = null;
				try {
					locationURL = location === null ? null : new URL(location, request.url);
				} catch {
					// error here can only be invalid URL in Location: header
					// do not throw when options.redirect == manual
					// let the user extract the errorneous redirect URL
					if (request.redirect !== 'manual') {
						reject(new FetchError(`uri requested responds with an invalid redirect URL: ${location}`, 'invalid-redirect'));
						finalize();
						return;
					}
				}

				// HTTP fetch step 5.5
				switch (request.redirect) {
					case 'error':
						reject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, 'no-redirect'));
						finalize();
						return;
					case 'manual':
						// Nothing to do
						break;
					case 'follow': {
						// HTTP-redirect fetch step 2
						if (locationURL === null) {
							break;
						}

						// HTTP-redirect fetch step 5
						if (request.counter >= request.follow) {
							reject(new FetchError(`maximum redirect reached at: ${request.url}`, 'max-redirect'));
							finalize();
							return;
						}

						// HTTP-redirect fetch step 6 (counter increment)
						// Create a new Request object.
						const requestOptions = {
							headers: new Headers(request.headers),
							follow: request.follow,
							counter: request.counter + 1,
							agent: request.agent,
							compress: request.compress,
							method: request.method,
							body: clone(request),
							signal: request.signal,
							size: request.size,
							referrer: request.referrer,
							referrerPolicy: request.referrerPolicy
						};

						// when forwarding sensitive headers like "Authorization",
						// "WWW-Authenticate", and "Cookie" to untrusted targets,
						// headers will be ignored when following a redirect to a domain
						// that is not a subdomain match or exact match of the initial domain.
						// For example, a redirect from "foo.com" to either "foo.com" or "sub.foo.com"
						// will forward the sensitive headers, but a redirect to "bar.com" will not.
						// headers will also be ignored when following a redirect to a domain using
						// a different protocol. For example, a redirect from "https://foo.com" to "http://foo.com"
						// will not forward the sensitive headers
						if (!isDomainOrSubdomain(request.url, locationURL) || !isSameProtocol(request.url, locationURL)) {
							for (const name of ['authorization', 'www-authenticate', 'cookie', 'cookie2']) {
								requestOptions.headers.delete(name);
							}
						}

						// HTTP-redirect fetch step 9
						if (response_.statusCode !== 303 && request.body && options_.body instanceof external_node_stream_namespaceObject.Readable) {
							reject(new FetchError('Cannot follow redirect with body being a readable stream', 'unsupported-redirect'));
							finalize();
							return;
						}

						// HTTP-redirect fetch step 11
						if (response_.statusCode === 303 || ((response_.statusCode === 301 || response_.statusCode === 302) && request.method === 'POST')) {
							requestOptions.method = 'GET';
							requestOptions.body = undefined;
							requestOptions.headers.delete('content-length');
						}

						// HTTP-redirect fetch step 14
						const responseReferrerPolicy = parseReferrerPolicyFromHeader(headers);
						if (responseReferrerPolicy) {
							requestOptions.referrerPolicy = responseReferrerPolicy;
						}

						// HTTP-redirect fetch step 15
						resolve(fetch(new Request(locationURL, requestOptions)));
						finalize();
						return;
					}

					default:
						return reject(new TypeError(`Redirect option '${request.redirect}' is not a valid value of RequestRedirect`));
				}
			}

			// Prepare response
			if (signal) {
				response_.once('end', () => {
					signal.removeEventListener('abort', abortAndFinalize);
				});
			}

			let body = (0,external_node_stream_namespaceObject.pipeline)(response_, new external_node_stream_namespaceObject.PassThrough(), error => {
				if (error) {
					reject(error);
				}
			});
			// see https://github.com/nodejs/node/pull/29376
			/* c8 ignore next 3 */
			if (process.version < 'v12.10') {
				response_.on('aborted', abortAndFinalize);
			}

			const responseOptions = {
				url: request.url,
				status: response_.statusCode,
				statusText: response_.statusMessage,
				headers,
				size: request.size,
				counter: request.counter,
				highWaterMark: request.highWaterMark
			};

			// HTTP-network fetch step 12.1.1.3
			const codings = headers.get('Content-Encoding');

			// HTTP-network fetch step 12.1.1.4: handle content codings

			// in following scenarios we ignore compression support
			// 1. compression support is disabled
			// 2. HEAD request
			// 3. no Content-Encoding header
			// 4. no content response (204)
			// 5. content not modified response (304)
			if (!request.compress || request.method === 'HEAD' || codings === null || response_.statusCode === 204 || response_.statusCode === 304) {
				response = new Response(body, responseOptions);
				resolve(response);
				return;
			}

			// For Node v6+
			// Be less strict when decoding compressed responses, since sometimes
			// servers send slightly invalid responses that are still accepted
			// by common browsers.
			// Always using Z_SYNC_FLUSH is what cURL does.
			const zlibOptions = {
				flush: external_node_zlib_namespaceObject.Z_SYNC_FLUSH,
				finishFlush: external_node_zlib_namespaceObject.Z_SYNC_FLUSH
			};

			// For gzip
			if (codings === 'gzip' || codings === 'x-gzip') {
				body = (0,external_node_stream_namespaceObject.pipeline)(body, external_node_zlib_namespaceObject.createGunzip(zlibOptions), error => {
					if (error) {
						reject(error);
					}
				});
				response = new Response(body, responseOptions);
				resolve(response);
				return;
			}

			// For deflate
			if (codings === 'deflate' || codings === 'x-deflate') {
				// Handle the infamous raw deflate response from old servers
				// a hack for old IIS and Apache servers
				const raw = (0,external_node_stream_namespaceObject.pipeline)(response_, new external_node_stream_namespaceObject.PassThrough(), error => {
					if (error) {
						reject(error);
					}
				});
				raw.once('data', chunk => {
					// See http://stackoverflow.com/questions/37519828
					if ((chunk[0] & 0x0F) === 0x08) {
						body = (0,external_node_stream_namespaceObject.pipeline)(body, external_node_zlib_namespaceObject.createInflate(), error => {
							if (error) {
								reject(error);
							}
						});
					} else {
						body = (0,external_node_stream_namespaceObject.pipeline)(body, external_node_zlib_namespaceObject.createInflateRaw(), error => {
							if (error) {
								reject(error);
							}
						});
					}

					response = new Response(body, responseOptions);
					resolve(response);
				});
				raw.once('end', () => {
					// Some old IIS servers return zero-length OK deflate responses, so
					// 'data' is never emitted. See https://github.com/node-fetch/node-fetch/pull/903
					if (!response) {
						response = new Response(body, responseOptions);
						resolve(response);
					}
				});
				return;
			}

			// For br
			if (codings === 'br') {
				body = (0,external_node_stream_namespaceObject.pipeline)(body, external_node_zlib_namespaceObject.createBrotliDecompress(), error => {
					if (error) {
						reject(error);
					}
				});
				response = new Response(body, responseOptions);
				resolve(response);
				return;
			}

			// Otherwise, use response as-is
			response = new Response(body, responseOptions);
			resolve(response);
		});

		// eslint-disable-next-line promise/prefer-await-to-then
		writeToStream(request_, request).catch(reject);
	});
}

function fixResponseChunkedTransferBadEnding(request, errorCallback) {
	const LAST_CHUNK = external_node_buffer_namespaceObject.Buffer.from('0\r\n\r\n');

	let isChunkedTransfer = false;
	let properLastChunkReceived = false;
	let previousChunk;

	request.on('response', response => {
		const {headers} = response;
		isChunkedTransfer = headers['transfer-encoding'] === 'chunked' && !headers['content-length'];
	});

	request.on('socket', socket => {
		const onSocketClose = () => {
			if (isChunkedTransfer && !properLastChunkReceived) {
				const error = new Error('Premature close');
				error.code = 'ERR_STREAM_PREMATURE_CLOSE';
				errorCallback(error);
			}
		};

		const onData = buf => {
			properLastChunkReceived = external_node_buffer_namespaceObject.Buffer.compare(buf.slice(-5), LAST_CHUNK) === 0;

			// Sometimes final 0-length chunk and end of message code are in separate packets
			if (!properLastChunkReceived && previousChunk) {
				properLastChunkReceived = (
					external_node_buffer_namespaceObject.Buffer.compare(previousChunk.slice(-3), LAST_CHUNK.slice(0, 3)) === 0 &&
					external_node_buffer_namespaceObject.Buffer.compare(buf.slice(-2), LAST_CHUNK.slice(3)) === 0
				);
			}

			previousChunk = buf;
		};

		socket.prependListener('close', onSocketClose);
		socket.on('data', onData);

		request.on('close', () => {
			socket.removeListener('close', onSocketClose);
			socket.removeListener('data', onData);
		});
	});
}


/***/ }),

/***/ 56:
/***/ ((module) => {

module.exports = /*#__PURE__*/JSON.parse('{"name":"dotenv","version":"16.4.7","description":"Loads environment variables from .env file","main":"lib/main.js","types":"lib/main.d.ts","exports":{".":{"types":"./lib/main.d.ts","require":"./lib/main.js","default":"./lib/main.js"},"./config":"./config.js","./config.js":"./config.js","./lib/env-options":"./lib/env-options.js","./lib/env-options.js":"./lib/env-options.js","./lib/cli-options":"./lib/cli-options.js","./lib/cli-options.js":"./lib/cli-options.js","./package.json":"./package.json"},"scripts":{"dts-check":"tsc --project tests/types/tsconfig.json","lint":"standard","pretest":"npm run lint && npm run dts-check","test":"tap run --allow-empty-coverage --disable-coverage --timeout=60000","test:coverage":"tap run --show-full-coverage --timeout=60000 --coverage-report=lcov","prerelease":"npm test","release":"standard-version"},"repository":{"type":"git","url":"git://github.com/motdotla/dotenv.git"},"funding":"https://dotenvx.com","keywords":["dotenv","env",".env","environment","variables","config","settings"],"readmeFilename":"README.md","license":"BSD-2-Clause","devDependencies":{"@types/node":"^18.11.3","decache":"^4.6.2","sinon":"^14.0.1","standard":"^17.0.0","standard-version":"^9.5.0","tap":"^19.2.0","typescript":"^4.8.4"},"engines":{"node":">=12"},"browser":{"fs":false}}');

/***/ }),

/***/ 1813:
/***/ ((module) => {

module.exports = /*#__PURE__*/JSON.parse('{"application/1d-interleaved-parityfec":{"source":"iana"},"application/3gpdash-qoe-report+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/3gpp-ims+xml":{"source":"iana","compressible":true},"application/3gpphal+json":{"source":"iana","compressible":true},"application/3gpphalforms+json":{"source":"iana","compressible":true},"application/a2l":{"source":"iana"},"application/ace+cbor":{"source":"iana"},"application/activemessage":{"source":"iana"},"application/activity+json":{"source":"iana","compressible":true},"application/alto-costmap+json":{"source":"iana","compressible":true},"application/alto-costmapfilter+json":{"source":"iana","compressible":true},"application/alto-directory+json":{"source":"iana","compressible":true},"application/alto-endpointcost+json":{"source":"iana","compressible":true},"application/alto-endpointcostparams+json":{"source":"iana","compressible":true},"application/alto-endpointprop+json":{"source":"iana","compressible":true},"application/alto-endpointpropparams+json":{"source":"iana","compressible":true},"application/alto-error+json":{"source":"iana","compressible":true},"application/alto-networkmap+json":{"source":"iana","compressible":true},"application/alto-networkmapfilter+json":{"source":"iana","compressible":true},"application/alto-updatestreamcontrol+json":{"source":"iana","compressible":true},"application/alto-updatestreamparams+json":{"source":"iana","compressible":true},"application/aml":{"source":"iana"},"application/andrew-inset":{"source":"iana","extensions":["ez"]},"application/applefile":{"source":"iana"},"application/applixware":{"source":"apache","extensions":["aw"]},"application/at+jwt":{"source":"iana"},"application/atf":{"source":"iana"},"application/atfx":{"source":"iana"},"application/atom+xml":{"source":"iana","compressible":true,"extensions":["atom"]},"application/atomcat+xml":{"source":"iana","compressible":true,"extensions":["atomcat"]},"application/atomdeleted+xml":{"source":"iana","compressible":true,"extensions":["atomdeleted"]},"application/atomicmail":{"source":"iana"},"application/atomsvc+xml":{"source":"iana","compressible":true,"extensions":["atomsvc"]},"application/atsc-dwd+xml":{"source":"iana","compressible":true,"extensions":["dwd"]},"application/atsc-dynamic-event-message":{"source":"iana"},"application/atsc-held+xml":{"source":"iana","compressible":true,"extensions":["held"]},"application/atsc-rdt+json":{"source":"iana","compressible":true},"application/atsc-rsat+xml":{"source":"iana","compressible":true,"extensions":["rsat"]},"application/atxml":{"source":"iana"},"application/auth-policy+xml":{"source":"iana","compressible":true},"application/bacnet-xdd+zip":{"source":"iana","compressible":false},"application/batch-smtp":{"source":"iana"},"application/bdoc":{"compressible":false,"extensions":["bdoc"]},"application/beep+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/calendar+json":{"source":"iana","compressible":true},"application/calendar+xml":{"source":"iana","compressible":true,"extensions":["xcs"]},"application/call-completion":{"source":"iana"},"application/cals-1840":{"source":"iana"},"application/captive+json":{"source":"iana","compressible":true},"application/cbor":{"source":"iana"},"application/cbor-seq":{"source":"iana"},"application/cccex":{"source":"iana"},"application/ccmp+xml":{"source":"iana","compressible":true},"application/ccxml+xml":{"source":"iana","compressible":true,"extensions":["ccxml"]},"application/cdfx+xml":{"source":"iana","compressible":true,"extensions":["cdfx"]},"application/cdmi-capability":{"source":"iana","extensions":["cdmia"]},"application/cdmi-container":{"source":"iana","extensions":["cdmic"]},"application/cdmi-domain":{"source":"iana","extensions":["cdmid"]},"application/cdmi-object":{"source":"iana","extensions":["cdmio"]},"application/cdmi-queue":{"source":"iana","extensions":["cdmiq"]},"application/cdni":{"source":"iana"},"application/cea":{"source":"iana"},"application/cea-2018+xml":{"source":"iana","compressible":true},"application/cellml+xml":{"source":"iana","compressible":true},"application/cfw":{"source":"iana"},"application/city+json":{"source":"iana","compressible":true},"application/clr":{"source":"iana"},"application/clue+xml":{"source":"iana","compressible":true},"application/clue_info+xml":{"source":"iana","compressible":true},"application/cms":{"source":"iana"},"application/cnrp+xml":{"source":"iana","compressible":true},"application/coap-group+json":{"source":"iana","compressible":true},"application/coap-payload":{"source":"iana"},"application/commonground":{"source":"iana"},"application/conference-info+xml":{"source":"iana","compressible":true},"application/cose":{"source":"iana"},"application/cose-key":{"source":"iana"},"application/cose-key-set":{"source":"iana"},"application/cpl+xml":{"source":"iana","compressible":true,"extensions":["cpl"]},"application/csrattrs":{"source":"iana"},"application/csta+xml":{"source":"iana","compressible":true},"application/cstadata+xml":{"source":"iana","compressible":true},"application/csvm+json":{"source":"iana","compressible":true},"application/cu-seeme":{"source":"apache","extensions":["cu"]},"application/cwt":{"source":"iana"},"application/cybercash":{"source":"iana"},"application/dart":{"compressible":true},"application/dash+xml":{"source":"iana","compressible":true,"extensions":["mpd"]},"application/dash-patch+xml":{"source":"iana","compressible":true,"extensions":["mpp"]},"application/dashdelta":{"source":"iana"},"application/davmount+xml":{"source":"iana","compressible":true,"extensions":["davmount"]},"application/dca-rft":{"source":"iana"},"application/dcd":{"source":"iana"},"application/dec-dx":{"source":"iana"},"application/dialog-info+xml":{"source":"iana","compressible":true},"application/dicom":{"source":"iana"},"application/dicom+json":{"source":"iana","compressible":true},"application/dicom+xml":{"source":"iana","compressible":true},"application/dii":{"source":"iana"},"application/dit":{"source":"iana"},"application/dns":{"source":"iana"},"application/dns+json":{"source":"iana","compressible":true},"application/dns-message":{"source":"iana"},"application/docbook+xml":{"source":"apache","compressible":true,"extensions":["dbk"]},"application/dots+cbor":{"source":"iana"},"application/dskpp+xml":{"source":"iana","compressible":true},"application/dssc+der":{"source":"iana","extensions":["dssc"]},"application/dssc+xml":{"source":"iana","compressible":true,"extensions":["xdssc"]},"application/dvcs":{"source":"iana"},"application/ecmascript":{"source":"iana","compressible":true,"extensions":["es","ecma"]},"application/edi-consent":{"source":"iana"},"application/edi-x12":{"source":"iana","compressible":false},"application/edifact":{"source":"iana","compressible":false},"application/efi":{"source":"iana"},"application/elm+json":{"source":"iana","charset":"UTF-8","compressible":true},"application/elm+xml":{"source":"iana","compressible":true},"application/emergencycalldata.cap+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/emergencycalldata.comment+xml":{"source":"iana","compressible":true},"application/emergencycalldata.control+xml":{"source":"iana","compressible":true},"application/emergencycalldata.deviceinfo+xml":{"source":"iana","compressible":true},"application/emergencycalldata.ecall.msd":{"source":"iana"},"application/emergencycalldata.providerinfo+xml":{"source":"iana","compressible":true},"application/emergencycalldata.serviceinfo+xml":{"source":"iana","compressible":true},"application/emergencycalldata.subscriberinfo+xml":{"source":"iana","compressible":true},"application/emergencycalldata.veds+xml":{"source":"iana","compressible":true},"application/emma+xml":{"source":"iana","compressible":true,"extensions":["emma"]},"application/emotionml+xml":{"source":"iana","compressible":true,"extensions":["emotionml"]},"application/encaprtp":{"source":"iana"},"application/epp+xml":{"source":"iana","compressible":true},"application/epub+zip":{"source":"iana","compressible":false,"extensions":["epub"]},"application/eshop":{"source":"iana"},"application/exi":{"source":"iana","extensions":["exi"]},"application/expect-ct-report+json":{"source":"iana","compressible":true},"application/express":{"source":"iana","extensions":["exp"]},"application/fastinfoset":{"source":"iana"},"application/fastsoap":{"source":"iana"},"application/fdt+xml":{"source":"iana","compressible":true,"extensions":["fdt"]},"application/fhir+json":{"source":"iana","charset":"UTF-8","compressible":true},"application/fhir+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/fido.trusted-apps+json":{"compressible":true},"application/fits":{"source":"iana"},"application/flexfec":{"source":"iana"},"application/font-sfnt":{"source":"iana"},"application/font-tdpfr":{"source":"iana","extensions":["pfr"]},"application/font-woff":{"source":"iana","compressible":false},"application/framework-attributes+xml":{"source":"iana","compressible":true},"application/geo+json":{"source":"iana","compressible":true,"extensions":["geojson"]},"application/geo+json-seq":{"source":"iana"},"application/geopackage+sqlite3":{"source":"iana"},"application/geoxacml+xml":{"source":"iana","compressible":true},"application/gltf-buffer":{"source":"iana"},"application/gml+xml":{"source":"iana","compressible":true,"extensions":["gml"]},"application/gpx+xml":{"source":"apache","compressible":true,"extensions":["gpx"]},"application/gxf":{"source":"apache","extensions":["gxf"]},"application/gzip":{"source":"iana","compressible":false,"extensions":["gz"]},"application/h224":{"source":"iana"},"application/held+xml":{"source":"iana","compressible":true},"application/hjson":{"extensions":["hjson"]},"application/http":{"source":"iana"},"application/hyperstudio":{"source":"iana","extensions":["stk"]},"application/ibe-key-request+xml":{"source":"iana","compressible":true},"application/ibe-pkg-reply+xml":{"source":"iana","compressible":true},"application/ibe-pp-data":{"source":"iana"},"application/iges":{"source":"iana"},"application/im-iscomposing+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/index":{"source":"iana"},"application/index.cmd":{"source":"iana"},"application/index.obj":{"source":"iana"},"application/index.response":{"source":"iana"},"application/index.vnd":{"source":"iana"},"application/inkml+xml":{"source":"iana","compressible":true,"extensions":["ink","inkml"]},"application/iotp":{"source":"iana"},"application/ipfix":{"source":"iana","extensions":["ipfix"]},"application/ipp":{"source":"iana"},"application/isup":{"source":"iana"},"application/its+xml":{"source":"iana","compressible":true,"extensions":["its"]},"application/java-archive":{"source":"apache","compressible":false,"extensions":["jar","war","ear"]},"application/java-serialized-object":{"source":"apache","compressible":false,"extensions":["ser"]},"application/java-vm":{"source":"apache","compressible":false,"extensions":["class"]},"application/javascript":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["js","mjs"]},"application/jf2feed+json":{"source":"iana","compressible":true},"application/jose":{"source":"iana"},"application/jose+json":{"source":"iana","compressible":true},"application/jrd+json":{"source":"iana","compressible":true},"application/jscalendar+json":{"source":"iana","compressible":true},"application/json":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["json","map"]},"application/json-patch+json":{"source":"iana","compressible":true},"application/json-seq":{"source":"iana"},"application/json5":{"extensions":["json5"]},"application/jsonml+json":{"source":"apache","compressible":true,"extensions":["jsonml"]},"application/jwk+json":{"source":"iana","compressible":true},"application/jwk-set+json":{"source":"iana","compressible":true},"application/jwt":{"source":"iana"},"application/kpml-request+xml":{"source":"iana","compressible":true},"application/kpml-response+xml":{"source":"iana","compressible":true},"application/ld+json":{"source":"iana","compressible":true,"extensions":["jsonld"]},"application/lgr+xml":{"source":"iana","compressible":true,"extensions":["lgr"]},"application/link-format":{"source":"iana"},"application/load-control+xml":{"source":"iana","compressible":true},"application/lost+xml":{"source":"iana","compressible":true,"extensions":["lostxml"]},"application/lostsync+xml":{"source":"iana","compressible":true},"application/lpf+zip":{"source":"iana","compressible":false},"application/lxf":{"source":"iana"},"application/mac-binhex40":{"source":"iana","extensions":["hqx"]},"application/mac-compactpro":{"source":"apache","extensions":["cpt"]},"application/macwriteii":{"source":"iana"},"application/mads+xml":{"source":"iana","compressible":true,"extensions":["mads"]},"application/manifest+json":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["webmanifest"]},"application/marc":{"source":"iana","extensions":["mrc"]},"application/marcxml+xml":{"source":"iana","compressible":true,"extensions":["mrcx"]},"application/mathematica":{"source":"iana","extensions":["ma","nb","mb"]},"application/mathml+xml":{"source":"iana","compressible":true,"extensions":["mathml"]},"application/mathml-content+xml":{"source":"iana","compressible":true},"application/mathml-presentation+xml":{"source":"iana","compressible":true},"application/mbms-associated-procedure-description+xml":{"source":"iana","compressible":true},"application/mbms-deregister+xml":{"source":"iana","compressible":true},"application/mbms-envelope+xml":{"source":"iana","compressible":true},"application/mbms-msk+xml":{"source":"iana","compressible":true},"application/mbms-msk-response+xml":{"source":"iana","compressible":true},"application/mbms-protection-description+xml":{"source":"iana","compressible":true},"application/mbms-reception-report+xml":{"source":"iana","compressible":true},"application/mbms-register+xml":{"source":"iana","compressible":true},"application/mbms-register-response+xml":{"source":"iana","compressible":true},"application/mbms-schedule+xml":{"source":"iana","compressible":true},"application/mbms-user-service-description+xml":{"source":"iana","compressible":true},"application/mbox":{"source":"iana","extensions":["mbox"]},"application/media-policy-dataset+xml":{"source":"iana","compressible":true,"extensions":["mpf"]},"application/media_control+xml":{"source":"iana","compressible":true},"application/mediaservercontrol+xml":{"source":"iana","compressible":true,"extensions":["mscml"]},"application/merge-patch+json":{"source":"iana","compressible":true},"application/metalink+xml":{"source":"apache","compressible":true,"extensions":["metalink"]},"application/metalink4+xml":{"source":"iana","compressible":true,"extensions":["meta4"]},"application/mets+xml":{"source":"iana","compressible":true,"extensions":["mets"]},"application/mf4":{"source":"iana"},"application/mikey":{"source":"iana"},"application/mipc":{"source":"iana"},"application/missing-blocks+cbor-seq":{"source":"iana"},"application/mmt-aei+xml":{"source":"iana","compressible":true,"extensions":["maei"]},"application/mmt-usd+xml":{"source":"iana","compressible":true,"extensions":["musd"]},"application/mods+xml":{"source":"iana","compressible":true,"extensions":["mods"]},"application/moss-keys":{"source":"iana"},"application/moss-signature":{"source":"iana"},"application/mosskey-data":{"source":"iana"},"application/mosskey-request":{"source":"iana"},"application/mp21":{"source":"iana","extensions":["m21","mp21"]},"application/mp4":{"source":"iana","extensions":["mp4s","m4p"]},"application/mpeg4-generic":{"source":"iana"},"application/mpeg4-iod":{"source":"iana"},"application/mpeg4-iod-xmt":{"source":"iana"},"application/mrb-consumer+xml":{"source":"iana","compressible":true},"application/mrb-publish+xml":{"source":"iana","compressible":true},"application/msc-ivr+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/msc-mixer+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/msword":{"source":"iana","compressible":false,"extensions":["doc","dot"]},"application/mud+json":{"source":"iana","compressible":true},"application/multipart-core":{"source":"iana"},"application/mxf":{"source":"iana","extensions":["mxf"]},"application/n-quads":{"source":"iana","extensions":["nq"]},"application/n-triples":{"source":"iana","extensions":["nt"]},"application/nasdata":{"source":"iana"},"application/news-checkgroups":{"source":"iana","charset":"US-ASCII"},"application/news-groupinfo":{"source":"iana","charset":"US-ASCII"},"application/news-transmission":{"source":"iana"},"application/nlsml+xml":{"source":"iana","compressible":true},"application/node":{"source":"iana","extensions":["cjs"]},"application/nss":{"source":"iana"},"application/oauth-authz-req+jwt":{"source":"iana"},"application/oblivious-dns-message":{"source":"iana"},"application/ocsp-request":{"source":"iana"},"application/ocsp-response":{"source":"iana"},"application/octet-stream":{"source":"iana","compressible":false,"extensions":["bin","dms","lrf","mar","so","dist","distz","pkg","bpk","dump","elc","deploy","exe","dll","deb","dmg","iso","img","msi","msp","msm","buffer"]},"application/oda":{"source":"iana","extensions":["oda"]},"application/odm+xml":{"source":"iana","compressible":true},"application/odx":{"source":"iana"},"application/oebps-package+xml":{"source":"iana","compressible":true,"extensions":["opf"]},"application/ogg":{"source":"iana","compressible":false,"extensions":["ogx"]},"application/omdoc+xml":{"source":"apache","compressible":true,"extensions":["omdoc"]},"application/onenote":{"source":"apache","extensions":["onetoc","onetoc2","onetmp","onepkg"]},"application/opc-nodeset+xml":{"source":"iana","compressible":true},"application/oscore":{"source":"iana"},"application/oxps":{"source":"iana","extensions":["oxps"]},"application/p21":{"source":"iana"},"application/p21+zip":{"source":"iana","compressible":false},"application/p2p-overlay+xml":{"source":"iana","compressible":true,"extensions":["relo"]},"application/parityfec":{"source":"iana"},"application/passport":{"source":"iana"},"application/patch-ops-error+xml":{"source":"iana","compressible":true,"extensions":["xer"]},"application/pdf":{"source":"iana","compressible":false,"extensions":["pdf"]},"application/pdx":{"source":"iana"},"application/pem-certificate-chain":{"source":"iana"},"application/pgp-encrypted":{"source":"iana","compressible":false,"extensions":["pgp"]},"application/pgp-keys":{"source":"iana","extensions":["asc"]},"application/pgp-signature":{"source":"iana","extensions":["asc","sig"]},"application/pics-rules":{"source":"apache","extensions":["prf"]},"application/pidf+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/pidf-diff+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/pkcs10":{"source":"iana","extensions":["p10"]},"application/pkcs12":{"source":"iana"},"application/pkcs7-mime":{"source":"iana","extensions":["p7m","p7c"]},"application/pkcs7-signature":{"source":"iana","extensions":["p7s"]},"application/pkcs8":{"source":"iana","extensions":["p8"]},"application/pkcs8-encrypted":{"source":"iana"},"application/pkix-attr-cert":{"source":"iana","extensions":["ac"]},"application/pkix-cert":{"source":"iana","extensions":["cer"]},"application/pkix-crl":{"source":"iana","extensions":["crl"]},"application/pkix-pkipath":{"source":"iana","extensions":["pkipath"]},"application/pkixcmp":{"source":"iana","extensions":["pki"]},"application/pls+xml":{"source":"iana","compressible":true,"extensions":["pls"]},"application/poc-settings+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/postscript":{"source":"iana","compressible":true,"extensions":["ai","eps","ps"]},"application/ppsp-tracker+json":{"source":"iana","compressible":true},"application/problem+json":{"source":"iana","compressible":true},"application/problem+xml":{"source":"iana","compressible":true},"application/provenance+xml":{"source":"iana","compressible":true,"extensions":["provx"]},"application/prs.alvestrand.titrax-sheet":{"source":"iana"},"application/prs.cww":{"source":"iana","extensions":["cww"]},"application/prs.cyn":{"source":"iana","charset":"7-BIT"},"application/prs.hpub+zip":{"source":"iana","compressible":false},"application/prs.nprend":{"source":"iana"},"application/prs.plucker":{"source":"iana"},"application/prs.rdf-xml-crypt":{"source":"iana"},"application/prs.xsf+xml":{"source":"iana","compressible":true},"application/pskc+xml":{"source":"iana","compressible":true,"extensions":["pskcxml"]},"application/pvd+json":{"source":"iana","compressible":true},"application/qsig":{"source":"iana"},"application/raml+yaml":{"compressible":true,"extensions":["raml"]},"application/raptorfec":{"source":"iana"},"application/rdap+json":{"source":"iana","compressible":true},"application/rdf+xml":{"source":"iana","compressible":true,"extensions":["rdf","owl"]},"application/reginfo+xml":{"source":"iana","compressible":true,"extensions":["rif"]},"application/relax-ng-compact-syntax":{"source":"iana","extensions":["rnc"]},"application/remote-printing":{"source":"iana"},"application/reputon+json":{"source":"iana","compressible":true},"application/resource-lists+xml":{"source":"iana","compressible":true,"extensions":["rl"]},"application/resource-lists-diff+xml":{"source":"iana","compressible":true,"extensions":["rld"]},"application/rfc+xml":{"source":"iana","compressible":true},"application/riscos":{"source":"iana"},"application/rlmi+xml":{"source":"iana","compressible":true},"application/rls-services+xml":{"source":"iana","compressible":true,"extensions":["rs"]},"application/route-apd+xml":{"source":"iana","compressible":true,"extensions":["rapd"]},"application/route-s-tsid+xml":{"source":"iana","compressible":true,"extensions":["sls"]},"application/route-usd+xml":{"source":"iana","compressible":true,"extensions":["rusd"]},"application/rpki-ghostbusters":{"source":"iana","extensions":["gbr"]},"application/rpki-manifest":{"source":"iana","extensions":["mft"]},"application/rpki-publication":{"source":"iana"},"application/rpki-roa":{"source":"iana","extensions":["roa"]},"application/rpki-updown":{"source":"iana"},"application/rsd+xml":{"source":"apache","compressible":true,"extensions":["rsd"]},"application/rss+xml":{"source":"apache","compressible":true,"extensions":["rss"]},"application/rtf":{"source":"iana","compressible":true,"extensions":["rtf"]},"application/rtploopback":{"source":"iana"},"application/rtx":{"source":"iana"},"application/samlassertion+xml":{"source":"iana","compressible":true},"application/samlmetadata+xml":{"source":"iana","compressible":true},"application/sarif+json":{"source":"iana","compressible":true},"application/sarif-external-properties+json":{"source":"iana","compressible":true},"application/sbe":{"source":"iana"},"application/sbml+xml":{"source":"iana","compressible":true,"extensions":["sbml"]},"application/scaip+xml":{"source":"iana","compressible":true},"application/scim+json":{"source":"iana","compressible":true},"application/scvp-cv-request":{"source":"iana","extensions":["scq"]},"application/scvp-cv-response":{"source":"iana","extensions":["scs"]},"application/scvp-vp-request":{"source":"iana","extensions":["spq"]},"application/scvp-vp-response":{"source":"iana","extensions":["spp"]},"application/sdp":{"source":"iana","extensions":["sdp"]},"application/secevent+jwt":{"source":"iana"},"application/senml+cbor":{"source":"iana"},"application/senml+json":{"source":"iana","compressible":true},"application/senml+xml":{"source":"iana","compressible":true,"extensions":["senmlx"]},"application/senml-etch+cbor":{"source":"iana"},"application/senml-etch+json":{"source":"iana","compressible":true},"application/senml-exi":{"source":"iana"},"application/sensml+cbor":{"source":"iana"},"application/sensml+json":{"source":"iana","compressible":true},"application/sensml+xml":{"source":"iana","compressible":true,"extensions":["sensmlx"]},"application/sensml-exi":{"source":"iana"},"application/sep+xml":{"source":"iana","compressible":true},"application/sep-exi":{"source":"iana"},"application/session-info":{"source":"iana"},"application/set-payment":{"source":"iana"},"application/set-payment-initiation":{"source":"iana","extensions":["setpay"]},"application/set-registration":{"source":"iana"},"application/set-registration-initiation":{"source":"iana","extensions":["setreg"]},"application/sgml":{"source":"iana"},"application/sgml-open-catalog":{"source":"iana"},"application/shf+xml":{"source":"iana","compressible":true,"extensions":["shf"]},"application/sieve":{"source":"iana","extensions":["siv","sieve"]},"application/simple-filter+xml":{"source":"iana","compressible":true},"application/simple-message-summary":{"source":"iana"},"application/simplesymbolcontainer":{"source":"iana"},"application/sipc":{"source":"iana"},"application/slate":{"source":"iana"},"application/smil":{"source":"iana"},"application/smil+xml":{"source":"iana","compressible":true,"extensions":["smi","smil"]},"application/smpte336m":{"source":"iana"},"application/soap+fastinfoset":{"source":"iana"},"application/soap+xml":{"source":"iana","compressible":true},"application/sparql-query":{"source":"iana","extensions":["rq"]},"application/sparql-results+xml":{"source":"iana","compressible":true,"extensions":["srx"]},"application/spdx+json":{"source":"iana","compressible":true},"application/spirits-event+xml":{"source":"iana","compressible":true},"application/sql":{"source":"iana"},"application/srgs":{"source":"iana","extensions":["gram"]},"application/srgs+xml":{"source":"iana","compressible":true,"extensions":["grxml"]},"application/sru+xml":{"source":"iana","compressible":true,"extensions":["sru"]},"application/ssdl+xml":{"source":"apache","compressible":true,"extensions":["ssdl"]},"application/ssml+xml":{"source":"iana","compressible":true,"extensions":["ssml"]},"application/stix+json":{"source":"iana","compressible":true},"application/swid+xml":{"source":"iana","compressible":true,"extensions":["swidtag"]},"application/tamp-apex-update":{"source":"iana"},"application/tamp-apex-update-confirm":{"source":"iana"},"application/tamp-community-update":{"source":"iana"},"application/tamp-community-update-confirm":{"source":"iana"},"application/tamp-error":{"source":"iana"},"application/tamp-sequence-adjust":{"source":"iana"},"application/tamp-sequence-adjust-confirm":{"source":"iana"},"application/tamp-status-query":{"source":"iana"},"application/tamp-status-response":{"source":"iana"},"application/tamp-update":{"source":"iana"},"application/tamp-update-confirm":{"source":"iana"},"application/tar":{"compressible":true},"application/taxii+json":{"source":"iana","compressible":true},"application/td+json":{"source":"iana","compressible":true},"application/tei+xml":{"source":"iana","compressible":true,"extensions":["tei","teicorpus"]},"application/tetra_isi":{"source":"iana"},"application/thraud+xml":{"source":"iana","compressible":true,"extensions":["tfi"]},"application/timestamp-query":{"source":"iana"},"application/timestamp-reply":{"source":"iana"},"application/timestamped-data":{"source":"iana","extensions":["tsd"]},"application/tlsrpt+gzip":{"source":"iana"},"application/tlsrpt+json":{"source":"iana","compressible":true},"application/tnauthlist":{"source":"iana"},"application/token-introspection+jwt":{"source":"iana"},"application/toml":{"compressible":true,"extensions":["toml"]},"application/trickle-ice-sdpfrag":{"source":"iana"},"application/trig":{"source":"iana","extensions":["trig"]},"application/ttml+xml":{"source":"iana","compressible":true,"extensions":["ttml"]},"application/tve-trigger":{"source":"iana"},"application/tzif":{"source":"iana"},"application/tzif-leap":{"source":"iana"},"application/ubjson":{"compressible":false,"extensions":["ubj"]},"application/ulpfec":{"source":"iana"},"application/urc-grpsheet+xml":{"source":"iana","compressible":true},"application/urc-ressheet+xml":{"source":"iana","compressible":true,"extensions":["rsheet"]},"application/urc-targetdesc+xml":{"source":"iana","compressible":true,"extensions":["td"]},"application/urc-uisocketdesc+xml":{"source":"iana","compressible":true},"application/vcard+json":{"source":"iana","compressible":true},"application/vcard+xml":{"source":"iana","compressible":true},"application/vemmi":{"source":"iana"},"application/vividence.scriptfile":{"source":"apache"},"application/vnd.1000minds.decision-model+xml":{"source":"iana","compressible":true,"extensions":["1km"]},"application/vnd.3gpp-prose+xml":{"source":"iana","compressible":true},"application/vnd.3gpp-prose-pc3ch+xml":{"source":"iana","compressible":true},"application/vnd.3gpp-v2x-local-service-information":{"source":"iana"},"application/vnd.3gpp.5gnas":{"source":"iana"},"application/vnd.3gpp.access-transfer-events+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.bsf+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.gmop+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.gtpc":{"source":"iana"},"application/vnd.3gpp.interworking-data":{"source":"iana"},"application/vnd.3gpp.lpp":{"source":"iana"},"application/vnd.3gpp.mc-signalling-ear":{"source":"iana"},"application/vnd.3gpp.mcdata-affiliation-command+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcdata-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcdata-payload":{"source":"iana"},"application/vnd.3gpp.mcdata-service-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcdata-signalling":{"source":"iana"},"application/vnd.3gpp.mcdata-ue-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcdata-user-profile+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-affiliation-command+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-floor-request+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-location-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-mbms-usage-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-service-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-signed+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-ue-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-ue-init-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-user-profile+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-affiliation-command+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-affiliation-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-location-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-mbms-usage-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-service-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-transmission-request+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-ue-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-user-profile+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mid-call+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.ngap":{"source":"iana"},"application/vnd.3gpp.pfcp":{"source":"iana"},"application/vnd.3gpp.pic-bw-large":{"source":"iana","extensions":["plb"]},"application/vnd.3gpp.pic-bw-small":{"source":"iana","extensions":["psb"]},"application/vnd.3gpp.pic-bw-var":{"source":"iana","extensions":["pvb"]},"application/vnd.3gpp.s1ap":{"source":"iana"},"application/vnd.3gpp.sms":{"source":"iana"},"application/vnd.3gpp.sms+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.srvcc-ext+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.srvcc-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.state-and-event-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.ussd+xml":{"source":"iana","compressible":true},"application/vnd.3gpp2.bcmcsinfo+xml":{"source":"iana","compressible":true},"application/vnd.3gpp2.sms":{"source":"iana"},"application/vnd.3gpp2.tcap":{"source":"iana","extensions":["tcap"]},"application/vnd.3lightssoftware.imagescal":{"source":"iana"},"application/vnd.3m.post-it-notes":{"source":"iana","extensions":["pwn"]},"application/vnd.accpac.simply.aso":{"source":"iana","extensions":["aso"]},"application/vnd.accpac.simply.imp":{"source":"iana","extensions":["imp"]},"application/vnd.acucobol":{"source":"iana","extensions":["acu"]},"application/vnd.acucorp":{"source":"iana","extensions":["atc","acutc"]},"application/vnd.adobe.air-application-installer-package+zip":{"source":"apache","compressible":false,"extensions":["air"]},"application/vnd.adobe.flash.movie":{"source":"iana"},"application/vnd.adobe.formscentral.fcdt":{"source":"iana","extensions":["fcdt"]},"application/vnd.adobe.fxp":{"source":"iana","extensions":["fxp","fxpl"]},"application/vnd.adobe.partial-upload":{"source":"iana"},"application/vnd.adobe.xdp+xml":{"source":"iana","compressible":true,"extensions":["xdp"]},"application/vnd.adobe.xfdf":{"source":"iana","extensions":["xfdf"]},"application/vnd.aether.imp":{"source":"iana"},"application/vnd.afpc.afplinedata":{"source":"iana"},"application/vnd.afpc.afplinedata-pagedef":{"source":"iana"},"application/vnd.afpc.cmoca-cmresource":{"source":"iana"},"application/vnd.afpc.foca-charset":{"source":"iana"},"application/vnd.afpc.foca-codedfont":{"source":"iana"},"application/vnd.afpc.foca-codepage":{"source":"iana"},"application/vnd.afpc.modca":{"source":"iana"},"application/vnd.afpc.modca-cmtable":{"source":"iana"},"application/vnd.afpc.modca-formdef":{"source":"iana"},"application/vnd.afpc.modca-mediummap":{"source":"iana"},"application/vnd.afpc.modca-objectcontainer":{"source":"iana"},"application/vnd.afpc.modca-overlay":{"source":"iana"},"application/vnd.afpc.modca-pagesegment":{"source":"iana"},"application/vnd.age":{"source":"iana","extensions":["age"]},"application/vnd.ah-barcode":{"source":"iana"},"application/vnd.ahead.space":{"source":"iana","extensions":["ahead"]},"application/vnd.airzip.filesecure.azf":{"source":"iana","extensions":["azf"]},"application/vnd.airzip.filesecure.azs":{"source":"iana","extensions":["azs"]},"application/vnd.amadeus+json":{"source":"iana","compressible":true},"application/vnd.amazon.ebook":{"source":"apache","extensions":["azw"]},"application/vnd.amazon.mobi8-ebook":{"source":"iana"},"application/vnd.americandynamics.acc":{"source":"iana","extensions":["acc"]},"application/vnd.amiga.ami":{"source":"iana","extensions":["ami"]},"application/vnd.amundsen.maze+xml":{"source":"iana","compressible":true},"application/vnd.android.ota":{"source":"iana"},"application/vnd.android.package-archive":{"source":"apache","compressible":false,"extensions":["apk"]},"application/vnd.anki":{"source":"iana"},"application/vnd.anser-web-certificate-issue-initiation":{"source":"iana","extensions":["cii"]},"application/vnd.anser-web-funds-transfer-initiation":{"source":"apache","extensions":["fti"]},"application/vnd.antix.game-component":{"source":"iana","extensions":["atx"]},"application/vnd.apache.arrow.file":{"source":"iana"},"application/vnd.apache.arrow.stream":{"source":"iana"},"application/vnd.apache.thrift.binary":{"source":"iana"},"application/vnd.apache.thrift.compact":{"source":"iana"},"application/vnd.apache.thrift.json":{"source":"iana"},"application/vnd.api+json":{"source":"iana","compressible":true},"application/vnd.aplextor.warrp+json":{"source":"iana","compressible":true},"application/vnd.apothekende.reservation+json":{"source":"iana","compressible":true},"application/vnd.apple.installer+xml":{"source":"iana","compressible":true,"extensions":["mpkg"]},"application/vnd.apple.keynote":{"source":"iana","extensions":["key"]},"application/vnd.apple.mpegurl":{"source":"iana","extensions":["m3u8"]},"application/vnd.apple.numbers":{"source":"iana","extensions":["numbers"]},"application/vnd.apple.pages":{"source":"iana","extensions":["pages"]},"application/vnd.apple.pkpass":{"compressible":false,"extensions":["pkpass"]},"application/vnd.arastra.swi":{"source":"iana"},"application/vnd.aristanetworks.swi":{"source":"iana","extensions":["swi"]},"application/vnd.artisan+json":{"source":"iana","compressible":true},"application/vnd.artsquare":{"source":"iana"},"application/vnd.astraea-software.iota":{"source":"iana","extensions":["iota"]},"application/vnd.audiograph":{"source":"iana","extensions":["aep"]},"application/vnd.autopackage":{"source":"iana"},"application/vnd.avalon+json":{"source":"iana","compressible":true},"application/vnd.avistar+xml":{"source":"iana","compressible":true},"application/vnd.balsamiq.bmml+xml":{"source":"iana","compressible":true,"extensions":["bmml"]},"application/vnd.balsamiq.bmpr":{"source":"iana"},"application/vnd.banana-accounting":{"source":"iana"},"application/vnd.bbf.usp.error":{"source":"iana"},"application/vnd.bbf.usp.msg":{"source":"iana"},"application/vnd.bbf.usp.msg+json":{"source":"iana","compressible":true},"application/vnd.bekitzur-stech+json":{"source":"iana","compressible":true},"application/vnd.bint.med-content":{"source":"iana"},"application/vnd.biopax.rdf+xml":{"source":"iana","compressible":true},"application/vnd.blink-idb-value-wrapper":{"source":"iana"},"application/vnd.blueice.multipass":{"source":"iana","extensions":["mpm"]},"application/vnd.bluetooth.ep.oob":{"source":"iana"},"application/vnd.bluetooth.le.oob":{"source":"iana"},"application/vnd.bmi":{"source":"iana","extensions":["bmi"]},"application/vnd.bpf":{"source":"iana"},"application/vnd.bpf3":{"source":"iana"},"application/vnd.businessobjects":{"source":"iana","extensions":["rep"]},"application/vnd.byu.uapi+json":{"source":"iana","compressible":true},"application/vnd.cab-jscript":{"source":"iana"},"application/vnd.canon-cpdl":{"source":"iana"},"application/vnd.canon-lips":{"source":"iana"},"application/vnd.capasystems-pg+json":{"source":"iana","compressible":true},"application/vnd.cendio.thinlinc.clientconf":{"source":"iana"},"application/vnd.century-systems.tcp_stream":{"source":"iana"},"application/vnd.chemdraw+xml":{"source":"iana","compressible":true,"extensions":["cdxml"]},"application/vnd.chess-pgn":{"source":"iana"},"application/vnd.chipnuts.karaoke-mmd":{"source":"iana","extensions":["mmd"]},"application/vnd.ciedi":{"source":"iana"},"application/vnd.cinderella":{"source":"iana","extensions":["cdy"]},"application/vnd.cirpack.isdn-ext":{"source":"iana"},"application/vnd.citationstyles.style+xml":{"source":"iana","compressible":true,"extensions":["csl"]},"application/vnd.claymore":{"source":"iana","extensions":["cla"]},"application/vnd.cloanto.rp9":{"source":"iana","extensions":["rp9"]},"application/vnd.clonk.c4group":{"source":"iana","extensions":["c4g","c4d","c4f","c4p","c4u"]},"application/vnd.cluetrust.cartomobile-config":{"source":"iana","extensions":["c11amc"]},"application/vnd.cluetrust.cartomobile-config-pkg":{"source":"iana","extensions":["c11amz"]},"application/vnd.coffeescript":{"source":"iana"},"application/vnd.collabio.xodocuments.document":{"source":"iana"},"application/vnd.collabio.xodocuments.document-template":{"source":"iana"},"application/vnd.collabio.xodocuments.presentation":{"source":"iana"},"application/vnd.collabio.xodocuments.presentation-template":{"source":"iana"},"application/vnd.collabio.xodocuments.spreadsheet":{"source":"iana"},"application/vnd.collabio.xodocuments.spreadsheet-template":{"source":"iana"},"application/vnd.collection+json":{"source":"iana","compressible":true},"application/vnd.collection.doc+json":{"source":"iana","compressible":true},"application/vnd.collection.next+json":{"source":"iana","compressible":true},"application/vnd.comicbook+zip":{"source":"iana","compressible":false},"application/vnd.comicbook-rar":{"source":"iana"},"application/vnd.commerce-battelle":{"source":"iana"},"application/vnd.commonspace":{"source":"iana","extensions":["csp"]},"application/vnd.contact.cmsg":{"source":"iana","extensions":["cdbcmsg"]},"application/vnd.coreos.ignition+json":{"source":"iana","compressible":true},"application/vnd.cosmocaller":{"source":"iana","extensions":["cmc"]},"application/vnd.crick.clicker":{"source":"iana","extensions":["clkx"]},"application/vnd.crick.clicker.keyboard":{"source":"iana","extensions":["clkk"]},"application/vnd.crick.clicker.palette":{"source":"iana","extensions":["clkp"]},"application/vnd.crick.clicker.template":{"source":"iana","extensions":["clkt"]},"application/vnd.crick.clicker.wordbank":{"source":"iana","extensions":["clkw"]},"application/vnd.criticaltools.wbs+xml":{"source":"iana","compressible":true,"extensions":["wbs"]},"application/vnd.cryptii.pipe+json":{"source":"iana","compressible":true},"application/vnd.crypto-shade-file":{"source":"iana"},"application/vnd.cryptomator.encrypted":{"source":"iana"},"application/vnd.cryptomator.vault":{"source":"iana"},"application/vnd.ctc-posml":{"source":"iana","extensions":["pml"]},"application/vnd.ctct.ws+xml":{"source":"iana","compressible":true},"application/vnd.cups-pdf":{"source":"iana"},"application/vnd.cups-postscript":{"source":"iana"},"application/vnd.cups-ppd":{"source":"iana","extensions":["ppd"]},"application/vnd.cups-raster":{"source":"iana"},"application/vnd.cups-raw":{"source":"iana"},"application/vnd.curl":{"source":"iana"},"application/vnd.curl.car":{"source":"apache","extensions":["car"]},"application/vnd.curl.pcurl":{"source":"apache","extensions":["pcurl"]},"application/vnd.cyan.dean.root+xml":{"source":"iana","compressible":true},"application/vnd.cybank":{"source":"iana"},"application/vnd.cyclonedx+json":{"source":"iana","compressible":true},"application/vnd.cyclonedx+xml":{"source":"iana","compressible":true},"application/vnd.d2l.coursepackage1p0+zip":{"source":"iana","compressible":false},"application/vnd.d3m-dataset":{"source":"iana"},"application/vnd.d3m-problem":{"source":"iana"},"application/vnd.dart":{"source":"iana","compressible":true,"extensions":["dart"]},"application/vnd.data-vision.rdz":{"source":"iana","extensions":["rdz"]},"application/vnd.datapackage+json":{"source":"iana","compressible":true},"application/vnd.dataresource+json":{"source":"iana","compressible":true},"application/vnd.dbf":{"source":"iana","extensions":["dbf"]},"application/vnd.debian.binary-package":{"source":"iana"},"application/vnd.dece.data":{"source":"iana","extensions":["uvf","uvvf","uvd","uvvd"]},"application/vnd.dece.ttml+xml":{"source":"iana","compressible":true,"extensions":["uvt","uvvt"]},"application/vnd.dece.unspecified":{"source":"iana","extensions":["uvx","uvvx"]},"application/vnd.dece.zip":{"source":"iana","extensions":["uvz","uvvz"]},"application/vnd.denovo.fcselayout-link":{"source":"iana","extensions":["fe_launch"]},"application/vnd.desmume.movie":{"source":"iana"},"application/vnd.dir-bi.plate-dl-nosuffix":{"source":"iana"},"application/vnd.dm.delegation+xml":{"source":"iana","compressible":true},"application/vnd.dna":{"source":"iana","extensions":["dna"]},"application/vnd.document+json":{"source":"iana","compressible":true},"application/vnd.dolby.mlp":{"source":"apache","extensions":["mlp"]},"application/vnd.dolby.mobile.1":{"source":"iana"},"application/vnd.dolby.mobile.2":{"source":"iana"},"application/vnd.doremir.scorecloud-binary-document":{"source":"iana"},"application/vnd.dpgraph":{"source":"iana","extensions":["dpg"]},"application/vnd.dreamfactory":{"source":"iana","extensions":["dfac"]},"application/vnd.drive+json":{"source":"iana","compressible":true},"application/vnd.ds-keypoint":{"source":"apache","extensions":["kpxx"]},"application/vnd.dtg.local":{"source":"iana"},"application/vnd.dtg.local.flash":{"source":"iana"},"application/vnd.dtg.local.html":{"source":"iana"},"application/vnd.dvb.ait":{"source":"iana","extensions":["ait"]},"application/vnd.dvb.dvbisl+xml":{"source":"iana","compressible":true},"application/vnd.dvb.dvbj":{"source":"iana"},"application/vnd.dvb.esgcontainer":{"source":"iana"},"application/vnd.dvb.ipdcdftnotifaccess":{"source":"iana"},"application/vnd.dvb.ipdcesgaccess":{"source":"iana"},"application/vnd.dvb.ipdcesgaccess2":{"source":"iana"},"application/vnd.dvb.ipdcesgpdd":{"source":"iana"},"application/vnd.dvb.ipdcroaming":{"source":"iana"},"application/vnd.dvb.iptv.alfec-base":{"source":"iana"},"application/vnd.dvb.iptv.alfec-enhancement":{"source":"iana"},"application/vnd.dvb.notif-aggregate-root+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-container+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-generic+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-ia-msglist+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-ia-registration-request+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-ia-registration-response+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-init+xml":{"source":"iana","compressible":true},"application/vnd.dvb.pfr":{"source":"iana"},"application/vnd.dvb.service":{"source":"iana","extensions":["svc"]},"application/vnd.dxr":{"source":"iana"},"application/vnd.dynageo":{"source":"iana","extensions":["geo"]},"application/vnd.dzr":{"source":"iana"},"application/vnd.easykaraoke.cdgdownload":{"source":"iana"},"application/vnd.ecdis-update":{"source":"iana"},"application/vnd.ecip.rlp":{"source":"iana"},"application/vnd.eclipse.ditto+json":{"source":"iana","compressible":true},"application/vnd.ecowin.chart":{"source":"iana","extensions":["mag"]},"application/vnd.ecowin.filerequest":{"source":"iana"},"application/vnd.ecowin.fileupdate":{"source":"iana"},"application/vnd.ecowin.series":{"source":"iana"},"application/vnd.ecowin.seriesrequest":{"source":"iana"},"application/vnd.ecowin.seriesupdate":{"source":"iana"},"application/vnd.efi.img":{"source":"iana"},"application/vnd.efi.iso":{"source":"iana"},"application/vnd.emclient.accessrequest+xml":{"source":"iana","compressible":true},"application/vnd.enliven":{"source":"iana","extensions":["nml"]},"application/vnd.enphase.envoy":{"source":"iana"},"application/vnd.eprints.data+xml":{"source":"iana","compressible":true},"application/vnd.epson.esf":{"source":"iana","extensions":["esf"]},"application/vnd.epson.msf":{"source":"iana","extensions":["msf"]},"application/vnd.epson.quickanime":{"source":"iana","extensions":["qam"]},"application/vnd.epson.salt":{"source":"iana","extensions":["slt"]},"application/vnd.epson.ssf":{"source":"iana","extensions":["ssf"]},"application/vnd.ericsson.quickcall":{"source":"iana"},"application/vnd.espass-espass+zip":{"source":"iana","compressible":false},"application/vnd.eszigno3+xml":{"source":"iana","compressible":true,"extensions":["es3","et3"]},"application/vnd.etsi.aoc+xml":{"source":"iana","compressible":true},"application/vnd.etsi.asic-e+zip":{"source":"iana","compressible":false},"application/vnd.etsi.asic-s+zip":{"source":"iana","compressible":false},"application/vnd.etsi.cug+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvcommand+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvdiscovery+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvprofile+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvsad-bc+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvsad-cod+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvsad-npvr+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvservice+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvsync+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvueprofile+xml":{"source":"iana","compressible":true},"application/vnd.etsi.mcid+xml":{"source":"iana","compressible":true},"application/vnd.etsi.mheg5":{"source":"iana"},"application/vnd.etsi.overload-control-policy-dataset+xml":{"source":"iana","compressible":true},"application/vnd.etsi.pstn+xml":{"source":"iana","compressible":true},"application/vnd.etsi.sci+xml":{"source":"iana","compressible":true},"application/vnd.etsi.simservs+xml":{"source":"iana","compressible":true},"application/vnd.etsi.timestamp-token":{"source":"iana"},"application/vnd.etsi.tsl+xml":{"source":"iana","compressible":true},"application/vnd.etsi.tsl.der":{"source":"iana"},"application/vnd.eu.kasparian.car+json":{"source":"iana","compressible":true},"application/vnd.eudora.data":{"source":"iana"},"application/vnd.evolv.ecig.profile":{"source":"iana"},"application/vnd.evolv.ecig.settings":{"source":"iana"},"application/vnd.evolv.ecig.theme":{"source":"iana"},"application/vnd.exstream-empower+zip":{"source":"iana","compressible":false},"application/vnd.exstream-package":{"source":"iana"},"application/vnd.ezpix-album":{"source":"iana","extensions":["ez2"]},"application/vnd.ezpix-package":{"source":"iana","extensions":["ez3"]},"application/vnd.f-secure.mobile":{"source":"iana"},"application/vnd.familysearch.gedcom+zip":{"source":"iana","compressible":false},"application/vnd.fastcopy-disk-image":{"source":"iana"},"application/vnd.fdf":{"source":"iana","extensions":["fdf"]},"application/vnd.fdsn.mseed":{"source":"iana","extensions":["mseed"]},"application/vnd.fdsn.seed":{"source":"iana","extensions":["seed","dataless"]},"application/vnd.ffsns":{"source":"iana"},"application/vnd.ficlab.flb+zip":{"source":"iana","compressible":false},"application/vnd.filmit.zfc":{"source":"iana"},"application/vnd.fints":{"source":"iana"},"application/vnd.firemonkeys.cloudcell":{"source":"iana"},"application/vnd.flographit":{"source":"iana","extensions":["gph"]},"application/vnd.fluxtime.clip":{"source":"iana","extensions":["ftc"]},"application/vnd.font-fontforge-sfd":{"source":"iana"},"application/vnd.framemaker":{"source":"iana","extensions":["fm","frame","maker","book"]},"application/vnd.frogans.fnc":{"source":"iana","extensions":["fnc"]},"application/vnd.frogans.ltf":{"source":"iana","extensions":["ltf"]},"application/vnd.fsc.weblaunch":{"source":"iana","extensions":["fsc"]},"application/vnd.fujifilm.fb.docuworks":{"source":"iana"},"application/vnd.fujifilm.fb.docuworks.binder":{"source":"iana"},"application/vnd.fujifilm.fb.docuworks.container":{"source":"iana"},"application/vnd.fujifilm.fb.jfi+xml":{"source":"iana","compressible":true},"application/vnd.fujitsu.oasys":{"source":"iana","extensions":["oas"]},"application/vnd.fujitsu.oasys2":{"source":"iana","extensions":["oa2"]},"application/vnd.fujitsu.oasys3":{"source":"iana","extensions":["oa3"]},"application/vnd.fujitsu.oasysgp":{"source":"iana","extensions":["fg5"]},"application/vnd.fujitsu.oasysprs":{"source":"iana","extensions":["bh2"]},"application/vnd.fujixerox.art-ex":{"source":"iana"},"application/vnd.fujixerox.art4":{"source":"iana"},"application/vnd.fujixerox.ddd":{"source":"iana","extensions":["ddd"]},"application/vnd.fujixerox.docuworks":{"source":"iana","extensions":["xdw"]},"application/vnd.fujixerox.docuworks.binder":{"source":"iana","extensions":["xbd"]},"application/vnd.fujixerox.docuworks.container":{"source":"iana"},"application/vnd.fujixerox.hbpl":{"source":"iana"},"application/vnd.fut-misnet":{"source":"iana"},"application/vnd.futoin+cbor":{"source":"iana"},"application/vnd.futoin+json":{"source":"iana","compressible":true},"application/vnd.fuzzysheet":{"source":"iana","extensions":["fzs"]},"application/vnd.genomatix.tuxedo":{"source":"iana","extensions":["txd"]},"application/vnd.gentics.grd+json":{"source":"iana","compressible":true},"application/vnd.geo+json":{"source":"iana","compressible":true},"application/vnd.geocube+xml":{"source":"iana","compressible":true},"application/vnd.geogebra.file":{"source":"iana","extensions":["ggb"]},"application/vnd.geogebra.slides":{"source":"iana"},"application/vnd.geogebra.tool":{"source":"iana","extensions":["ggt"]},"application/vnd.geometry-explorer":{"source":"iana","extensions":["gex","gre"]},"application/vnd.geonext":{"source":"iana","extensions":["gxt"]},"application/vnd.geoplan":{"source":"iana","extensions":["g2w"]},"application/vnd.geospace":{"source":"iana","extensions":["g3w"]},"application/vnd.gerber":{"source":"iana"},"application/vnd.globalplatform.card-content-mgt":{"source":"iana"},"application/vnd.globalplatform.card-content-mgt-response":{"source":"iana"},"application/vnd.gmx":{"source":"iana","extensions":["gmx"]},"application/vnd.google-apps.document":{"compressible":false,"extensions":["gdoc"]},"application/vnd.google-apps.presentation":{"compressible":false,"extensions":["gslides"]},"application/vnd.google-apps.spreadsheet":{"compressible":false,"extensions":["gsheet"]},"application/vnd.google-earth.kml+xml":{"source":"iana","compressible":true,"extensions":["kml"]},"application/vnd.google-earth.kmz":{"source":"iana","compressible":false,"extensions":["kmz"]},"application/vnd.gov.sk.e-form+xml":{"source":"iana","compressible":true},"application/vnd.gov.sk.e-form+zip":{"source":"iana","compressible":false},"application/vnd.gov.sk.xmldatacontainer+xml":{"source":"iana","compressible":true},"application/vnd.grafeq":{"source":"iana","extensions":["gqf","gqs"]},"application/vnd.gridmp":{"source":"iana"},"application/vnd.groove-account":{"source":"iana","extensions":["gac"]},"application/vnd.groove-help":{"source":"iana","extensions":["ghf"]},"application/vnd.groove-identity-message":{"source":"iana","extensions":["gim"]},"application/vnd.groove-injector":{"source":"iana","extensions":["grv"]},"application/vnd.groove-tool-message":{"source":"iana","extensions":["gtm"]},"application/vnd.groove-tool-template":{"source":"iana","extensions":["tpl"]},"application/vnd.groove-vcard":{"source":"iana","extensions":["vcg"]},"application/vnd.hal+json":{"source":"iana","compressible":true},"application/vnd.hal+xml":{"source":"iana","compressible":true,"extensions":["hal"]},"application/vnd.handheld-entertainment+xml":{"source":"iana","compressible":true,"extensions":["zmm"]},"application/vnd.hbci":{"source":"iana","extensions":["hbci"]},"application/vnd.hc+json":{"source":"iana","compressible":true},"application/vnd.hcl-bireports":{"source":"iana"},"application/vnd.hdt":{"source":"iana"},"application/vnd.heroku+json":{"source":"iana","compressible":true},"application/vnd.hhe.lesson-player":{"source":"iana","extensions":["les"]},"application/vnd.hl7cda+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.hl7v2+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.hp-hpgl":{"source":"iana","extensions":["hpgl"]},"application/vnd.hp-hpid":{"source":"iana","extensions":["hpid"]},"application/vnd.hp-hps":{"source":"iana","extensions":["hps"]},"application/vnd.hp-jlyt":{"source":"iana","extensions":["jlt"]},"application/vnd.hp-pcl":{"source":"iana","extensions":["pcl"]},"application/vnd.hp-pclxl":{"source":"iana","extensions":["pclxl"]},"application/vnd.httphone":{"source":"iana"},"application/vnd.hydrostatix.sof-data":{"source":"iana","extensions":["sfd-hdstx"]},"application/vnd.hyper+json":{"source":"iana","compressible":true},"application/vnd.hyper-item+json":{"source":"iana","compressible":true},"application/vnd.hyperdrive+json":{"source":"iana","compressible":true},"application/vnd.hzn-3d-crossword":{"source":"iana"},"application/vnd.ibm.afplinedata":{"source":"iana"},"application/vnd.ibm.electronic-media":{"source":"iana"},"application/vnd.ibm.minipay":{"source":"iana","extensions":["mpy"]},"application/vnd.ibm.modcap":{"source":"iana","extensions":["afp","listafp","list3820"]},"application/vnd.ibm.rights-management":{"source":"iana","extensions":["irm"]},"application/vnd.ibm.secure-container":{"source":"iana","extensions":["sc"]},"application/vnd.iccprofile":{"source":"iana","extensions":["icc","icm"]},"application/vnd.ieee.1905":{"source":"iana"},"application/vnd.igloader":{"source":"iana","extensions":["igl"]},"application/vnd.imagemeter.folder+zip":{"source":"iana","compressible":false},"application/vnd.imagemeter.image+zip":{"source":"iana","compressible":false},"application/vnd.immervision-ivp":{"source":"iana","extensions":["ivp"]},"application/vnd.immervision-ivu":{"source":"iana","extensions":["ivu"]},"application/vnd.ims.imsccv1p1":{"source":"iana"},"application/vnd.ims.imsccv1p2":{"source":"iana"},"application/vnd.ims.imsccv1p3":{"source":"iana"},"application/vnd.ims.lis.v2.result+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolconsumerprofile+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolproxy+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolproxy.id+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolsettings+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolsettings.simple+json":{"source":"iana","compressible":true},"application/vnd.informedcontrol.rms+xml":{"source":"iana","compressible":true},"application/vnd.informix-visionary":{"source":"iana"},"application/vnd.infotech.project":{"source":"iana"},"application/vnd.infotech.project+xml":{"source":"iana","compressible":true},"application/vnd.innopath.wamp.notification":{"source":"iana"},"application/vnd.insors.igm":{"source":"iana","extensions":["igm"]},"application/vnd.intercon.formnet":{"source":"iana","extensions":["xpw","xpx"]},"application/vnd.intergeo":{"source":"iana","extensions":["i2g"]},"application/vnd.intertrust.digibox":{"source":"iana"},"application/vnd.intertrust.nncp":{"source":"iana"},"application/vnd.intu.qbo":{"source":"iana","extensions":["qbo"]},"application/vnd.intu.qfx":{"source":"iana","extensions":["qfx"]},"application/vnd.iptc.g2.catalogitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.conceptitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.knowledgeitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.newsitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.newsmessage+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.packageitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.planningitem+xml":{"source":"iana","compressible":true},"application/vnd.ipunplugged.rcprofile":{"source":"iana","extensions":["rcprofile"]},"application/vnd.irepository.package+xml":{"source":"iana","compressible":true,"extensions":["irp"]},"application/vnd.is-xpr":{"source":"iana","extensions":["xpr"]},"application/vnd.isac.fcs":{"source":"iana","extensions":["fcs"]},"application/vnd.iso11783-10+zip":{"source":"iana","compressible":false},"application/vnd.jam":{"source":"iana","extensions":["jam"]},"application/vnd.japannet-directory-service":{"source":"iana"},"application/vnd.japannet-jpnstore-wakeup":{"source":"iana"},"application/vnd.japannet-payment-wakeup":{"source":"iana"},"application/vnd.japannet-registration":{"source":"iana"},"application/vnd.japannet-registration-wakeup":{"source":"iana"},"application/vnd.japannet-setstore-wakeup":{"source":"iana"},"application/vnd.japannet-verification":{"source":"iana"},"application/vnd.japannet-verification-wakeup":{"source":"iana"},"application/vnd.jcp.javame.midlet-rms":{"source":"iana","extensions":["rms"]},"application/vnd.jisp":{"source":"iana","extensions":["jisp"]},"application/vnd.joost.joda-archive":{"source":"iana","extensions":["joda"]},"application/vnd.jsk.isdn-ngn":{"source":"iana"},"application/vnd.kahootz":{"source":"iana","extensions":["ktz","ktr"]},"application/vnd.kde.karbon":{"source":"iana","extensions":["karbon"]},"application/vnd.kde.kchart":{"source":"iana","extensions":["chrt"]},"application/vnd.kde.kformula":{"source":"iana","extensions":["kfo"]},"application/vnd.kde.kivio":{"source":"iana","extensions":["flw"]},"application/vnd.kde.kontour":{"source":"iana","extensions":["kon"]},"application/vnd.kde.kpresenter":{"source":"iana","extensions":["kpr","kpt"]},"application/vnd.kde.kspread":{"source":"iana","extensions":["ksp"]},"application/vnd.kde.kword":{"source":"iana","extensions":["kwd","kwt"]},"application/vnd.kenameaapp":{"source":"iana","extensions":["htke"]},"application/vnd.kidspiration":{"source":"iana","extensions":["kia"]},"application/vnd.kinar":{"source":"iana","extensions":["kne","knp"]},"application/vnd.koan":{"source":"iana","extensions":["skp","skd","skt","skm"]},"application/vnd.kodak-descriptor":{"source":"iana","extensions":["sse"]},"application/vnd.las":{"source":"iana"},"application/vnd.las.las+json":{"source":"iana","compressible":true},"application/vnd.las.las+xml":{"source":"iana","compressible":true,"extensions":["lasxml"]},"application/vnd.laszip":{"source":"iana"},"application/vnd.leap+json":{"source":"iana","compressible":true},"application/vnd.liberty-request+xml":{"source":"iana","compressible":true},"application/vnd.llamagraphics.life-balance.desktop":{"source":"iana","extensions":["lbd"]},"application/vnd.llamagraphics.life-balance.exchange+xml":{"source":"iana","compressible":true,"extensions":["lbe"]},"application/vnd.logipipe.circuit+zip":{"source":"iana","compressible":false},"application/vnd.loom":{"source":"iana"},"application/vnd.lotus-1-2-3":{"source":"iana","extensions":["123"]},"application/vnd.lotus-approach":{"source":"iana","extensions":["apr"]},"application/vnd.lotus-freelance":{"source":"iana","extensions":["pre"]},"application/vnd.lotus-notes":{"source":"iana","extensions":["nsf"]},"application/vnd.lotus-organizer":{"source":"iana","extensions":["org"]},"application/vnd.lotus-screencam":{"source":"iana","extensions":["scm"]},"application/vnd.lotus-wordpro":{"source":"iana","extensions":["lwp"]},"application/vnd.macports.portpkg":{"source":"iana","extensions":["portpkg"]},"application/vnd.mapbox-vector-tile":{"source":"iana","extensions":["mvt"]},"application/vnd.marlin.drm.actiontoken+xml":{"source":"iana","compressible":true},"application/vnd.marlin.drm.conftoken+xml":{"source":"iana","compressible":true},"application/vnd.marlin.drm.license+xml":{"source":"iana","compressible":true},"application/vnd.marlin.drm.mdcf":{"source":"iana"},"application/vnd.mason+json":{"source":"iana","compressible":true},"application/vnd.maxar.archive.3tz+zip":{"source":"iana","compressible":false},"application/vnd.maxmind.maxmind-db":{"source":"iana"},"application/vnd.mcd":{"source":"iana","extensions":["mcd"]},"application/vnd.medcalcdata":{"source":"iana","extensions":["mc1"]},"application/vnd.mediastation.cdkey":{"source":"iana","extensions":["cdkey"]},"application/vnd.meridian-slingshot":{"source":"iana"},"application/vnd.mfer":{"source":"iana","extensions":["mwf"]},"application/vnd.mfmp":{"source":"iana","extensions":["mfm"]},"application/vnd.micro+json":{"source":"iana","compressible":true},"application/vnd.micrografx.flo":{"source":"iana","extensions":["flo"]},"application/vnd.micrografx.igx":{"source":"iana","extensions":["igx"]},"application/vnd.microsoft.portable-executable":{"source":"iana"},"application/vnd.microsoft.windows.thumbnail-cache":{"source":"iana"},"application/vnd.miele+json":{"source":"iana","compressible":true},"application/vnd.mif":{"source":"iana","extensions":["mif"]},"application/vnd.minisoft-hp3000-save":{"source":"iana"},"application/vnd.mitsubishi.misty-guard.trustweb":{"source":"iana"},"application/vnd.mobius.daf":{"source":"iana","extensions":["daf"]},"application/vnd.mobius.dis":{"source":"iana","extensions":["dis"]},"application/vnd.mobius.mbk":{"source":"iana","extensions":["mbk"]},"application/vnd.mobius.mqy":{"source":"iana","extensions":["mqy"]},"application/vnd.mobius.msl":{"source":"iana","extensions":["msl"]},"application/vnd.mobius.plc":{"source":"iana","extensions":["plc"]},"application/vnd.mobius.txf":{"source":"iana","extensions":["txf"]},"application/vnd.mophun.application":{"source":"iana","extensions":["mpn"]},"application/vnd.mophun.certificate":{"source":"iana","extensions":["mpc"]},"application/vnd.motorola.flexsuite":{"source":"iana"},"application/vnd.motorola.flexsuite.adsi":{"source":"iana"},"application/vnd.motorola.flexsuite.fis":{"source":"iana"},"application/vnd.motorola.flexsuite.gotap":{"source":"iana"},"application/vnd.motorola.flexsuite.kmr":{"source":"iana"},"application/vnd.motorola.flexsuite.ttc":{"source":"iana"},"application/vnd.motorola.flexsuite.wem":{"source":"iana"},"application/vnd.motorola.iprm":{"source":"iana"},"application/vnd.mozilla.xul+xml":{"source":"iana","compressible":true,"extensions":["xul"]},"application/vnd.ms-3mfdocument":{"source":"iana"},"application/vnd.ms-artgalry":{"source":"iana","extensions":["cil"]},"application/vnd.ms-asf":{"source":"iana"},"application/vnd.ms-cab-compressed":{"source":"iana","extensions":["cab"]},"application/vnd.ms-color.iccprofile":{"source":"apache"},"application/vnd.ms-excel":{"source":"iana","compressible":false,"extensions":["xls","xlm","xla","xlc","xlt","xlw"]},"application/vnd.ms-excel.addin.macroenabled.12":{"source":"iana","extensions":["xlam"]},"application/vnd.ms-excel.sheet.binary.macroenabled.12":{"source":"iana","extensions":["xlsb"]},"application/vnd.ms-excel.sheet.macroenabled.12":{"source":"iana","extensions":["xlsm"]},"application/vnd.ms-excel.template.macroenabled.12":{"source":"iana","extensions":["xltm"]},"application/vnd.ms-fontobject":{"source":"iana","compressible":true,"extensions":["eot"]},"application/vnd.ms-htmlhelp":{"source":"iana","extensions":["chm"]},"application/vnd.ms-ims":{"source":"iana","extensions":["ims"]},"application/vnd.ms-lrm":{"source":"iana","extensions":["lrm"]},"application/vnd.ms-office.activex+xml":{"source":"iana","compressible":true},"application/vnd.ms-officetheme":{"source":"iana","extensions":["thmx"]},"application/vnd.ms-opentype":{"source":"apache","compressible":true},"application/vnd.ms-outlook":{"compressible":false,"extensions":["msg"]},"application/vnd.ms-package.obfuscated-opentype":{"source":"apache"},"application/vnd.ms-pki.seccat":{"source":"apache","extensions":["cat"]},"application/vnd.ms-pki.stl":{"source":"apache","extensions":["stl"]},"application/vnd.ms-playready.initiator+xml":{"source":"iana","compressible":true},"application/vnd.ms-powerpoint":{"source":"iana","compressible":false,"extensions":["ppt","pps","pot"]},"application/vnd.ms-powerpoint.addin.macroenabled.12":{"source":"iana","extensions":["ppam"]},"application/vnd.ms-powerpoint.presentation.macroenabled.12":{"source":"iana","extensions":["pptm"]},"application/vnd.ms-powerpoint.slide.macroenabled.12":{"source":"iana","extensions":["sldm"]},"application/vnd.ms-powerpoint.slideshow.macroenabled.12":{"source":"iana","extensions":["ppsm"]},"application/vnd.ms-powerpoint.template.macroenabled.12":{"source":"iana","extensions":["potm"]},"application/vnd.ms-printdevicecapabilities+xml":{"source":"iana","compressible":true},"application/vnd.ms-printing.printticket+xml":{"source":"apache","compressible":true},"application/vnd.ms-printschematicket+xml":{"source":"iana","compressible":true},"application/vnd.ms-project":{"source":"iana","extensions":["mpp","mpt"]},"application/vnd.ms-tnef":{"source":"iana"},"application/vnd.ms-windows.devicepairing":{"source":"iana"},"application/vnd.ms-windows.nwprinting.oob":{"source":"iana"},"application/vnd.ms-windows.printerpairing":{"source":"iana"},"application/vnd.ms-windows.wsd.oob":{"source":"iana"},"application/vnd.ms-wmdrm.lic-chlg-req":{"source":"iana"},"application/vnd.ms-wmdrm.lic-resp":{"source":"iana"},"application/vnd.ms-wmdrm.meter-chlg-req":{"source":"iana"},"application/vnd.ms-wmdrm.meter-resp":{"source":"iana"},"application/vnd.ms-word.document.macroenabled.12":{"source":"iana","extensions":["docm"]},"application/vnd.ms-word.template.macroenabled.12":{"source":"iana","extensions":["dotm"]},"application/vnd.ms-works":{"source":"iana","extensions":["wps","wks","wcm","wdb"]},"application/vnd.ms-wpl":{"source":"iana","extensions":["wpl"]},"application/vnd.ms-xpsdocument":{"source":"iana","compressible":false,"extensions":["xps"]},"application/vnd.msa-disk-image":{"source":"iana"},"application/vnd.mseq":{"source":"iana","extensions":["mseq"]},"application/vnd.msign":{"source":"iana"},"application/vnd.multiad.creator":{"source":"iana"},"application/vnd.multiad.creator.cif":{"source":"iana"},"application/vnd.music-niff":{"source":"iana"},"application/vnd.musician":{"source":"iana","extensions":["mus"]},"application/vnd.muvee.style":{"source":"iana","extensions":["msty"]},"application/vnd.mynfc":{"source":"iana","extensions":["taglet"]},"application/vnd.nacamar.ybrid+json":{"source":"iana","compressible":true},"application/vnd.ncd.control":{"source":"iana"},"application/vnd.ncd.reference":{"source":"iana"},"application/vnd.nearst.inv+json":{"source":"iana","compressible":true},"application/vnd.nebumind.line":{"source":"iana"},"application/vnd.nervana":{"source":"iana"},"application/vnd.netfpx":{"source":"iana"},"application/vnd.neurolanguage.nlu":{"source":"iana","extensions":["nlu"]},"application/vnd.nimn":{"source":"iana"},"application/vnd.nintendo.nitro.rom":{"source":"iana"},"application/vnd.nintendo.snes.rom":{"source":"iana"},"application/vnd.nitf":{"source":"iana","extensions":["ntf","nitf"]},"application/vnd.noblenet-directory":{"source":"iana","extensions":["nnd"]},"application/vnd.noblenet-sealer":{"source":"iana","extensions":["nns"]},"application/vnd.noblenet-web":{"source":"iana","extensions":["nnw"]},"application/vnd.nokia.catalogs":{"source":"iana"},"application/vnd.nokia.conml+wbxml":{"source":"iana"},"application/vnd.nokia.conml+xml":{"source":"iana","compressible":true},"application/vnd.nokia.iptv.config+xml":{"source":"iana","compressible":true},"application/vnd.nokia.isds-radio-presets":{"source":"iana"},"application/vnd.nokia.landmark+wbxml":{"source":"iana"},"application/vnd.nokia.landmark+xml":{"source":"iana","compressible":true},"application/vnd.nokia.landmarkcollection+xml":{"source":"iana","compressible":true},"application/vnd.nokia.n-gage.ac+xml":{"source":"iana","compressible":true,"extensions":["ac"]},"application/vnd.nokia.n-gage.data":{"source":"iana","extensions":["ngdat"]},"application/vnd.nokia.n-gage.symbian.install":{"source":"iana","extensions":["n-gage"]},"application/vnd.nokia.ncd":{"source":"iana"},"application/vnd.nokia.pcd+wbxml":{"source":"iana"},"application/vnd.nokia.pcd+xml":{"source":"iana","compressible":true},"application/vnd.nokia.radio-preset":{"source":"iana","extensions":["rpst"]},"application/vnd.nokia.radio-presets":{"source":"iana","extensions":["rpss"]},"application/vnd.novadigm.edm":{"source":"iana","extensions":["edm"]},"application/vnd.novadigm.edx":{"source":"iana","extensions":["edx"]},"application/vnd.novadigm.ext":{"source":"iana","extensions":["ext"]},"application/vnd.ntt-local.content-share":{"source":"iana"},"application/vnd.ntt-local.file-transfer":{"source":"iana"},"application/vnd.ntt-local.ogw_remote-access":{"source":"iana"},"application/vnd.ntt-local.sip-ta_remote":{"source":"iana"},"application/vnd.ntt-local.sip-ta_tcp_stream":{"source":"iana"},"application/vnd.oasis.opendocument.chart":{"source":"iana","extensions":["odc"]},"application/vnd.oasis.opendocument.chart-template":{"source":"iana","extensions":["otc"]},"application/vnd.oasis.opendocument.database":{"source":"iana","extensions":["odb"]},"application/vnd.oasis.opendocument.formula":{"source":"iana","extensions":["odf"]},"application/vnd.oasis.opendocument.formula-template":{"source":"iana","extensions":["odft"]},"application/vnd.oasis.opendocument.graphics":{"source":"iana","compressible":false,"extensions":["odg"]},"application/vnd.oasis.opendocument.graphics-template":{"source":"iana","extensions":["otg"]},"application/vnd.oasis.opendocument.image":{"source":"iana","extensions":["odi"]},"application/vnd.oasis.opendocument.image-template":{"source":"iana","extensions":["oti"]},"application/vnd.oasis.opendocument.presentation":{"source":"iana","compressible":false,"extensions":["odp"]},"application/vnd.oasis.opendocument.presentation-template":{"source":"iana","extensions":["otp"]},"application/vnd.oasis.opendocument.spreadsheet":{"source":"iana","compressible":false,"extensions":["ods"]},"application/vnd.oasis.opendocument.spreadsheet-template":{"source":"iana","extensions":["ots"]},"application/vnd.oasis.opendocument.text":{"source":"iana","compressible":false,"extensions":["odt"]},"application/vnd.oasis.opendocument.text-master":{"source":"iana","extensions":["odm"]},"application/vnd.oasis.opendocument.text-template":{"source":"iana","extensions":["ott"]},"application/vnd.oasis.opendocument.text-web":{"source":"iana","extensions":["oth"]},"application/vnd.obn":{"source":"iana"},"application/vnd.ocf+cbor":{"source":"iana"},"application/vnd.oci.image.manifest.v1+json":{"source":"iana","compressible":true},"application/vnd.oftn.l10n+json":{"source":"iana","compressible":true},"application/vnd.oipf.contentaccessdownload+xml":{"source":"iana","compressible":true},"application/vnd.oipf.contentaccessstreaming+xml":{"source":"iana","compressible":true},"application/vnd.oipf.cspg-hexbinary":{"source":"iana"},"application/vnd.oipf.dae.svg+xml":{"source":"iana","compressible":true},"application/vnd.oipf.dae.xhtml+xml":{"source":"iana","compressible":true},"application/vnd.oipf.mippvcontrolmessage+xml":{"source":"iana","compressible":true},"application/vnd.oipf.pae.gem":{"source":"iana"},"application/vnd.oipf.spdiscovery+xml":{"source":"iana","compressible":true},"application/vnd.oipf.spdlist+xml":{"source":"iana","compressible":true},"application/vnd.oipf.ueprofile+xml":{"source":"iana","compressible":true},"application/vnd.oipf.userprofile+xml":{"source":"iana","compressible":true},"application/vnd.olpc-sugar":{"source":"iana","extensions":["xo"]},"application/vnd.oma-scws-config":{"source":"iana"},"application/vnd.oma-scws-http-request":{"source":"iana"},"application/vnd.oma-scws-http-response":{"source":"iana"},"application/vnd.oma.bcast.associated-procedure-parameter+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.drm-trigger+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.imd+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.ltkm":{"source":"iana"},"application/vnd.oma.bcast.notification+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.provisioningtrigger":{"source":"iana"},"application/vnd.oma.bcast.sgboot":{"source":"iana"},"application/vnd.oma.bcast.sgdd+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.sgdu":{"source":"iana"},"application/vnd.oma.bcast.simple-symbol-container":{"source":"iana"},"application/vnd.oma.bcast.smartcard-trigger+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.sprov+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.stkm":{"source":"iana"},"application/vnd.oma.cab-address-book+xml":{"source":"iana","compressible":true},"application/vnd.oma.cab-feature-handler+xml":{"source":"iana","compressible":true},"application/vnd.oma.cab-pcc+xml":{"source":"iana","compressible":true},"application/vnd.oma.cab-subs-invite+xml":{"source":"iana","compressible":true},"application/vnd.oma.cab-user-prefs+xml":{"source":"iana","compressible":true},"application/vnd.oma.dcd":{"source":"iana"},"application/vnd.oma.dcdc":{"source":"iana"},"application/vnd.oma.dd2+xml":{"source":"iana","compressible":true,"extensions":["dd2"]},"application/vnd.oma.drm.risd+xml":{"source":"iana","compressible":true},"application/vnd.oma.group-usage-list+xml":{"source":"iana","compressible":true},"application/vnd.oma.lwm2m+cbor":{"source":"iana"},"application/vnd.oma.lwm2m+json":{"source":"iana","compressible":true},"application/vnd.oma.lwm2m+tlv":{"source":"iana"},"application/vnd.oma.pal+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.detailed-progress-report+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.final-report+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.groups+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.invocation-descriptor+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.optimized-progress-report+xml":{"source":"iana","compressible":true},"application/vnd.oma.push":{"source":"iana"},"application/vnd.oma.scidm.messages+xml":{"source":"iana","compressible":true},"application/vnd.oma.xcap-directory+xml":{"source":"iana","compressible":true},"application/vnd.omads-email+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.omads-file+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.omads-folder+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.omaloc-supl-init":{"source":"iana"},"application/vnd.onepager":{"source":"iana"},"application/vnd.onepagertamp":{"source":"iana"},"application/vnd.onepagertamx":{"source":"iana"},"application/vnd.onepagertat":{"source":"iana"},"application/vnd.onepagertatp":{"source":"iana"},"application/vnd.onepagertatx":{"source":"iana"},"application/vnd.openblox.game+xml":{"source":"iana","compressible":true,"extensions":["obgx"]},"application/vnd.openblox.game-binary":{"source":"iana"},"application/vnd.openeye.oeb":{"source":"iana"},"application/vnd.openofficeorg.extension":{"source":"apache","extensions":["oxt"]},"application/vnd.openstreetmap.data+xml":{"source":"iana","compressible":true,"extensions":["osm"]},"application/vnd.opentimestamps.ots":{"source":"iana"},"application/vnd.openxmlformats-officedocument.custom-properties+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.customxmlproperties+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawing+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.chart+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.extended-properties+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.comments+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.presentation":{"source":"iana","compressible":false,"extensions":["pptx"]},"application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.presprops+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slide":{"source":"iana","extensions":["sldx"]},"application/vnd.openxmlformats-officedocument.presentationml.slide+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slideshow":{"source":"iana","extensions":["ppsx"]},"application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.tags+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.template":{"source":"iana","extensions":["potx"]},"application/vnd.openxmlformats-officedocument.presentationml.template.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet":{"source":"iana","compressible":false,"extensions":["xlsx"]},"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.template":{"source":"iana","extensions":["xltx"]},"application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.theme+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.themeoverride+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.vmldrawing":{"source":"iana"},"application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.document":{"source":"iana","compressible":false,"extensions":["docx"]},"application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.template":{"source":"iana","extensions":["dotx"]},"application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-package.core-properties+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-package.relationships+xml":{"source":"iana","compressible":true},"application/vnd.oracle.resource+json":{"source":"iana","compressible":true},"application/vnd.orange.indata":{"source":"iana"},"application/vnd.osa.netdeploy":{"source":"iana"},"application/vnd.osgeo.mapguide.package":{"source":"iana","extensions":["mgp"]},"application/vnd.osgi.bundle":{"source":"iana"},"application/vnd.osgi.dp":{"source":"iana","extensions":["dp"]},"application/vnd.osgi.subsystem":{"source":"iana","extensions":["esa"]},"application/vnd.otps.ct-kip+xml":{"source":"iana","compressible":true},"application/vnd.oxli.countgraph":{"source":"iana"},"application/vnd.pagerduty+json":{"source":"iana","compressible":true},"application/vnd.palm":{"source":"iana","extensions":["pdb","pqa","oprc"]},"application/vnd.panoply":{"source":"iana"},"application/vnd.paos.xml":{"source":"iana"},"application/vnd.patentdive":{"source":"iana"},"application/vnd.patientecommsdoc":{"source":"iana"},"application/vnd.pawaafile":{"source":"iana","extensions":["paw"]},"application/vnd.pcos":{"source":"iana"},"application/vnd.pg.format":{"source":"iana","extensions":["str"]},"application/vnd.pg.osasli":{"source":"iana","extensions":["ei6"]},"application/vnd.piaccess.application-licence":{"source":"iana"},"application/vnd.picsel":{"source":"iana","extensions":["efif"]},"application/vnd.pmi.widget":{"source":"iana","extensions":["wg"]},"application/vnd.poc.group-advertisement+xml":{"source":"iana","compressible":true},"application/vnd.pocketlearn":{"source":"iana","extensions":["plf"]},"application/vnd.powerbuilder6":{"source":"iana","extensions":["pbd"]},"application/vnd.powerbuilder6-s":{"source":"iana"},"application/vnd.powerbuilder7":{"source":"iana"},"application/vnd.powerbuilder7-s":{"source":"iana"},"application/vnd.powerbuilder75":{"source":"iana"},"application/vnd.powerbuilder75-s":{"source":"iana"},"application/vnd.preminet":{"source":"iana"},"application/vnd.previewsystems.box":{"source":"iana","extensions":["box"]},"application/vnd.proteus.magazine":{"source":"iana","extensions":["mgz"]},"application/vnd.psfs":{"source":"iana"},"application/vnd.publishare-delta-tree":{"source":"iana","extensions":["qps"]},"application/vnd.pvi.ptid1":{"source":"iana","extensions":["ptid"]},"application/vnd.pwg-multiplexed":{"source":"iana"},"application/vnd.pwg-xhtml-print+xml":{"source":"iana","compressible":true},"application/vnd.qualcomm.brew-app-res":{"source":"iana"},"application/vnd.quarantainenet":{"source":"iana"},"application/vnd.quark.quarkxpress":{"source":"iana","extensions":["qxd","qxt","qwd","qwt","qxl","qxb"]},"application/vnd.quobject-quoxdocument":{"source":"iana"},"application/vnd.radisys.moml+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit-conf+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit-conn+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit-dialog+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit-stream+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-conf+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-base+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-fax-detect+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-fax-sendrecv+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-group+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-speech+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-transform+xml":{"source":"iana","compressible":true},"application/vnd.rainstor.data":{"source":"iana"},"application/vnd.rapid":{"source":"iana"},"application/vnd.rar":{"source":"iana","extensions":["rar"]},"application/vnd.realvnc.bed":{"source":"iana","extensions":["bed"]},"application/vnd.recordare.musicxml":{"source":"iana","extensions":["mxl"]},"application/vnd.recordare.musicxml+xml":{"source":"iana","compressible":true,"extensions":["musicxml"]},"application/vnd.renlearn.rlprint":{"source":"iana"},"application/vnd.resilient.logic":{"source":"iana"},"application/vnd.restful+json":{"source":"iana","compressible":true},"application/vnd.rig.cryptonote":{"source":"iana","extensions":["cryptonote"]},"application/vnd.rim.cod":{"source":"apache","extensions":["cod"]},"application/vnd.rn-realmedia":{"source":"apache","extensions":["rm"]},"application/vnd.rn-realmedia-vbr":{"source":"apache","extensions":["rmvb"]},"application/vnd.route66.link66+xml":{"source":"iana","compressible":true,"extensions":["link66"]},"application/vnd.rs-274x":{"source":"iana"},"application/vnd.ruckus.download":{"source":"iana"},"application/vnd.s3sms":{"source":"iana"},"application/vnd.sailingtracker.track":{"source":"iana","extensions":["st"]},"application/vnd.sar":{"source":"iana"},"application/vnd.sbm.cid":{"source":"iana"},"application/vnd.sbm.mid2":{"source":"iana"},"application/vnd.scribus":{"source":"iana"},"application/vnd.sealed.3df":{"source":"iana"},"application/vnd.sealed.csf":{"source":"iana"},"application/vnd.sealed.doc":{"source":"iana"},"application/vnd.sealed.eml":{"source":"iana"},"application/vnd.sealed.mht":{"source":"iana"},"application/vnd.sealed.net":{"source":"iana"},"application/vnd.sealed.ppt":{"source":"iana"},"application/vnd.sealed.tiff":{"source":"iana"},"application/vnd.sealed.xls":{"source":"iana"},"application/vnd.sealedmedia.softseal.html":{"source":"iana"},"application/vnd.sealedmedia.softseal.pdf":{"source":"iana"},"application/vnd.seemail":{"source":"iana","extensions":["see"]},"application/vnd.seis+json":{"source":"iana","compressible":true},"application/vnd.sema":{"source":"iana","extensions":["sema"]},"application/vnd.semd":{"source":"iana","extensions":["semd"]},"application/vnd.semf":{"source":"iana","extensions":["semf"]},"application/vnd.shade-save-file":{"source":"iana"},"application/vnd.shana.informed.formdata":{"source":"iana","extensions":["ifm"]},"application/vnd.shana.informed.formtemplate":{"source":"iana","extensions":["itp"]},"application/vnd.shana.informed.interchange":{"source":"iana","extensions":["iif"]},"application/vnd.shana.informed.package":{"source":"iana","extensions":["ipk"]},"application/vnd.shootproof+json":{"source":"iana","compressible":true},"application/vnd.shopkick+json":{"source":"iana","compressible":true},"application/vnd.shp":{"source":"iana"},"application/vnd.shx":{"source":"iana"},"application/vnd.sigrok.session":{"source":"iana"},"application/vnd.simtech-mindmapper":{"source":"iana","extensions":["twd","twds"]},"application/vnd.siren+json":{"source":"iana","compressible":true},"application/vnd.smaf":{"source":"iana","extensions":["mmf"]},"application/vnd.smart.notebook":{"source":"iana"},"application/vnd.smart.teacher":{"source":"iana","extensions":["teacher"]},"application/vnd.snesdev-page-table":{"source":"iana"},"application/vnd.software602.filler.form+xml":{"source":"iana","compressible":true,"extensions":["fo"]},"application/vnd.software602.filler.form-xml-zip":{"source":"iana"},"application/vnd.solent.sdkm+xml":{"source":"iana","compressible":true,"extensions":["sdkm","sdkd"]},"application/vnd.spotfire.dxp":{"source":"iana","extensions":["dxp"]},"application/vnd.spotfire.sfs":{"source":"iana","extensions":["sfs"]},"application/vnd.sqlite3":{"source":"iana"},"application/vnd.sss-cod":{"source":"iana"},"application/vnd.sss-dtf":{"source":"iana"},"application/vnd.sss-ntf":{"source":"iana"},"application/vnd.stardivision.calc":{"source":"apache","extensions":["sdc"]},"application/vnd.stardivision.draw":{"source":"apache","extensions":["sda"]},"application/vnd.stardivision.impress":{"source":"apache","extensions":["sdd"]},"application/vnd.stardivision.math":{"source":"apache","extensions":["smf"]},"application/vnd.stardivision.writer":{"source":"apache","extensions":["sdw","vor"]},"application/vnd.stardivision.writer-global":{"source":"apache","extensions":["sgl"]},"application/vnd.stepmania.package":{"source":"iana","extensions":["smzip"]},"application/vnd.stepmania.stepchart":{"source":"iana","extensions":["sm"]},"application/vnd.street-stream":{"source":"iana"},"application/vnd.sun.wadl+xml":{"source":"iana","compressible":true,"extensions":["wadl"]},"application/vnd.sun.xml.calc":{"source":"apache","extensions":["sxc"]},"application/vnd.sun.xml.calc.template":{"source":"apache","extensions":["stc"]},"application/vnd.sun.xml.draw":{"source":"apache","extensions":["sxd"]},"application/vnd.sun.xml.draw.template":{"source":"apache","extensions":["std"]},"application/vnd.sun.xml.impress":{"source":"apache","extensions":["sxi"]},"application/vnd.sun.xml.impress.template":{"source":"apache","extensions":["sti"]},"application/vnd.sun.xml.math":{"source":"apache","extensions":["sxm"]},"application/vnd.sun.xml.writer":{"source":"apache","extensions":["sxw"]},"application/vnd.sun.xml.writer.global":{"source":"apache","extensions":["sxg"]},"application/vnd.sun.xml.writer.template":{"source":"apache","extensions":["stw"]},"application/vnd.sus-calendar":{"source":"iana","extensions":["sus","susp"]},"application/vnd.svd":{"source":"iana","extensions":["svd"]},"application/vnd.swiftview-ics":{"source":"iana"},"application/vnd.sycle+xml":{"source":"iana","compressible":true},"application/vnd.syft+json":{"source":"iana","compressible":true},"application/vnd.symbian.install":{"source":"apache","extensions":["sis","sisx"]},"application/vnd.syncml+xml":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["xsm"]},"application/vnd.syncml.dm+wbxml":{"source":"iana","charset":"UTF-8","extensions":["bdm"]},"application/vnd.syncml.dm+xml":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["xdm"]},"application/vnd.syncml.dm.notification":{"source":"iana"},"application/vnd.syncml.dmddf+wbxml":{"source":"iana"},"application/vnd.syncml.dmddf+xml":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["ddf"]},"application/vnd.syncml.dmtnds+wbxml":{"source":"iana"},"application/vnd.syncml.dmtnds+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.syncml.ds.notification":{"source":"iana"},"application/vnd.tableschema+json":{"source":"iana","compressible":true},"application/vnd.tao.intent-module-archive":{"source":"iana","extensions":["tao"]},"application/vnd.tcpdump.pcap":{"source":"iana","extensions":["pcap","cap","dmp"]},"application/vnd.think-cell.ppttc+json":{"source":"iana","compressible":true},"application/vnd.tmd.mediaflex.api+xml":{"source":"iana","compressible":true},"application/vnd.tml":{"source":"iana"},"application/vnd.tmobile-livetv":{"source":"iana","extensions":["tmo"]},"application/vnd.tri.onesource":{"source":"iana"},"application/vnd.trid.tpt":{"source":"iana","extensions":["tpt"]},"application/vnd.triscape.mxs":{"source":"iana","extensions":["mxs"]},"application/vnd.trueapp":{"source":"iana","extensions":["tra"]},"application/vnd.truedoc":{"source":"iana"},"application/vnd.ubisoft.webplayer":{"source":"iana"},"application/vnd.ufdl":{"source":"iana","extensions":["ufd","ufdl"]},"application/vnd.uiq.theme":{"source":"iana","extensions":["utz"]},"application/vnd.umajin":{"source":"iana","extensions":["umj"]},"application/vnd.unity":{"source":"iana","extensions":["unityweb"]},"application/vnd.uoml+xml":{"source":"iana","compressible":true,"extensions":["uoml"]},"application/vnd.uplanet.alert":{"source":"iana"},"application/vnd.uplanet.alert-wbxml":{"source":"iana"},"application/vnd.uplanet.bearer-choice":{"source":"iana"},"application/vnd.uplanet.bearer-choice-wbxml":{"source":"iana"},"application/vnd.uplanet.cacheop":{"source":"iana"},"application/vnd.uplanet.cacheop-wbxml":{"source":"iana"},"application/vnd.uplanet.channel":{"source":"iana"},"application/vnd.uplanet.channel-wbxml":{"source":"iana"},"application/vnd.uplanet.list":{"source":"iana"},"application/vnd.uplanet.list-wbxml":{"source":"iana"},"application/vnd.uplanet.listcmd":{"source":"iana"},"application/vnd.uplanet.listcmd-wbxml":{"source":"iana"},"application/vnd.uplanet.signal":{"source":"iana"},"application/vnd.uri-map":{"source":"iana"},"application/vnd.valve.source.material":{"source":"iana"},"application/vnd.vcx":{"source":"iana","extensions":["vcx"]},"application/vnd.vd-study":{"source":"iana"},"application/vnd.vectorworks":{"source":"iana"},"application/vnd.vel+json":{"source":"iana","compressible":true},"application/vnd.verimatrix.vcas":{"source":"iana"},"application/vnd.veritone.aion+json":{"source":"iana","compressible":true},"application/vnd.veryant.thin":{"source":"iana"},"application/vnd.ves.encrypted":{"source":"iana"},"application/vnd.vidsoft.vidconference":{"source":"iana"},"application/vnd.visio":{"source":"iana","extensions":["vsd","vst","vss","vsw"]},"application/vnd.visionary":{"source":"iana","extensions":["vis"]},"application/vnd.vividence.scriptfile":{"source":"iana"},"application/vnd.vsf":{"source":"iana","extensions":["vsf"]},"application/vnd.wap.sic":{"source":"iana"},"application/vnd.wap.slc":{"source":"iana"},"application/vnd.wap.wbxml":{"source":"iana","charset":"UTF-8","extensions":["wbxml"]},"application/vnd.wap.wmlc":{"source":"iana","extensions":["wmlc"]},"application/vnd.wap.wmlscriptc":{"source":"iana","extensions":["wmlsc"]},"application/vnd.webturbo":{"source":"iana","extensions":["wtb"]},"application/vnd.wfa.dpp":{"source":"iana"},"application/vnd.wfa.p2p":{"source":"iana"},"application/vnd.wfa.wsc":{"source":"iana"},"application/vnd.windows.devicepairing":{"source":"iana"},"application/vnd.wmc":{"source":"iana"},"application/vnd.wmf.bootstrap":{"source":"iana"},"application/vnd.wolfram.mathematica":{"source":"iana"},"application/vnd.wolfram.mathematica.package":{"source":"iana"},"application/vnd.wolfram.player":{"source":"iana","extensions":["nbp"]},"application/vnd.wordperfect":{"source":"iana","extensions":["wpd"]},"application/vnd.wqd":{"source":"iana","extensions":["wqd"]},"application/vnd.wrq-hp3000-labelled":{"source":"iana"},"application/vnd.wt.stf":{"source":"iana","extensions":["stf"]},"application/vnd.wv.csp+wbxml":{"source":"iana"},"application/vnd.wv.csp+xml":{"source":"iana","compressible":true},"application/vnd.wv.ssp+xml":{"source":"iana","compressible":true},"application/vnd.xacml+json":{"source":"iana","compressible":true},"application/vnd.xara":{"source":"iana","extensions":["xar"]},"application/vnd.xfdl":{"source":"iana","extensions":["xfdl"]},"application/vnd.xfdl.webform":{"source":"iana"},"application/vnd.xmi+xml":{"source":"iana","compressible":true},"application/vnd.xmpie.cpkg":{"source":"iana"},"application/vnd.xmpie.dpkg":{"source":"iana"},"application/vnd.xmpie.plan":{"source":"iana"},"application/vnd.xmpie.ppkg":{"source":"iana"},"application/vnd.xmpie.xlim":{"source":"iana"},"application/vnd.yamaha.hv-dic":{"source":"iana","extensions":["hvd"]},"application/vnd.yamaha.hv-script":{"source":"iana","extensions":["hvs"]},"application/vnd.yamaha.hv-voice":{"source":"iana","extensions":["hvp"]},"application/vnd.yamaha.openscoreformat":{"source":"iana","extensions":["osf"]},"application/vnd.yamaha.openscoreformat.osfpvg+xml":{"source":"iana","compressible":true,"extensions":["osfpvg"]},"application/vnd.yamaha.remote-setup":{"source":"iana"},"application/vnd.yamaha.smaf-audio":{"source":"iana","extensions":["saf"]},"application/vnd.yamaha.smaf-phrase":{"source":"iana","extensions":["spf"]},"application/vnd.yamaha.through-ngn":{"source":"iana"},"application/vnd.yamaha.tunnel-udpencap":{"source":"iana"},"application/vnd.yaoweme":{"source":"iana"},"application/vnd.yellowriver-custom-menu":{"source":"iana","extensions":["cmp"]},"application/vnd.youtube.yt":{"source":"iana"},"application/vnd.zul":{"source":"iana","extensions":["zir","zirz"]},"application/vnd.zzazz.deck+xml":{"source":"iana","compressible":true,"extensions":["zaz"]},"application/voicexml+xml":{"source":"iana","compressible":true,"extensions":["vxml"]},"application/voucher-cms+json":{"source":"iana","compressible":true},"application/vq-rtcpxr":{"source":"iana"},"application/wasm":{"source":"iana","compressible":true,"extensions":["wasm"]},"application/watcherinfo+xml":{"source":"iana","compressible":true,"extensions":["wif"]},"application/webpush-options+json":{"source":"iana","compressible":true},"application/whoispp-query":{"source":"iana"},"application/whoispp-response":{"source":"iana"},"application/widget":{"source":"iana","extensions":["wgt"]},"application/winhlp":{"source":"apache","extensions":["hlp"]},"application/wita":{"source":"iana"},"application/wordperfect5.1":{"source":"iana"},"application/wsdl+xml":{"source":"iana","compressible":true,"extensions":["wsdl"]},"application/wspolicy+xml":{"source":"iana","compressible":true,"extensions":["wspolicy"]},"application/x-7z-compressed":{"source":"apache","compressible":false,"extensions":["7z"]},"application/x-abiword":{"source":"apache","extensions":["abw"]},"application/x-ace-compressed":{"source":"apache","extensions":["ace"]},"application/x-amf":{"source":"apache"},"application/x-apple-diskimage":{"source":"apache","extensions":["dmg"]},"application/x-arj":{"compressible":false,"extensions":["arj"]},"application/x-authorware-bin":{"source":"apache","extensions":["aab","x32","u32","vox"]},"application/x-authorware-map":{"source":"apache","extensions":["aam"]},"application/x-authorware-seg":{"source":"apache","extensions":["aas"]},"application/x-bcpio":{"source":"apache","extensions":["bcpio"]},"application/x-bdoc":{"compressible":false,"extensions":["bdoc"]},"application/x-bittorrent":{"source":"apache","extensions":["torrent"]},"application/x-blorb":{"source":"apache","extensions":["blb","blorb"]},"application/x-bzip":{"source":"apache","compressible":false,"extensions":["bz"]},"application/x-bzip2":{"source":"apache","compressible":false,"extensions":["bz2","boz"]},"application/x-cbr":{"source":"apache","extensions":["cbr","cba","cbt","cbz","cb7"]},"application/x-cdlink":{"source":"apache","extensions":["vcd"]},"application/x-cfs-compressed":{"source":"apache","extensions":["cfs"]},"application/x-chat":{"source":"apache","extensions":["chat"]},"application/x-chess-pgn":{"source":"apache","extensions":["pgn"]},"application/x-chrome-extension":{"extensions":["crx"]},"application/x-cocoa":{"source":"nginx","extensions":["cco"]},"application/x-compress":{"source":"apache"},"application/x-conference":{"source":"apache","extensions":["nsc"]},"application/x-cpio":{"source":"apache","extensions":["cpio"]},"application/x-csh":{"source":"apache","extensions":["csh"]},"application/x-deb":{"compressible":false},"application/x-debian-package":{"source":"apache","extensions":["deb","udeb"]},"application/x-dgc-compressed":{"source":"apache","extensions":["dgc"]},"application/x-director":{"source":"apache","extensions":["dir","dcr","dxr","cst","cct","cxt","w3d","fgd","swa"]},"application/x-doom":{"source":"apache","extensions":["wad"]},"application/x-dtbncx+xml":{"source":"apache","compressible":true,"extensions":["ncx"]},"application/x-dtbook+xml":{"source":"apache","compressible":true,"extensions":["dtb"]},"application/x-dtbresource+xml":{"source":"apache","compressible":true,"extensions":["res"]},"application/x-dvi":{"source":"apache","compressible":false,"extensions":["dvi"]},"application/x-envoy":{"source":"apache","extensions":["evy"]},"application/x-eva":{"source":"apache","extensions":["eva"]},"application/x-font-bdf":{"source":"apache","extensions":["bdf"]},"application/x-font-dos":{"source":"apache"},"application/x-font-framemaker":{"source":"apache"},"application/x-font-ghostscript":{"source":"apache","extensions":["gsf"]},"application/x-font-libgrx":{"source":"apache"},"application/x-font-linux-psf":{"source":"apache","extensions":["psf"]},"application/x-font-pcf":{"source":"apache","extensions":["pcf"]},"application/x-font-snf":{"source":"apache","extensions":["snf"]},"application/x-font-speedo":{"source":"apache"},"application/x-font-sunos-news":{"source":"apache"},"application/x-font-type1":{"source":"apache","extensions":["pfa","pfb","pfm","afm"]},"application/x-font-vfont":{"source":"apache"},"application/x-freearc":{"source":"apache","extensions":["arc"]},"application/x-futuresplash":{"source":"apache","extensions":["spl"]},"application/x-gca-compressed":{"source":"apache","extensions":["gca"]},"application/x-glulx":{"source":"apache","extensions":["ulx"]},"application/x-gnumeric":{"source":"apache","extensions":["gnumeric"]},"application/x-gramps-xml":{"source":"apache","extensions":["gramps"]},"application/x-gtar":{"source":"apache","extensions":["gtar"]},"application/x-gzip":{"source":"apache"},"application/x-hdf":{"source":"apache","extensions":["hdf"]},"application/x-httpd-php":{"compressible":true,"extensions":["php"]},"application/x-install-instructions":{"source":"apache","extensions":["install"]},"application/x-iso9660-image":{"source":"apache","extensions":["iso"]},"application/x-iwork-keynote-sffkey":{"extensions":["key"]},"application/x-iwork-numbers-sffnumbers":{"extensions":["numbers"]},"application/x-iwork-pages-sffpages":{"extensions":["pages"]},"application/x-java-archive-diff":{"source":"nginx","extensions":["jardiff"]},"application/x-java-jnlp-file":{"source":"apache","compressible":false,"extensions":["jnlp"]},"application/x-javascript":{"compressible":true},"application/x-keepass2":{"extensions":["kdbx"]},"application/x-latex":{"source":"apache","compressible":false,"extensions":["latex"]},"application/x-lua-bytecode":{"extensions":["luac"]},"application/x-lzh-compressed":{"source":"apache","extensions":["lzh","lha"]},"application/x-makeself":{"source":"nginx","extensions":["run"]},"application/x-mie":{"source":"apache","extensions":["mie"]},"application/x-mobipocket-ebook":{"source":"apache","extensions":["prc","mobi"]},"application/x-mpegurl":{"compressible":false},"application/x-ms-application":{"source":"apache","extensions":["application"]},"application/x-ms-shortcut":{"source":"apache","extensions":["lnk"]},"application/x-ms-wmd":{"source":"apache","extensions":["wmd"]},"application/x-ms-wmz":{"source":"apache","extensions":["wmz"]},"application/x-ms-xbap":{"source":"apache","extensions":["xbap"]},"application/x-msaccess":{"source":"apache","extensions":["mdb"]},"application/x-msbinder":{"source":"apache","extensions":["obd"]},"application/x-mscardfile":{"source":"apache","extensions":["crd"]},"application/x-msclip":{"source":"apache","extensions":["clp"]},"application/x-msdos-program":{"extensions":["exe"]},"application/x-msdownload":{"source":"apache","extensions":["exe","dll","com","bat","msi"]},"application/x-msmediaview":{"source":"apache","extensions":["mvb","m13","m14"]},"application/x-msmetafile":{"source":"apache","extensions":["wmf","wmz","emf","emz"]},"application/x-msmoney":{"source":"apache","extensions":["mny"]},"application/x-mspublisher":{"source":"apache","extensions":["pub"]},"application/x-msschedule":{"source":"apache","extensions":["scd"]},"application/x-msterminal":{"source":"apache","extensions":["trm"]},"application/x-mswrite":{"source":"apache","extensions":["wri"]},"application/x-netcdf":{"source":"apache","extensions":["nc","cdf"]},"application/x-ns-proxy-autoconfig":{"compressible":true,"extensions":["pac"]},"application/x-nzb":{"source":"apache","extensions":["nzb"]},"application/x-perl":{"source":"nginx","extensions":["pl","pm"]},"application/x-pilot":{"source":"nginx","extensions":["prc","pdb"]},"application/x-pkcs12":{"source":"apache","compressible":false,"extensions":["p12","pfx"]},"application/x-pkcs7-certificates":{"source":"apache","extensions":["p7b","spc"]},"application/x-pkcs7-certreqresp":{"source":"apache","extensions":["p7r"]},"application/x-pki-message":{"source":"iana"},"application/x-rar-compressed":{"source":"apache","compressible":false,"extensions":["rar"]},"application/x-redhat-package-manager":{"source":"nginx","extensions":["rpm"]},"application/x-research-info-systems":{"source":"apache","extensions":["ris"]},"application/x-sea":{"source":"nginx","extensions":["sea"]},"application/x-sh":{"source":"apache","compressible":true,"extensions":["sh"]},"application/x-shar":{"source":"apache","extensions":["shar"]},"application/x-shockwave-flash":{"source":"apache","compressible":false,"extensions":["swf"]},"application/x-silverlight-app":{"source":"apache","extensions":["xap"]},"application/x-sql":{"source":"apache","extensions":["sql"]},"application/x-stuffit":{"source":"apache","compressible":false,"extensions":["sit"]},"application/x-stuffitx":{"source":"apache","extensions":["sitx"]},"application/x-subrip":{"source":"apache","extensions":["srt"]},"application/x-sv4cpio":{"source":"apache","extensions":["sv4cpio"]},"application/x-sv4crc":{"source":"apache","extensions":["sv4crc"]},"application/x-t3vm-image":{"source":"apache","extensions":["t3"]},"application/x-tads":{"source":"apache","extensions":["gam"]},"application/x-tar":{"source":"apache","compressible":true,"extensions":["tar"]},"application/x-tcl":{"source":"apache","extensions":["tcl","tk"]},"application/x-tex":{"source":"apache","extensions":["tex"]},"application/x-tex-tfm":{"source":"apache","extensions":["tfm"]},"application/x-texinfo":{"source":"apache","extensions":["texinfo","texi"]},"application/x-tgif":{"source":"apache","extensions":["obj"]},"application/x-ustar":{"source":"apache","extensions":["ustar"]},"application/x-virtualbox-hdd":{"compressible":true,"extensions":["hdd"]},"application/x-virtualbox-ova":{"compressible":true,"extensions":["ova"]},"application/x-virtualbox-ovf":{"compressible":true,"extensions":["ovf"]},"application/x-virtualbox-vbox":{"compressible":true,"extensions":["vbox"]},"application/x-virtualbox-vbox-extpack":{"compressible":false,"extensions":["vbox-extpack"]},"application/x-virtualbox-vdi":{"compressible":true,"extensions":["vdi"]},"application/x-virtualbox-vhd":{"compressible":true,"extensions":["vhd"]},"application/x-virtualbox-vmdk":{"compressible":true,"extensions":["vmdk"]},"application/x-wais-source":{"source":"apache","extensions":["src"]},"application/x-web-app-manifest+json":{"compressible":true,"extensions":["webapp"]},"application/x-www-form-urlencoded":{"source":"iana","compressible":true},"application/x-x509-ca-cert":{"source":"iana","extensions":["der","crt","pem"]},"application/x-x509-ca-ra-cert":{"source":"iana"},"application/x-x509-next-ca-cert":{"source":"iana"},"application/x-xfig":{"source":"apache","extensions":["fig"]},"application/x-xliff+xml":{"source":"apache","compressible":true,"extensions":["xlf"]},"application/x-xpinstall":{"source":"apache","compressible":false,"extensions":["xpi"]},"application/x-xz":{"source":"apache","extensions":["xz"]},"application/x-zmachine":{"source":"apache","extensions":["z1","z2","z3","z4","z5","z6","z7","z8"]},"application/x400-bp":{"source":"iana"},"application/xacml+xml":{"source":"iana","compressible":true},"application/xaml+xml":{"source":"apache","compressible":true,"extensions":["xaml"]},"application/xcap-att+xml":{"source":"iana","compressible":true,"extensions":["xav"]},"application/xcap-caps+xml":{"source":"iana","compressible":true,"extensions":["xca"]},"application/xcap-diff+xml":{"source":"iana","compressible":true,"extensions":["xdf"]},"application/xcap-el+xml":{"source":"iana","compressible":true,"extensions":["xel"]},"application/xcap-error+xml":{"source":"iana","compressible":true},"application/xcap-ns+xml":{"source":"iana","compressible":true,"extensions":["xns"]},"application/xcon-conference-info+xml":{"source":"iana","compressible":true},"application/xcon-conference-info-diff+xml":{"source":"iana","compressible":true},"application/xenc+xml":{"source":"iana","compressible":true,"extensions":["xenc"]},"application/xhtml+xml":{"source":"iana","compressible":true,"extensions":["xhtml","xht"]},"application/xhtml-voice+xml":{"source":"apache","compressible":true},"application/xliff+xml":{"source":"iana","compressible":true,"extensions":["xlf"]},"application/xml":{"source":"iana","compressible":true,"extensions":["xml","xsl","xsd","rng"]},"application/xml-dtd":{"source":"iana","compressible":true,"extensions":["dtd"]},"application/xml-external-parsed-entity":{"source":"iana"},"application/xml-patch+xml":{"source":"iana","compressible":true},"application/xmpp+xml":{"source":"iana","compressible":true},"application/xop+xml":{"source":"iana","compressible":true,"extensions":["xop"]},"application/xproc+xml":{"source":"apache","compressible":true,"extensions":["xpl"]},"application/xslt+xml":{"source":"iana","compressible":true,"extensions":["xsl","xslt"]},"application/xspf+xml":{"source":"apache","compressible":true,"extensions":["xspf"]},"application/xv+xml":{"source":"iana","compressible":true,"extensions":["mxml","xhvml","xvml","xvm"]},"application/yang":{"source":"iana","extensions":["yang"]},"application/yang-data+json":{"source":"iana","compressible":true},"application/yang-data+xml":{"source":"iana","compressible":true},"application/yang-patch+json":{"source":"iana","compressible":true},"application/yang-patch+xml":{"source":"iana","compressible":true},"application/yin+xml":{"source":"iana","compressible":true,"extensions":["yin"]},"application/zip":{"source":"iana","compressible":false,"extensions":["zip"]},"application/zlib":{"source":"iana"},"application/zstd":{"source":"iana"},"audio/1d-interleaved-parityfec":{"source":"iana"},"audio/32kadpcm":{"source":"iana"},"audio/3gpp":{"source":"iana","compressible":false,"extensions":["3gpp"]},"audio/3gpp2":{"source":"iana"},"audio/aac":{"source":"iana"},"audio/ac3":{"source":"iana"},"audio/adpcm":{"source":"apache","extensions":["adp"]},"audio/amr":{"source":"iana","extensions":["amr"]},"audio/amr-wb":{"source":"iana"},"audio/amr-wb+":{"source":"iana"},"audio/aptx":{"source":"iana"},"audio/asc":{"source":"iana"},"audio/atrac-advanced-lossless":{"source":"iana"},"audio/atrac-x":{"source":"iana"},"audio/atrac3":{"source":"iana"},"audio/basic":{"source":"iana","compressible":false,"extensions":["au","snd"]},"audio/bv16":{"source":"iana"},"audio/bv32":{"source":"iana"},"audio/clearmode":{"source":"iana"},"audio/cn":{"source":"iana"},"audio/dat12":{"source":"iana"},"audio/dls":{"source":"iana"},"audio/dsr-es201108":{"source":"iana"},"audio/dsr-es202050":{"source":"iana"},"audio/dsr-es202211":{"source":"iana"},"audio/dsr-es202212":{"source":"iana"},"audio/dv":{"source":"iana"},"audio/dvi4":{"source":"iana"},"audio/eac3":{"source":"iana"},"audio/encaprtp":{"source":"iana"},"audio/evrc":{"source":"iana"},"audio/evrc-qcp":{"source":"iana"},"audio/evrc0":{"source":"iana"},"audio/evrc1":{"source":"iana"},"audio/evrcb":{"source":"iana"},"audio/evrcb0":{"source":"iana"},"audio/evrcb1":{"source":"iana"},"audio/evrcnw":{"source":"iana"},"audio/evrcnw0":{"source":"iana"},"audio/evrcnw1":{"source":"iana"},"audio/evrcwb":{"source":"iana"},"audio/evrcwb0":{"source":"iana"},"audio/evrcwb1":{"source":"iana"},"audio/evs":{"source":"iana"},"audio/flexfec":{"source":"iana"},"audio/fwdred":{"source":"iana"},"audio/g711-0":{"source":"iana"},"audio/g719":{"source":"iana"},"audio/g722":{"source":"iana"},"audio/g7221":{"source":"iana"},"audio/g723":{"source":"iana"},"audio/g726-16":{"source":"iana"},"audio/g726-24":{"source":"iana"},"audio/g726-32":{"source":"iana"},"audio/g726-40":{"source":"iana"},"audio/g728":{"source":"iana"},"audio/g729":{"source":"iana"},"audio/g7291":{"source":"iana"},"audio/g729d":{"source":"iana"},"audio/g729e":{"source":"iana"},"audio/gsm":{"source":"iana"},"audio/gsm-efr":{"source":"iana"},"audio/gsm-hr-08":{"source":"iana"},"audio/ilbc":{"source":"iana"},"audio/ip-mr_v2.5":{"source":"iana"},"audio/isac":{"source":"apache"},"audio/l16":{"source":"iana"},"audio/l20":{"source":"iana"},"audio/l24":{"source":"iana","compressible":false},"audio/l8":{"source":"iana"},"audio/lpc":{"source":"iana"},"audio/melp":{"source":"iana"},"audio/melp1200":{"source":"iana"},"audio/melp2400":{"source":"iana"},"audio/melp600":{"source":"iana"},"audio/mhas":{"source":"iana"},"audio/midi":{"source":"apache","extensions":["mid","midi","kar","rmi"]},"audio/mobile-xmf":{"source":"iana","extensions":["mxmf"]},"audio/mp3":{"compressible":false,"extensions":["mp3"]},"audio/mp4":{"source":"iana","compressible":false,"extensions":["m4a","mp4a"]},"audio/mp4a-latm":{"source":"iana"},"audio/mpa":{"source":"iana"},"audio/mpa-robust":{"source":"iana"},"audio/mpeg":{"source":"iana","compressible":false,"extensions":["mpga","mp2","mp2a","mp3","m2a","m3a"]},"audio/mpeg4-generic":{"source":"iana"},"audio/musepack":{"source":"apache"},"audio/ogg":{"source":"iana","compressible":false,"extensions":["oga","ogg","spx","opus"]},"audio/opus":{"source":"iana"},"audio/parityfec":{"source":"iana"},"audio/pcma":{"source":"iana"},"audio/pcma-wb":{"source":"iana"},"audio/pcmu":{"source":"iana"},"audio/pcmu-wb":{"source":"iana"},"audio/prs.sid":{"source":"iana"},"audio/qcelp":{"source":"iana"},"audio/raptorfec":{"source":"iana"},"audio/red":{"source":"iana"},"audio/rtp-enc-aescm128":{"source":"iana"},"audio/rtp-midi":{"source":"iana"},"audio/rtploopback":{"source":"iana"},"audio/rtx":{"source":"iana"},"audio/s3m":{"source":"apache","extensions":["s3m"]},"audio/scip":{"source":"iana"},"audio/silk":{"source":"apache","extensions":["sil"]},"audio/smv":{"source":"iana"},"audio/smv-qcp":{"source":"iana"},"audio/smv0":{"source":"iana"},"audio/sofa":{"source":"iana"},"audio/sp-midi":{"source":"iana"},"audio/speex":{"source":"iana"},"audio/t140c":{"source":"iana"},"audio/t38":{"source":"iana"},"audio/telephone-event":{"source":"iana"},"audio/tetra_acelp":{"source":"iana"},"audio/tetra_acelp_bb":{"source":"iana"},"audio/tone":{"source":"iana"},"audio/tsvcis":{"source":"iana"},"audio/uemclip":{"source":"iana"},"audio/ulpfec":{"source":"iana"},"audio/usac":{"source":"iana"},"audio/vdvi":{"source":"iana"},"audio/vmr-wb":{"source":"iana"},"audio/vnd.3gpp.iufp":{"source":"iana"},"audio/vnd.4sb":{"source":"iana"},"audio/vnd.audiokoz":{"source":"iana"},"audio/vnd.celp":{"source":"iana"},"audio/vnd.cisco.nse":{"source":"iana"},"audio/vnd.cmles.radio-events":{"source":"iana"},"audio/vnd.cns.anp1":{"source":"iana"},"audio/vnd.cns.inf1":{"source":"iana"},"audio/vnd.dece.audio":{"source":"iana","extensions":["uva","uvva"]},"audio/vnd.digital-winds":{"source":"iana","extensions":["eol"]},"audio/vnd.dlna.adts":{"source":"iana"},"audio/vnd.dolby.heaac.1":{"source":"iana"},"audio/vnd.dolby.heaac.2":{"source":"iana"},"audio/vnd.dolby.mlp":{"source":"iana"},"audio/vnd.dolby.mps":{"source":"iana"},"audio/vnd.dolby.pl2":{"source":"iana"},"audio/vnd.dolby.pl2x":{"source":"iana"},"audio/vnd.dolby.pl2z":{"source":"iana"},"audio/vnd.dolby.pulse.1":{"source":"iana"},"audio/vnd.dra":{"source":"iana","extensions":["dra"]},"audio/vnd.dts":{"source":"iana","extensions":["dts"]},"audio/vnd.dts.hd":{"source":"iana","extensions":["dtshd"]},"audio/vnd.dts.uhd":{"source":"iana"},"audio/vnd.dvb.file":{"source":"iana"},"audio/vnd.everad.plj":{"source":"iana"},"audio/vnd.hns.audio":{"source":"iana"},"audio/vnd.lucent.voice":{"source":"iana","extensions":["lvp"]},"audio/vnd.ms-playready.media.pya":{"source":"iana","extensions":["pya"]},"audio/vnd.nokia.mobile-xmf":{"source":"iana"},"audio/vnd.nortel.vbk":{"source":"iana"},"audio/vnd.nuera.ecelp4800":{"source":"iana","extensions":["ecelp4800"]},"audio/vnd.nuera.ecelp7470":{"source":"iana","extensions":["ecelp7470"]},"audio/vnd.nuera.ecelp9600":{"source":"iana","extensions":["ecelp9600"]},"audio/vnd.octel.sbc":{"source":"iana"},"audio/vnd.presonus.multitrack":{"source":"iana"},"audio/vnd.qcelp":{"source":"iana"},"audio/vnd.rhetorex.32kadpcm":{"source":"iana"},"audio/vnd.rip":{"source":"iana","extensions":["rip"]},"audio/vnd.rn-realaudio":{"compressible":false},"audio/vnd.sealedmedia.softseal.mpeg":{"source":"iana"},"audio/vnd.vmx.cvsd":{"source":"iana"},"audio/vnd.wave":{"compressible":false},"audio/vorbis":{"source":"iana","compressible":false},"audio/vorbis-config":{"source":"iana"},"audio/wav":{"compressible":false,"extensions":["wav"]},"audio/wave":{"compressible":false,"extensions":["wav"]},"audio/webm":{"source":"apache","compressible":false,"extensions":["weba"]},"audio/x-aac":{"source":"apache","compressible":false,"extensions":["aac"]},"audio/x-aiff":{"source":"apache","extensions":["aif","aiff","aifc"]},"audio/x-caf":{"source":"apache","compressible":false,"extensions":["caf"]},"audio/x-flac":{"source":"apache","extensions":["flac"]},"audio/x-m4a":{"source":"nginx","extensions":["m4a"]},"audio/x-matroska":{"source":"apache","extensions":["mka"]},"audio/x-mpegurl":{"source":"apache","extensions":["m3u"]},"audio/x-ms-wax":{"source":"apache","extensions":["wax"]},"audio/x-ms-wma":{"source":"apache","extensions":["wma"]},"audio/x-pn-realaudio":{"source":"apache","extensions":["ram","ra"]},"audio/x-pn-realaudio-plugin":{"source":"apache","extensions":["rmp"]},"audio/x-realaudio":{"source":"nginx","extensions":["ra"]},"audio/x-tta":{"source":"apache"},"audio/x-wav":{"source":"apache","extensions":["wav"]},"audio/xm":{"source":"apache","extensions":["xm"]},"chemical/x-cdx":{"source":"apache","extensions":["cdx"]},"chemical/x-cif":{"source":"apache","extensions":["cif"]},"chemical/x-cmdf":{"source":"apache","extensions":["cmdf"]},"chemical/x-cml":{"source":"apache","extensions":["cml"]},"chemical/x-csml":{"source":"apache","extensions":["csml"]},"chemical/x-pdb":{"source":"apache"},"chemical/x-xyz":{"source":"apache","extensions":["xyz"]},"font/collection":{"source":"iana","extensions":["ttc"]},"font/otf":{"source":"iana","compressible":true,"extensions":["otf"]},"font/sfnt":{"source":"iana"},"font/ttf":{"source":"iana","compressible":true,"extensions":["ttf"]},"font/woff":{"source":"iana","extensions":["woff"]},"font/woff2":{"source":"iana","extensions":["woff2"]},"image/aces":{"source":"iana","extensions":["exr"]},"image/apng":{"compressible":false,"extensions":["apng"]},"image/avci":{"source":"iana","extensions":["avci"]},"image/avcs":{"source":"iana","extensions":["avcs"]},"image/avif":{"source":"iana","compressible":false,"extensions":["avif"]},"image/bmp":{"source":"iana","compressible":true,"extensions":["bmp"]},"image/cgm":{"source":"iana","extensions":["cgm"]},"image/dicom-rle":{"source":"iana","extensions":["drle"]},"image/emf":{"source":"iana","extensions":["emf"]},"image/fits":{"source":"iana","extensions":["fits"]},"image/g3fax":{"source":"iana","extensions":["g3"]},"image/gif":{"source":"iana","compressible":false,"extensions":["gif"]},"image/heic":{"source":"iana","extensions":["heic"]},"image/heic-sequence":{"source":"iana","extensions":["heics"]},"image/heif":{"source":"iana","extensions":["heif"]},"image/heif-sequence":{"source":"iana","extensions":["heifs"]},"image/hej2k":{"source":"iana","extensions":["hej2"]},"image/hsj2":{"source":"iana","extensions":["hsj2"]},"image/ief":{"source":"iana","extensions":["ief"]},"image/jls":{"source":"iana","extensions":["jls"]},"image/jp2":{"source":"iana","compressible":false,"extensions":["jp2","jpg2"]},"image/jpeg":{"source":"iana","compressible":false,"extensions":["jpeg","jpg","jpe"]},"image/jph":{"source":"iana","extensions":["jph"]},"image/jphc":{"source":"iana","extensions":["jhc"]},"image/jpm":{"source":"iana","compressible":false,"extensions":["jpm"]},"image/jpx":{"source":"iana","compressible":false,"extensions":["jpx","jpf"]},"image/jxr":{"source":"iana","extensions":["jxr"]},"image/jxra":{"source":"iana","extensions":["jxra"]},"image/jxrs":{"source":"iana","extensions":["jxrs"]},"image/jxs":{"source":"iana","extensions":["jxs"]},"image/jxsc":{"source":"iana","extensions":["jxsc"]},"image/jxsi":{"source":"iana","extensions":["jxsi"]},"image/jxss":{"source":"iana","extensions":["jxss"]},"image/ktx":{"source":"iana","extensions":["ktx"]},"image/ktx2":{"source":"iana","extensions":["ktx2"]},"image/naplps":{"source":"iana"},"image/pjpeg":{"compressible":false},"image/png":{"source":"iana","compressible":false,"extensions":["png"]},"image/prs.btif":{"source":"iana","extensions":["btif"]},"image/prs.pti":{"source":"iana","extensions":["pti"]},"image/pwg-raster":{"source":"iana"},"image/sgi":{"source":"apache","extensions":["sgi"]},"image/svg+xml":{"source":"iana","compressible":true,"extensions":["svg","svgz"]},"image/t38":{"source":"iana","extensions":["t38"]},"image/tiff":{"source":"iana","compressible":false,"extensions":["tif","tiff"]},"image/tiff-fx":{"source":"iana","extensions":["tfx"]},"image/vnd.adobe.photoshop":{"source":"iana","compressible":true,"extensions":["psd"]},"image/vnd.airzip.accelerator.azv":{"source":"iana","extensions":["azv"]},"image/vnd.cns.inf2":{"source":"iana"},"image/vnd.dece.graphic":{"source":"iana","extensions":["uvi","uvvi","uvg","uvvg"]},"image/vnd.djvu":{"source":"iana","extensions":["djvu","djv"]},"image/vnd.dvb.subtitle":{"source":"iana","extensions":["sub"]},"image/vnd.dwg":{"source":"iana","extensions":["dwg"]},"image/vnd.dxf":{"source":"iana","extensions":["dxf"]},"image/vnd.fastbidsheet":{"source":"iana","extensions":["fbs"]},"image/vnd.fpx":{"source":"iana","extensions":["fpx"]},"image/vnd.fst":{"source":"iana","extensions":["fst"]},"image/vnd.fujixerox.edmics-mmr":{"source":"iana","extensions":["mmr"]},"image/vnd.fujixerox.edmics-rlc":{"source":"iana","extensions":["rlc"]},"image/vnd.globalgraphics.pgb":{"source":"iana"},"image/vnd.microsoft.icon":{"source":"iana","compressible":true,"extensions":["ico"]},"image/vnd.mix":{"source":"iana"},"image/vnd.mozilla.apng":{"source":"iana"},"image/vnd.ms-dds":{"compressible":true,"extensions":["dds"]},"image/vnd.ms-modi":{"source":"iana","extensions":["mdi"]},"image/vnd.ms-photo":{"source":"apache","extensions":["wdp"]},"image/vnd.net-fpx":{"source":"iana","extensions":["npx"]},"image/vnd.pco.b16":{"source":"iana","extensions":["b16"]},"image/vnd.radiance":{"source":"iana"},"image/vnd.sealed.png":{"source":"iana"},"image/vnd.sealedmedia.softseal.gif":{"source":"iana"},"image/vnd.sealedmedia.softseal.jpg":{"source":"iana"},"image/vnd.svf":{"source":"iana"},"image/vnd.tencent.tap":{"source":"iana","extensions":["tap"]},"image/vnd.valve.source.texture":{"source":"iana","extensions":["vtf"]},"image/vnd.wap.wbmp":{"source":"iana","extensions":["wbmp"]},"image/vnd.xiff":{"source":"iana","extensions":["xif"]},"image/vnd.zbrush.pcx":{"source":"iana","extensions":["pcx"]},"image/webp":{"source":"apache","extensions":["webp"]},"image/wmf":{"source":"iana","extensions":["wmf"]},"image/x-3ds":{"source":"apache","extensions":["3ds"]},"image/x-cmu-raster":{"source":"apache","extensions":["ras"]},"image/x-cmx":{"source":"apache","extensions":["cmx"]},"image/x-freehand":{"source":"apache","extensions":["fh","fhc","fh4","fh5","fh7"]},"image/x-icon":{"source":"apache","compressible":true,"extensions":["ico"]},"image/x-jng":{"source":"nginx","extensions":["jng"]},"image/x-mrsid-image":{"source":"apache","extensions":["sid"]},"image/x-ms-bmp":{"source":"nginx","compressible":true,"extensions":["bmp"]},"image/x-pcx":{"source":"apache","extensions":["pcx"]},"image/x-pict":{"source":"apache","extensions":["pic","pct"]},"image/x-portable-anymap":{"source":"apache","extensions":["pnm"]},"image/x-portable-bitmap":{"source":"apache","extensions":["pbm"]},"image/x-portable-graymap":{"source":"apache","extensions":["pgm"]},"image/x-portable-pixmap":{"source":"apache","extensions":["ppm"]},"image/x-rgb":{"source":"apache","extensions":["rgb"]},"image/x-tga":{"source":"apache","extensions":["tga"]},"image/x-xbitmap":{"source":"apache","extensions":["xbm"]},"image/x-xcf":{"compressible":false},"image/x-xpixmap":{"source":"apache","extensions":["xpm"]},"image/x-xwindowdump":{"source":"apache","extensions":["xwd"]},"message/cpim":{"source":"iana"},"message/delivery-status":{"source":"iana"},"message/disposition-notification":{"source":"iana","extensions":["disposition-notification"]},"message/external-body":{"source":"iana"},"message/feedback-report":{"source":"iana"},"message/global":{"source":"iana","extensions":["u8msg"]},"message/global-delivery-status":{"source":"iana","extensions":["u8dsn"]},"message/global-disposition-notification":{"source":"iana","extensions":["u8mdn"]},"message/global-headers":{"source":"iana","extensions":["u8hdr"]},"message/http":{"source":"iana","compressible":false},"message/imdn+xml":{"source":"iana","compressible":true},"message/news":{"source":"iana"},"message/partial":{"source":"iana","compressible":false},"message/rfc822":{"source":"iana","compressible":true,"extensions":["eml","mime"]},"message/s-http":{"source":"iana"},"message/sip":{"source":"iana"},"message/sipfrag":{"source":"iana"},"message/tracking-status":{"source":"iana"},"message/vnd.si.simp":{"source":"iana"},"message/vnd.wfa.wsc":{"source":"iana","extensions":["wsc"]},"model/3mf":{"source":"iana","extensions":["3mf"]},"model/e57":{"source":"iana"},"model/gltf+json":{"source":"iana","compressible":true,"extensions":["gltf"]},"model/gltf-binary":{"source":"iana","compressible":true,"extensions":["glb"]},"model/iges":{"source":"iana","compressible":false,"extensions":["igs","iges"]},"model/mesh":{"source":"iana","compressible":false,"extensions":["msh","mesh","silo"]},"model/mtl":{"source":"iana","extensions":["mtl"]},"model/obj":{"source":"iana","extensions":["obj"]},"model/step":{"source":"iana"},"model/step+xml":{"source":"iana","compressible":true,"extensions":["stpx"]},"model/step+zip":{"source":"iana","compressible":false,"extensions":["stpz"]},"model/step-xml+zip":{"source":"iana","compressible":false,"extensions":["stpxz"]},"model/stl":{"source":"iana","extensions":["stl"]},"model/vnd.collada+xml":{"source":"iana","compressible":true,"extensions":["dae"]},"model/vnd.dwf":{"source":"iana","extensions":["dwf"]},"model/vnd.flatland.3dml":{"source":"iana"},"model/vnd.gdl":{"source":"iana","extensions":["gdl"]},"model/vnd.gs-gdl":{"source":"apache"},"model/vnd.gs.gdl":{"source":"iana"},"model/vnd.gtw":{"source":"iana","extensions":["gtw"]},"model/vnd.moml+xml":{"source":"iana","compressible":true},"model/vnd.mts":{"source":"iana","extensions":["mts"]},"model/vnd.opengex":{"source":"iana","extensions":["ogex"]},"model/vnd.parasolid.transmit.binary":{"source":"iana","extensions":["x_b"]},"model/vnd.parasolid.transmit.text":{"source":"iana","extensions":["x_t"]},"model/vnd.pytha.pyox":{"source":"iana"},"model/vnd.rosette.annotated-data-model":{"source":"iana"},"model/vnd.sap.vds":{"source":"iana","extensions":["vds"]},"model/vnd.usdz+zip":{"source":"iana","compressible":false,"extensions":["usdz"]},"model/vnd.valve.source.compiled-map":{"source":"iana","extensions":["bsp"]},"model/vnd.vtu":{"source":"iana","extensions":["vtu"]},"model/vrml":{"source":"iana","compressible":false,"extensions":["wrl","vrml"]},"model/x3d+binary":{"source":"apache","compressible":false,"extensions":["x3db","x3dbz"]},"model/x3d+fastinfoset":{"source":"iana","extensions":["x3db"]},"model/x3d+vrml":{"source":"apache","compressible":false,"extensions":["x3dv","x3dvz"]},"model/x3d+xml":{"source":"iana","compressible":true,"extensions":["x3d","x3dz"]},"model/x3d-vrml":{"source":"iana","extensions":["x3dv"]},"multipart/alternative":{"source":"iana","compressible":false},"multipart/appledouble":{"source":"iana"},"multipart/byteranges":{"source":"iana"},"multipart/digest":{"source":"iana"},"multipart/encrypted":{"source":"iana","compressible":false},"multipart/form-data":{"source":"iana","compressible":false},"multipart/header-set":{"source":"iana"},"multipart/mixed":{"source":"iana"},"multipart/multilingual":{"source":"iana"},"multipart/parallel":{"source":"iana"},"multipart/related":{"source":"iana","compressible":false},"multipart/report":{"source":"iana"},"multipart/signed":{"source":"iana","compressible":false},"multipart/vnd.bint.med-plus":{"source":"iana"},"multipart/voice-message":{"source":"iana"},"multipart/x-mixed-replace":{"source":"iana"},"text/1d-interleaved-parityfec":{"source":"iana"},"text/cache-manifest":{"source":"iana","compressible":true,"extensions":["appcache","manifest"]},"text/calendar":{"source":"iana","extensions":["ics","ifb"]},"text/calender":{"compressible":true},"text/cmd":{"compressible":true},"text/coffeescript":{"extensions":["coffee","litcoffee"]},"text/cql":{"source":"iana"},"text/cql-expression":{"source":"iana"},"text/cql-identifier":{"source":"iana"},"text/css":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["css"]},"text/csv":{"source":"iana","compressible":true,"extensions":["csv"]},"text/csv-schema":{"source":"iana"},"text/directory":{"source":"iana"},"text/dns":{"source":"iana"},"text/ecmascript":{"source":"iana"},"text/encaprtp":{"source":"iana"},"text/enriched":{"source":"iana"},"text/fhirpath":{"source":"iana"},"text/flexfec":{"source":"iana"},"text/fwdred":{"source":"iana"},"text/gff3":{"source":"iana"},"text/grammar-ref-list":{"source":"iana"},"text/html":{"source":"iana","compressible":true,"extensions":["html","htm","shtml"]},"text/jade":{"extensions":["jade"]},"text/javascript":{"source":"iana","compressible":true},"text/jcr-cnd":{"source":"iana"},"text/jsx":{"compressible":true,"extensions":["jsx"]},"text/less":{"compressible":true,"extensions":["less"]},"text/markdown":{"source":"iana","compressible":true,"extensions":["markdown","md"]},"text/mathml":{"source":"nginx","extensions":["mml"]},"text/mdx":{"compressible":true,"extensions":["mdx"]},"text/mizar":{"source":"iana"},"text/n3":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["n3"]},"text/parameters":{"source":"iana","charset":"UTF-8"},"text/parityfec":{"source":"iana"},"text/plain":{"source":"iana","compressible":true,"extensions":["txt","text","conf","def","list","log","in","ini"]},"text/provenance-notation":{"source":"iana","charset":"UTF-8"},"text/prs.fallenstein.rst":{"source":"iana"},"text/prs.lines.tag":{"source":"iana","extensions":["dsc"]},"text/prs.prop.logic":{"source":"iana"},"text/raptorfec":{"source":"iana"},"text/red":{"source":"iana"},"text/rfc822-headers":{"source":"iana"},"text/richtext":{"source":"iana","compressible":true,"extensions":["rtx"]},"text/rtf":{"source":"iana","compressible":true,"extensions":["rtf"]},"text/rtp-enc-aescm128":{"source":"iana"},"text/rtploopback":{"source":"iana"},"text/rtx":{"source":"iana"},"text/sgml":{"source":"iana","extensions":["sgml","sgm"]},"text/shaclc":{"source":"iana"},"text/shex":{"source":"iana","extensions":["shex"]},"text/slim":{"extensions":["slim","slm"]},"text/spdx":{"source":"iana","extensions":["spdx"]},"text/strings":{"source":"iana"},"text/stylus":{"extensions":["stylus","styl"]},"text/t140":{"source":"iana"},"text/tab-separated-values":{"source":"iana","compressible":true,"extensions":["tsv"]},"text/troff":{"source":"iana","extensions":["t","tr","roff","man","me","ms"]},"text/turtle":{"source":"iana","charset":"UTF-8","extensions":["ttl"]},"text/ulpfec":{"source":"iana"},"text/uri-list":{"source":"iana","compressible":true,"extensions":["uri","uris","urls"]},"text/vcard":{"source":"iana","compressible":true,"extensions":["vcard"]},"text/vnd.a":{"source":"iana"},"text/vnd.abc":{"source":"iana"},"text/vnd.ascii-art":{"source":"iana"},"text/vnd.curl":{"source":"iana","extensions":["curl"]},"text/vnd.curl.dcurl":{"source":"apache","extensions":["dcurl"]},"text/vnd.curl.mcurl":{"source":"apache","extensions":["mcurl"]},"text/vnd.curl.scurl":{"source":"apache","extensions":["scurl"]},"text/vnd.debian.copyright":{"source":"iana","charset":"UTF-8"},"text/vnd.dmclientscript":{"source":"iana"},"text/vnd.dvb.subtitle":{"source":"iana","extensions":["sub"]},"text/vnd.esmertec.theme-descriptor":{"source":"iana","charset":"UTF-8"},"text/vnd.familysearch.gedcom":{"source":"iana","extensions":["ged"]},"text/vnd.ficlab.flt":{"source":"iana"},"text/vnd.fly":{"source":"iana","extensions":["fly"]},"text/vnd.fmi.flexstor":{"source":"iana","extensions":["flx"]},"text/vnd.gml":{"source":"iana"},"text/vnd.graphviz":{"source":"iana","extensions":["gv"]},"text/vnd.hans":{"source":"iana"},"text/vnd.hgl":{"source":"iana"},"text/vnd.in3d.3dml":{"source":"iana","extensions":["3dml"]},"text/vnd.in3d.spot":{"source":"iana","extensions":["spot"]},"text/vnd.iptc.newsml":{"source":"iana"},"text/vnd.iptc.nitf":{"source":"iana"},"text/vnd.latex-z":{"source":"iana"},"text/vnd.motorola.reflex":{"source":"iana"},"text/vnd.ms-mediapackage":{"source":"iana"},"text/vnd.net2phone.commcenter.command":{"source":"iana"},"text/vnd.radisys.msml-basic-layout":{"source":"iana"},"text/vnd.senx.warpscript":{"source":"iana"},"text/vnd.si.uricatalogue":{"source":"iana"},"text/vnd.sosi":{"source":"iana"},"text/vnd.sun.j2me.app-descriptor":{"source":"iana","charset":"UTF-8","extensions":["jad"]},"text/vnd.trolltech.linguist":{"source":"iana","charset":"UTF-8"},"text/vnd.wap.si":{"source":"iana"},"text/vnd.wap.sl":{"source":"iana"},"text/vnd.wap.wml":{"source":"iana","extensions":["wml"]},"text/vnd.wap.wmlscript":{"source":"iana","extensions":["wmls"]},"text/vtt":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["vtt"]},"text/x-asm":{"source":"apache","extensions":["s","asm"]},"text/x-c":{"source":"apache","extensions":["c","cc","cxx","cpp","h","hh","dic"]},"text/x-component":{"source":"nginx","extensions":["htc"]},"text/x-fortran":{"source":"apache","extensions":["f","for","f77","f90"]},"text/x-gwt-rpc":{"compressible":true},"text/x-handlebars-template":{"extensions":["hbs"]},"text/x-java-source":{"source":"apache","extensions":["java"]},"text/x-jquery-tmpl":{"compressible":true},"text/x-lua":{"extensions":["lua"]},"text/x-markdown":{"compressible":true,"extensions":["mkd"]},"text/x-nfo":{"source":"apache","extensions":["nfo"]},"text/x-opml":{"source":"apache","extensions":["opml"]},"text/x-org":{"compressible":true,"extensions":["org"]},"text/x-pascal":{"source":"apache","extensions":["p","pas"]},"text/x-processing":{"compressible":true,"extensions":["pde"]},"text/x-sass":{"extensions":["sass"]},"text/x-scss":{"extensions":["scss"]},"text/x-setext":{"source":"apache","extensions":["etx"]},"text/x-sfv":{"source":"apache","extensions":["sfv"]},"text/x-suse-ymp":{"compressible":true,"extensions":["ymp"]},"text/x-uuencode":{"source":"apache","extensions":["uu"]},"text/x-vcalendar":{"source":"apache","extensions":["vcs"]},"text/x-vcard":{"source":"apache","extensions":["vcf"]},"text/xml":{"source":"iana","compressible":true,"extensions":["xml"]},"text/xml-external-parsed-entity":{"source":"iana"},"text/yaml":{"compressible":true,"extensions":["yaml","yml"]},"video/1d-interleaved-parityfec":{"source":"iana"},"video/3gpp":{"source":"iana","extensions":["3gp","3gpp"]},"video/3gpp-tt":{"source":"iana"},"video/3gpp2":{"source":"iana","extensions":["3g2"]},"video/av1":{"source":"iana"},"video/bmpeg":{"source":"iana"},"video/bt656":{"source":"iana"},"video/celb":{"source":"iana"},"video/dv":{"source":"iana"},"video/encaprtp":{"source":"iana"},"video/ffv1":{"source":"iana"},"video/flexfec":{"source":"iana"},"video/h261":{"source":"iana","extensions":["h261"]},"video/h263":{"source":"iana","extensions":["h263"]},"video/h263-1998":{"source":"iana"},"video/h263-2000":{"source":"iana"},"video/h264":{"source":"iana","extensions":["h264"]},"video/h264-rcdo":{"source":"iana"},"video/h264-svc":{"source":"iana"},"video/h265":{"source":"iana"},"video/iso.segment":{"source":"iana","extensions":["m4s"]},"video/jpeg":{"source":"iana","extensions":["jpgv"]},"video/jpeg2000":{"source":"iana"},"video/jpm":{"source":"apache","extensions":["jpm","jpgm"]},"video/jxsv":{"source":"iana"},"video/mj2":{"source":"iana","extensions":["mj2","mjp2"]},"video/mp1s":{"source":"iana"},"video/mp2p":{"source":"iana"},"video/mp2t":{"source":"iana","extensions":["ts"]},"video/mp4":{"source":"iana","compressible":false,"extensions":["mp4","mp4v","mpg4"]},"video/mp4v-es":{"source":"iana"},"video/mpeg":{"source":"iana","compressible":false,"extensions":["mpeg","mpg","mpe","m1v","m2v"]},"video/mpeg4-generic":{"source":"iana"},"video/mpv":{"source":"iana"},"video/nv":{"source":"iana"},"video/ogg":{"source":"iana","compressible":false,"extensions":["ogv"]},"video/parityfec":{"source":"iana"},"video/pointer":{"source":"iana"},"video/quicktime":{"source":"iana","compressible":false,"extensions":["qt","mov"]},"video/raptorfec":{"source":"iana"},"video/raw":{"source":"iana"},"video/rtp-enc-aescm128":{"source":"iana"},"video/rtploopback":{"source":"iana"},"video/rtx":{"source":"iana"},"video/scip":{"source":"iana"},"video/smpte291":{"source":"iana"},"video/smpte292m":{"source":"iana"},"video/ulpfec":{"source":"iana"},"video/vc1":{"source":"iana"},"video/vc2":{"source":"iana"},"video/vnd.cctv":{"source":"iana"},"video/vnd.dece.hd":{"source":"iana","extensions":["uvh","uvvh"]},"video/vnd.dece.mobile":{"source":"iana","extensions":["uvm","uvvm"]},"video/vnd.dece.mp4":{"source":"iana"},"video/vnd.dece.pd":{"source":"iana","extensions":["uvp","uvvp"]},"video/vnd.dece.sd":{"source":"iana","extensions":["uvs","uvvs"]},"video/vnd.dece.video":{"source":"iana","extensions":["uvv","uvvv"]},"video/vnd.directv.mpeg":{"source":"iana"},"video/vnd.directv.mpeg-tts":{"source":"iana"},"video/vnd.dlna.mpeg-tts":{"source":"iana"},"video/vnd.dvb.file":{"source":"iana","extensions":["dvb"]},"video/vnd.fvt":{"source":"iana","extensions":["fvt"]},"video/vnd.hns.video":{"source":"iana"},"video/vnd.iptvforum.1dparityfec-1010":{"source":"iana"},"video/vnd.iptvforum.1dparityfec-2005":{"source":"iana"},"video/vnd.iptvforum.2dparityfec-1010":{"source":"iana"},"video/vnd.iptvforum.2dparityfec-2005":{"source":"iana"},"video/vnd.iptvforum.ttsavc":{"source":"iana"},"video/vnd.iptvforum.ttsmpeg2":{"source":"iana"},"video/vnd.motorola.video":{"source":"iana"},"video/vnd.motorola.videop":{"source":"iana"},"video/vnd.mpegurl":{"source":"iana","extensions":["mxu","m4u"]},"video/vnd.ms-playready.media.pyv":{"source":"iana","extensions":["pyv"]},"video/vnd.nokia.interleaved-multimedia":{"source":"iana"},"video/vnd.nokia.mp4vr":{"source":"iana"},"video/vnd.nokia.videovoip":{"source":"iana"},"video/vnd.objectvideo":{"source":"iana"},"video/vnd.radgamettools.bink":{"source":"iana"},"video/vnd.radgamettools.smacker":{"source":"iana"},"video/vnd.sealed.mpeg1":{"source":"iana"},"video/vnd.sealed.mpeg4":{"source":"iana"},"video/vnd.sealed.swf":{"source":"iana"},"video/vnd.sealedmedia.softseal.mov":{"source":"iana"},"video/vnd.uvvu.mp4":{"source":"iana","extensions":["uvu","uvvu"]},"video/vnd.vivo":{"source":"iana","extensions":["viv"]},"video/vnd.youtube.yt":{"source":"iana"},"video/vp8":{"source":"iana"},"video/vp9":{"source":"iana"},"video/webm":{"source":"apache","compressible":false,"extensions":["webm"]},"video/x-f4v":{"source":"apache","extensions":["f4v"]},"video/x-fli":{"source":"apache","extensions":["fli"]},"video/x-flv":{"source":"apache","compressible":false,"extensions":["flv"]},"video/x-m4v":{"source":"apache","extensions":["m4v"]},"video/x-matroska":{"source":"apache","compressible":false,"extensions":["mkv","mk3d","mks"]},"video/x-mng":{"source":"apache","extensions":["mng"]},"video/x-ms-asf":{"source":"apache","extensions":["asf","asx"]},"video/x-ms-vob":{"source":"apache","extensions":["vob"]},"video/x-ms-wm":{"source":"apache","extensions":["wm"]},"video/x-ms-wmv":{"source":"apache","compressible":false,"extensions":["wmv"]},"video/x-ms-wmx":{"source":"apache","extensions":["wmx"]},"video/x-ms-wvx":{"source":"apache","extensions":["wvx"]},"video/x-msvideo":{"source":"apache","extensions":["avi"]},"video/x-sgi-movie":{"source":"apache","extensions":["movie"]},"video/x-smv":{"source":"apache","extensions":["smv"]},"x-conference/x-cooltalk":{"source":"apache","extensions":["ice"]},"x-shader/x-fragment":{"compressible":true},"x-shader/x-vertex":{"compressible":true}}');

/***/ })

/******/ });
/************************************************************************/
/******/ // The module cache
/******/ var __webpack_module_cache__ = {};
/******/ 
/******/ // The require function
/******/ function __nccwpck_require__(moduleId) {
/******/ 	// Check if module is in cache
/******/ 	var cachedModule = __webpack_module_cache__[moduleId];
/******/ 	if (cachedModule !== undefined) {
/******/ 		return cachedModule.exports;
/******/ 	}
/******/ 	// Create a new module (and put it into the cache)
/******/ 	var module = __webpack_module_cache__[moduleId] = {
/******/ 		// no module.id needed
/******/ 		// no module.loaded needed
/******/ 		exports: {}
/******/ 	};
/******/ 
/******/ 	// Execute the module function
/******/ 	var threw = true;
/******/ 	try {
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __nccwpck_require__);
/******/ 		threw = false;
/******/ 	} finally {
/******/ 		if(threw) delete __webpack_module_cache__[moduleId];
/******/ 	}
/******/ 
/******/ 	// Return the exports of the module
/******/ 	return module.exports;
/******/ }
/******/ 
/******/ // expose the modules object (__webpack_modules__)
/******/ __nccwpck_require__.m = __webpack_modules__;
/******/ 
/************************************************************************/
/******/ /* webpack/runtime/define property getters */
/******/ (() => {
/******/ 	// define getter functions for harmony exports
/******/ 	__nccwpck_require__.d = (exports, definition) => {
/******/ 		for(var key in definition) {
/******/ 			if(__nccwpck_require__.o(definition, key) && !__nccwpck_require__.o(exports, key)) {
/******/ 				Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 			}
/******/ 		}
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/ensure chunk */
/******/ (() => {
/******/ 	__nccwpck_require__.f = {};
/******/ 	// This file contains only the entry chunk.
/******/ 	// The chunk loading function for additional chunks
/******/ 	__nccwpck_require__.e = (chunkId) => {
/******/ 		return Promise.all(Object.keys(__nccwpck_require__.f).reduce((promises, key) => {
/******/ 			__nccwpck_require__.f[key](chunkId, promises);
/******/ 			return promises;
/******/ 		}, []));
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/get javascript chunk filename */
/******/ (() => {
/******/ 	// This function allow to reference async chunks
/******/ 	__nccwpck_require__.u = (chunkId) => {
/******/ 		// return url for filenames based on template
/******/ 		return "" + chunkId + ".index.js";
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/hasOwnProperty shorthand */
/******/ (() => {
/******/ 	__nccwpck_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ })();
/******/ 
/******/ /* webpack/runtime/make namespace object */
/******/ (() => {
/******/ 	// define __esModule on exports
/******/ 	__nccwpck_require__.r = (exports) => {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/compat */
/******/ 
/******/ if (typeof __nccwpck_require__ !== 'undefined') __nccwpck_require__.ab = new URL('.', import.meta.url).pathname.slice(import.meta.url.match(/^file:\/\/\/\w:/) ? 1 : 0, -1) + "/";
/******/ 
/******/ /* webpack/runtime/import chunk loading */
/******/ (() => {
/******/ 	// no baseURI
/******/ 	
/******/ 	// object to store loaded and loading chunks
/******/ 	// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 	// [resolve, Promise] = chunk loading, 0 = chunk loaded
/******/ 	var installedChunks = {
/******/ 		792: 0
/******/ 	};
/******/ 	
/******/ 	var installChunk = (data) => {
/******/ 		var {ids, modules, runtime} = data;
/******/ 		// add "modules" to the modules object,
/******/ 		// then flag all "ids" as loaded and fire callback
/******/ 		var moduleId, chunkId, i = 0;
/******/ 		for(moduleId in modules) {
/******/ 			if(__nccwpck_require__.o(modules, moduleId)) {
/******/ 				__nccwpck_require__.m[moduleId] = modules[moduleId];
/******/ 			}
/******/ 		}
/******/ 		if(runtime) runtime(__nccwpck_require__);
/******/ 		for(;i < ids.length; i++) {
/******/ 			chunkId = ids[i];
/******/ 			if(__nccwpck_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 				installedChunks[chunkId][0]();
/******/ 			}
/******/ 			installedChunks[ids[i]] = 0;
/******/ 		}
/******/ 	
/******/ 	}
/******/ 	
/******/ 	__nccwpck_require__.f.j = (chunkId, promises) => {
/******/ 			// import() chunk loading for javascript
/******/ 			var installedChunkData = __nccwpck_require__.o(installedChunks, chunkId) ? installedChunks[chunkId] : undefined;
/******/ 			if(installedChunkData !== 0) { // 0 means "already installed".
/******/ 	
/******/ 				// a Promise means "currently loading".
/******/ 				if(installedChunkData) {
/******/ 					promises.push(installedChunkData[1]);
/******/ 				} else {
/******/ 					if(true) { // all chunks have JS
/******/ 						// setup Promise in chunk cache
/******/ 						var promise = import("./" + __nccwpck_require__.u(chunkId)).then(installChunk, (e) => {
/******/ 							if(installedChunks[chunkId] !== 0) installedChunks[chunkId] = undefined;
/******/ 							throw e;
/******/ 						});
/******/ 						var promise = Promise.race([promise, new Promise((resolve) => (installedChunkData = installedChunks[chunkId] = [resolve]))])
/******/ 						promises.push(installedChunkData[1] = promise);
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 	};
/******/ 	
/******/ 	// no prefetching
/******/ 	
/******/ 	// no preloaded
/******/ 	
/******/ 	// no external install chunk
/******/ 	
/******/ 	// no on chunks loaded
/******/ })();
/******/ 
/************************************************************************/
/******/ 
/******/ // startup
/******/ // Load entry module and return exports
/******/ // This entry module is referenced by other modules so it can't be inlined
/******/ var __webpack_exports__ = __nccwpck_require__(98);
/******/ 
